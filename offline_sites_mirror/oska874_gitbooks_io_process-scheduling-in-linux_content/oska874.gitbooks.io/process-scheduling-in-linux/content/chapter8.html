<!DOCTYPE html><html lang="zh">
<!-- Mirrored from oska874.gitbooks.io/process-scheduling-in-linux/content/chapter8.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:23:51 GMT -->
<head>
        <title>8 CFS Implementation Details &#xB7; Linux Process Schedule</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content>
        <meta name="generator" content="GitBook 3.1.1">
        <meta name="author" content="Ezio Zhang">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-comment/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://gstatic.gitbook.com/images/b1c4c86ca817a71628d2debe73be9a64.ico" type="image/x-icon">

    
    <link rel="next" href="chapter9.html">
    
    
    <link rel="prev" href="chapter7.html">
    

    
<style>
    .book .book-summary .book-search,
    .book .book-summary ul.summary {
        position: relative;
        top: auto;
        left: auto;
        right: auto;
        bottom: auto;
    }
    .book-summary {
        display: -webkit-box;
        display: -moz-box;
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        flex-direction: column;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        overflow-y: auto;
    }
    .book-summary > nav {
        flex: 1 1 auto;
        overflow-y: auto;
        overflow-y: overlay;
    }
    .gl-wrapper {
        margin: 0;
        display: block;
        padding: 0;
        position: relative;
        line-height: 15px;
        background: #fafafa;
    }
    .gl-wrapper:before {
        background: -webkit-linear-gradient(to bottom, rgba(250,250,250,0) 0%, #fafafa 100%);
        background: -moz-linear-gradient(to bottom, rgba(250,250,250,0) 0%, #fafafa 100%);
        top: -24px;
        width: 100%;
        height: 24px;
        content: "";
        display: block;
        position: absolute;
        background: linear-gradient(to bottom, rgba(250,250,250,0) 0%, #fafafa 100%);
    }
    .book.color-theme-1 .gl-wrapper {
        background: #121212;
    }
    .book.color-theme-1 .gl-wrapper:before {
        background: -webkit-linear-gradient(to bottom, rgba(18,18,18,0) 0%, #121212 100%);
        background: -moz-linear-gradient(to bottom, rgba(18,18,18,0) 0%, #121212 100%);
        background: linear-gradient(to bottom, rgba(18,18,18,0) 0%, #121212 100%);
    }
    .book.color-theme-2 .gl-wrapper {
        background: #2e3243;
    }
    .book.color-theme-2 .gl-wrapper:before {
        background: -webkit-linear-gradient(to bottom, rgba(46,50,67,0) 0%, #2e3243 100%);
        background: -moz-linear-gradient(to bottom, rgba(46,50,67,0) 0%, #2e3243 100%);
        background: linear-gradient(to bottom, rgba(46,50,67,0) 0%, #2e3243 100%);
    }
    .gl-wrapper .gitbook-link {
        display: -webkit-box;
        display: -moz-box;
        display: -ms-flexbox;
        display: -webkit-flex;
        color: #9DAAB6;
        margin: 16px;
        display: flex;
        padding: 0;
        align-items: center;
        margin-left: 32px;
        padding-top: 8px;
        padding-left: 16px;
        border-radius: 3px;
        padding-right: 16px;
        padding-bottom: 8px;
        text-decoration: none;
        background-color: #E6ECF1;
        -webkit-box-align: center;
    }
    .gl-wrapper .tm-logo {
        margin: 0;
        display: block;
        padding: 0;
        font-size: 40px;
    }
    .gl-wrapper .tm-content {
        flex: 1;
        margin: 0;
        display: block;
        padding: 0;
        padding-left: 16px;
    }
    .gl-wrapper .tm-content .container {
        margin: 0;
        display: block;
        padding: 0;
    }
    .gl-wrapper .tm-content .tm-container .tm-text {
        font-size: 12px;
        font-family: "Roboto", sans-serif;
        font-weight: 400;
        line-height: 1.625;
    }
</style></head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search">
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://www.gitbook.com/book/oska874/process-scheduling-in-linux" target="_blank" class="custom-link">Linux Process Schedule</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="index.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="chapter1.html">
            
                <a href="chapter1.html">
            
                    
                    1 Process Scheduling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="chapter2.html">
            
                <a href="chapter2.html">
            
                    
                    2 Task Classification
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="chapter3.html">
            
                <a href="chapter3.html">
            
                    
                    3 Scheduling Classes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="chapter4.html">
            
                <a href="chapter4.html">
            
                    
                    4 Main Runqueue
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="chapter5.html">
            
                <a href="chapter5.html">
            
                    
                    5 Scheduler Skeleton
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="chapter6.html">
            
                <a href="chapter6.html">
            
                    
                    6 Short Scheduling Algorithm History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="chapter7.html">
            
                <a href="chapter7.html">
            
                    
                    7 Completely Fair Scheduler (CFS)
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.9" data-path="chapter8.html">
            
                <a href="chapter8.html">
            
                    
                    8 CFS Implementation Details
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="chapter9.html">
            
                <a href="chapter9.html">
            
                    
                    9 Soft Real-Time Scheduling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="chapter10.html">
            
                <a href="chapter10.html">
            
                    
                    10 Load Balancing on SMP Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="chapter11.html">
            
                <a href="chapter11.html">
            
                    
                    11 Real Time Load Balancing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="chapter12.html">
            
                <a href="chapter12.html">
            
                    
                    12. Resources
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    
</ul>


                </nav>
            
        
    
<div class="gl-wrapper">
    <a class="gitbook-link" href="https://www.gitbook.com/?utm_source=public_site_legacy&amp;utm_medium=referral&amp;utm_campaign=trademark&amp;utm_term=oska874&amp;utm_content=powered_by" target="blank">
        <div class="tm-logo">
            <svg preserveAspectRatio="xMidYMid meet" height="1em" width="1em" fill="currentColor" viewBox="0 0 1067 769" xmlns="http://www.w3.org/2000/svg" stroke="none" class="icon-7f6730be--text-3f89f380"><g><path d="M480.026 640.677c17.205 0 31.2 13.997 31.2 31.194s-13.995 31.193-31.2 31.193c-17.197 0-31.193-13.996-31.193-31.193 0-17.197 13.996-31.194 31.193-31.194m489.93-193.226c-17.203 0-31.2-13.998-31.2-31.195 0-17.204 13.997-31.2 31.2-31.2 17.198 0 31.194 13.996 31.194 31.2 0 17.197-13.996 31.195-31.193 31.195m0-127.804c-53.269 0-96.609 43.34-96.609 96.609 0 10.373 1.723 20.702 5.123 30.741L559.328 616.879c-18.132-26.128-47.521-41.617-79.302-41.617-36.821 0-70.391 21.065-86.63 54.003L106.68 478.109c-30.288-15.927-52.965-65.817-50.56-111.223 1.248-23.687 9.438-42.071 21.897-49.17 7.916-4.493 17.436-4.099 27.526 1.188l1.916 1.01c75.96 40.022 324.6 170.981 335.063 175.844 16.157 7.47 25.14 10.5 52.659-2.547l513.958-267.3c7.53-2.844 16.315-10.062 16.315-21.023 0-15.205-15.72-21.199-15.765-21.199-29.218-14.018-74.163-35.054-117.987-55.57C798.033 84.26 691.861 34.547 645.23 10.132c-40.253-21.072-72.655-3.311-78.432.282l-11.227 5.555C345.727 119.743 64.898 258.826 48.911 268.553 20.278 285.973 2.547 320.679.252 363.768c-3.586 68.304 31.261 139.506 81.069 165.634l303.172 156.354c6.83 47.306 47.55 82.725 95.532 82.725 52.78 0 95.808-42.546 96.603-95.14L910.541 492.38c16.93 13.233 37.92 20.486 59.416 20.486 53.268 0 96.61-43.341 96.61-96.61s-43.342-96.61-96.61-96.61" fill-rule="evenodd"/></g></svg>
        </div>
        <div class="tm-content">
            <div class="tm-container">
                <span class="tm-text">
                    Powered by <b>GitBook</b>
                </span>
            </div>
        </div>
    </a>
</div></div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".html">8 CFS Implementation Details</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="8-cfs-implementation-details">8. CFS Implementation Details</h1>
<h2 id="81-data-structures">8.1. Data Structures</h2>
<p>With the CFS scheduler, a structure called sched_entity was introduced into the Linux scheduler. It is mainly used for time accounting for the single tasks and was added as the se member to each task&apos;s task_struct. Its defined in include/linux/sched.h:</p>
<pre><code>struct sched_entity {

    struct load_weight load; /* for load-balancing */
    struct rb_node run_node;
    struct list_head group_node;
    unsigned int on_rq;
    u64 exec_start;
    u64 sum_exec_runtime;
    u64 vruntime;
    u64 prev_sum_exec_runtime;
    u64 nr_migrations;

#ifdef CONFIG_SCHEDSTATS
    struct sched_statistics statistics;
#endif

#ifdef CONFIG_FAIR_GROUP_SCHED
    struct sched_entity *parent;
    /* rq on which this entity is (to be) queued: */
    struct cfs_rq *cfs_rq;
    /* rq &quot;owned&quot; by this entity/group: */
    struct cfs_rq *my_q;
#endif

};
</code></pre><p>Another CFS related field, called cfs, was added to the main runqueue data structure. It is of the type cfs_rq, which is implemented in kernel/sched.c. It contains a list of pointers to all running CFS tasks, the root of CFS&apos; red-black-tree, a pointer to the left most node, min_vruntime, pointers to previously and currently scheduled tasks and additional members for group and smp scheduling and load balancing. The priority of the task is encoded in the load_weight data structure.</p>
<pre><code>/* CFS-related fields in a runqueue */

struct cfs_rq {
    struct load_weight load;
    unsigned long nr_running;
    u64 exec_clock;
    u64 min_vruntime;

#ifndef CONFIG_64BIT
    u64 min_vruntime_copy;
#endif

    struct rb_root tasks_timeline;
    struct rb_node *rb_leftmost;
    struct list_head tasks;
    struct list_head *balance_iterator;

    /*
    * &apos;curr&apos; points to currently running entity on this cfs_rq.
    * It is set to NULL otherwise (i.e when none are currently running).
    */
    struct sched_entity *curr, *next, *last, *skip;

#ifdef CONFIG_SCHED_DEBUG
    unsigned int nr_spread_over;
#endif

#ifdef CONFIG_FAIR_GROUP_SCHED
    struct rq *rq; /* cpu runqueue to which this cfs_rq is attached */
    /*
    * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in
    * a hierarchy). Non-leaf lrqs hold other higher schedulable entities
    * (like users, containers etc.)
    *
    * leaf_cfs_rq_list ties together list of leaf cfs_rq&apos;s in a cpu. This
    * list is used during load balance.
    */
    int on_list;
    struct list_head leaf_cfs_rq_list;
    struct task_group *tg;/* group that &quot;owns&quot; this runqueue */

#ifdef CONFIG_SMP
    /*
    * the part of load.weight contributed by tasks
    */
    unsigned long task_weight;

    /*
    * h_load = weight * f(tg)
    *
    * Where f(tg) is the recursive weight fraction assigned to
    * this group.
    */

    unsigned long h_load;

    /*
    * Maintaining per-cpu shares distribution for group scheduling
    *
    * load_stamp is the last time we updated the load average
    * load_last is the last time we updated the load average and saw load
    * load_unacc_exec_time is currently unaccounted execution time
    */
    u64 load_avg;
    u64 load_period;
    u64 load_stamp, load_last, load_unacc_exec_time;
    unsigned long load_contribution;
#endif
#endif

};
</code></pre><h2 id="82-time-accounting">8.2 Time Accounting</h2>
<p>As mentioned above, vruntime is used to track the virtual runtime of runnable tasks in CFS&apos; redblack-tree. The scheduler_tick() function of the scheduler skeleton regularly calls the task_tick() hook into CFS. This hook internally calls task_tick_fair() which is the entry point into the CFS task update:</p>
<pre><code>/*
* scheduler tick hitting a task of our scheduling class:
*/
static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)
{
    struct cfs_rq *cfs_rq;
    struct sched_entity *se = &amp;curr-&gt;se;
    for_each_sched_entity(se) {
        cfs_rq = cfs_rq_of(se);
        entity_tick(cfs_rq, se, queued);
    }

}
</code></pre><p>task_tick_fair() calls entity_tick() for the tasks scheduling entity and corresponding runqueue. entity_tick() executes two main tasks: First, it updates runtime statistics for the currently scheduled task and secondly, it checks if the current task needs to be pre-empted.</p>
<pre><code>entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)
{
    /*
    * Update run-time statistics of the &apos;current&apos;.
    */
    update_curr(cfs_rq);
    /*
    * Update share accounting for long-running entities.
    */
    update_entity_shares_tick(cfs_rq);
#ifdef CONFIG_SCHED_HRTICK
    /*
    * queued ticks are scheduled to match the slice, so don&apos;t bother
    * validating it and just reschedule.
    */
    if (queued) {
        resched_task(rq_of(cfs_rq)-&gt;curr);
        return;
    }
    /*
    * don&apos;t let the period tick interfere with the hrtick preemption
    */
    if (!sched_feat(DOUBLE_TICK) &amp;&amp;
        hrtimer_active(&amp;rq_of(cfs_rq)-&gt;hrtick_timer))
        return;
#endif
    if (cfs_rq-&gt;nr_running &gt; 1 || !sched_feat(WAKEUP_PREEMPT))
        check_preempt_tick(cfs_rq, curr);
}
</code></pre><p>update_curr() is the responsible function to update the current task&apos;s runtime statistics. It calculates the elapsed time since the current task was scheduled last and passes the result, delta_exec, on to __update_curr().</p>
<pre><code>static void update_curr(struct cfs_rq *cfs_rq)
{
    struct sched_entity *curr = cfs_rq-&gt;curr;
    u64 now = rq_of(cfs_rq)-&gt;clock_task;
    unsigned long delta_exec;
    if (unlikely(!curr))
        return;
    /*
    * Get the amount of time the current task was running
    * since the last time we changed load (this cannot
    * overflow on 32 bits):
    */
    delta_exec = (unsigned long)(now - curr-&gt;exec_start);
    if (!delta_exec)
        return;
    __update_curr(cfs_rq, curr, delta_exec);
    curr-&gt;exec_start = now;
    if (entity_is_task(curr)) {
        struct task_struct *curtask = task_of(curr);
        trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);
        cpuacct_charge(curtask, delta_exec);
        account_group_exec_runtime(curtask, delta_exec);
    }
}
</code></pre><p>The runtime delta is weighted by current task&apos;s priority, which is encoded in load_weigth, and the result is added to the current task&apos;s vruntime. This is the location where vruntime grows faster or slower, depending on the task&apos; priority. You can also see that __update_curr() updates min_vruntime.</p>
<pre><code>/*
 * Update the current task&apos;s runtime statistics. Skip current tasks that
 * are not in our scheduling class.
*/
static inline void __update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,unsigned long delta_exec)
{
    unsigned long delta_exec_weighted;
    schedstat_set(curr-&gt;statistics.exec_max,max((u64)delta_exec, curr-&gt;statistics.exec_max));
    curr-&gt;sum_exec_runtime += delta_exec;
    schedstat_add(cfs_rq, exec_clock, delta_exec);
    delta_exec_weighted = calc_delta_fair(delta_exec, curr);
    curr-&gt;vruntime += delta_exec_weighted;
    update_min_vruntime(cfs_rq);
#if defined CONFIG_SMP &amp;&amp; defined  CONFIG_FAIR_GROUP_SCHED
    cfs_rq-&gt;load_unacc_exec_time += delta_exec;
#endif
}
</code></pre><p>In addition to this regular update, update_current() is also called if the corresponding task becomes runnable or goes to sleep.</p>
<p>Back to entity_tick(). After the current task was updated, check_preempt_tick() is called to satisfy CFS&apos; concept of giving each task a fair share. vruntime of the current process is checked against vruntime of the left most task in the red-black-tree to decide if a process switch is necessary.</p>
<pre><code>/*
* Preempt the current task with a newly woken task if needed:
*/
static void
check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
    unsigned long ideal_runtime, delta_exec;
    ideal_runtime = sched_slice(cfs_rq, curr);
    delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;
    if (delta_exec &gt; ideal_runtime) {
        resched_task(rq_of(cfs_rq)-&gt;curr);
        /*
        * The current task ran long enough, ensure it doesn&apos;t get
        * re-elected due to buddy favours.
        */
        clear_buddies(cfs_rq, curr);
        return;
    }
    /*
    * Ensure that a task that missed wakeup preemption by a
    * narrow margin doesn&apos;t have to wait for a full slice.
    * This also mitigates buddy induced latencies under load.
    */
    if (!sched_feat(WAKEUP_PREEMPT))
        return;
    if (delta_exec &lt; sysctl_sched_min_granularity)
        return;
    if (cfs_rq-&gt;nr_running &gt; 1) {
        struct sched_entity *se = __pick_first_entity(cfs_rq);
        s64 delta = curr-&gt;vruntime - se-&gt;vruntime;
        if (delta &lt; 0)
            return;
        if (delta &gt; ideal_runtime)
            resched_task(rq_of(cfs_rq)-&gt;curr);
    }
}
</code></pre><p>sched_slice() returns the target latency runtime for the current task, depending on the number of runnable processes. If its delta runtime is larger than this amount, the need_resched flag is set for this task.</p>
<p>If not, the runtime is checked against the minimum granularity. If the task ran longer than that and more than one tasks are in total in the red-black-tree, a comparison with the left most node is done.If the vruntime difference between those two is positive, that means the current task ran longer than the left most one, and larger than the target latency runtime calculated above, need_resched flag is set as well to reschedule ASAP.</p>
<h2 id="83-modifying-the-red-black-tree">8.3 Modifying the Red-Black-Tree</h2>
<p>In Scheduler Skeleton you could see how tasks where deactivated when they were removed from the runqueue or activated when woken up in try_to_wake_up(). For the CFS scheduling class, enqueue_task_fair() and dequeue_task_fair() are called which end up in enqueue_entity() and dequeue_entity() to modify the red-black-tree.</p>
<p>In enqueue_entity(), you can see how the tasks vruntime is updated, as mentioned above, and that __enqueue_entity() is called. This function is responsible for the red-black-tree insert magic that fulfils the data structures properties. You can also find caching operations of the left most node there.</p>
<pre><code>static void enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
{
    /*
    * Update the normalized vruntime before updating min_vruntime
    * through callig update_curr().
    */
    if (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_WAKING))
        se-&gt;vruntime += cfs_rq-&gt;min_vruntime;
    /*
    * Update run-time statistics of the &apos;current&apos;.
    */
    update_curr(cfs_rq);
    update_cfs_load(cfs_rq, 0);
    account_entity_enqueue(cfs_rq, se);
    update_cfs_shares(cfs_rq);
    if (flags &amp; ENQUEUE_WAKEUP) {
        place_entity(cfs_rq, se, 0);
        enqueue_sleeper(cfs_rq, se);
    }
    update_stats_enqueue(cfs_rq, se);
    check_spread(cfs_rq, se);
    if (se != cfs_rq-&gt;curr)
        __enqueue_entity(cfs_rq, se);
    se-&gt;on_rq = 1;
    if (cfs_rq-&gt;nr_running == 1)
        list_add_leaf_cfs_rq(cfs_rq);
}
</code></pre><p>Removing a node works in a similar way. First, vruntime is updated and then the task is removed from the tree using __dequeue_entity().</p>
<pre><code>static void dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
{
    /*
    * Update run-time statistics of the &apos;current&apos;.
    */
    update_curr(cfs_rq);
    update_stats_dequeue(cfs_rq, se);
    if (flags &amp; DEQUEUE_SLEEP) {
#ifdef CONFIG_SCHEDSTATS
        if (entity_is_task(se)) {
            struct task_struct *tsk = task_of(se);
            if (tsk-&gt;state &amp; TASK_INTERRUPTIBLE)
                se-&gt;statistics.sleep_start = rq_of(cfs_rq)-&gt;clock;
            if (tsk-&gt;state &amp; TASK_UNINTERRUPTIBLE)
                se-&gt;statistics.block_start = rq_of(cfs_rq)-&gt;clock;
        }
#endif
    }
    clear_buddies(cfs_rq, se);
    if (se != cfs_rq-&gt;curr)
        __dequeue_entity(cfs_rq, se);
    se-&gt;on_rq = 0;
    update_cfs_load(cfs_rq, 0);
    account_entity_dequeue(cfs_rq, se);
    /*
    * Normalize the entity after updating the min_vruntime because the
    * update can refer to the -&gt;curr item and we need to reflect this
    * movement in our normalized position.
    */
    if (!(flags &amp; DEQUEUE_SLEEP))
        se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;
    update_min_vruntime(cfs_rq);
    update_cfs_shares(cfs_rq);
}
</code></pre><p>The additional calls you see are necessary for group scheduling, scheduling statistic updates and the buddy system which is used for picking the next task to run.</p>
<h2 id="84-picking-the-next-runnable-task">8.4 Picking the next runnable task</h2>
<p>The main scheduler function schedule() calls pick_next_task() of the scheduling class with the highest priority that has runnable tasks. If this is called for the CFS class, the class hook calls pick_next_task_fair().</p>
<p>If no tasks are in this class, NULL is returned immediately. Otherwise pick_next_entity() is called to select the next task from the tree. This is then forwarded to set_next_entity() which removes it from the tree since scheduled processes are not allowed in there. The while loop is used to account for fair group scheduling.</p>
<pre><code>static struct task_struct *pick_next_task_fair(struct rq *rq)
{
    struct task_struct *p;
    struct cfs_rq *cfs_rq = &amp;rq-&gt;cfs;
    struct sched_entity *se;
    if (!cfs_rq-&gt;nr_running)
        return NULL;
    do {
        se = pick_next_entity(cfs_rq);
        set_next_entity(cfs_rq, se);
        cfs_rq = group_cfs_rq(se);
    } while (cfs_rq);
    p = task_of(se);
    hrtick_start_fair(rq, p);
    return p;
}
</code></pre><p>In pick_next_entity() not necessarily the left most task is picked to run next. A buddy system gives a certain degree of freedom in selecting the next task to run. This is supposed to benefit cache locality and group scheduling.</p>
<pre><code>/*
* Pick the next process, keeping these things in mind, in this order:
* 1) keep things fair between processes/task groups
* 2) pick the &quot;next&quot; process, since someone really wants that to run
* 3) pick the &quot;last&quot; process, for cache locality
* 4) do not run the &quot;skip&quot; process, if something else is available
*/
static struct sched_entity *pick_next_entity(struct cfs_rq *cfs_rq)
{
    struct sched_entity *se = __pick_first_entity(cfs_rq);
    struct sched_entity *left = se;
    /*
    * Avoid running the skip buddy, if running something else can
    * be done without getting too unfair.
    */
    if (cfs_rq-&gt;skip == se) {
        struct sched_entity *second = __pick_next_entity(se);
        if (second &amp;&amp; wakeup_preempt_entity(second, left) &lt; 1)
            se = second;
    }
    /*
    * Prefer last buddy, try to return the CPU to a preempted task.
    */
    if (cfs_rq-&gt;last &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;last, left) &lt; 1)
        se = cfs_rq-&gt;last;
    /*
    * Someone really wants this to run. If it&apos;s not unfair, run it.
    */
    if (cfs_rq-&gt;next &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;next, left) &lt; 1)
        se = cfs_rq-&gt;next;
    clear_buddies(cfs_rq, se);
    return se;
}
</code></pre><p>__pick_first_entity() picks the left most node from the tree, which is very easy and fast as you can see below:</p>
<pre><code>static struct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq)
{
    struct rb_node *left = cfs_rq-&gt;rb_leftmost;
    if (!left)
        return NULL;
    return rb_entry(left, struct sched_entity, run_node);
}
</code></pre><hr>
<h1 id="8-cfs-&#x5B9E;&#x73B0;&#x7EC6;&#x8282;">8. CFS &#x5B9E;&#x73B0;&#x7EC6;&#x8282;</h1>
<h2 id="81-&#x6570;&#x636E;&#x7ED3;&#x6784;">8.1. &#x6570;&#x636E;&#x7ED3;&#x6784;</h2>
<p>CFS &#x8C03;&#x5EA6;&#x5668;&#x4E3A; Linux &#x7684;&#x8FDB;&#x7A0B;&#x8C03;&#x5EA6;&#x5668;&#x5F15;&#x5165;&#x4E86;&#x4E00;&#x4E2A;&#x540D;&#x53EB; <code>sched_entity</code> &#x7684;&#x7ED3;&#x6784;&#x4F53;&#x3002;&#x5B83;&#x6700;&#x4E3B;&#x8981;&#x7684;&#x7528;&#x5904;&#x662F;&#x8BB0;&#x5F55;&#x5355;&#x4E2A;&#x4EFB;&#x52A1;&#x7684;&#x8FD0;&#x884C;&#x65F6;&#x95F4;&#xFF0C;&#x5E76;&#x4E14;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x6210;&#x5458;&#x6DFB;&#x52A0;&#x5230;&#x4E86;&#x6BCF;&#x4E2A;&#x4EFB;&#x52A1;&#x7684; <code>task_struct</code> &#x7ED3;&#x6784;&#x4F53;&#x4E2D;&#x3002;&#x5B83;&#x5B9A;&#x4E49;&#x5728;&#x6587;&#x4EF6; <code>include/linux/sched.h</code> &#x4E2D;&#xFF1A;</p>
<pre><code>struct sched_entity {

    struct load_weight load; /* for load-balancing */
    struct rb_node run_node;
    struct list_head group_node;
    unsigned int on_rq;
    u64 exec_start;
    u64 sum_exec_runtime;
    u64 vruntime;
    u64 prev_sum_exec_runtime;
    u64 nr_migrations;

#ifdef CONFIG_SCHEDSTATS
    struct sched_statistics statistics;
#endif

#ifdef CONFIG_FAIR_GROUP_SCHED
    struct sched_entity *parent;
    /* rq on which this entity is (to be) queued: */
    struct cfs_rq *cfs_rq;
    /* rq &quot;owned&quot; by this entity/group: */
    struct cfs_rq *my_q;
#endif

};
</code></pre><p>&#x53E6;&#x4E00;&#x4E2A;&#x548C; CFS &#x76F8;&#x5173;&#x7684;&#x5B57;&#x6BB5;&#x662F;&#x4E00;&#x4E2A;&#x6DFB;&#x52A0;&#x5230;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x6210;&#x5458;&#x53D8;&#x91CF; <code>cfs</code>&#x3002;&#x5B83;&#x7684;&#x7C7B;&#x578B;&#x662F; <code>cfs_rq</code> &#xFF0C;&#x5728;&#x6587;&#x4EF6; <code>kernel/sched.c</code> &#x4E2D;&#x5B9E;&#x73B0;&#x3002;&#x5B83;&#x5305;&#x542B;&#x4E00;&#x4E2A;&#x7531;&#x6307;&#x5411;&#x5168;&#x90E8;&#x8FD0;&#x884C;&#x4E2D;&#x7684; CFS &#x4EFB;&#x52A1;&#x7684;&#x6307;&#x9488;&#x7684;&#x94FE;&#x8868;&#xFF0C;CFS &#x8C03;&#x5EA6;&#x5668;&#x7684;&#x7EA2;&#x9ED1;&#x6811;&#x7684;&#x6839;&#xFF0C;&#x4E00;&#x4E2A;&#x6307;&#x5411;&#x6700;&#x5DE6;&#x8FB9;&#x8282;&#x70B9;&#x7684;&#x6307;&#x9488;&#xFF0C;&#x6700;&#x5C0F;&#x865A;&#x62DF;&#x8FD0;&#x884C;&#x65F6;&#xFF08;<code>min_vruntime</code>)&#xFF0C;&#x6307;&#x5411;&#x524D;&#x4E00;&#x4E2A;&#x4EFB;&#x52A1;&#x548C;&#x5F53;&#x524D;&#x8C03;&#x5EA6;&#x7684;&#x4EFB;&#x52A1;&#x7684;&#x6307;&#x9488;&#x4EE5;&#x53CA;&#x989D;&#x5916;&#x7684;&#x7528;&#x4E8E;&#x516C;&#x5E73;&#x7EC4;&#x8C03;&#x5EA6;&#x548C; SMP &#x8C03;&#x5EA6;&#x548C;&#x8D1F;&#x8F7D;&#x8FD0;&#x884C;&#x7684;&#x6210;&#x5458;&#x53D8;&#x91CF;&#x3002;&#x4EFB;&#x52A1;&#x7684;&#x4F18;&#x5148;&#x7EA7;&#x5DF2;&#x7ECF;&#x7F16;&#x7801;&#x5230;&#x4E86; <code>load_weight</code> &#x6570;&#x636E;&#x7ED3;&#x6784;&#x4E2D;&#x3002;</p>
<pre><code>/* CFS-related fields in a runqueue */

struct cfs_rq {
    struct load_weight load;
    unsigned long nr_running;
    u64 exec_clock;
    u64 min_vruntime;

#ifndef CONFIG_64BIT
    u64 min_vruntime_copy;
#endif

    struct rb_root tasks_timeline;
    struct rb_node *rb_leftmost;
    struct list_head tasks;
    struct list_head *balance_iterator;

    /*
    * &apos;curr&apos; points to currently running entity on this cfs_rq.
    * It is set to NULL otherwise (i.e when none are currently running).
    */
    struct sched_entity *curr, *next, *last, *skip;

#ifdef CONFIG_SCHED_DEBUG
    unsigned int nr_spread_over;
#endif

#ifdef CONFIG_FAIR_GROUP_SCHED
    struct rq *rq; /* cpu runqueue to which this cfs_rq is attached */
    /*
    * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in
    * a hierarchy). Non-leaf lrqs hold other higher schedulable entities
    * (like users, containers etc.)
    *
    * leaf_cfs_rq_list ties together list of leaf cfs_rq&apos;s in a cpu. This
    * list is used during load balance.
    */
    int on_list;
    struct list_head leaf_cfs_rq_list;
    struct task_group *tg;/* group that &quot;owns&quot; this runqueue */

#ifdef CONFIG_SMP
    /*
    * the part of load.weight contributed by tasks
    */
    unsigned long task_weight;

    /*
    * h_load = weight * f(tg)
    *
    * Where f(tg) is the recursive weight fraction assigned to
    * this group.
    */

    unsigned long h_load;

    /*
    * Maintaining per-cpu shares distribution for group scheduling
    *
    * load_stamp is the last time we updated the load average
    * load_last is the last time we updated the load average and saw load
    * load_unacc_exec_time is currently unaccounted execution time
    */
    u64 load_avg;
    u64 load_period;
    u64 load_stamp, load_last, load_unacc_exec_time;
    unsigned long load_contribution;
#endif
#endif

};
</code></pre><h2 id="82-&#x65F6;&#x95F4;&#x5BA1;&#x8BA1;">8.2. &#x65F6;&#x95F4;&#x5BA1;&#x8BA1;</h2>
<p>&#x5982;&#x4E0A;&#x6240;&#x8FF0;&#xFF0C; vruntime &#x662F;&#x7528;&#x6765;&#x8BB0;&#x5F55; CFS &#x7684;&#x7EA2;&#x9ED1;&#x6811;&#x4E2D;&#x7684;&#x53EF;&#x8FD0;&#x884C;&#x4EFB;&#x52A1;&#x7684;&#x865A;&#x62DF;&#x65F6;&#x95F4;&#x7684;&#x3002;&#x8C03;&#x5EA6;&#x5668;&#x6846;&#x67B6;&#x7684;&#x51FD;&#x6570; <code>scheduler_tick()</code> &#x5468;&#x671F;&#x6027;&#x8C03;&#x7528; CFS &#x8DDF;&#x65B0;&#x4EFB;&#x52A1;&#x7684;&#x94A9;&#x5B50;&#x51FD;&#x6570; <code>task_tick()</code> &#xFF1A;</p>
<pre><code>/*
* scheduler tick hitting a task of our scheduling class:
*/
static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)
{
    struct cfs_rq *cfs_rq;
    struct sched_entity *se = &amp;curr-&gt;se;
    for_each_sched_entity(se) {
        cfs_rq = cfs_rq_of(se);
        entity_tick(cfs_rq, se, queued);
    }

}
</code></pre><p><code>task_tick_fair()</code> &#x8C03;&#x7528; <code>entity_tick()</code> &#x662F;&#x4E3A;&#x4E86;&#x4EFB;&#x52A1;&#x8C03;&#x5EA6;&#x5B9E;&#x4F53;&#x548C;&#x76F8;&#x5E94;&#x7684;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x3002;<code>entity_tick()</code> &#x6709;&#x4E24;&#x4E2A;&#x4E3B;&#x8981;&#x4EFB;&#x52A1;&#xFF1A;&#x7B2C;&#x4E00;&#x662F;&#x4E3A;&#x5F53;&#x524D;&#x8C03;&#x5EA6;&#x7684;&#x4EFB;&#x52A1;&#x66F4;&#x65B0;&#x8FD0;&#x884C;&#x65F6;&#x6570;&#x636E;&#xFF0C;&#x7B2C;&#x4E8C;&#x662F;&#x68C0;&#x67E5;&#x5F53;&#x524D;&#x4EFB;&#x52A1;&#x662F;&#x5426;&#x9700;&#x8981;&#x88AB;&#x62A2;&#x5360;&#x3002;</p>
<pre><code>entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)
{
    /*
    * Update run-time statistics of the &apos;current&apos;.
    */
    update_curr(cfs_rq);
    /*
    * Update share accounting for long-running entities.
    */
    update_entity_shares_tick(cfs_rq);
#ifdef CONFIG_SCHED_HRTICK
    /*
    * queued ticks are scheduled to match the slice, so don&apos;t bother
    * validating it and just reschedule.
    */
    if (queued) {
        resched_task(rq_of(cfs_rq)-&gt;curr);
        return;
    }
    /*
    * don&apos;t let the period tick interfere with the hrtick preemption
    */
    if (!sched_feat(DOUBLE_TICK) &amp;&amp;
        hrtimer_active(&amp;rq_of(cfs_rq)-&gt;hrtick_timer))
        return;
#endif
    if (cfs_rq-&gt;nr_running &gt; 1 || !sched_feat(WAKEUP_PREEMPT))
        check_preempt_tick(cfs_rq, curr);
}
</code></pre><p>&#x51FD;&#x6570; <code>update_curr()</code> &#x8D1F;&#x8D23;&#x66F4;&#x65B0;&#x5F53;&#x524D;&#x4EFB;&#x52A1;&#x7684;&#x8FD0;&#x884C;&#x65F6;&#x6570;&#x636E;&#x3002;&#x5B83;&#x4F1A;&#x8BA1;&#x7B97;&#x5F53;&#x524D;&#x4EFB;&#x52A1;&#x81EA;&#x4ECE;&#x4E0A;&#x6B21;&#x88AB;&#x8C03;&#x7528;&#x4EE5;&#x540E;&#x4F7F;&#x7528;&#x4E86;&#x7684;&#x65F6;&#x95F4;&#xFF0C;&#x7136;&#x540E;&#x4F7F;&#x7528;&#x51FD;&#x6570; <code>__update_curr()</code> &#x5C06;&#x7ED3;&#x679C; <code>delta_exec</code> &#x4F20;&#x7ED9;&#x51FA;&#x53BB;&#x3002;</p>
<pre><code>static void update_curr(struct cfs_rq *cfs_rq)
{
    struct sched_entity *curr = cfs_rq-&gt;curr;
    u64 now = rq_of(cfs_rq)-&gt;clock_task;
    unsigned long delta_exec;
    if (unlikely(!curr))
        return;
    /*
    * Get the amount of time the current task was running
    * since the last time we changed load (this cannot
    * overflow on 32 bits):
    */
    delta_exec = (unsigned long)(now - curr-&gt;exec_start);
    if (!delta_exec)
        return;
    __update_curr(cfs_rq, curr, delta_exec);
    curr-&gt;exec_start = now;
    if (entity_is_task(curr)) {
        struct task_struct *curtask = task_of(curr);
        trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);
        cpuacct_charge(curtask, delta_exec);
        account_group_exec_runtime(curtask, delta_exec);
    }
}
</code></pre><p>&#x8FD0;&#x884C;&#x65F6;&#x5DEE;&#x503C;&#x53EF;&#x4EE5;&#x52A0;&#x6743;&#x5F53;&#x524D;&#x4EFB;&#x52A1;&#x7684;&#x4F18;&#x5148;&#x7EA7;&#xFF0C;&#x800C;&#x8FD9;&#x4E2A;&#x503C;&#x662F;&#x7F16;&#x7801;&#x5728; <code>load_weigth</code> &#x5F53;&#x4E2D;&#x7684;&#xFF0C;&#x800C;&#x4E14;&#x8FD9;&#x4E2A;&#x7ED3;&#x679C;&#x4F1A;&#x52A0;&#x5230;&#x5F53;&#x524D;&#x4EFB;&#x52A1;&#x7684; <code>vruntime</code> &#x3002;&#x8FD9;&#x5C31;&#x662F; <code>vruntime</code> &#x589E;&#x957F;&#x7684;&#x66F4;&#x5FEB;&#x6216;&#x8005;&#x66F4;&#x6162;&#x7684;&#x5730;&#x65B9;&#xFF0C;&#x8FD9;&#x4F9D;&#x8D56;&#x4E8E;&#x4EFB;&#x52A1;&#x7684;&#x4F18;&#x5148;&#x7EA7;&#xFF0C;&#x540C;&#x65F6;&#x4F60;&#x4E5F;&#x53EF;&#x4EE5;&#x770B;&#x5230; <code>__update_curr()</code> &#x66F4;&#x65B0;&#x4E86; <code>min_vruntime</code> &#x3002;</p>
<pre><code>/*
 * Update the current task&apos;s runtime statistics. Skip current tasks that
 * are not in our scheduling class.
*/
static inline void __update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,unsigned long delta_exec)
{
    unsigned long delta_exec_weighted;
    schedstat_set(curr-&gt;statistics.exec_max,max((u64)delta_exec, curr-&gt;statistics.exec_max));
    curr-&gt;sum_exec_runtime += delta_exec;
    schedstat_add(cfs_rq, exec_clock, delta_exec);
    delta_exec_weighted = calc_delta_fair(delta_exec, curr);
    curr-&gt;vruntime += delta_exec_weighted;
    update_min_vruntime(cfs_rq);
#if defined CONFIG_SMP &amp;&amp; defined  CONFIG_FAIR_GROUP_SCHED
    cfs_rq-&gt;load_unacc_exec_time += delta_exec;
#endif
}
</code></pre><p>&#x9664;&#x4E86;&#x5468;&#x671F;&#x6027;&#x66F4;&#x65B0;&#x5916;&#xFF0C; &#x5728;&#x5BF9;&#x5E94;&#x7684;&#x4EFB;&#x52A1;&#x53D8;&#x6210;&#x53EF;&#x8FD0;&#x884C;&#x6216;&#x8005;&#x5C06;&#x8981;&#x7761;&#x7720;&#x7684;&#x65F6;&#x5019; <code>update_current()</code> &#x4E5F;&#x4F1A;&#x88AB;&#x8C03;&#x7528;&#x3002;</p>
<p>&#x56DE;&#x5230; <code>entity_tick()</code>&#x3002;&#x5728;&#x66F4;&#x65B0;&#x4E86;&#x5F53;&#x524D;&#x4EFB;&#x52A1;&#x4E4B;&#x540E;&#xFF0C; &#x4F1A;&#x8C03;&#x7528; <code>check_preempt_tick()</code> &#x6765;&#x6EE1;&#x8DB3; CFS &#x7684;&#x57FA;&#x672C;&#x539F;&#x5219;&#xFF1A;&#x4E3A;&#x6BCF;&#x4E2A;&#x4EFB;&#x52A1;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x516C;&#x5E73;&#x7684; CPU &#x4EFD;&#x989D;&#x3002;&#x5F53;&#x524D;&#x8FDB;&#x7A0B;&#x7684; <code>vruntime</code> &#x4F1A;&#x548C;&#x7EA2;&#x9ED1;&#x6811;&#x4E2D;&#x6700;&#x5DE6;&#x8FB9;&#x7684;&#x4EFB;&#x52A1;&#x8FDB;&#x884C;&#x6BD4;&#x8F83;&#xFF0C;&#x4EE5;&#x6B64;&#x6765;&#x51B3;&#x5B9A;&#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x662F;&#x5426;&#x662F;&#x5FC5;&#x987B;&#x7684;&#x3002;</p>
<pre><code>/*
* Preempt the current task with a newly woken task if needed:
*/
static void
check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
    unsigned long ideal_runtime, delta_exec;
    ideal_runtime = sched_slice(cfs_rq, curr);
    delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;
    if (delta_exec &gt; ideal_runtime) {
        resched_task(rq_of(cfs_rq)-&gt;curr);
        /*
        * The current task ran long enough, ensure it doesn&apos;t get
        * re-elected due to buddy favours.
        */
        clear_buddies(cfs_rq, curr);
        return;
    }
    /*
    * Ensure that a task that missed wakeup preemption by a
    * narrow margin doesn&apos;t have to wait for a full slice.
    * This also mitigates buddy induced latencies under load.
    */
    if (!sched_feat(WAKEUP_PREEMPT))
        return;
    if (delta_exec &lt; sysctl_sched_min_granularity)
        return;
    if (cfs_rq-&gt;nr_running &gt; 1) {
        struct sched_entity *se = __pick_first_entity(cfs_rq);
        s64 delta = curr-&gt;vruntime - se-&gt;vruntime;
        if (delta &lt; 0)
            return;
        if (delta &gt; ideal_runtime)
            resched_task(rq_of(cfs_rq)-&gt;curr);
    }
}
</code></pre><p>&#x5220;&#x9664;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x65B9;&#x6CD5;&#x4E5F;&#x662F;&#x7C7B;&#x4F3C;&#x7684;&#x3002;&#x9996;&#x5148;&#x66F4;&#x65B0; <code>vruntime</code> &#x4F7F;&#x7528;&#x7136;&#x540E; <code>__dequeue_entity()</code> &#x5C06;&#x4EFB;&#x52A1;&#x4ECE;&#x6811;&#x4E0A;&#x5220;&#x9664;&#x6389;&#x3002;</p>
<pre><code>static void dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
{
    /*
    * Update run-time statistics of the &apos;current&apos;.
    */
    update_curr(cfs_rq);
    update_stats_dequeue(cfs_rq, se);
    if (flags &amp; DEQUEUE_SLEEP) {
#ifdef CONFIG_SCHEDSTATS
        if (entity_is_task(se)) {
            struct task_struct *tsk = task_of(se);
            if (tsk-&gt;state &amp; TASK_INTERRUPTIBLE)
                se-&gt;statistics.sleep_start = rq_of(cfs_rq)-&gt;clock;
            if (tsk-&gt;state &amp; TASK_UNINTERRUPTIBLE)
                se-&gt;statistics.block_start = rq_of(cfs_rq)-&gt;clock;
        }
#endif
    }
    clear_buddies(cfs_rq, se);
    if (se != cfs_rq-&gt;curr)
        __dequeue_entity(cfs_rq, se);
    se-&gt;on_rq = 0;
    update_cfs_load(cfs_rq, 0);
    account_entity_dequeue(cfs_rq, se);
    /*
    * Normalize the entity after updating the min_vruntime because the
    * update can refer to the -&gt;curr item and we need to reflect this
    * movement in our normalized position.
    */
    if (!(flags &amp; DEQUEUE_SLEEP))
        se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;
    update_min_vruntime(cfs_rq);
    update_cfs_shares(cfs_rq);
}
</code></pre><p>&#x4F60;&#x6240;&#x770B;&#x5230;&#x7684;&#x5176;&#x5B83;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x662F;&#x7EC4;&#x8C03;&#x5EA6;&#xFF0C;&#x66F4;&#x65B0;&#x8C03;&#x5EA6;&#x6570;&#x636E;&#x548C;&#x4F19;&#x4F34;&#x7CFB;&#x7EDF;&#x6240;&#x5FC5;&#x987B;&#x7684;&#xFF0C;&#x4F19;&#x4F34;&#x7CFB;&#x7EDF;&#x7528;&#x6765;&#x6311;&#x9009;&#x4E0B;&#x4E00;&#x4E2A;&#x8981;&#x8FD0;&#x884C;&#x7684;&#x4EFB;&#x52A1;&#x3002;</p>
<h2 id="84-&#x6311;&#x9009;&#x4E0B;&#x4E00;&#x4E2A;&#x53EF;&#x8FD0;&#x884C;&#x7684;&#x4EFB;&#x52A1;">8.4. &#x6311;&#x9009;&#x4E0B;&#x4E00;&#x4E2A;&#x53EF;&#x8FD0;&#x884C;&#x7684;&#x4EFB;&#x52A1;</h2>
<p>&#x4E3B;&#x8C03;&#x5EA6;&#x51FD;&#x6570; <code>schedule()</code> &#x4F1A;&#x8C03;&#x7528;&#x62E5;&#x6709;&#x53EF;&#x8FD0;&#x884C;&#x4EFB;&#x52A1;&#x7684;&#x6700;&#x9AD8;&#x4F18;&#x5148;&#x7EA7;&#x7684;&#x8C03;&#x5EA6;&#x7C7B;&#x7684; <code>pick_next_task()</code> &#x3002;&#x5982;&#x679C;&#x8C03;&#x7528;&#x7684;&#x662F; CFS &#x8C03;&#x5EA6;&#x7C7B;&#x7684;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#xFF0C;&#x8C03;&#x5EA6;&#x7C7B;&#x94A9;&#x5B50;&#x51FD;&#x6570;&#x4F1A;&#x8C03;&#x7528; <code>pick_next_task_fair()</code>&#x3002;</p>
<p>&#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x8C03;&#x5EA6;&#x7C7B;&#x4E2D;&#x6CA1;&#x6709;&#x4EFB;&#x52A1;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE; <code>NULL</code>&#x3002;&#x5426;&#x5219;&#x8C03;&#x7528; <code>pick_next_entity()</code> &#x4ECE;&#x6811;&#x4E2D;&#x6311;&#x9009;&#x4E0B;&#x4E00;&#x4E2A;&#x4EFB;&#x52A1;&#x3002;&#x4E4B;&#x540E;&#x4F1A;&#x8F6C;&#x53D1;&#x7ED9; <code>set_next_entity()</code> &#x6765;&#x5C06;&#x4EFB;&#x52A1;&#x4ECE;&#x6811;&#x4E0A;&#x5220;&#x9664;&#xFF0C;&#x56E0;&#x4E3A;&#x8C03;&#x5EA6;&#x4E86;&#x7684;&#x8FDB;&#x7A0B;&#x662F;&#x4E0D;&#x5141;&#x8BB8;&#x7EE7;&#x7EED;&#x5B58;&#x5728;&#x8FD9;&#x91CC;&#x3002;&#x8FD9;&#x4E2A; <code>while</code> &#x5FAA;&#x73AF;&#x4F7F;&#x7528;&#x6765;&#x8FDB;&#x884C;&#x516C;&#x5E73;&#x7EC4;&#x8C03;&#x5EA6;&#x7684;&#x3002;</p>
<pre><code>static struct task_struct *pick_next_task_fair(struct rq *rq)
{
    struct task_struct *p;
    struct cfs_rq *cfs_rq = &amp;rq-&gt;cfs;
    struct sched_entity *se;
    if (!cfs_rq-&gt;nr_running)
        return NULL;
    do {
        se = pick_next_entity(cfs_rq);
        set_next_entity(cfs_rq, se);
        cfs_rq = group_cfs_rq(se);
    } while (cfs_rq);
    p = task_of(se);
    hrtick_start_fair(rq, p);
    return p;
}
</code></pre><p>&#x5728; <code>pick_next_entity()</code> &#x4E2D;&#xFF0C;&#x6811;&#x4E2D;&#x6700;&#x5DE6;&#x8FB9;&#x7684;&#x4EFB;&#x52A1;&#x5E76;&#x4E0D;&#x4E00;&#x5B9A;&#x4F1A;&#x88AB;&#x9009;&#x51FA;&#x6765;&#x8FD0;&#x884C;&#x3002;&#x4F19;&#x4F34;&#x7CFB;&#x7EDF;&#x4F1A;&#x7ED9;&#x51FA;&#x9009;&#x62E9;&#x4E0B;&#x4E00;&#x4E2A;&#x8981;&#x8FD0;&#x884C;&#x7684;&#x4EFB;&#x52A1;&#x7684;&#x7B49;&#x7EA7;&#x3002;&#x8FD9;&#x88AB;&#x8BA4;&#x4E3A;&#x662F;&#x6709;&#x76CA;&#x4E8E;&#x7F13;&#x5B58;&#x4F4D;&#x7F6E;&#x548C;&#x7EC4;&#x8C03;&#x5EA6;&#x3002;</p>
<pre><code>/*
* Pick the next process, keeping these things in mind, in this order:
* 1) keep things fair between processes/task groups
* 2) pick the &quot;next&quot; process, since someone really wants that to run
* 3) pick the &quot;last&quot; process, for cache locality
* 4) do not run the &quot;skip&quot; process, if something else is available
*/
static struct sched_entity *pick_next_entity(struct cfs_rq *cfs_rq)
{
    struct sched_entity *se = __pick_first_entity(cfs_rq);
    struct sched_entity *left = se;
    /*
    * Avoid running the skip buddy, if running something else can
    * be done without getting too unfair.
    */
    if (cfs_rq-&gt;skip == se) {
        struct sched_entity *second = __pick_next_entity(se);
        if (second &amp;&amp; wakeup_preempt_entity(second, left) &lt; 1)
            se = second;
    }
    /*
    * Prefer last buddy, try to return the CPU to a preempted task.
    */
    if (cfs_rq-&gt;last &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;last, left) &lt; 1)
        se = cfs_rq-&gt;last;
    /*
    * Someone really wants this to run. If it&apos;s not unfair, run it.
    */
    if (cfs_rq-&gt;next &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;next, left) &lt; 1)
        se = cfs_rq-&gt;next;
    clear_buddies(cfs_rq, se);
    return se;
}
</code></pre><p><code>__pick_first_entity()</code> &#x4ECE;&#x6811;&#x4E2D;&#x6311;&#x9009;&#x51FA;&#x6700;&#x5DE6;&#x8FB9;&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x4ECE;&#x4E0B;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x770B;&#x51FA;&#x6765;&#x8FD9;&#x662F;&#x975E;&#x5E38;&#x7B80;&#x5355;&#x548C;&#x5FEB;&#x901F;&#x7684;&#xFF1A;</p>
<pre><code>static struct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq)
{
    struct rb_node *left = cfs_rq-&gt;rb_leftmost;
    if (!left)
        return NULL;
    return rb_entry(left, struct sched_entity, run_node);
}
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class="search-results-count"></span> results matching &quot;<span class="search-query"></span>&quot;</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching &quot;<span class="search-query"></span>&quot;</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter7.html" class="navigation navigation-prev " aria-label="Previous page: 7 Completely Fair Scheduler (CFS)">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter9.html" class="navigation navigation-next " aria-label="Next page: 9 Soft Real-Time Scheduling">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"8 CFS Implementation Details","level":"1.9","depth":1,"next":{"title":"9 Soft Real-Time Scheduling","level":"1.10","depth":1,"path":"chapter9.md","ref":"chapter9.md","articles":[]},"previous":{"title":"7 Completely Fair Scheduler (CFS)","level":"1.8","depth":1,"path":"chapter7.md","ref":"chapter7.md","articles":[]},"dir":"ltr"},"config":{"plugins":["comment"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"comment":{"highlightCommented":true},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Ezio Zhang","pdf":{"pageNumbers":true,"fontSize":16,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Linux Process Schedule","language":"zh","links":{"sidebar":{"Linux Process Schedule":"https://www.gitbook.com/book/oska874/process-scheduling-in-linux"},"gitbook":true},"gitbook":"*","description":"tittle : Process Scheduling in Linux\r\n\r\nauthor : Volker Seeker  University of Edinburgh\r\n\r\ntype : technology translation\r\n\r\ninterpret : Ezio"},"file":{"path":"chapter8.md","mtime":"2016-08-11T15:51:40.000Z","type":"markdown"},"gitbook":{"version":"3.1.1","time":"2016-08-12T02:04:09.535Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-comment/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    


</body>
<!-- Mirrored from oska874.gitbooks.io/process-scheduling-in-linux/content/chapter8.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:23:51 GMT -->
</html>