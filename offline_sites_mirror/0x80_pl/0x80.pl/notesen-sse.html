<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen-sse.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:27 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Articles with tag sse</title>
<link rel="stylesheet" href="index.css" type="text/css" />
</head>
<body>
<div class="document" id="articles-with-tag-sse">
<h1 class="title">Articles with tag sse</h1>

<p><a class="reference external" href="notesen.html">all</a> |
by tag:
<a class="reference external" href="notesen-algorithms.html">algorithms</a>
|
<a class="reference external" href="notesen-assembler.html">assembler</a>
|
<a class="reference external" href="notesen-avx2.html">avx2</a>
|
<a class="reference external" href="notesen-avx512.html">avx512</a>
|
<a class="reference external" href="notesen-base64.html">base64</a>
|
<a class="reference external" href="notesen-bit-twiddling.html">bit twiddling</a>
|
<a class="reference external" href="notesen-bmi.html">bmi</a>
|
<a class="reference external" href="notesen-c.html">c</a>
|
<a class="reference external" href="notesen-c%2b%2b.html">c++</a>
|
<a class="reference external" href="notesen-codedive.html">codedive</a>
|
<a class="reference external" href="notesen-compilers.html">compilers</a>
|
<a class="reference external" href="notesen-compression.html">compression</a>
|
<a class="reference external" href="notesen-computer-graphics.html">computer graphics</a>
|
<a class="reference external" href="notesen-corectness.html">corectness</a>
|
<a class="reference external" href="notesen-data-structures.html">data structures</a>
|
<a class="reference external" href="notesen-floating-point.html">floating-point</a>
|
<a class="reference external" href="notesen-gcc.html">gcc</a>
|
<a class="reference external" href="notesen-hashing.html">hashing</a>
|
<a class="reference external" href="notesen-javascript.html">javascript</a>
|
<a class="reference external" href="notesen-k-means.html">k-means</a>
|
<a class="reference external" href="notesen-loongarch64.html">loongarch64</a>
|
<a class="reference external" href="notesen-neon.html">neon</a>
|
<a class="reference external" href="notesen-number-printing.html">number printing</a>
|
<a class="reference external" href="notesen-parsing.html">parsing</a>
|
<a class="reference external" href="notesen-perfect-hashing.html">perfect hashing</a>
|
<a class="reference external" href="notesen-php.html">php</a>
|
<a class="reference external" href="notesen-popcount.html">popcount</a>
|
<a class="reference external" href="notesen-pospocount.html">pospocount</a>
|
<a class="reference external" href="notesen-postgres.html">postgres</a>
|
<a class="reference external" href="notesen-printing-numbers.html">printing numbers</a>
|
<a class="reference external" href="notesen-python.html">python</a>
|
<a class="reference external" href="notesen-raster-graphics.html">raster graphics</a>
|
<a class="reference external" href="notesen-riscv.html">riscv</a>
|
<a class="reference external" href="notesen-rvv.html">rvv</a>
|
<a class="reference external" href="notesen-simd.html">simd</a>
|
<a class="reference external" href="notesen-sse.html">sse</a>
|
<a class="reference external" href="notesen-sse2.html">sse2</a>
|
<a class="reference external" href="notesen-sse4.html">sse4</a>
|
<a class="reference external" href="notesen-ssse3.html">ssse3</a>
|
<a class="reference external" href="notesen-strings.html">strings</a>
|
<a class="reference external" href="notesen-swar.html">swar</a>
|
<a class="reference external" href="notesen-unicode.html">unicode</a>
|
<a class="reference external" href="notesen-unix.html">unix</a>
|
<a class="reference external" href="notesen-varia.html">varia</a>
|
<a class="reference external" href="notesen-x86.html">x86</a>
|
<a class="reference external" href="notesen-xop.html">xop</a></p>
<p><a class="reference external" href="search.html">üîç search</a></p>
<div class="section" id="section-1">
<h1>2025</h1>
<ul class="simple">
<li>[2025-01-03] <a class="reference external" href="notesen/2025-01-03-uint16-division.html">Dividing unsigned 16-bit numbers</a></li>
</ul>
</div>
<div class="section" id="section-2">
<h1>2024</h1>
<ul class="simple">
<li>[2024-12-21] <a class="reference external" href="notesen/2024-12-21-uint8-division.html">Dividing unsigned 8-bit numbers</a></li>
</ul>
</div>
<div class="section" id="section-3">
<h1>2023</h1>
<ul class="simple">
<li>[2023-04-09] <a class="reference external" href="notesen/2023-04-09-faster-parse-ipv4.html">SIMD-ized faster parse of IPv4 addresses</a> &mdash; 2-3 times faster than scalar version</li>
</ul>
</div>
<div class="section" id="section-4">
<h1>2022</h1>
<ul class="simple">
<li>[2022-01-17] <a class="reference external" href="notesen/2022-01-17-validating-hex-parse.html">Parsing hex numbers with validation</a></li>
</ul>
</div>
<div class="section" id="section-5">
<h1>2021</h1>
<ul class="simple">
<li>[2021-02-02] <a class="reference external" href="notesen/2021-02-02-all-bytes-in-reg-are-equal.html">How to detect if all bytes in SIMD register are the same?</a></li>
</ul>
</div>
<div class="section" id="section-6">
<h1>2019</h1>
<ul class="simple">
<li>[2019-02-03] <a class="reference external" href="notesen/2019-02-03-simd-switch-implementation.html">SIMDization of switch statements</a> &mdash; some switch statements can be vectorized</li>
<li>[2019-01-29] <a class="reference external" href="notesen/2019-01-29-simd-count-byte.html">SIMDized counting byte in byte stream</a> &mdash; SSE/AVX2/AVX512 can help a lot</li>
</ul>
</div>
<div class="section" id="section-7">
<h1>2018</h1>
<ul class="simple">
<li>[2018-11-18] <a class="reference external" href="notesen/2018-11-18-sse-sumbytes-part2.html">SIMDized sum of all bytes in the array &mdash; part 2: signed bytes</a> &mdash; <tt class="docutils literal"><span class="pre">std::accumulate(array,</span> array + size, int32_t(0))</tt> can be 2.5 times faster</li>
<li>[2018-10-28] <a class="reference external" href="notesen/2018-10-28-cpp-static-vectors.html">SIMD &mdash; why you shouldn't use static vector constants</a></li>
<li>[2018-10-24] <a class="reference external" href="notesen/2018-10-24-sse-sumbytes.html">SIMDized sum of all bytes in the array</a> &mdash; <tt class="docutils literal"><span class="pre">std::accumulate(array,</span> array + size, 0)</tt> can be six times faster</li>
<li>[2018-10-18] <a class="reference external" href="notesen/2018-10-18-simd-byte-lookup.html">SIMDized check which bytes are in a set</a> &mdash; functions like <tt class="docutils literal">isspace</tt> with SSE/AVX2/AVX512 instructions</li>
<li>[2018-10-03] <a class="reference external" href="notesen/2018-10-03-simd-index-of-min.html">Finding index of the minimum value using SIMD instructions</a> &mdash; compilers can't do this (yet)</li>
<li>[2018-04-19] <a class="reference external" href="notesen/2018-04-19-simd-parsing-int-sequences.html">Parsing series of integers with SIMD</a> &mdash; parse multiple decimal integers separated by arbitrary number of delimiters can be really fast with SSE</li>
<li>[2018-04-11] <a class="reference external" href="notesen/2018-04-11-simd-is-sorted.html">Is sorted using SIMD instructions</a> &mdash; faster <tt class="docutils literal"><span class="pre">std::is_sorted</span></tt></li>
<li>[2018-03-14] <a class="reference external" href="notesen/2018-03-14-set-intersection.html">Intersection of ordered sets</a> &mdash; a study of a special case (SIMD approach included)</li>
<li>[2018-03-11] <a class="reference external" href="notesen/2018-03-11-sse-abs-unsigned.html">SSE/AVX: absolute value of difference of unsigned integers</a></li>
</ul>
</div>
<div class="section" id="section-8">
<h1>2016</h1>
<ul class="simple">
<li>[2016-11-28] <a class="reference external" href="notesen/2016-11-28-simd-strfind.html">SIMD-friendly algorithms for substring searching</a> &mdash; faster <tt class="docutils literal">strstr</tt> with SIMD instructions (SSE4, AVX2, AVX512, ARM Neon)</li>
<li>[2016-09-14] <a class="reference external" href="notesen/2016-09-14-simd-bit-mask.html">SIMD bit mask</a> &mdash; fill a SIMD register starting from k-th bit</li>
<li>[2016-09-14] <a class="reference external" href="notesen/2016-09-14-building-bitmask.html">Building a bitmask</a> &mdash; There is an array of 32-bit integers and a key &mdash; specific value. The result have to be a bit vector with bits set on these position where the key is equal to array items.</li>
<li>[2016-03-13] <a class="reference external" href="notesen/2016-03-13-simd-lookup-pshufb.html">Implementing byte-wise lookup table with PSHUFB</a> &mdash; a spin off from base64 decoding research, pretty straightforward use of <tt class="docutils literal">pshufb</tt></li>
<li>[2016-01-17] <a class="reference external" href="notesen/2016-01-17-sse-base64-decoding.html">Base64 decoding with SIMD instructions</a> &mdash; SSE code could by more than 2 times faster than lookup-based scalar code</li>
<li>[2016-01-12] <a class="reference external" href="notesen/2016-01-12-sse-base64-encoding.html">Base64 encoding with SIMD instructions</a> &mdash; SSE code could by more than 2 times faster than lookup-based scalar code</li>
</ul>
</div>
<div class="section" id="section-9">
<h1>2015</h1>
<ul class="simple">
<li>[2015-04-08] <a class="reference external" href="notesen/2015-04-08-simd-search.html">SIMD-ized searching in unique constant dictionary</a> &mdash; there is a <strong>ordered dictionary</strong> containing only <strong>unique</strong> keys, the dictionary is read only, and keys are 32-bit (SSE) or 64-bit (AVX2)</li>
<li>[2015-03-22] <a class="reference external" href="notesen/2015-03-22-simd-pattern.html">SIMD: detecting a bit pattern</a> &mdash; trying to solve specific problem, different approaches are shown</li>
<li>[2015-03-21] <a class="reference external" href="notesen/2015-03-21-sse-generating-mask.html">SSE/AVX2: Generating mask where n leading (trailing) bytes are set</a> &mdash; three methods, one the best</li>
</ul>
</div>
<div class="section" id="section-10">
<h1>2014</h1>
<ul class="simple">
<li>[2014-10-22] <a class="reference external" href="notesen/2014-10-22-sse-convert-hex-to-ascii.html">Using SSE to convert from hexadecimal ASCII to number</a> &mdash; SSE procedure can convert 16- and 32-digits inputs producing 8- and 16-byte results</li>
<li>[2014-10-02] <a class="reference external" href="notesen/2014-10-02-convert-to-oct.html">Conversion numbers to octal representation</a></li>
<li>[2014-09-21] <a class="reference external" href="notesen/2014-09-21-convert-to-hex.html">Conversion numbers to hexadecimal representation</a> &mdash; SWAR, SSE and BMI2 conversions</li>
<li>[2014-03-16] <a class="reference external" href="notesen/2014-03-16-scalar-sse-movmask.html">Scalar version of SSE move mask instruction</a> &mdash; how to emulate instruction <tt class="docutils literal">PMOVMSKB</tt></li>
<li>[2014-03-11] <a class="reference external" href="notesen/2014-03-11-simd-friendly-karp-rabin.html">SIMD-friendly Rabin-Karp modification</a> &mdash; speedup over <tt class="docutils literal">strstr</tt> is around 3-4 times</li>
<li>[2014-01-26] <a class="reference external" href="notesen/2014-01-26-sse-penalties-of-errors.html">Penalties of errors in SSE floating point calculations</a> &mdash; special floating-point values (for example denormalized) slow down computations</li>
</ul>
</div>
<div class="section" id="section-11">
<h1>2013</h1>
<ul class="simple">
<li>[2013-09-30] <a class="reference external" href="notesen/2013-09-30-sse-trie.html">SSE: trie lookup speedup</a> &mdash; different methods of walking along paths in tries</li>
</ul>
</div>
<div class="section" id="section-12">
<h1>2011</h1>
<ul class="simple">
<li>[2011-10-21] <a class="reference external" href="notesen/2011-10-21-sse-itoa.html">SSE: conversion integers to decimal representation</a> &mdash; fast conversion integers to decimal representation using SSE instructions</li>
</ul>
</div>
<div class="section" id="section-13">
<h1>2010</h1>
<ul class="simple">
<li>[2010-05-01] <a class="reference external" href="notesen/2010-05-01-reverse-array-of-bytes.html">Speedup reversing table of bytes</a></li>
<li>[2010-03-31] <a class="reference external" href="notesen/2010-03-31-simd-transpose-bits.html">Transpose bits in byte using SIMD instructions</a></li>
</ul>
</div>
<div class="section" id="section-14">
<h1>2008</h1>
<ul class="simple">
<li>[2008-06-21] <a class="reference external" href="notesen/2008-06-21-sse4-crossfading.html">SSSE3: PMADDUBSW and image crossfading</a></li>
<li>[2008-06-18] <a class="reference external" href="notesen/2008-06-18-sse-uint32-to-float.html">SSE: conversion uint32 to float</a></li>
<li>[2008-06-15] <a class="reference external" href="notesen/2008-06-15-fptricks.html">Floating point tricks</a></li>
<li>[2008-06-01] <a class="reference external" href="notesen/2008-06-01-sse-pix16to32bpp.html">16bpp/15bpp to 32bpp pixel conversions &mdash; different methods</a></li>
<li>[2008-05-24] <a class="reference external" href="notesen/2008-05-24-sse-popcount.html">SSSE3: fast popcount</a> &mdash; Population count on large bitstring could be sevaral times faster than lookup-based approach. And an AVX2 implementation is faster than dedicated <tt class="docutils literal">popcnt</tt> instruction.</li>
</ul>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen-sse.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:27 GMT -->
</html>
