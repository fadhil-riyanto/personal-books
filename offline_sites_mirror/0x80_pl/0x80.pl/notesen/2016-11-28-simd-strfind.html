<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2016-11-28-simd-strfind.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:42 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>SIMD-friendly algorithms for substring searching</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="simd-friendly-algorithms-for-substring-searching">
<h1 class="title">SIMD-friendly algorithms for substring searching</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2016-11-28</td>
</tr>
<tr class="updated-on field"><th class="docinfo-name">Updated on:</th><td class="field-body">2018-02-14 (spelling), 2017-04-29 (ARMv8 results)</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>Popular programming languages provide methods or functions which locate a
substring in a given string. In C it is the function <tt class="docutils literal">strstr</tt>, the C++
class <tt class="docutils literal"><span class="pre">std::string</span></tt> has the method <tt class="docutils literal">find</tt>, Python's <tt class="docutils literal">string</tt> has methods
<tt class="docutils literal">pos</tt> and <tt class="docutils literal">index</tt>, and so on, so forth. All these APIs were designed for
<strong>one-shot searches</strong>.  During past decades several algorithms to solve this
problem were designed, an excellent page by <strong>Christian Charras</strong> and
<strong>Thierry Lecroq</strong> <a class="reference external" href="http://www-igm.univ-mlv.fr/~lecroq/string/">lists most of them</a> (if not all). Basically these
algorithms could be split into two major categories: (1) based on
Deterministic Finite Automaton, like Knuth-Morris-Pratt, Boyer Moore, etc.,
and (2) based on a simple comparison, like the Karp-Rabin algorithm.</p>
<p>The main problem with these standard algorithms is a silent assumption
that comparing a pair of characters, looking up in an extra table and
conditions are cheap, while comparing two substrings is expansive.</p>
<p>But current desktop CPUs do not meet this assumption, in particular:</p>
<ul class="simple">
<li>There is no difference in comparing one, two, four or 8 bytes on a 64-bit
CPU.  When a processor supports SIMD instructions, then comparing vectors
(it means 16, 32 or even 64 bytes) is as cheap as comparing a single byte.</li>
<li>Thus comparing short sequences of chars can be faster than fancy algorithms
which avoids such comparison.</li>
<li>Looking up in a table costs one memory fetch, so at least a L1 cache round
(~3 cycles). Reading char-by-char also cost as much cycles.</li>
<li>Mispredicted jumps cost several cycles of penalty (~10-20 cycles).</li>
<li>There is a short chain of dependencies: read char, compare it, conditionally
jump, which make hard to utilize out-of-order execution capabilities present
in a CPU.</li>
</ul>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#solution" id="toc-entry-2">Solution</a></li>
<li><a class="reference internal" href="#algorithm-1-generic-simd" id="toc-entry-3">Algorithm 1: Generic SIMD</a><ul>
<li><a class="reference internal" href="#algorithm" id="toc-entry-4">Algorithm</a><ul>
<li><a class="reference internal" href="#example" id="toc-entry-5">Example</a></li>
<li><a class="reference internal" href="#first-and-last" id="toc-entry-6">First and last?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="toc-entry-7">Implementation</a><ul>
<li><a class="reference internal" href="#sse-avx2" id="toc-entry-8">SSE &amp; AVX2</a></li>
<li><a class="reference internal" href="#swar" id="toc-entry-9">SWAR</a></li>
<li><a class="reference internal" href="#avx512f" id="toc-entry-10">AVX512F</a></li>
<li><a class="reference internal" href="#arm-neon-32-bit-code" id="toc-entry-11">ARM Neon (32 bit code)</a></li>
<li><a class="reference internal" href="#aarch64-64-bit-code" id="toc-entry-12">AArch64 (64 bit code)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#algorithm-2-sse-specific-mpsadbw" id="toc-entry-13">Algorithm 2: SSE-specific (MPSADBW)</a><ul>
<li><a class="reference internal" href="#algorithm-1" id="toc-entry-14">Algorithm</a></li>
<li><a class="reference internal" href="#implementation-1" id="toc-entry-15">Implementation</a><ul>
<li><a class="reference internal" href="#sse" id="toc-entry-16">SSE</a></li>
<li><a class="reference internal" href="#avx512f-1" id="toc-entry-17">AVX512F</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#algorithm-3-sse4-2-specific-pcmpestrm" id="toc-entry-18">Algorithm 3: SSE4.2-specific (PCMPESTRM)</a><ul>
<li><a class="reference internal" href="#algorithm-2" id="toc-entry-19">Algorithm</a></li>
<li><a class="reference internal" href="#implementation-2" id="toc-entry-20">Implementation</a><ul>
<li><a class="reference internal" href="#sse-1" id="toc-entry-21">SSE</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#performance-results" id="toc-entry-22">Performance results</a><ul>
<li><a class="reference internal" href="#x64-computers" id="toc-entry-23">x64 computers</a></li>
<li><a class="reference internal" href="#arm-computers" id="toc-entry-24">ARM computers</a></li>
<li><a class="reference internal" href="#conclusions-and-remarks" id="toc-entry-25">Conclusions and remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgments" id="toc-entry-26">Acknowledgments</a></li>
<li><a class="reference internal" href="#source-code" id="toc-entry-27">Source code</a></li>
<li><a class="reference internal" href="#history" id="toc-entry-28">History</a></li>
</ul>
</div>
</div>
<div class="section" id="solution">
<h1>Solution</h1>
<p>This article shows two approaches utilizing SIMD instructions which I've
already described in <a class="reference external" href="2014-03-11-simd-friendly-karp-rabin.html">SIMD-friendly Rabin-Karp modification</a> and <a class="reference external" href="2008-05-27-sse4-substring-locate.html">SSE4
string search &mdash; modification of Karp-Rabin algorithm</a>.  I merged the
articles, compared these two methods and extended material.  Article shows
also performance results for various implementations, ranging from
<a class="reference external" href="http://en.wikipedia.org/wiki/SWAR">SWAR</a> to AVX512F.</p>
<p>The Karp-Rabin algorithm does the exact substring comparison whenever <strong>weak
hashes</strong> are equal. One hash is calculated just once for searched substring,
and another one is calculated for string's portion; in every iteration the
second hash is updated at small cost. Following code shows the idea:</p>
<pre class="code ada literal-block">
<span class="n">k</span>  <span class="p">:=</span> <span class="n">substring</span> <span class="n">length</span>
<span class="n">h1</span> <span class="p">:=</span> <span class="n">hash</span><span class="p">(</span><span class="n">substring</span><span class="p">)</span>
<span class="n">h2</span> <span class="p">:=</span> <span class="n">hash</span><span class="p">(</span><span class="kt">string</span><span class="p">[</span><span class="n">i</span> <span class="p">..</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">])</span>
<span class="kr">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="kr">loop</span>
    <span class="kr">if</span> <span class="n">h1</span> <span class="o">==</span> <span class="n">h2</span> <span class="kr">then</span>
        <span class="kr">if</span> <span class="n">substring</span> <span class="o">==</span> <span class="kt">string</span><span class="p">[</span><span class="n">i</span> <span class="p">..</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="kr">then</span>
            <span class="kr">return</span> <span class="n">i</span>
        <span class="kr">end</span> <span class="kr">if</span>
    <span class="nf">end</span> <span class="kr">if</span>

    <span class="nf">h</span> <span class="err">=</span> <span class="nf">next_hash</span><span class="err">(</span><span class="nf">h</span><span class="err">,</span> <span class="nf">...</span><span class="err">)</span> <span class="err">#</span> <span class="nf">this</span> <span class="nf">meant</span> <span class="nf">to</span> <span class="nf">be</span> <span class="nf">cheap</span>
<span class="nf">end</span> <span class="kr">loop</span>
</pre>
<p>SIMD solutions replace the hash predicate with <strong>a vector predicate</strong>, which
is calculated in parallel and, hopefully, is calculated fast.  For each
&quot;true&quot; element of the predicate vector an exact comparison of substrings is
performed.</p>
<p>This is one source of improvement, another is a careful implementation.
A generic implementation calls a function like <tt class="docutils literal">memcmp</tt> to compare
substrings.  But while we know the length of searched substring, we may
provide specialisations for certain lengths, where a subprocedure call
is replaced by a few CPU instructions, even just one. Thanks to that
the cost of calling the procedure and all internal <tt class="docutils literal">memcmp</tt> costs are
simply ridden off.</p>
</div>
<div class="section" id="algorithm-1-generic-simd">
<span id="algorithm-1-generic"></span><h1>Algorithm 1: Generic SIMD</h1>
<div class="section" id="algorithm">
<h2>Algorithm</h2>
<p>This algorithm is suitable for all SIMD instruction sets and also SWAR approach.  It
uses as a predicate equality of <strong>the first</strong> and <strong>the last</strong> characters from the
substring.</p>
<p>These two characters are populated in two registers, <strong>F</strong> and <strong>L</strong>
respectively.  Then in each iteration two chunks of strings are loaded.  The
first chunk (<strong>A</strong>) is read from offset <tt class="docutils literal">i</tt> (where <tt class="docutils literal">i</tt> is the current
offset) and the second chunk (<strong>B</strong>) is read from offset <tt class="docutils literal">i + k - 1</tt>, where
<tt class="docutils literal">k</tt> is substring's length.</p>
<p>Then we compute a vector expression <tt class="docutils literal">F == A and B == L</tt>. This step yields a
byte vector (or a bit mask), where &quot;true&quot; values denote position of potential
substring occurrences.  Finally, just at these positions an exact comparisons of
substrings are performed.</p>
<div class="section" id="example">
<h3>Example</h3>
<p>Let's assume 8-byte registers. We're searching for word &quot;cat&quot;, thus:</p>
<pre class="literal-block">
F    = [ c | c | c | c | c | c | c | c ]
L    = [ t | t | t | t | t | t | t | t ]
</pre>
<p>We're searching in the string &quot;a_cat_tries&quot;. In the first iteration the register
<strong>A</strong> gets data from offset 0, <strong>B</strong> from offset 2:</p>
<pre class="literal-block">
A    = [ a | _ | c | a | t | _ | t | r ]
B    = [ c | a | t | _ | t | r | i | e ]
</pre>
<p>Now we compare:</p>
<pre class="literal-block">
AF   = (A == F)
     = [ 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 ]

BL   = (B == L)
     = [ 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 ]
</pre>
<p>After merging comparison results, i.e. <tt class="docutils literal">AF &amp; BL</tt>, we get following mask:</p>
<pre class="literal-block">
mask = [ 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 ]
</pre>
<p>Since the mask is non-zero, it means there are possible substring occurrences.
As we see, there is only one non-zero element at index 2, thus only one
substring comparison must be performed.</p>
</div>
<div class="section" id="first-and-last">
<h3>First and last?</h3>
<p>Choosing the first and the last character from a substring is not always a
wise decision. Consider following scenario: a string contains mostly 'A'
characters, and a user wants to find &quot;AjohndoeA&quot; &mdash; in such situation the
number of char-wise would be large.</p>
<p>In order to prevent such situations an implementation can pick &quot;last&quot; character
as the farthest character not equal to the first one. If there is no such
character, it means that all characters in substring are the same (for example
&quot;AAAAA&quot;). A specialised procedure may be used to handle such patterns.</p>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<div class="section" id="sse-avx2">
<span id="generic-sse-avx2"></span><h3>SSE &amp; AVX2</h3>
<p>Both SSE and AVX2 versions are practically the same, and both use the
minimum number of instruction. Below is a generic AVX2 version.</p>
<p>It's worth to note that since we already know that the first and the last
characters match, we don't need to compare them again with <tt class="docutils literal">memcmp</tt>.</p>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">avx2_strstr_anysize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_set1_epi8</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_set1_epi8</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">block_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">block_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">eq_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cmpeq_epi8</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">block_first</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">eq_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cmpeq_epi8</span><span class="p">(</span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">block_last</span><span class="p">);</span><span class="w">

        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_movemask_epi8</span><span class="p">(</span><span class="n">_mm256_and_si256</span><span class="p">(</span><span class="n">eq_first</span><span class="p">,</span><span class="w"> </span><span class="n">eq_last</span><span class="p">));</span><span class="w">

        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">bitpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bits</span><span class="o">::</span><span class="n">get_first_bit_set</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bitpos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bitpos</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bits</span><span class="o">::</span><span class="n">clear_leftmost_set</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="swar">
<span id="generic-swar"></span><h3>SWAR</h3>
<p>In SWAR approach, comparison for equality uses bit xor operation, which yields zero when
two bytes are equal. Therefore instead of anding partial results, the bitwise
or is used. Clearly this part of algorithm has the same complexity as the
SSE/AVX2 code.</p>
<p>However, SWAR requires more effort to locate zero bytes. Following procedure
calculates <strong>an exact byte mask</strong>, where MSBs of <tt class="docutils literal">zeros</tt> are set when the
corresponding byte in <tt class="docutils literal">x</tt> is zero.</p>
<pre class="code cpp literal-block">
<span class="c1">// 7th bit set if lower 7 bits are zero
</span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x7f7f7f7f7f7f7f7fllu</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x0101010101010101llu</span><span class="p">;</span><span class="w">
</span><span class="c1">// 7th bit set if 7th bit is zero
</span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x8080808080808080llu</span><span class="p">);</span><span class="w">
</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">zeros</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span>
</pre>
<p>Below is the C++ implementation for 64-bit vectors. The while loop contains an
additional condition which might look not optimal. But searching the first set
bit and later clearing it (as the SSE version does) is slower.</p>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">swar64_strstr_anysize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0101010101010101llu</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0101010101010101llu</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w">

    </span><span class="kt">uint64_t</span><span class="o">*</span><span class="w"> </span><span class="n">block_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="o">*</span><span class="w"> </span><span class="n">block_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0u</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">block_first</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">block_last</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">block_first</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">block_last</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">last</span><span class="p">);</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="n">eq</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x7f7f7f7f7f7f7f7fllu</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x0101010101010101llu</span><span class="p">;</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="n">eq</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x8080808080808080llu</span><span class="p">);</span><span class="w">
        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">zeros</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span><span class="w">
        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">

        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">zeros</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x80</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">substr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">block_first</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">substr</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">zeros</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">
            </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx512f">
<span id="generic-avx512f"></span><h3>AVX512F</h3>
<p>AVX512F lacks of operations on bytes, the smallest vector item is a
32-bit word. The limitation forces us to use SWAR techniques.</p>
<ol class="arabic simple">
<li>Using AVX512F instructions we compare two vectors, like in SWAR version,
i.e. two xors joined with bitwise or.
There is only one difference, a single <a class="reference external" href="2015-03-22-avx512-ternary-functions.html">ternary logic instruction</a>
expresses one xor and bitwise or.</li>
<li>Using AVX512F instructions we locate which 32-bit elements
contain any zero byte.</li>
<li>Then for such 32-bit element check four substrings for equality.</li>
</ol>
<p>Unlike the SWAR procedure, where we need a precise mask for zero bytes, an
AVX512F procedure requires just information &quot;a word has zero byte&quot;.  A
simpler algorithm, described in <a class="reference external" href="https://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a> is used; below
is its C++ implementation.</p>
<pre class="code cpp literal-block">
<span class="n">__mmask16</span><span class="w"> </span><span class="nf">zero_byte_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">v01</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="mh">0x01010101u</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">v80</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="mh">0x80808080u</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">v1</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_sub_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">v01</span><span class="p">);</span><span class="w">
    </span><span class="c1">// tmp1 = (v - 0x01010101) &amp; ~v &amp; 0x80808080
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_ternarylogic_epi32</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">v80</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">);</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">_mm512_test_epi32_mask</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span><span class="w"> </span><span class="n">tmp1</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>Generic C++ implementation.</p>
<pre class="code cpp literal-block">
<span class="cp">#define _mm512_set1_epu8(c) _mm512_set1_epi32(uint32_t(c) * 0x01010101u)
</span><span class="w">
</span><span class="kt">size_t</span><span class="w"> </span><span class="nf">avx512f_strstr_v2_anysize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">assert</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
    </span><span class="n">assert</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epu8</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epu8</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w">

    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">string</span><span class="p">);</span><span class="w">
    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="cm">/**/</span><span class="p">;</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">block_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">block_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">first_zeros</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_xor_si512</span><span class="p">(</span><span class="n">block_first</span><span class="p">,</span><span class="w"> </span><span class="n">first</span><span class="p">);</span><span class="w">
        </span><span class="c1">// zeros = first_zeros | (block_last ^ last)
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">zeros</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_ternarylogic_epi32</span><span class="p">(</span><span class="n">first_zeros</span><span class="p">,</span><span class="w"> </span><span class="n">block_last</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf6</span><span class="p">);</span><span class="w">

        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero_byte_mask</span><span class="p">(</span><span class="n">zeros</span><span class="p">);</span><span class="w">
        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

            </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bits</span><span class="o">::</span><span class="n">clear_leftmost_set</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="kt">size_t</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="arm-neon-32-bit-code">
<span id="generic-neon32"></span><h3>ARM Neon (32 bit code)</h3>
<p>The algorithm can be also easily realised using ARM Neon instructions, having
128-bit SIMD registers.  The only problem is caused by long round trip from
the Neon unit back to the CPU.</p>
<p>It was solved by saving back the comparison result in a 64 bit word in memory:
lower nibbles come from the lower half of a SIMD register, likewise higher
nibbles come from the higher half of the register.</p>
<p>Comparison is done in two loops, separately for lower and higher nibbles.
This split is required to detect substring occurrences in the correct order.</p>
<p>Below is a sample implementation.</p>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="n">FORCE_INLINE</span><span class="w"> </span><span class="n">neon_strstr_anysize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">assert</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
    </span><span class="n">assert</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x16_t</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vdupq_n_u8</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x16_t</span><span class="w"> </span><span class="n">last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">vdupq_n_u8</span><span class="p">(</span><span class="n">needle</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x8_t</span><span class="w">  </span><span class="n">half</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">vdup_n_u8</span><span class="p">(</span><span class="mh">0x0f</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">

    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w">
        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">word</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">
    </span><span class="p">};</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x16_t</span><span class="w"> </span><span class="n">block_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vld1q_u8</span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x16_t</span><span class="w"> </span><span class="n">block_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">vld1q_u8</span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x16_t</span><span class="w"> </span><span class="n">eq_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vceqq_u8</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">block_first</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x16_t</span><span class="w"> </span><span class="n">eq_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">vceqq_u8</span><span class="p">(</span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">block_last</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x16_t</span><span class="w"> </span><span class="n">pred_16</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">vandq_u8</span><span class="p">(</span><span class="n">eq_first</span><span class="p">,</span><span class="w"> </span><span class="n">eq_last</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">uint8x8_t</span><span class="w"> </span><span class="n">pred_8</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">vbsl_u8</span><span class="p">(</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">vget_low_u8</span><span class="p">(</span><span class="n">pred_16</span><span class="p">),</span><span class="w"> </span><span class="n">vget_high_u8</span><span class="p">(</span><span class="n">pred_16</span><span class="p">));</span><span class="w">

        </span><span class="n">vst1_u8</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">pred_8</span><span class="p">);</span><span class="w">

        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">continue</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xf0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>It appeared that unrolling the two inner loops brought about 1.2 speedup.</p>
</div>
<div class="section" id="aarch64-64-bit-code">
<span id="generic-aarch64"></span><h3>AArch64 (64 bit code)</h3>
<p>AArch64 code is almost the exact copy of the above ARM Neon procedure.
The only exception is direct reading of SIMD registers lanes, as the
architecture made this operation fast.</p>
</div>
</div>
</div>
<div class="section" id="algorithm-2-sse-specific-mpsadbw">
<h1>Algorithm 2: SSE-specific (MPSADBW)</h1>
<div class="section" id="algorithm-1">
<h2>Algorithm</h2>
<p>SSE4.1 and AVX2 provide instruction <tt class="docutils literal">MPSADBW</tt>, which calculates eight
<a class="reference external" href="http://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distances</a> (L1) between given 4-byte
sub-vector from one register and eight subsequent 4-byte sub-vector from
second register. The instruction returns vector of eight words (16-bit values).</p>
<p>When two sub-vectors are equal, then the L1 distance is 0, and we may use this
property to locate possible substring locations. In other words <strong>equality of
four leading characters</strong> is used as a predicate.</p>
<p>Albeit it seems to be a stronger predicate than matching the first and the last
characters, a quadratic complexity is unavoidable.  For example, when the
searched string contains one letter &quot;a&quot;, and we're looking for &quot;aaaabcde&quot;, then
the predicate obviously will be true for all input characters.</p>
<p>If it isn't enough, there are following problems:</p>
<ul class="simple">
<li>This method handles substring not shorter than four characters.
Handling three-char substrings is viable, but require additional code.</li>
<li>SSE variant of <tt class="docutils literal">MPSADBW</tt> processes only 8 bytes at once, while the
generic SIMD variant uses the whole register.</li>
<li>AVX2 variant of <tt class="docutils literal">MPSADBW</tt> works on lanes, i.e. 128-bit helves of
a register rather than the whole 256-bit register. This imposes
additional code to properly load data.</li>
<li>Latency of the instruction is pretty hight &mdash; 5 or 7 cycles,
depending on CPU architecture. Luckily throughput is 1 or 2 cycles,
thus unrolling a loop can hide latency.</li>
</ul>
</div>
<div class="section" id="implementation-1">
<h2>Implementation</h2>
<div class="section" id="sse">
<span id="mpsadbw-sse-avx2"></span><h3>SSE</h3>
<p>The generic, simplest implementation.</p>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">sse4_strstr_anysize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">needle_size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">needle</span><span class="p">));</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">zeros</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_setzero_si128</span><span class="p">();</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">data</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_mpsadbw_epu8</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">cmp</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi16</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zeros</span><span class="p">);</span><span class="w">

        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">cmp</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x5555</span><span class="p">;</span><span class="w">

        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">bitpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bits</span><span class="o">::</span><span class="n">get_first_bit_set</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bitpos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">needle_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bitpos</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bits</span><span class="o">::</span><span class="n">clear_leftmost_set</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx512f-1">
<span id="mpsadbw-avx512f"></span><h3>AVX512F</h3>
<p>Although AVX512F doesn't support <tt class="docutils literal">MPSADBW</tt> (AVX512BW defines it) we still
can use 4-byte prefix equality as a predicate, utilizing fact that 32-bit
elements are natively supported.</p>
<p>In each iteration we generate four AVX512 vectors containing all possible
4-byte prefixes. Example:</p>
<pre class="literal-block">
string = &quot;the-cat-tries-to-eat...&quot;

vec0  = [ t | h | e | - ][ c | a | t | - ][ t | r | i | e ][ s | - | t | o ][ ... ]
vec1  = [ h | e | - | c ][ a | t | - | t ][ r | i | e | s ][ - | t | o | - ][ ... ]
vec2  = [ e | - | c | a ][ t | - | t | r ][ i | e | s | - ][ t | o | - | e ][ ... ]
vec3  = [ - | c | a | t ][ - | t | r | i ][ e | s | - | t ][ o | - ] e | a ][ ... ]
</pre>
<p>Vector <tt class="docutils literal">vec0</tt> contains prefixes for position 0, 4, 8, 12, ...;
<tt class="docutils literal">vec1</tt> &mdash; 1, 5, 9, 13, ..., <tt class="docutils literal">vec2</tt> &mdash; 2, 6, 10, 14, ...;
<tt class="docutils literal">vec3</tt> &mdash; 3, 7, 11, 15, etc.</p>
<p>Building each vector require two shifts and one bitwise or. In each iteration
four vector comparison are performed and then four bitmasks are examined. This
make a loop, which compares substrings, quite complicated.</p>
<p>Moreover, to properly fill the last elements of vectors we need four bytes
beyond vector.  This is accomplished by having two adjacent vectors per
iterations (one load per iteration is needed, though). Finally, instruction
<tt class="docutils literal">VPALIGNR</tt> is used to extract required data.</p>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">avx512f_strstr_long</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">
    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w">
    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">;</span><span class="w">

    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">string</span><span class="p">);</span><span class="w">
    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">last</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">prf</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">needle</span><span class="p">;</span><span class="w"> </span><span class="c1">// the first 4 bytes of needle
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="n">prf</span><span class="p">);</span><span class="w">

    </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">(</span><span class="n">haystack</span><span class="p">);</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="cm">/**/</span><span class="p">;</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">haystack</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w">
        </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">shft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_alignr_epi32</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

        </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">

        </span><span class="p">{</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_srli_epi32</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_slli_epi32</span><span class="p">(</span><span class="n">shft</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w">
            </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_or_si512</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_srli_epi32</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_slli_epi32</span><span class="p">(</span><span class="n">shft</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w">
            </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_or_si512</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_srli_epi32</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_slli_epi32</span><span class="p">(</span><span class="n">shft</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w">
            </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_or_si512</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">m0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi32_mask</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span><span class="w">
        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi32_mask</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span><span class="w">
        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi32_mask</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span><span class="w">
        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">m3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi32_mask</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span><span class="w">

        </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w">
        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">m0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
                </span><span class="n">m0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
                </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
                </span><span class="n">m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">m3</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
                </span><span class="n">m3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m3</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">memcmp</span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">haystack</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="kt">size_t</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
</div>
</div>
<div class="section" id="algorithm-3-sse4-2-specific-pcmpestrm">
<h1>Algorithm 3: SSE4.2-specific (PCMPESTRM)</h1>
<div class="section" id="algorithm-2">
<h2>Algorithm</h2>
<p>SSE4.2 introduced <a class="reference external" href="http://en.wikipedia.org/wiki/SSE4#SSE4.2">String and Text New Instructions</a> (STNI), a set of very
complex instructions that were meant to be a building block for string
operations.  Unfortunately, Intel practically discontinued STNI in newer
processors, hasn't introduced AVX2 versions of STNI and make them extremely
slow (11 cycles latency is unacceptable).</p>
<p>Basically <tt class="docutils literal">PCMPxSTRx</tt> instruction exists in four variants, which differs
only in:</p>
<ol class="arabic simple">
<li>A way to determine string length: the length might be given explicitly
or the first zero byte marks string end, as in traditional C strings.</li>
<li>How the result is saved, it might be either a bit-mask/byte-mask or
the number of first/last bit set in the bit-mask.</li>
</ol>
<p>Additional instruction's argument (immediate constant) defines several aspects
of execution, specifically the algorithm of comparison.  There are four
different algorithms available, one we're using is called <strong>range ordered</strong>.
Despite the name, this algorithm locates substring, or its prefix if a
substring goes beyond register width.</p>
<p>For example, when we're searching &quot;ABCD&quot; in &quot;ABCD_ABC_ABCD_AB&quot; the instruction
returns bitmask 0b0100001000000001, treating suffix &quot;AB&quot; as a match. Thus we
can safely assume that only <strong>the first character matches</strong>, as tail might or
might not be present in a register. (Of course it can be determined, but
require additional calculations which is not very handy.)</p>
<p>Below is a code snippet which does the above operation.</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABCD_ABC_ABCD_AB&quot;</span><span class="p">;</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABCD____________&quot;</span><span class="p">;</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_SIDD_UBYTE_OPS</span><span class="w">
               </span><span class="o">|</span><span class="w"> </span><span class="n">_SIDD_CMP_EQUAL_ORDERED</span><span class="w">
               </span><span class="o">|</span><span class="w"> </span><span class="n">_SIDD_BIT_MASK</span><span class="p">;</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">N</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">s2</span><span class="p">));</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">D</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">s1</span><span class="p">));</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpestrm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w">
</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cvtsi128_si64</span><span class="p">(</span><span class="n">res</span><span class="p">);</span><span class="w"> </span><span class="c1">// = 0b0100001000000001</span>
</pre>
</div>
<div class="section" id="implementation-2">
<h2>Implementation</h2>
<div class="section" id="sse-1">
<span id="pcmpstr-sse"></span><h3>SSE</h3>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">sse42_strstr_anysize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">needle</span><span class="p">);</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_SIDD_UBYTE_OPS</span><span class="w">
                       </span><span class="o">|</span><span class="w"> </span><span class="n">_SIDD_CMP_EQUAL_ORDERED</span><span class="w">
                       </span><span class="o">|</span><span class="w"> </span><span class="n">_SIDD_BIT_MASK</span><span class="p">;</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">D</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpestrm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w">
        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cvtsi128_si64</span><span class="p">(</span><span class="n">res</span><span class="p">);</span><span class="w">

        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">bitpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bits</span><span class="o">::</span><span class="n">get_first_bit_set</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">

            </span><span class="c1">// we know that at least the first character of needle matches
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bitpos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">needle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bitpos</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bits</span><span class="o">::</span><span class="n">clear_leftmost_set</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
</div>
</div>
<div class="section" id="performance-results">
<h1>Performance results</h1>
<p>Performance of various SIMD implementations were measured.  Test programs also
have got specialisation for short substrings, that are selected at run time.
Performance of a C <tt class="docutils literal">strstr</tt> is included for comparison.  I omitted C++
<tt class="docutils literal"><span class="pre">string::find</span></tt> due to <a class="reference external" href="2016-10-08-slow-std-string-find.html">performance bug in GNU libc</a> which makes the method
10 times slower than <tt class="docutils literal">strstr</tt>.</p>
<p>Test programs were run three times. Following computers, running either
Debian or Ubuntu, were tested:</p>
<ol class="arabic simple">
<li>Westmere i5 M540, GCC 6.2.0,</li>
<li>Bulldozer FX-8150 CPU, GCC 4.8.4</li>
<li>Haswell i7 4470, GCC 5.4.1,</li>
<li>Skylake i7 6700, GCC 5.4.1,</li>
<li>Knights Landing (KNL) 7210, GCC 5.3.0.</li>
<li>ARMv7 (Raspberry Pi 3, 32-bit code), GCC 4.9.2</li>
<li>ARMv8 (<a class="reference external" href="https://shop.softiron.com/product/overdrive-1000/">ARM Cortex A57 - AMD Opteron A1100</a>, 64-bit code), Clang 3.8.0</li>
</ol>
<div class="section" id="x64-computers">
<h2>x64 computers</h2>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" rowspan="2">procedure</th>
<th class="head" colspan="5">time in seconds</th>
</tr>
<tr><th class="head">Westemere</th>
<th class="head">Bulldozer</th>
<th class="head">Haswell</th>
<th class="head">Skylake</th>
<th class="head">KNL</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>std::strstr</td>
<td>0.82246</td>
<td>9.37792</td>
<td>0.52786</td>
<td>0.66148</td>
<td>4.94606</td>
</tr>
<tr><td>std::string::find</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td><a class="reference internal" href="#generic-swar">SWAR 64-bit (generic)</a></td>
<td>2.49859</td>
<td>2.93836</td>
<td>1.57715</td>
<td>1.40404</td>
<td>8.17075</td>
</tr>
<tr><td><a class="reference internal" href="#generic-sse-avx2">SSE2 (generic)</a></td>
<td><strong>0.74589</strong></td>
<td><strong>0.78871</strong></td>
<td>0.55435</td>
<td><strong>0.48863</strong></td>
<td>6.10786</td>
</tr>
<tr><td><a class="reference internal" href="#mpsadbw-sse-avx2">SSE4.1 (MPSADBW)</a></td>
<td>1.45040</td>
<td>1.98863</td>
<td>0.89775</td>
<td><strong>0.63875</strong></td>
<td>18.71666</td>
</tr>
<tr><td>SSE4.1 (MPSADBW unrolled)</td>
<td>1.23849</td>
<td>2.06008</td>
<td>0.99647</td>
<td>0.87919</td>
<td>13.72486</td>
</tr>
<tr><td><a class="reference internal" href="#pcmpstr-sse">SSE4.2 (PCMPESTRM)</a></td>
<td>1.69968</td>
<td>2.00681</td>
<td>1.55992</td>
<td>1.39063</td>
<td>6.28869</td>
</tr>
<tr><td><a class="reference internal" href="#mpsadbw-sse-avx2">AVX2 (MPSADBW)</a></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>0.61578</td>
<td><strong>0.56981</strong></td>
<td>13.15136</td>
</tr>
<tr><td><a class="reference internal" href="#generic-sse-avx2">AVX2 (generic)</a></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><strong>0.38653</strong></td>
<td><strong>0.36309</strong></td>
<td><strong>4.09478</strong></td>
</tr>
<tr><td><a class="reference internal" href="#mpsadbw-avx512f">AVX512F (MPSADBW-like)</a></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><strong>2.32616</strong></td>
</tr>
<tr><td><a class="reference internal" href="#generic-avx512f">AVX512F (generic)</a></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><strong>1.14057</strong></td>
</tr>
<tr><td>biggest speed-up to <tt class="docutils literal">strstr</tt></td>
<td>1.10</td>
<td>---</td>
<td>1.37</td>
<td>1.82</td>
<td>4.33</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performance of <tt class="docutils literal">strstr</tt> on the machine with Bulldozer is terrible, it'd pointless to use
it as a reference.</li>
</ul>
</div>
<div class="section" id="arm-computers">
<h2>ARM computers</h2>
<table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="19%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" rowspan="2">procedure</th>
<th class="head" colspan="2">time in seconds</th>
</tr>
<tr><th class="head">ARMv7</th>
<th class="head">ARMv8</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>std::strstr</td>
<td>7.30405</td>
<td>3.37546</td>
</tr>
<tr><td>std::string::find</td>
<td>4.17131</td>
<td>1.81368</td>
</tr>
<tr><td><a class="reference internal" href="#generic-swar">SWAR 64-bit (generic)</a></td>
<td>36.65012</td>
<td>0.46269</td>
</tr>
<tr><td>SWAR 32-bit (generic)</td>
<td>2.45058</td>
<td>0.81075</td>
</tr>
<tr><td><a class="reference internal" href="#generic-neon32">ARM Neon (32-bit, generic)</a></td>
<td>1.29861</td>
<td>0.40699</td>
</tr>
<tr><td><a class="reference internal" href="#generic-aarch64">AArch64  (64-bit, generic)</a></td>
<td>---</td>
<td>0.27897</td>
</tr>
<tr><td>biggest speed-up to <tt class="docutils literal"><span class="pre">std::string::find</span></tt></td>
<td>3.1</td>
<td>6.5</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="conclusions-and-remarks">
<h2>Conclusions and remarks</h2>
<ul class="simple">
<li>The generic SIMD algorithm outperforms C <tt class="docutils literal">strstr</tt> on all platforms.
An implementation should use the highest SIMD version available on
a certain CPU.</li>
<li><tt class="docutils literal">MPSADBW</tt> performs pretty bad, with an exception for Skylake.
Knights Landing performance is terrible.</li>
<li><tt class="docutils literal">PCMPESTRM</tt> performs worse than <tt class="docutils literal">MPSADBW</tt>.</li>
<li>ARM Neon performance is pretty good even for SWAR implementation.
The SWAR version is 1.7 times faster than <tt class="docutils literal"><span class="pre">string::find</span></tt>, SIMD
version is 3.1 times faster.</li>
<li>AArch64 performance of scalar SWAR64 is almost as good as 32-bit SIMD
procedure.</li>
<li>Comparison with <tt class="docutils literal">strstr</tt> might be considered unfair, as the
procedure deals with string of unknown length, while my implementations
get lengths and take advantage of this. I fully agree.</li>
<li>Procedures I implemented are also unsafe, because might read data off
the input string. This may lead to access violation if strings are
located just before unmapped memory. And for sure address sanitizers
will complain. Making the procedures safe is feasible, but it wasn't
my goal.</li>
</ul>
</div>
</div>
<div class="section" id="acknowledgments">
<h1>Acknowledgments</h1>
<p><a class="reference external" href="http://lemire.me/">Daniel Lemire</a> has gave me access to Haswell, Skylake, KNL, Bulldozer
and ARMv8 machines, where I compiled and run test programs. Thank you!</p>
</div>
<div class="section" id="source-code">
<h1>Source code</h1>
<p>All implementations and tests programs are available at <a class="reference external" href="https://github.com/WojciechMula/sse4-strstr">github</a>.</p>
</div>
<div class="section" id="history">
<h1>History</h1>
<ul class="simple">
<li>2017-04-29 &mdash; ARMv8 results</li>
<li>2017-01-30 &mdash; better timings from Raspberry Pi 3</li>
<li>2017-01-26 &mdash; ARM Neon &amp; results from Raspberry Pi 3</li>
<li>2017-01-25 &mdash; spelling</li>
<li>2016-12-22 &mdash; added results from Bulldozer</li>
<li>2016-11-30 &mdash; spelling</li>
</ul>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2016-11-28-simd-strfind.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:42 GMT -->
</html>
