<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2018-10-03-simd-index-of-min.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:40 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>Finding index of the minimum value using SIMD instructions</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="finding-index-of-the-minimum-value-using-simd-instructions">
<h1 class="title">Finding index of the minimum value using SIMD instructions</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2018-10-03</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#simd-approach" id="toc-entry-2">SIMD approach</a></li>
<li><a class="reference internal" href="#experiments" id="toc-entry-3">Experiments</a><ul>
<li><a class="reference internal" href="#sse-implementation" id="toc-entry-4">SSE implementation</a></li>
<li><a class="reference internal" href="#avx512f-implementation" id="toc-entry-5">AVX512F implementation</a></li>
<li><a class="reference internal" href="#performance-evaluation" id="toc-entry-6">Performance evaluation</a><ul>
<li><a class="reference internal" href="#skylake" id="toc-entry-7">Skylake</a></li>
<li><a class="reference internal" href="#skylake-x" id="toc-entry-8">Skylake-X</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements" id="toc-entry-9">Acknowledgements</a></li>
<li><a class="reference internal" href="#source-code" id="toc-entry-10">Source code</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>The goal is to find the first index of the minimum value in a non-empty
sequence.</p>
<p>Following C code shows the idea.</p>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">min_index_scalar</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">assert</span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w">
    </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">

    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">minvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">minvalue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">minvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
            </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">minindex</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The C++ standard library allows to express the same algorithm in one line.</p>
<pre class="code cpp literal-block">
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span><span class="c1"> // for std::min_element</span><span class="cp">
#include</span><span class="w"> </span><span class="cpf">&lt;iterator&gt;</span><span class="c1">  // for std::distance</span><span class="cp">
</span><span class="w">
</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w">
</span><span class="kt">size_t</span><span class="w"> </span><span class="n">min_index</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The current versions of compilers (GCC 8.2, clang 7.0.0) are not able to
autovectorize the code. However, they do autovectorize finding the minimum
value, i.e. statement like <tt class="docutils literal">return <span class="pre">*std::min_element(v.begin(),</span> <span class="pre">v.end())</span></tt>.</p>
</div>
<div class="section" id="simd-approach">
<h1>SIMD approach</h1>
<p>In a SIMD approach we keep three <strong>vectors</strong> of: minimum values, corresponding
indices and also current scalar indices. When the main loop completes, we select
the appropriate single index from these vectors.</p>
<p>The algorithm outline is shown below (for four-element vectors).</p>
<pre class="code cpp literal-block">
<span class="c1">// 1. SIMD part
</span><span class="w">
</span><span class="n">Vector</span><span class="w"> </span><span class="n">indices</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">                    </span><span class="c1">// basically [i + 0, i + 1, i + 2, i + 4]
</span><span class="n">Vector</span><span class="w"> </span><span class="n">increment</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
                                                    </span><span class="c1">// sample values
</span><span class="n">Vector</span><span class="w"> </span><span class="n">minvalues</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">load_vector</span><span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w">           </span><span class="c1">// [77, 33, 11, 44]
</span><span class="n">Vector</span><span class="w"> </span><span class="n">minindices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">                    </span><span class="c1">// [ 0,  1,  2,  3]
</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">input_size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="c1">// advance scalar indices
</span><span class="w">    </span><span class="n">indices</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">increment</span><span class="p">;</span><span class="w">                           </span><span class="c1">// [4, 5, 6, 7]
</span><span class="w">
    </span><span class="c1">// compare
</span><span class="w">    </span><span class="n">Vector</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_vector</span><span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w">          </span><span class="c1">// [55, 44, 22, 22]
</span><span class="w">    </span><span class="n">Mask</span><span class="w">   </span><span class="n">less</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">minvalues</span><span class="p">);</span><span class="w">     </span><span class="c1">// [55 &lt; 77, 44 &lt; 33, 22 &lt; 11, 22 &lt; 44]
</span><span class="w">                                                    </span><span class="c1">// [true, false, false, true]
</span><span class="w">                                                    </span><span class="c1">//  two items will be updated
</span><span class="w">    </span><span class="c1">// update
</span><span class="w">    </span><span class="n">minvalues</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">blend</span><span class="p">(</span><span class="n">minvalues</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">less</span><span class="p">)</span><span class="w">     </span><span class="c1">// [55, 33, 11, 22]
</span><span class="w">    </span><span class="n">minindices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blend</span><span class="p">(</span><span class="n">minindices</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">less</span><span class="p">);</span><span class="w">  </span><span class="c1">// [ 4,  1,  2,  7]
</span><span class="p">}</span><span class="w">

</span><span class="c1">// 2. scalar part
</span><span class="w">
</span><span class="n">min_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_item</span><span class="p">(</span><span class="n">min_values</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="n">min_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_item</span><span class="p">(</span><span class="n">min_indices</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">get_item</span><span class="p">(</span><span class="n">min_values</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">min_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_item</span><span class="p">(</span><span class="n">min_values</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
        </span><span class="n">min_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_item</span><span class="p">(</span><span class="n">min_indices</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">get_item</span><span class="p">(</span><span class="n">min_values</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">min_values</span><span class="p">)</span><span class="w">
        </span><span class="c1">// if some values are repeated, pick the smaller index
</span><span class="w">        </span><span class="n">min_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">min_index</span><span class="p">,</span><span class="w"> </span><span class="n">get_item</span><span class="p">(</span><span class="n">min_indices</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="k">return</span><span class="w"> </span><span class="n">min_index</span><span class="p">;</span>
</pre>
<p>Function <strong>compare</strong> yields a mask, it can be a byte-mask (SSE, AVX2) or a
bit-mask (AVX512). In SSE it might be instruction <tt class="docutils literal">pcmpgtd</tt>
(<tt class="docutils literal">_mm_pcmplt_epi32</tt>), in AVX512 it might be <tt class="docutils literal">vpcmpd</tt>
(<tt class="docutils literal">_mm512_cmp_epi32_mask</tt>).</p>
<p>Function <strong>blend</strong> is a vector selection operator, i.e. <tt class="docutils literal">mask[i] ? x[i] :
y[i]</tt>; it stores items from either vector <tt class="docutils literal">x</tt> or <tt class="docutils literal">y</tt> based on the
corresponding mask value.  Many SIMD ISAs provides such operation; for instance
SSE has the instruction <tt class="docutils literal">pblendv</tt> (<tt class="docutils literal">_mm_blendv_epi8</tt>).</p>
<p>Please note that in case of SSE the blend instruction is relative new, as it was
introduced in SSE4.1. For really old CPUs the blend operator has to be expressed
with binary operations: <tt class="docutils literal">(x &amp; mask) | (y &amp; ~mask)</tt>. Such expression is
compiled into a sequence of three instructions: <tt class="docutils literal">and</tt>, <tt class="docutils literal"><span class="pre">and-not</span></tt>, <tt class="docutils literal">or</tt>.</p>
<p>Additionally, since <strong>blend</strong> instructions tend to be slow, it's better to
update <tt class="docutils literal">minvalues</tt> vector using the min operator.</p>
</div>
<div class="section" id="experiments">
<h1>Experiments</h1>
<p>The above schema was translated into procedures using SSE (including an unrolled
version), AVX2 and AVX512. In this article just SSE and AVX512 procedures are
shown, but obviously all implementations are <a class="reference internal" href="#source">available</a>.</p>
<div class="section" id="sse-implementation">
<span id="sse"></span><h2>SSE implementation</h2>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">min_index_sse</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">common_assertions</span><span class="p">;</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi32</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
    </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">indices</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_setr_epi32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
    </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">minindices</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">;</span><span class="w">
    </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">minvalues</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">array</span><span class="p">);</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">increment</span><span class="p">);</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">values</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">lt</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">minvalues</span><span class="p">);</span><span class="w">
        </span><span class="n">minindices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_blendv_epi8</span><span class="p">(</span><span class="n">minindices</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">lt</span><span class="p">);</span><span class="w">
        </span><span class="n">minvalues</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_min_epi32</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">minvalues</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="c1">// find min index in vector result (in an extremely naive way)
</span><span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">values_array</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w">
    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">indices_array</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w">

    </span><span class="n">_mm_storeu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">values_array</span><span class="p">,</span><span class="w"> </span><span class="n">minvalues</span><span class="p">);</span><span class="w">
    </span><span class="n">_mm_storeu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">indices_array</span><span class="p">,</span><span class="w"> </span><span class="n">minindices</span><span class="p">);</span><span class="w">

    </span><span class="kt">size_t</span><span class="w">  </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">minvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">values_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">minvalue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">minvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
            </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">values_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">minvalue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">minindex</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">(</span><span class="n">indices_array</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">minindex</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx512f-implementation">
<span id="avx512"></span><h2>AVX512F implementation</h2>
<pre class="code cpp literal-block">
<span class="kt">size_t</span><span class="w"> </span><span class="nf">min_index_avx512f</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">common_assertions</span><span class="p">;</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span><span class="w">
    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">indices</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_setr_epi32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span><span class="w">
    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">minindices</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">;</span><span class="w">
    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">minvalues</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">((</span><span class="n">__m512i</span><span class="o">*</span><span class="p">)</span><span class="n">array</span><span class="p">);</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_add_epi32</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">increment</span><span class="p">);</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">values</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">((</span><span class="n">__m512i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__mmask16</span><span class="w"> </span><span class="n">lt</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmplt_epi32_mask</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">minvalues</span><span class="p">);</span><span class="w">
        </span><span class="n">minindices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_blend_epi32</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span><span class="w"> </span><span class="n">minindices</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="p">);</span><span class="w">
        </span><span class="n">minvalues</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_min_epi32</span><span class="p">(</span><span class="n">minvalues</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="c1">// find min index in vector result (in an extremely naive way)
</span><span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">values_array</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w">
    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">indices_array</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w">

    </span><span class="n">_mm512_storeu_si512</span><span class="p">((</span><span class="n">__m512i</span><span class="o">*</span><span class="p">)</span><span class="n">values_array</span><span class="p">,</span><span class="w"> </span><span class="n">minvalues</span><span class="p">);</span><span class="w">
    </span><span class="n">_mm512_storeu_si512</span><span class="p">((</span><span class="n">__m512i</span><span class="o">*</span><span class="p">)</span><span class="n">indices_array</span><span class="p">,</span><span class="w"> </span><span class="n">minindices</span><span class="p">);</span><span class="w">

    </span><span class="kt">size_t</span><span class="w">  </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">minvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">values_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">minvalue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">minvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
            </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">values_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">minvalue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">minindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">minindex</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">(</span><span class="n">indices_array</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">minindex</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="performance-evaluation">
<h2>Performance evaluation</h2>
<p>Following procedures were tested:</p>
<ul class="simple">
<li><a class="reference internal" href="#sse">SSE</a>,</li>
<li>SSE unrolled,</li>
<li>AVX2,</li>
<li>and <a class="reference internal" href="#avx512">AVX512F</a>.</li>
</ul>
<p>All procedures work on signed 32-bit integers.</p>
<p>Test programs were run three times and minimum measurements were noted. The unit
is CPU cycles per array item.</p>
<div class="section" id="skylake">
<h3>Skylake</h3>
<p>Compiler: GCC 7.3.0</p>
<p>CPU: Intel(R) Core(TM) i7-6700 CPU &#64; 3.40GHz</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="10%" />
<col width="10%" />
<col width="9%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="5">size 4096 items</td>
</tr>
<tr><td>scalar</td>
<td>3.006</td>
<td>3.036</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████▍</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>1.823</td>
<td>1.865</td>
<td>1.65</td>
<td><tt class="docutils literal"><span class="pre">███████▎</span></tt></td>
</tr>
<tr><td>SSE unrolled</td>
<td>0.624</td>
<td>0.632</td>
<td>4.82</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.268</td>
<td>0.272</td>
<td>11.22</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td colspan="5">size 16384 items</td>
</tr>
<tr><td>scalar</td>
<td>3.010</td>
<td>3.021</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████▍</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>1.829</td>
<td>1.875</td>
<td>1.65</td>
<td><tt class="docutils literal"><span class="pre">███████▎</span></tt></td>
</tr>
<tr><td>SSE unrolled</td>
<td>0.636</td>
<td>0.643</td>
<td>4.73</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.292</td>
<td>0.298</td>
<td>10.31</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████▉</span></tt></td>
</tr>
<tr><td colspan="5">size 32768 items</td>
</tr>
<tr><td>scalar</td>
<td>3.013</td>
<td>3.022</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████▍</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>1.830</td>
<td>1.876</td>
<td>1.65</td>
<td><tt class="docutils literal"><span class="pre">███████▎</span></tt></td>
</tr>
<tr><td>SSE unrolled</td>
<td>0.640</td>
<td>0.645</td>
<td>4.71</td>
<td><tt class="docutils literal"><span class="pre">████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.295</td>
<td>0.300</td>
<td>10.21</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████▌</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="skylake-x">
<h3>Skylake-X</h3>
<p>Compiler: GCC 8.1.0</p>
<p>CPU: Intel(R) Xeon(R) W-2104 CPU &#64; 3.20GHz</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="10%" />
<col width="10%" />
<col width="9%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="5">size 4096 items</td>
</tr>
<tr><td>scalar</td>
<td>2.994</td>
<td>3.408</td>
<td>1.00</td>
<td><tt class="docutils literal">██▋</tt></td>
</tr>
<tr><td>SSE</td>
<td>1.721</td>
<td>1.814</td>
<td>1.74</td>
<td><tt class="docutils literal"><span class="pre">████▊</span></tt></td>
</tr>
<tr><td>SSE unrolled</td>
<td>0.652</td>
<td>0.656</td>
<td>4.59</td>
<td><tt class="docutils literal"><span class="pre">████████████▌</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.265</td>
<td>0.273</td>
<td>11.30</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX512F</td>
<td>0.164</td>
<td>0.173</td>
<td>18.26</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td colspan="5">size 16384 items</td>
</tr>
<tr><td>scalar</td>
<td>2.996</td>
<td>3.430</td>
<td>1.00</td>
<td><tt class="docutils literal">██▋</tt></td>
</tr>
<tr><td>SSE</td>
<td>1.605</td>
<td>1.681</td>
<td>1.87</td>
<td><tt class="docutils literal"><span class="pre">█████</span></tt></td>
</tr>
<tr><td>SSE unrolled</td>
<td>0.564</td>
<td>0.568</td>
<td>5.31</td>
<td><tt class="docutils literal"><span class="pre">██████████████▌</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.322</td>
<td>0.326</td>
<td>9.30</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▍</span></tt></td>
</tr>
<tr><td>AVX512F</td>
<td>0.208</td>
<td>0.213</td>
<td>14.40</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████████████▍</span></tt></td>
</tr>
<tr><td colspan="5">size 32768 items</td>
</tr>
<tr><td>scalar</td>
<td>3.000</td>
<td>3.548</td>
<td>1.00</td>
<td><tt class="docutils literal">██▋</tt></td>
</tr>
<tr><td>SSE</td>
<td>1.622</td>
<td>1.681</td>
<td>1.85</td>
<td><tt class="docutils literal"><span class="pre">█████</span></tt></td>
</tr>
<tr><td>SSE unrolled</td>
<td>0.563</td>
<td>0.567</td>
<td>5.33</td>
<td><tt class="docutils literal"><span class="pre">██████████████▌</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.321</td>
<td>0.325</td>
<td>9.35</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▌</span></tt></td>
</tr>
<tr><td>AVX512F</td>
<td>0.206</td>
<td>0.210</td>
<td>14.56</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████████████▉</span></tt></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="acknowledgements">
<h1>Acknowledgements</h1>
<p>I would like to thank my friend Romek, who inspired me to work again on side
projects.</p>
</div>
<div class="section" id="source-code">
<span id="source"></span><h1>Source code</h1>
<p>Source code is available on <a class="reference external" href="https://github.com/WojciechMula/toys/tree/master/simd-min-index">github</a>.</p>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2018-10-03-simd-index-of-min.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:40 GMT -->
</html>
