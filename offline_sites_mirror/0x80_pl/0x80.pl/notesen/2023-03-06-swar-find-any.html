<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2023-03-06-swar-find-any.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:32 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>SWAR find any byte from set</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="swar-find-any-byte-from-set">
<h1 class="title">SWAR find any byte from set</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2023-03-06</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#faster-swar-procedure" id="toc-entry-2">Faster SWAR procedure</a></li>
<li><a class="reference internal" href="#comparison" id="toc-entry-3">Comparison</a><ul>
<li><a class="reference internal" href="#reference-implementation" id="toc-entry-4">Reference implementation</a></li>
<li><a class="reference internal" href="#faster-swar-procedure-1" id="toc-entry-5">Faster SWAR procedure</a></li>
<li><a class="reference internal" href="#benchmark-results" id="toc-entry-6">Benchmark results</a></li>
<li><a class="reference internal" href="#summary" id="toc-entry-7">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#source-code" id="toc-entry-8">Source code</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>When I was browsing the source code of project <a class="reference external" href="https://github.com/ada-url/ada">Ada</a> (<em>WHATWG-compliant
and fast URL parser written in modern C++</em>) the following procedure
caught my attention:</p>
<pre class="code cpp literal-block">
<span class="n">ada_really_inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">find_authority_delimiter_special</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">view</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">auto</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0101010101010101</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x8080808080808080</span><span class="p">);</span><span class="w">
  </span><span class="p">};</span><span class="w">
  </span><span class="k">auto</span><span class="w"> </span><span class="n">index_of_first_set_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="p">((((</span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x101010101010101</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x101010101010101</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">56</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;,</span><span class="w">
  </span><span class="p">};</span><span class="w">
  </span><span class="k">auto</span><span class="w"> </span><span class="n">broadcast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mh">0x101010101010101</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">
  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'&#64;'</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'/'</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'?'</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'\\'</span><span class="p">);</span><span class="w">

  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">word</span><span class="p">{};</span><span class="w">
    </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">));</span><span class="w">
    </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swap_bytes_if_big_endian</span><span class="p">(</span><span class="n">word</span><span class="p">);</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask1</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask2</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask3</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask4</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">is_match</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor3</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor4</span><span class="p">);</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_match</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index_of_first_set_byte</span><span class="p">(</span><span class="n">is_match</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">

  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">word</span><span class="p">{};</span><span class="w">
    </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
    </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swap_bytes_if_big_endian</span><span class="p">(</span><span class="n">word</span><span class="p">);</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask1</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask2</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask3</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask4</span><span class="p">;</span><span class="w">
    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">is_match</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor3</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor4</span><span class="p">);</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_match</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index_of_first_set_byte</span><span class="p">(</span><span class="n">is_match</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">

  </span><span class="k">return</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The above procedure finds the position of the first occurrence of a char
from the set <tt class="docutils literal">&#64;</tt>, <tt class="docutils literal">/</tt>, <tt class="docutils literal">?</tt> and <tt class="docutils literal">/</tt>. It returns the length
of input string if nothing was found.</p>
<p>The procedure uses <a class="reference external" href="http://en.wikipedia.org/wiki/SWAR">SWAR</a> techniques: it processes several bytes at once,
taking advantage on the current CPUs architecture that process 64-bit values.
The procedure implementation comes from <tt class="docutils literal">src/helpers.cpp</tt>, and more
function from that file follow exactly the same SWAR approach.</p>
<p>These two functions are crucial:</p>
<ul class="simple">
<li><tt class="docutils literal">has_zero_byte</tt> is non-zero if a multi-byte word has at least one zero byte;
note that the procedure also keeps only the most significant bits.</li>
<li><tt class="docutils literal">index_of_first_set_byte</tt> returns the index of first non-zero byte; it uses
the fact it is called on word formed with bytes 0x00 and 0x80.</li>
</ul>
<p>The pattern used is quite straightforward. If we bit-xor input bytes with a
word filled with one of bytes from set, then the result has zero byte if the
byte was there.  We check then if it least one result of bit-xor has zero-byte
and if it is true, we're looking for its position.</p>
<p>While the production code processes multi-word inputs, let's focus on a basic
building block that processes a single 64-bit word.</p>
<pre class="code cpp literal-block">
<span class="kt">int</span><span class="w"> </span><span class="nf">find_authority_delimiter_special_reference</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">auto</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x0101010101010101</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x8080808080808080</span><span class="p">);</span><span class="w">
  </span><span class="p">};</span><span class="w">
  </span><span class="k">auto</span><span class="w"> </span><span class="n">index_of_first_set_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="p">((((</span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x101010101010101</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x101010101010101</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">56</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
  </span><span class="p">};</span><span class="w">
  </span><span class="k">auto</span><span class="w"> </span><span class="n">broadcast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mh">0x101010101010101</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'&#64;'</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'/'</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'?'</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'\\'</span><span class="p">);</span><span class="w">

  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask1</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask2</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask3</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">xor4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">mask4</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">is_match</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor3</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">has_zero_byte</span><span class="p">(</span><span class="n">xor4</span><span class="p">);</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_match</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="k">return</span><span class="w"> </span><span class="n">index_of_first_set_byte</span><span class="p">(</span><span class="n">is_match</span><span class="p">);</span><span class="w">
  </span><span class="p">}</span><span class="w">

  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The following assembly is produced by GCC 12.2.0 from Debian for the IceLake Server architecture
(<tt class="docutils literal">gcc <span class="pre">-O3</span> <span class="pre">-march=icelake-server</span></tt>).</p>
<pre class="code literal-block">
movabs $0x2f2f2f2f2f2f2f2f,%rax
movabs $0xfefefefefefefeff,%rsi
xor    %rdi,%rax
movabs $0xd0d0d0d0d0d0d0d0,%rcx
xor    %rdi,%rcx
add    %rsi,%rax
and    %rcx,%rax
movabs $0x4040404040404040,%rcx
mov    %rdi,%rdx
xor    %rdi,%rcx
movabs $0xbfbfbfbfbfbfbfbf,%rdi
xor    %rdx,%rdi
add    %rsi,%rcx
and    %rdi,%rcx
or     %rcx,%rax
movabs $0x3f3f3f3f3f3f3f3f,%rcx
xor    %rdx,%rcx
movabs $0xc0c0c0c0c0c0c0c0,%rdi
add    %rsi,%rcx
xor    %rdx,%rdi
and    %rdi,%rcx
or     %rcx,%rax
movabs $0x5c5c5c5c5c5c5c5c,%rcx
xor    %rdx,%rcx
add    %rsi,%rcx
movabs $0xa3a3a3a3a3a3a3a3,%rsi
xor    %rsi,%rdx
and    %rcx,%rdx
or     %rdx,%rax
movabs $0x8080808080808080,%rdx
and    %rdx,%rax
je     &lt;_Z42find_authority_delimiter_special_referencem+0xc0&gt;
movabs $0x101010101010101,%rdx
dec    %rax
and    %rdx,%rax
imul   %rdx,%rax
shr    $0x38,%rax
dec    %eax
ret
mov    $0xffffffff,%eax
ret
</pre>
<p>The assembly contains:</p>
<ul class="simple">
<li>11 x constants,</li>
<li>6 x xor,</li>
<li>6 x and,</li>
<li>4 x add,</li>
<li>3 x or,</li>
<li>1 x multiplication (<tt class="docutils literal">imul</tt>),</li>
<li>1 x shift right,</li>
<li>1 x branch.</li>
</ul>
</div>
<div class="section" id="faster-swar-procedure">
<h1>Faster SWAR procedure</h1>
<p>While the approach used by Ada library is universal and can be used for locating
any byte, there's faster method that can be used with the set contains only ASCII
chars, i.e. bytes that do not have set the 7th bit. The set <tt class="docutils literal">&#64;</tt>, <tt class="docutils literal">/</tt>, <tt class="docutils literal">?</tt>
and <tt class="docutils literal">\\</tt> falls into this category.</p>
<p>In this approach we pretend that the input is 7-bit. If the input has any
8-bit byte (for instance UTF-8 characters) we'll fix up wrongly detected
bytes at the end.</p>
<p>We also use bit-xor to produce zero bytes for matching bytes. However, we
then convert the result into a bit. The result of bit-xor can be zero
or non zero (<tt class="docutils literal">x</tt> - bit 0 or 1, but at least one is 1):</p>
<pre class="literal-block">
┌─────────┐ ┌─────────┐
│0000 0000│ │0xxx xxxx│
└─────────┘ └─────────┘
</pre>
<p>If we add <tt class="docutils literal">0x7f</tt> = <tt class="docutils literal">0b0111_1111</tt> then the result is:</p>
<pre class="literal-block">
┌─────────┐ ┌─────────┐
│0111 1111│ │1yyy yyyy│
└─────────┘ └─────────┘
</pre>
<p>We can see that the most significant bit expresses relation &quot;byte is not zero&quot;.
Let's review the basic algorithm steps, that use the above observation.</p>
<ol class="arabic" start="0">
<li><p class="first">Input 8-byte string is <tt class="docutils literal"><span class="pre">a\\xc0ą&#64;b?c</span></tt>:</p>
<pre class="literal-block">
 'a'=0x61   \xc0     'ą'=&lt;0xc4, 0x85&gt;    '&#64;'=0x40  'b'=0x62  '?'=0x3f  'c'=0x63
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0110 0001│1100 0000│1100 0100│1000 0101│0100 0000│0110 0010│0011 1111│0110 0011│ = input
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</pre>
</li>
</ol>
<ol class="arabic" start="0">
<li><p class="first">And we're looking for '&#64;' = <tt class="docutils literal">0x40</tt>:</p>
<pre class="literal-block">
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│ = byte
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</pre>
</li>
<li><p class="first">Xor input and mask:</p>
<pre class="literal-block">
t0 = word ^ 0x4040404040404040

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0010 0001│1000 0000│1000 0100│1100 0101│0000 0000│0010 0010│0111 1111│0010 0011│ = t0
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     21        80        84        c5        00        22        7f        23
</pre>
</li>
<li><p class="first">Mask MSB from input:</p>
<pre class="literal-block">
t1 = t0 &amp; 0x7f7f7f7f7f7f7f7f

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0010 0001│0000 0000│0000 0100│0100 0101│0000 0000│0010 0010│0111 1111│0010 0011│ = t1
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     21        00        04        45        00        22        7f        23
</pre>
</li>
<li><p class="first">Add <tt class="docutils literal">0x7f</tt> to locate non-zero bytes. Note that two bytes were found, but the
first one is not valid.:</p>
<pre class="literal-block">
t2 = t1 + 0x7f7f7f7f7f7f7f7f

┌─────────┲━━━━━━━━━┱─────────┬─────────┲━━━━━━━━━┱─────────┬─────────┬─────────┐
│1010 0000┃0111 1111┃1000 0011│1100 0100┃0111 1111┃1010 0001│1111 1110│1010 0010│ = t2
└─────────┺━━━━━━━━━┹─────────┴─────────┺━━━━━━━━━┹─────────┴─────────┴─────────┘
     a0        7f        83        c4        7f        a1        fe        a2
</pre>
</li>
<li><p class="first">At this point, MSBs equal zero denote byte position. To fix up the result we
bit-or the t2 with input. If input byte has MSB set, it will discard wrong
results.:</p>
<pre class="literal-block">
t3 = t2 | input

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│1110 0001│1111 1111│1100 0111│1100 0101│0111 1111│1110 0011│1111 1111│1110 0011│ = t3
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     e1        ff        c7        c5        7f        e3        ff        e3
</pre>
</li>
<li><p class="first">Now, we keep only MSBs:</p>
<pre class="literal-block">
t4 = t3 &amp; 0x8080808080808080

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│1000 0000│1000 0000│1000 0000│1000 0000│0000 0000│1000 0000│1000 0000│1000 0000│ = t4
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     80        80        80        80        00        80        80        80
</pre>
</li>
<li><p class="first">Negate the MSBs &mdash; ones would point found positions. As we can see, now we have
exactly one non-zero byte:</p>
<pre class="literal-block">
t5 = t4 ^ 0x8080808080808080

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0000 0000│0000 0000│0000 0000│0000 0000│1000 0000│0000 0000│0000 0000│0000 0000│ = t5
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     00        00        00        00        80        00        00        00
</pre>
</li>
<li><p class="first">To find the position of byte we simply looking for first bit set and divide
result by 8.</p>
</li>
</ol>
<p>The above algorithm was used to code the fully functional procedure.</p>
<pre class="code cpp literal-block">
<span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">find_authority_delimiter_special_better</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">auto</span><span class="w"> </span><span class="n">broadcast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mh">0x101010101010101</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">

  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="mh">0x7f</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">lo7bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w">

  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lo7bits</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'&#64;'</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lo7bits</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'/'</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lo7bits</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'?'</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lo7bits</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="sc">'\\'</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w">

  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">x0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">x3</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">word</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span><span class="w">
  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">broadcast</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span><span class="w">

  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_ctzl</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">
  </span><span class="p">}</span><span class="w">

  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The following assembly is produced by GCC 12.2.0 from Debian for the IceLake Server architecture
(<tt class="docutils literal">gcc <span class="pre">-O3</span> <span class="pre">-march=icelake-server</span></tt>).</p>
<pre class="code literal-block">
movabs $0x7f7f7f7f7f7f7f7f,%rcx
mov    %rdi,%rax
and    %rcx,%rax
movabs $0x4040404040404040,%rdx
movabs $0x2f2f2f2f2f2f2f2f,%rsi
xor    %rax,%rdx
xor    %rax,%rsi
add    %rcx,%rsi
add    %rcx,%rdx
and    %rsi,%rdx
movabs $0x3f3f3f3f3f3f3f3f,%rsi
xor    %rax,%rsi
add    %rcx,%rsi
and    %rsi,%rdx
movabs $0x5c5c5c5c5c5c5c5c,%rsi
xor    %rsi,%rax
add    %rcx,%rax
and    %rax,%rdx
or     %rdi,%rdx
movabs $0x8080808080808080,%rax
andn   %rax,%rdx,%rdx
xor    %eax,%eax
tzcnt  %rdx,%rax
shr    $0x3,%rax
test   %rdx,%rdx
mov    $0xffffffffffffffff,%rdx
cmove  %rdx,%rax
ret
</pre>
<p>The assembly contains:</p>
<ul class="simple">
<li>6 x constants,</li>
<li>5 x xor,</li>
<li>5 x and,</li>
<li>4 x add,</li>
<li>1 x or,</li>
<li>1 x count trailing zeros,</li>
<li>1 x shift right,</li>
<li>1 x condition move.</li>
</ul>
</div>
<div class="section" id="comparison">
<h1>Comparison</h1>
<div class="section" id="reference-implementation">
<h2>Reference implementation</h2>
<p>Since the reference assembly contains the jump instruction, I rewrote it to:</p>
<pre class="literal-block">
    movabs $0x2f2f2f2f2f2f2f2f,%rax
    movabs $0xfefefefefefefeff,%rsi
    xor    %rdi,%rax
    movabs $0xd0d0d0d0d0d0d0d0,%rcx
    xor    %rdi,%rcx
    add    %rsi,%rax
    and    %rcx,%rax
    movabs $0x4040404040404040,%rcx
    mov    %rdi,%rdx
    xor    %rdi,%rcx
    movabs $0xbfbfbfbfbfbfbfbf,%rdi
    xor    %rdx,%rdi
    add    %rsi,%rcx
    and    %rdi,%rcx
    or     %rcx,%rax
    movabs $0x3f3f3f3f3f3f3f3f,%rcx
    xor    %rdx,%rcx
    movabs $0xc0c0c0c0c0c0c0c0,%rdi
    add    %rsi,%rcx
    xor    %rdx,%rdi
    and    %rdi,%rcx
    or     %rcx,%rax
    movabs $0x5c5c5c5c5c5c5c5c,%rcx
    xor    %rdx,%rcx
    add    %rsi,%rcx
    movabs $0xa3a3a3a3a3a3a3a3,%rsi
    xor    %rsi,%rdx
    and    %rcx,%rdx
    or     %rdx,%rax
    movabs $0x8080808080808080,%rdx
    and    %rdx,%rax
sete   %cl                      // cl = 1 or 0
    movabs $0x101010101010101,%rdx
    dec    %rax
    and    %rdx,%rax
    imul   %rdx,%rax
    shr    $0x38,%rax
    dec    %eax
testb  %cl,%cl                  // reapply `and` result
    mov    $0xffffffff,%ebx         //
cmove  %rbx,%rax                // and conditionally overwrite rax
    ret
</pre>
<p>For the above procedure <a class="reference external" href="https://uica.uops.info/">uICA</a> give the following analysis.</p>
<pre class="literal-block">
Throughput (in cycles per iteration): 13.18
Bottleneck: Predecoder

The following throughputs could be achieved if the given property were the only bottleneck:

  - Predecoder: 13.19
  - Decoder: 11.00
  - Issue: 8.20
  - Ports: 10.25
  - Dependencies: 2.00

┌───────────────────────┬────────┬───────┬─────────────────────────────────────────────────────────────────────────────────────────┐
│ MITE   MS   DSB   LSD │ Issued │ Exec. │ Port 0   Port 1   Port 2   Port 3   Port 4   Port 5   Port 6   Port 7   Port 8   Port 9 │
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  1                    │   1    │   1   │  0.11     0.11                                0.56     0.22                             │ mov rax, 0x2f2f2f2f2f2f2f2f
│  1                    │   1    │   1   │  0.11     0.39                                0.33     0.17                             │ mov rsi, 0xfefefefefefefeff
│  1                    │   1    │   1   │  0.28     0.33                                0.17     0.22                             │ xor rax, rdi
│  1                    │   1    │   1   │  0.11     0.17                                0.56     0.17                             │ mov rcx, 0xd0d0d0d0d0d0d0d0
│  1                    │   1    │   1   │  0.17     0.44                                0.28     0.11                             │ xor rcx, rdi
│  1                    │   1    │   1   │  0.22     0.44                                0.28     0.06                             │ add rax, rsi
│  1                    │   1    │   1   │  0.17     0.28                                0.28     0.28                             │ and rax, rcx
│  1                    │   1    │   1   │  0.17     0.39                                0.39     0.06                             │ mov rcx, 0x4040404040404040
│  1                    │   1    │   1   │  0.22     0.39                                0.11     0.28                             │ mov rdx, rdi
│  1                    │   1    │   1   │  0.56     0.11                                0.17     0.17                             │ xor rcx, rdi
│  1                    │   1    │   1   │  0.06     0.22                                0.22     0.5                              │ mov rdi, 0xbfbfbfbfbfbfbfbf
│  1                    │   1    │   1   │  0.11     0.33                                0.44     0.11                             │ xor rdi, rdx
│  1                    │   1    │   1   │  0.33     0.33                                0.28     0.06                             │ add rcx, rsi
│  1                    │   1    │   1   │  0.33     0.28                                0.06     0.33                             │ and rcx, rdi
│  1                    │   1    │   1   │  0.17     0.22                                0.11     0.5                              │ or rax, rcx
│  1                    │   1    │   1   │  0.17     0.22                                0.33     0.28                             │ mov rcx, 0x3f3f3f3f3f3f3f3f
│  1                    │   1    │   1   │  0.28     0.28                                0.33     0.11                             │ xor rcx, rdx
│  1                    │   1    │   1   │  0.17     0.44                                0.22     0.17                             │ mov rdi, 0xc0c0c0c0c0c0c0c0
│  1                    │   1    │   1   │  0.44     0.22                                0.22     0.11                             │ add rcx, rsi
│  1                    │   1    │   1   │  0.11     0.17                                0.28     0.44                             │ xor rdi, rdx
│  1                    │   1    │   1   │  0.39     0.22                                0.22     0.17                             │ and rcx, rdi
│  1                    │   1    │   1   │  0.17     0.22                                0.39     0.22                             │ or rax, rcx
│  1                    │   1    │   1   │  0.28     0.33                                0.11     0.28                             │ mov rcx, 0x5c5c5c5c5c5c5c5c
│  1                    │   1    │   1   │  0.33     0.22                                0.11     0.33                             │ xor rcx, rdx
│  1                    │   1    │   1   │  0.22     0.11                                0.28     0.39                             │ add rcx, rsi
│  1                    │   1    │   1   │  0.22     0.11                                0.33     0.33                             │ mov rsi, 0xa3a3a3a3a3a3a3a3
│  1                    │   1    │   1   │  0.11     0.22                                0.39     0.28                             │ xor rdx, rsi
│  1                    │   1    │   1   │  0.39     0.28                                0.11     0.22                             │ and rdx, rcx
│  1                    │   1    │   1   │  0.17     0.06                                0.5      0.28                             │ or rax, rdx
│  1                    │   1    │   1   │  0.22     0.28                                0.33     0.17                             │ mov rdx, 0x8080808080808080
│  1                    │   1    │   1   │  0.28     0.11                                0.17     0.44                             │ and rax, rdx
│  1                    │   1    │   1   │  0.39                                                  0.61                             │ setz cl
│  1                    │   1    │   1   │  0.22     0.17                                0.39     0.22                             │ mov rdx, 0x101010101010101
│  1                    │   1    │   1   │           0.11                                0.39     0.5                              │ dec rax
│  1                    │   1    │   1   │  0.44     0.28                                0.22     0.06                             │ and rax, rdx
│  1                    │   1    │   1   │            1                                                                            │ imul rax, rdx
│  1                    │   1    │   1   │  0.44                                                  0.56                             │ shr rax, 0x38
│  1                    │   1    │   1   │  0.17     0.17                                0.39     0.28                             │ dec eax
│  1                    │   1    │   1   │  0.11     0.17                                0.44     0.28                             │ mov ebx, 0xffffffff
│  1                    │   1    │   1   │  0.17     0.5                                 0.33                                      │ test cl, cl
│  1                    │   1    │   1   │  0.56                                                  0.44                             │ cmovnz rax, rbx
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  41                   │   41   │  41   │  9.56    10.33                               10.72    10.39                             │ Total
└───────────────────────┴────────┴───────┴─────────────────────────────────────────────────────────────────────────────────────────┘
</pre>
</div>
<div class="section" id="faster-swar-procedure-1">
<h2>Faster SWAR procedure</h2>
<p>uICA output:</p>
<pre class="literal-block">
Throughput (in cycles per iteration): 8.19
Bottleneck: Predecoder

The following throughputs could be achieved if the given property were the only bottleneck:

  - Predecoder: 8.25
  - Decoder: 7.00
  - Issue: 5.40
  - Ports: 6.50

┌───────────────────────┬────────┬───────┬─────────────────────────────────────────────────────────────────────────────────────────┐
│ MITE   MS   DSB   LSD │ Issued │ Exec. │ Port 0   Port 1   Port 2   Port 3   Port 4   Port 5   Port 6   Port 7   Port 8   Port 9 │
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  1                    │   1    │   1   │  0.29     0.14                                0.25     0.32                             │ mov rcx, 0x7f7f7f7f7f7f7f7f
│  1                    │   1    │   1   │  0.11     0.14                                0.39     0.36                             │ mov rax, rdi
│  1                    │   1    │   1   │  0.36     0.07                                0.25     0.32                             │ and rax, rcx
│  1                    │   1    │   1   │  0.18     0.11                                0.46     0.25                             │ mov rdx, 0x4040404040404040
│  1                    │   1    │   1   │  0.11     0.36                                0.36     0.18                             │ mov rsi, 0x2f2f2f2f2f2f2f2f
│  1                    │   1    │   1   │  0.32     0.18                                0.32     0.18                             │ xor rdx, rax
│  1                    │   1    │   1   │  0.29     0.29                                0.21     0.21                             │ xor rsi, rax
│  1                    │   1    │   1   │  0.11     0.14                                0.32     0.43                             │ add rsi, rcx
│  1                    │   1    │   1   │  0.32     0.39                                0.21     0.07                             │ add rdx, rcx
│  1                    │   1    │   1   │  0.18     0.11                                0.36     0.36                             │ and rdx, rsi
│  1                    │   1    │   1   │  0.29     0.11                                0.36     0.25                             │ mov rsi, 0x3f3f3f3f3f3f3f3f
│  1                    │   1    │   1   │  0.21     0.39                                0.14     0.25                             │ xor rsi, rax
│  1                    │   1    │   1   │  0.25     0.36                                0.18     0.21                             │ add rsi, rcx
│  1                    │   1    │   1   │  0.36     0.11                                0.29     0.25                             │ and rdx, rsi
│  1                    │   1    │   1   │  0.18     0.36                                0.25     0.21                             │ mov rsi, 0x5c5c5c5c5c5c5c5c
│  1                    │   1    │   1   │  0.36     0.29                                0.25     0.11                             │ xor rax, rsi
│  1                    │   1    │   1   │  0.29     0.11                                0.29     0.32                             │ add rax, rcx
│  1                    │   1    │   1   │  0.11     0.29                                0.29     0.32                             │ and rdx, rax
│  1                    │   1    │   1   │  0.29     0.29                                0.25     0.18                             │ or rdx, rdi
│  1                    │   1    │   1   │  0.25     0.32                                0.18     0.25                             │ mov rax, 0x8080808080808080
│  1                    │   1    │   1   │           0.36                                0.64                                      │ andn rdx, rdx, rax
│  1                    │   1    │       │                                                                                         │ xor eax, eax
│  1                    │   1    │   1   │            1                                                                            │ tzcnt rax, rdx
│  1                    │   1    │   1   │  0.54                                                  0.46                             │ shr rax, 0x3
│  1                    │   1    │   1   │  0.21     0.21                                0.32     0.25                             │ test rdx, rdx
│  1                    │   1    │   1   │  0.21     0.36                                0.29     0.14                             │ mov rdx, 0xffffffffffffffff
│  1                    │   1    │   1   │  0.39                                                  0.61                             │ cmovz rax, rdx
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  27                   │   27   │  26   │  6.18     6.46                                6.86     6.5                              │ Total
└───────────────────────┴────────┴───────┴─────────────────────────────────────────────────────────────────────────────────────────┘
</pre>
</div>
<div class="section" id="benchmark-results">
<h2>Benchmark results</h2>
<p>Microbenchmarks run on an IceLake machine:</p>
<pre class="literal-block">
$ cat /proc/cpuinfo | grep &quot;model name&quot; | head -n 1
model name  : Intel(R) Xeon(R) Platinum 8375C CPU &#64; 2.90GHz

$ g++ -Wall -Wextra -std=c++11 -O3 -march=native benchmark.cpp reference.o better.o -o benchmark
rdtsc_overhead set to 32
reference                           :    16.000 cycle/op (best)   21.878 cycle/op (avg)
better                              :    14.000 cycle/op (best)   20.360 cycle/op (avg)
</pre>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>The throughput reported by uICA for the faster procedure is 8.25 cycles,
for original code 13.19 cycles. In theory, we may expected 1.5x speedup
of the procedure, but in practice it's not that significant.</p>
</div>
</div>
<div class="section" id="source-code">
<h1>Source code</h1>
<p>Sample source code is available on <a class="reference external" href="https://github.com/WojciechMula/toys/tree/master/swar-any-equals">Github</a></p>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2023-03-06-swar-find-any.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:32 GMT -->
</html>
