<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2018-04-19-simd-parsing-int-sequences.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:41 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>Parsing series of integers with SIMD</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="parsing-series-of-integers-with-simd">
<h1 class="title">Parsing series of integers with SIMD</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2018-04-19</td>
</tr>
<tr class="updated-on field"><th class="docinfo-name">Updated on:</th><td class="field-body">2020-07-05 (fixed a typo <a class="reference internal" href="#conversion-2digit">in conversion 2-digit numbers</a>, thank to <strong>Alexander Vingardt</strong>),
2020-03-30 (added method <a class="reference internal" href="#detecting-digits">decimal_digits_mask_version2</a> by <strong>Carl Witty</strong>),
2020-03-29 (fixed a typo, thanks to <strong>Carl Witty</strong>),
2018-04-30 (info about <a class="reference internal" href="#sse-range-checking">overflows</a>),
2018-04-25 (added speed-up <a class="reference internal" href="#core-i7-results">comparison table</a>)</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#toc-entry-1">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>While conversion from a string into an integer value is feasible with SIMD
instructions, this application is unpractical. For typical cases, when a single
value is parsed, scalar procedures &mdash; like the standard <tt class="docutils literal">atoi</tt> or
<tt class="docutils literal">strtol</tt> &mdash; are faster than any fancy SSE code.</p>
<p>However, SIMD procedures can be really fast and convert <strong>in parallel</strong> several
numbers. There is only one &quot;but&quot;: the input data has to be regular and valid,
i.e. the input string must contain only ASCII digits. Recently, I updated
article about <a class="reference internal" href="#internal-links">SSE parsing</a> with the benchmark results.  The
speed-ups are really impressive, for example the SSSE3 parser is 7 to 9 times
faster than a naive, scalar code.</p>
<p>The obvious question is how these powerful SIMD procedures can be used to
convert real data? By <em>real</em> I mean possibly broken inputs that contain series
of numbers of different length separated with characters from a predefined set.</p>
<p>In this text I try to answer that question; major contributions of this
article are:</p>
<ul class="simple">
<li>Methods to efficiently <strong>parse and validate</strong> such strings using SSE
instructions. There is a special variant that handles only unsigned
numbers and also a fully featured variant for signed numbers.</li>
<li>Boosting the SSE procedure with AVX2 or AVX512 instructions when
possible.</li>
<li>A way to combine some of SIMD techniques with scalar conversions.</li>
</ul>
<p>The article starts with unsigned conversion, because it is easier than a signed
one. The signed conversion shares the core idea, it just adds some extra steps.</p>
<p>The text is accompanied with BSD-licensed software, that includes fully
functional implementations alongside the programs which validate and benchmark
the procedures.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#parser-specification" id="toc-entry-2">2&nbsp;&nbsp;&nbsp;Parser specification</a></li>
<li><a class="reference internal" href="#sse-conversion-capabilities" id="toc-entry-3">3&nbsp;&nbsp;&nbsp;SSE conversion capabilities</a><ul class="auto-toc">
<li><a class="reference internal" href="#range-checking" id="toc-entry-4">3.1&nbsp;&nbsp;&nbsp;Range checking</a></li>
<li><a class="reference internal" href="#sample-implementation" id="toc-entry-5">3.2&nbsp;&nbsp;&nbsp;Sample implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsing-and-conversions-of-unsigned-numbers" id="toc-entry-6">4&nbsp;&nbsp;&nbsp;Parsing and conversions of unsigned numbers</a><ul class="auto-toc">
<li><a class="reference internal" href="#algorithm-overview" id="toc-entry-7">4.1&nbsp;&nbsp;&nbsp;Algorithm overview</a></li>
<li><a class="reference internal" href="#normalizing-input" id="toc-entry-8">4.2&nbsp;&nbsp;&nbsp;Normalizing input</a></li>
<li><a class="reference internal" href="#precalculating-data" id="toc-entry-9">4.3&nbsp;&nbsp;&nbsp;Precalculating data</a><ul class="auto-toc">
<li><a class="reference internal" href="#example" id="toc-entry-10">4.3.1&nbsp;&nbsp;&nbsp;Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sse-algorithm-outline" id="toc-entry-11">4.4&nbsp;&nbsp;&nbsp;SSE algorithm outline</a></li>
<li><a class="reference internal" href="#detecting-invalid-inputs" id="toc-entry-12">4.5&nbsp;&nbsp;&nbsp;Detecting invalid inputs</a><ul class="auto-toc">
<li><a class="reference internal" href="#detecting-digits-1" id="toc-entry-13">4.5.1&nbsp;&nbsp;&nbsp;Detecting digits</a></li>
<li><a class="reference internal" href="#detecting-characters-from-set" id="toc-entry-14">4.5.2&nbsp;&nbsp;&nbsp;Detecting characters from set</a><ul class="auto-toc">
<li><a class="reference internal" href="#sse-avx2" id="toc-entry-15">4.5.2.1&nbsp;&nbsp;&nbsp;SSE &amp; AVX2</a></li>
<li><a class="reference internal" href="#sse4-2" id="toc-entry-16">4.5.2.2&nbsp;&nbsp;&nbsp;SSE4.2</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#caveats" id="toc-entry-17">4.6&nbsp;&nbsp;&nbsp;Caveats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsing-and-conversion-of-signed-numbers" id="toc-entry-18">5&nbsp;&nbsp;&nbsp;Parsing and conversion of signed numbers</a><ul class="auto-toc">
<li><a class="reference internal" href="#algorithm" id="toc-entry-19">5.1&nbsp;&nbsp;&nbsp;Algorithm</a></li>
<li><a class="reference internal" href="#implementation-note" id="toc-entry-20">5.2&nbsp;&nbsp;&nbsp;Implementation note</a></li>
<li><a class="reference internal" href="#detecting-invalid-inputs-1" id="toc-entry-21">5.3&nbsp;&nbsp;&nbsp;Detecting invalid inputs</a><ul class="auto-toc">
<li><a class="reference internal" href="#avx512vbmi" id="toc-entry-22">5.3.1&nbsp;&nbsp;&nbsp;AVX512VBMI</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sse-algorithm-outline-1" id="toc-entry-23">5.4&nbsp;&nbsp;&nbsp;SSE algorithm outline</a></li>
</ul>
</li>
<li><a class="reference internal" href="#processing-larger-inputs" id="toc-entry-24">6&nbsp;&nbsp;&nbsp;Processing larger inputs</a></li>
<li><a class="reference internal" href="#scalar-hybrid-1" id="toc-entry-25">7&nbsp;&nbsp;&nbsp;Scalar hybrid</a><ul class="auto-toc">
<li><a class="reference internal" href="#example-1" id="toc-entry-26">7.1&nbsp;&nbsp;&nbsp;Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-a-conversion-of-three-digit-numbers" id="toc-entry-27">8&nbsp;&nbsp;&nbsp;Appendix A &mdash; conversion of three-digit numbers</a></li>
<li><a class="reference internal" href="#appendix-b-conversion-of-two-four-digit-numbers" id="toc-entry-28">9&nbsp;&nbsp;&nbsp;Appendix B &mdash; conversion of two four-digit numbers</a></li>
<li><a class="reference internal" href="#reference-scalar-procedures" id="toc-entry-29">10&nbsp;&nbsp;&nbsp;Reference scalar procedures</a></li>
<li><a class="reference internal" href="#experiments" id="toc-entry-30">11&nbsp;&nbsp;&nbsp;Experiments</a><ul class="auto-toc">
<li><a class="reference internal" href="#sse-conversion-execution-statistics-1" id="toc-entry-31">11.1&nbsp;&nbsp;&nbsp;SSE conversion &mdash; execution statistics</a><ul class="auto-toc">
<li><a class="reference internal" href="#overview" id="toc-entry-32">11.1.1&nbsp;&nbsp;&nbsp;Overview</a></li>
<li><a class="reference internal" href="#sse-routines-calls" id="toc-entry-33">11.1.2&nbsp;&nbsp;&nbsp;SSE routines calls</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sse-conversion-runtime-analysis" id="toc-entry-34">11.2&nbsp;&nbsp;&nbsp;SSE conversion &mdash; runtime analysis</a><ul class="auto-toc">
<li><a class="reference internal" href="#input-size-4-096-bytes" id="toc-entry-35">11.2.1&nbsp;&nbsp;&nbsp;Input size 4,096 bytes</a></li>
<li><a class="reference internal" href="#input-size-65-536-bytes" id="toc-entry-36">11.2.2&nbsp;&nbsp;&nbsp;Input size 65,536 bytes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-comparison" id="toc-entry-37">11.3&nbsp;&nbsp;&nbsp;Performance comparison</a><ul class="auto-toc">
<li><a class="reference internal" href="#tested-procedures" id="toc-entry-38">11.3.1&nbsp;&nbsp;&nbsp;Tested procedures</a></li>
<li><a class="reference internal" href="#tests-setup" id="toc-entry-39">11.3.2&nbsp;&nbsp;&nbsp;Tests setup</a></li>
<li><a class="reference internal" href="#core-i7-results-1" id="toc-entry-40">11.3.3&nbsp;&nbsp;&nbsp;Core i7 results</a><ul class="auto-toc">
<li><a class="reference internal" href="#input-size-4096-bytes" id="toc-entry-41">11.3.3.1&nbsp;&nbsp;&nbsp;Input size 4096 bytes</a></li>
<li><a class="reference internal" href="#input-size-65536-bytes" id="toc-entry-42">11.3.3.2&nbsp;&nbsp;&nbsp;Input size 65536 bytes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conclusions" id="toc-entry-43">12&nbsp;&nbsp;&nbsp;Conclusions</a></li>
<li><a class="reference internal" href="#acknowledgements" id="toc-entry-44">13&nbsp;&nbsp;&nbsp;Acknowledgements</a></li>
<li><a class="reference internal" href="#see-also" id="toc-entry-45">14&nbsp;&nbsp;&nbsp;See also</a></li>
<li><a class="reference internal" href="#source-code" id="toc-entry-46">15&nbsp;&nbsp;&nbsp;Source code</a></li>
</ul>
</div>
</div>
<div class="section" id="parser-specification">
<h1><a class="toc-backref" href="#toc-entry-2">2&nbsp;&nbsp;&nbsp;Parser specification</a></h1>
<p>The input is defined as follows:</p>
<ul class="simple">
<li>It is a string of arbitrary length; but it should be large, say a few
kilobytes or megabytes.</li>
<li>The input contains integer numbers. A number is an optional sign character
'+' or '-' followed by a non-empty sequence of digits '0'..'9'.</li>
<li>Numbers are separated with characters from a user-defiend set;
for instance, it might be the comma and blank characters (space, new
line, etc.).</li>
<li>All characters other than digits, separators and signs are considered
invalid.</li>
<li>Parser must be able to check validity of the input, i.e. lack of invalid
characters and the proper input format (numbers are separated with at
least one character, sign characters are present only at the beginning
of a number).</li>
</ul>
<p>For the input string &quot;123; -52,     +432424  -999; 1234568, +879&quot;, and three
separators ',', ';' and ' ', an algorithm is expected to extract six integers:
[123, -52, 432424, -999, 1234568, 879]. The order of converted numbers must be
exactly the same as in the input string.</p>
<p>A simplified parser is also tested. This parser simply considers all
non-digit and non-sign characters as delimiters.</p>
</div>
<div class="section" id="sse-conversion-capabilities">
<span id="sse-conversion-capabilites"></span><h1><a class="toc-backref" href="#toc-entry-3">3&nbsp;&nbsp;&nbsp;SSE conversion capabilities</a></h1>
<p>SSE instructions work on 16-byte vectors. When the input numbers have <strong>the same
count of digits</strong> and the digits of each number are placed &mdash; depending of the
digits count &mdash; on bytes, words, double words or quad words of an SSE vector,
then an SSE procedure converts them <strong>in parallel</strong>. Below are required layouts
of vectors; the most significant digit is at index 0 of each subword.</p>
<ul>
<li><p class="first">16 one-digit unsigned numbers <tt class="docutils literal">a .. p</tt>:</p>
<pre class="literal-block">
[ a0 | b0 | c0 | d0 | e0 | f0 | g0 | h0 | i0 | j0 | k0 | l0 | m0 | n0 | o0 | p0 ]
</pre>
</li>
<li><p class="first">8 two-digit unsigned numbers <tt class="docutils literal">a .. h</tt>:</p>
<pre class="literal-block">
[ a0 | a1 | b0 | b1 | c0 | c1 | d0 | d1 | e0 | e1 | f0 | f1 | g0 | g1 | h0 | h1 ]
| input 0 | input 1 | input 2 | input 3 | input 4 | input 5 | input 6 | input 7 |
</pre>
</li>
<li><p class="first">4 four-digit unsigned numbers <tt class="docutils literal">a .. d</tt>:</p>
<pre class="literal-block">
[ a0 | a1 | a2 | a3 | b0 | b1 | b2 | b3 | c0 | c1 | c2 | c3 | d0 | d1 | d2 | d3 ]
|      input 0      |      input 1      |      input 2      |      input 3      |
</pre>
</li>
<li><p class="first">and 2 eight-digit unsigned numbers <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt>:</p>
<pre class="literal-block">
[ a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 ]
|                input 0                |                input 1                |
</pre>
</li>
</ul>
<p>The conversion is done gradually. We start with an input vector filled with
ASCII digits '0'..'9'; each byte of a vector contains single character. For
string &quot;1234567890123456&quot; we have:</p>
<pre class="literal-block">
in = ['1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'0'|'1'|'2'|'3'|'4'|'5'|'6']
</pre>
<p>A single subtract <tt class="docutils literal">_mm_subs_epu8</tt> (<tt class="docutils literal">psubusb</tt>) converts from ASCII into
numbers 0..9:</p>
<pre class="literal-block">
t0 = [ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 | 1 | 2 | 3 | 4 | 5 | 6 ]
</pre>
<p>At this point we converted 16 one-digit numbers. Now, by merging adjacent numbers
from <tt class="docutils literal">t0</tt>, we may obtain two-digit numbers. SSSE3 introduced the instruction
<tt class="docutils literal">_mm_maddubs_epi16</tt> (<tt class="docutils literal">pmaddubsw</tt>) which multiplies vectors of bytes and adds
intermediate 16-bit values producing a vector of 16-bit values. Thus, when we
multiply <tt class="docutils literal">t0</tt> by a vector filled with weights (1, 10) we get eight two-digit
numbers, each saved on a 16-bit field:</p>
<pre class="literal-block">
t1 = [   12  |  34   |  56   |  78   |  90   |  12   |  34   |  56   ]
</pre>
<p>Similarly, these numbers can be merged into four-digit numbers. SSE has the
instruction <tt class="docutils literal">_mm_madd_epi16</tt> (<tt class="docutils literal">pmaddwd</tt>) which performs similar operation as
<tt class="docutils literal">_mm_maddubs_epi16</tt>, but works on 16-bit values and yields vector of 32-bit
numbers. The other vector is filled with weights (1, 100) and we get four
four-digit numbers, each saved on a 32-bit field:</p>
<pre class="literal-block">
t2 = [     1234      |     5678      |     9012      |     3456      ]
</pre>
<p>Four-digit numbers fits into 16-bit values, we might convert the above result
into a 16-bit vector using <tt class="docutils literal">_mm_packus_epi32</tt> (<tt class="docutils literal">packusdw</tt>) and again apply
the <tt class="docutils literal">_mm_madd_epi16</tt> instruction, this time with weights (1, 10000). Then we
get two eight-digit numbers:</p>
<pre class="literal-block">
t3 = [           12345678            |           90123456            ]
</pre>
<p>To summarize: conversion from a 16-digit string into two unsigned eight-digit
numbers requires only one subtract, three multiply-add instructions and one
pack operation.</p>
<p>If we need narrower numbers we simply stop the above procedure at an earlier
step; for example, for four-digit numbers the result is <tt class="docutils literal">t2</tt>. Since the
intermediate vectors have different element size (8-, 16-, 32-bit) a cast to
other vector type might be needed. Widening can be done with the instructions
<tt class="docutils literal">pmovsx</tt> (intrinsics <tt class="docutils literal">_mm_cvtepi16_epi32</tt>, <tt class="docutils literal">_mm_cvtepi8_epi32</tt>, etc.);
narrowing with the mentioned pack instruction which is also available in
different variants.</p>
<p>The same conversion using a naive scalar procedure would require 16 subtracts,
14 multiplications and 14 additions. More advanced <a class="reference internal" href="#internal-links">SWAR procedures</a> would require fewer multiplications, but still not as few
as the SIMD procedure.</p>
<div class="section" id="range-checking">
<span id="sse-range-checking"></span><h2><a class="toc-backref" href="#toc-entry-4">3.1&nbsp;&nbsp;&nbsp;Range checking</a></h2>
<p>The maximum possible value from SSE conversion procedure is <span class="math"> &plusmn; 99999999</span>.  This value is smaller than the maximum that can hold a 32-bit number
(<span class="math">2<sup>31</sup> &minus; 1 = 2147483647</span>) and also absolute value of the minimum
(<span class="math">2<sup>31</sup> = 2147483648</span>).  It means that if an output collection uses at
least 32-bit numbers, then SSE procedures <strong>never cause overflow</strong> (signed nor
unsigned).</p>
<p>Obviously, for 16-bit outputs, overflow is possible. For such case an extra
step would be required, but I do not discuss it in this text.</p>
</div>
<div class="section" id="sample-implementation">
<h2><a class="toc-backref" href="#toc-entry-5">3.2&nbsp;&nbsp;&nbsp;Sample implementation</a></h2>
<p>Below is a sample SSE implementation which shows all described steps.</p>
<pre class="code cpp literal-block">
<span class="c1">// 1. convert from ASCII '0' .. '9' to numbers 0 .. 9
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_subs_epu8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii0</span><span class="p">);</span><span class="w">

</span><span class="c1">// 2. convert to 2-digit numbers
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">mul_1_10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_setr_epi8</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_maddubs_epi16</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">mul_1_10</span><span class="p">);</span><span class="w">

</span><span class="c1">// 3. convert to 4-digit numbers
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">mul_1_100</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_setr_epi16</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_madd_epi16</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">mul_1_100</span><span class="p">);</span><span class="w">

</span><span class="c1">// 4a. convert form 32-bit into 16-bit element vector
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_packus_epi32</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">

</span><span class="c1">// 4. convert to 8-digit numbers
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">mul_1_10000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_setr_epi16</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_madd_epi16</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">mul_1_10000</span><span class="p">);</span>
</pre>
</div>
</div>
<div class="section" id="parsing-and-conversions-of-unsigned-numbers">
<h1><a class="toc-backref" href="#toc-entry-6">4&nbsp;&nbsp;&nbsp;Parsing and conversions of unsigned numbers</a></h1>
<div class="contents local topic" id="topic-1">
<ul class="auto-toc simple">
<li><a class="reference internal" href="#algorithm-overview" id="toc-entry-47">4.1&nbsp;&nbsp;&nbsp;Algorithm overview</a></li>
<li><a class="reference internal" href="#normalizing-input" id="toc-entry-48">4.2&nbsp;&nbsp;&nbsp;Normalizing input</a></li>
<li><a class="reference internal" href="#precalculating-data" id="toc-entry-49">4.3&nbsp;&nbsp;&nbsp;Precalculating data</a><ul class="auto-toc">
<li><a class="reference internal" href="#example" id="toc-entry-50">4.3.1&nbsp;&nbsp;&nbsp;Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sse-algorithm-outline" id="toc-entry-51">4.4&nbsp;&nbsp;&nbsp;SSE algorithm outline</a></li>
<li><a class="reference internal" href="#detecting-invalid-inputs" id="toc-entry-52">4.5&nbsp;&nbsp;&nbsp;Detecting invalid inputs</a><ul class="auto-toc">
<li><a class="reference internal" href="#detecting-digits-1" id="toc-entry-53">4.5.1&nbsp;&nbsp;&nbsp;Detecting digits</a></li>
<li><a class="reference internal" href="#detecting-characters-from-set" id="toc-entry-54">4.5.2&nbsp;&nbsp;&nbsp;Detecting characters from set</a><ul class="auto-toc">
<li><a class="reference internal" href="#sse-avx2" id="toc-entry-55">4.5.2.1&nbsp;&nbsp;&nbsp;SSE &amp; AVX2</a></li>
<li><a class="reference internal" href="#sse4-2" id="toc-entry-56">4.5.2.2&nbsp;&nbsp;&nbsp;SSE4.2</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#caveats" id="toc-entry-57">4.6&nbsp;&nbsp;&nbsp;Caveats</a></li>
</ul>
</div>
<div class="section" id="algorithm-overview">
<h2><a class="toc-backref" href="#toc-entry-7">4.1&nbsp;&nbsp;&nbsp;Algorithm overview</a></h2>
<p>The conversion algorithm works in a loop, in each iteration exactly one input
vector is loaded from memory and processed.</p>
<ul class="simple">
<li>The vector is validated.</li>
<li>Depending on the layout of the digits, the input is <strong>normalized</strong> to the
format required by the SIMD procedures. At this step we choose: how many
numbers from the input are converted and which SIMD procedure is suitable
for conversion.</li>
<li>After conversion, the input pointer is advanced and the loop continues.</li>
</ul>
</div>
<div class="section" id="normalizing-input">
<h2><a class="toc-backref" href="#toc-entry-8">4.2&nbsp;&nbsp;&nbsp;Normalizing input</a></h2>
<p>Since SIMD procedures impose specific layout of digits within a vector, an
arbitrary input has to be properly aligned. In order to do this, we need to
identify <strong>spans of digits</strong> in the input and move each span onto certain
subarrays of a vector. Let's assume at this point that the input contains either
digits or separators (denoted with <tt class="docutils literal">_</tt>).</p>
<p>For instance, the vector with one-digit numbers <tt class="docutils literal">1___2_3__4__5_6_</tt> must be
transformed into <tt class="docutils literal">123456__________</tt>. Then an SSE procedure will convert in
parallel all the numbers into the array [1, 2, 3, 4, 5, 6]. Likewise, the vector
with two-digit numbers <tt class="docutils literal">_12__34___56_78_</tt> must be transformed into
<tt class="docutils literal">12345678________</tt> and then the result will be [12, 34, 56, 78].</p>
<p>Let's consider a more complicated case, when a string has numbers with
different count of digits. There are a few ways to convert the input
<tt class="docutils literal">_1_2_34_567_89__</tt>:</p>
<ul class="simple">
<li>If we choose conversion of one-digit numbers, then just the two first spans
can be converted &mdash; because we need to keep the order of numbers from the input.
After normalization the input into <tt class="docutils literal">12______________</tt> just two values [1,
2] will be produced. The input's tail <tt class="docutils literal">_34_567_89__</tt> remain untouched.</li>
<li>If we choose conversion of two-digit numbers, then the three first spans
can be converted. Shorter numbers are completed with zeros, then normalized
input is <tt class="docutils literal">010234__________</tt>. The result is [1, 2, 34]; this time
a bit shorter input's tail <tt class="docutils literal">_567_89__</tt> remain untouched.</li>
<li>Finally, if we choose conversion of four-digit numbers, then the four first
spans can be converted. Again, shorter numbers are completed with zeros,
and normalized input is <tt class="docutils literal">0001000200340567</tt>. The result is [1, 2, 34, 567],
but still the chunk's tail, i.e. <tt class="docutils literal">_89__</tt>, is unprocessed.</li>
</ul>
<p>We can see that in order to convert given span combination we need to know:</p>
<ol class="arabic simple">
<li>How to shuffle bytes in the input vector?</li>
<li>Which SIMD procedure can be used then?</li>
<li>How many numbers converted by the SIMD procedure must be stored?</li>
</ol>
<p>Obtaining this information seems to be quite complicated, especially when
we look at the last example.  Fortunately, all parameters can
be <strong>precalculated</strong>.  A span combination can be saved as a bit-pattern,
where ones represent digits. For example, from vector <tt class="docutils literal">_1_2_34_567_89__</tt>
we get the <strong>span pattern</strong> <tt class="docutils literal">0b0101011011101100 = 0x56ec</tt>.
A span pattern is used to fetch a record from the precalculated array.
The record contains following fields:</p>
<ul class="simple">
<li><strong>shuffle_digits</strong> &mdash; an array of 16 bytes, which is the argument for
the instruction <tt class="docutils literal">_mm_shuffle_epi8</tt> (<tt class="docutils literal">pshufb</tt>); the instruction
moves bytes at certain positions;</li>
<li><strong>conversion_routine</strong> &mdash; an enumeration that selects an SSE conversion
procedure; for instance, it tells that shuffled input is an array
of two-digit numbers;</li>
<li><strong>element_count</strong> &mdash; the number of elements from the SSE conversion
procedure that must be stored in the output collection.</li>
</ul>
<p>The solution with a precalculated array is suitable only for SSE, as span
patterns have 16 bits. In cases of AVX2 and AVX512, where vectors are wider,
such a table would be simply too large, respectively <span class="math">2<sup>32</sup></span> or
<span class="math">2<sup>64</sup></span> entries. Additionally, the AVX2 version of <tt class="docutils literal">pshufb</tt> instruction
works on lanes, i.e. 128-bit halves of a vector, thus it is impossible to
shuffle all inputs.</p>
<p>But AVX2 and AVX512 instructions still might be used in some parts of
algorithms, especially in input validation.</p>
</div>
<div class="section" id="precalculating-data">
<h2><a class="toc-backref" href="#toc-entry-9">4.3&nbsp;&nbsp;&nbsp;Precalculating data</a></h2>
<p>To build the whole precalculated table all 65536 span patterns have to be
processed. Processing a pattern consists following steps:</p>
<ol class="arabic simple">
<li><strong>Determine digit spans</strong>. For pattern <tt class="docutils literal">_ddd__d__ddd_dd_</tt> we have four spans
[(1,3), (6,6), (9,11), (14,15)]. But for pattern <tt class="docutils literal">____dddd___ddddd</tt> there
is only one span [(4,7)]. The span at the vector's end might be continued in
the next chunk, and we don't know how to convert it. However, we may assume
that a span which starts at the vector's beginning is a new number and thus
it is included into the span's list.</li>
<li><strong>Find the best conversion scheme for the spans</strong>. We systematically check
which SSE conversion is possible, i.e. one-/two-/four-/eight-digit and how
many spans each conversion can process &mdash; the procedure which processes the
most items is selected. The output from this step are values for the following
record fields:<ul>
<li><tt class="docutils literal">element_size</tt> &mdash; 1, 2, 4, 8 or 0 if SSE conversion is not possible;</li>
<li><tt class="docutils literal">element_count</tt> &mdash; the numbers of converted spans;</li>
<li><tt class="docutils literal">total_skip</tt> &mdash; how many <strong>input bytes</strong> are processed; for pattern
<tt class="docutils literal">____dddd________</tt> we know that the whole input is processed
(<tt class="docutils literal">total_skip=16</tt>); for pattern <tt class="docutils literal">____d____ddddd_d</tt> we process only the
first span at index 5, but we know that four non-digit characters after
the span can be also skipped, thus <tt class="docutils literal">total_skip</tt> is 9.</li>
</ul>
</li>
<li><strong>Construct the shuffle pattern</strong>. Having the element size and spans positions
the vector <tt class="docutils literal">shuffle_digits</tt> is built.  The characters from a span are mapped
on the appropriate subarrays in the vector.  Also zero completion is done in
this step, as the instruction <tt class="docutils literal">pshufb</tt> either copy given byte from the input
vector or put zero if the index has got the most significant bit set.</li>
</ol>
<div class="section" id="example">
<h3><a class="toc-backref" href="#toc-entry-10">4.3.1&nbsp;&nbsp;&nbsp;Example</a></h3>
<p>Let's consider span pattern <tt class="docutils literal">_ddd__d__ddd_dd_</tt>. It can be converted using
four-digit conversion, so the layout of normalized vector should be:</p>
<pre class="literal-block">
[ a0 | a1 | a2 | a3 | b0 | b1 | b2 | b3 | c0 | c1 | c2 | c3 | d0 | d1 | d2 | d3 ]
</pre>
<p>There are four numbers <tt class="docutils literal">a</tt>, <tt class="docutils literal">b</tt>, <tt class="docutils literal">c</tt> and <tt class="docutils literal">d</tt> in the vector; note
that the bytes at 0th index hold the most significant digits.</p>
<p>The first number in pattern has three digits at indices 1, 2 and 3. It means
that <tt class="docutils literal">a1 = 1</tt>, <tt class="docutils literal">a2 = 2</tt> and <tt class="docutils literal">a3 = 3</tt>; value of <tt class="docutils literal">a0</tt> should be zeroed,
so <tt class="docutils literal">a0 = 0x80</tt>.</p>
<p>The second number has just one digit at index 6. Thus <tt class="docutils literal">b3 = 6</tt> and, since
the rest digits have to be zero, <tt class="docutils literal">b0 = b1 = b2 = 0x80</tt>.</p>
<p>The third number has three digits at indices 9, 10, 11. Thus <tt class="docutils literal">c1 = 9</tt>,
<tt class="docutils literal">c2 = 10</tt>, <tt class="docutils literal">c3 = 11</tt>, and <tt class="docutils literal">c0 = 0x80</tt>.</p>
<p>The last, forth number, has got two digits at indices 14 and 15. Thus
<tt class="docutils literal">d2 = 14</tt>, <tt class="docutils literal">d3 = 15</tt> and the rest have to be zero, so <tt class="docutils literal">d0 = d1 = 0x80</tt>.</p>
<p>The final content of the <tt class="docutils literal">shuffle_digits</tt> vector is:</p>
<pre class="literal-block">
[ 80 |  1 |  2 |  3 | 80 | 80 | 80 |  6 | 80 |  9 | 10 | 11 | 80 | 80 | 14 | 15 ]
</pre>
</div>
</div>
<div class="section" id="sse-algorithm-outline">
<h2><a class="toc-backref" href="#toc-entry-11">4.4&nbsp;&nbsp;&nbsp;SSE algorithm outline</a></h2>
<p>Below are major steps of the algorithm's loop, with snippets from the actual
implementation.</p>
<ol class="arabic simple">
<li>Load 16 characters into the input vector.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
</pre>
<ol class="arabic simple" start="2">
<li>Check for invalid characters (will be discussed <a class="reference internal" href="#unsigned-invalid-inputs">later</a>).</li>
</ol>
<ol class="arabic simple" start="3">
<li>Build the span pattern:</li>
</ol>
<pre class="code cpp literal-block">
<span class="c1">// t0 = input[i] in ['0'..'9] ? 0xff : 0x00
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w">  </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimal_digits_mask</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">t0</span><span class="p">);</span>
</pre>
<ol class="arabic simple" start="5">
<li>Fetch the block info with the precalculate parameters.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="n">BlockInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blocks</span><span class="p">[</span><span class="n">span_mask</span><span class="p">];</span>
</pre>
<ol class="arabic simple" start="6">
<li>From the block info get the shuffle pattern for <tt class="docutils literal">_mm_shuffle_epi8</tt>.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">shuffle_digits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">.</span><span class="n">shuffle_digits</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">shuffled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">shuffle_digits</span><span class="p">);</span>
</pre>
<ol class="arabic simple" start="7">
<li>The <tt class="docutils literal">shuffled</tt> vector is then issued to the proper conversion routine. The block
info structure keeps the conversion kind (<tt class="docutils literal">conversion_routine</tt>) and also the number
of items to get from the SSE result (<tt class="docutils literal">element_count</tt>). It is not always
possible to use any SSE conversion procedure, thus a scalar code is needed
to handle odd cases.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE1Digit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_1digit</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE2Digits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_2digits</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE4Digits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_4digits</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE8Digits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_8digits</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="c1">// case unsupported, a scalar code is called here
</span><span class="p">}</span>
</pre>
<ol class="arabic simple" start="8">
<li>Advance the input pointer. The block info structure keeps how many bytes
were actually covered.</li>
</ol>
<pre class="code cpp literal-block">
<span class="n">data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">total_skip</span><span class="p">;</span>
</pre>
</div>
<div class="section" id="detecting-invalid-inputs">
<span id="unsigned-invalid-inputs"></span><h2><a class="toc-backref" href="#toc-entry-12">4.5&nbsp;&nbsp;&nbsp;Detecting invalid inputs</a></h2>
<p>In case of unsigned inputs we need to classify input characters into three
categories:</p>
<ul class="simple">
<li>digits, i.e. chars '0' .. '9';</li>
<li>user-defined set of separators;</li>
<li>invalid numbers.</li>
</ul>
<p>In practise we need two masks: one with positions of digits, another with
positions of separators. If the or'ed mask has some zero elements, it means
that there are invalid characters. Below is a schema:</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_digit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimal_digits_mask</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_sep</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">matcher</span><span class="p">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_or_si128</span><span class="p">(</span><span class="n">bytemask_digit</span><span class="p">,</span><span class="w"> </span><span class="n">bytemask_sep</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">valid_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">bytemask_valid</span><span class="p">);</span><span class="w">

</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">valid_mask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xffff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&quot;wrong input&quot;</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
<div class="section" id="detecting-digits-1">
<span id="detecting-digits"></span><h3><a class="toc-backref" href="#toc-entry-13">4.5.1&nbsp;&nbsp;&nbsp;Detecting digits</a></h3>
<p>The easiest algorithm implements expression <tt class="docutils literal">c &gt;= '0' and c &lt;= '9'</tt>:</p>
<pre class="code cpp literal-block">
<span class="kr">__m128i</span><span class="w"> </span><span class="n">decimal_digits_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">after_ascii9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'9'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmplt_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii0</span><span class="p">);</span><span class="w"> </span><span class="c1">// t1 = (x &lt; '0')
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmplt_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">after_ascii9</span><span class="p">);</span><span class="w"> </span><span class="c1">// t0 = (x &lt;= '9')
</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="n">_mm_andnot_si128</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span><span class="w"> </span><span class="c1">// x &lt;= '9' and x &gt;= '0'
</span><span class="p">}</span>
</pre>
<p>Following C-expression requires only one subtraction and one comparison:</p>
<pre class="code cpp literal-block">
<span class="kt">bool</span><span class="w"> </span><span class="nf">is_digit</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">'0'</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>However, it requires unsigned comparison, which is not available in both SSE
and AVX2. Only AVX512BW defines such instruction <tt class="docutils literal">_mm512_cmple_epu8_mask</tt>
(<tt class="docutils literal">vcmpgtub</tt>).</p>
<pre class="code cpp literal-block">
<span class="kt">uint64_t</span><span class="w"> </span><span class="nf">decimal_digits_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">ascii0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">ascii9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">'9'</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_sub_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii0</span><span class="p">);</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">__mm256_cmple_epu8_mask</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">ascii9</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>Fortunately, it's possible to use similar trick for signed bytes,
we need just different constants. First, we subtract from the
input byte value <tt class="docutils literal"><span class="pre">(ord('0')</span> + 128) &amp; 0xff = 176 &amp; 0xff = 80</tt>.
This moves codes of '0'..'9' to range -128..-119. Then it's
sufficient to compare subtracted value with -118.</p>
<pre class="code cpp literal-block">
<span class="kr">__m128i</span><span class="w"> </span><span class="n">decimal_digits_mask_version2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_sub_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="mi">80</span><span class="p">));</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">_mm_cmplt_epi8</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="mi">-118</span><span class="p">));</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="detecting-characters-from-set">
<h3><a class="toc-backref" href="#toc-entry-14">4.5.2&nbsp;&nbsp;&nbsp;Detecting characters from set</a></h3>
<div class="section" id="sse-avx2">
<h4><a class="toc-backref" href="#toc-entry-15">4.5.2.1&nbsp;&nbsp;&nbsp;SSE &amp; AVX2</a></h4>
<p>The most generic SSE implementation works in time proportional to the size
of a separators set. Each character from the set is broadcast into
a vector and then compared with the input vector. The resulting byte mask is
ored with the previous result.</p>
<pre class="code cpp literal-block">
<span class="kr">__m128i</span><span class="w"> </span><span class="n">get_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">&amp;</span><span class="w"> </span><span class="n">initial</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial</span><span class="p">;</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">letters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w">
        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_or_si128</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>If the separators set is known at compilation time, then a compiler may
unroll the loop.</p>
</div>
<div class="section" id="sse4-2">
<h4><a class="toc-backref" href="#toc-entry-16">4.5.2.2&nbsp;&nbsp;&nbsp;SSE4.2</a></h4>
<p>The SNTI instruction <tt class="docutils literal">pcmpestrm</tt> (<tt class="docutils literal">_mm_cmpestrm</tt>) from SSE4.2 can also be used
in same cases. The instruction gets two arguments. One is an input vector.
Another one is interpreted either as a set of individual characters (up to 16) or
characters ranges (up to 8). The result is a mask for the input characters matching
the set (or ranges).  In the example below the set variant was used.</p>
<pre class="code cpp literal-block">
<span class="kr">__m128i</span><span class="w"> </span><span class="n">get_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">&amp;</span><span class="w"> </span><span class="n">initial</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_SIDD_UBYTE_OPS</span><span class="w">
                       </span><span class="o">|</span><span class="w"> </span><span class="n">_SIDD_CMP_EQUAL_ANY</span><span class="w">
                       </span><span class="o">|</span><span class="w"> </span><span class="n">_SIDD_UNIT_MASK</span><span class="p">;</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">_mm_or_si128</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_cmpestrm</span><span class="p">(</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="n">set_size</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">));</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
</div>
</div>
<div class="section" id="caveats">
<h2><a class="toc-backref" href="#toc-entry-17">4.6&nbsp;&nbsp;&nbsp;Caveats</a></h2>
<ol class="arabic simple">
<li>It is unlikely, and sometimes impossible, to process all digits from the
input vector. In a single iteration one to 16 bytes are converted. The table
below shows details &mdash; an important conclusion is that almost 95% of
patterns process at least half of an input vector.</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="20%" />
<col width="16%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">bytes processed</th>
<th class="head">patterns</th>
<th class="head">%</th>
<th class="head">cumulative %</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>17</td>
<td>0.03%</td>
<td>0.03%</td>
</tr>
<tr><td>2</td>
<td>32</td>
<td>0.05%</td>
<td>0.07%</td>
</tr>
<tr><td>3</td>
<td>48</td>
<td>0.07%</td>
<td>0.15%</td>
</tr>
<tr><td>4</td>
<td>176</td>
<td>0.27%</td>
<td>0.42%</td>
</tr>
<tr><td>5</td>
<td>360</td>
<td>0.55%</td>
<td>0.97%</td>
</tr>
<tr><td>6</td>
<td>542</td>
<td>0.83%</td>
<td>1.79%</td>
</tr>
<tr><td>7</td>
<td>693</td>
<td>1.06%</td>
<td>2.85%</td>
</tr>
<tr><td>8</td>
<td>1084</td>
<td>1.65%</td>
<td>4.50%</td>
</tr>
<tr><td>9</td>
<td>1620</td>
<td>2.47%</td>
<td>6.98%</td>
</tr>
<tr><td>10</td>
<td>2274</td>
<td>3.47%</td>
<td>10.45%</td>
</tr>
<tr><td>11</td>
<td>3057</td>
<td>4.66%</td>
<td>15.11%</td>
</tr>
<tr><td>12</td>
<td>4526</td>
<td>6.91%</td>
<td>22.02%</td>
</tr>
<tr><td>13</td>
<td>6193</td>
<td>9.45%</td>
<td>31.47%</td>
</tr>
<tr><td>14</td>
<td>8952</td>
<td>13.66%</td>
<td>45.13%</td>
</tr>
<tr><td>15</td>
<td>12890</td>
<td>19.67%</td>
<td>64.79%</td>
</tr>
<tr><td>16</td>
<td>23072</td>
<td>35.21%</td>
<td>100.00%</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>However, the input validation is always done for the whole vector,
all 16 bytes. This problem might be overcome, see <a class="reference internal" href="#processing-larger-inputs">Processing larger
inputs</a>.</li>
<li>SSE units are underutilized. The longest one-digit number sequence
is &quot;1;2;3;4;5;6;7;8;&quot;. It contains eight numbers, while the SSE procedure
is able to process 16 numbers. Likewise, the longest two-digit number
sequence is &quot;12;34;56;78;98;;&quot;. It has five numbers, but the SSE procedure
is able to convert eight numbers. Similarly, the longest four-digit numbers
sequence is &quot;1234;5678;9123;;&quot; &mdash; it has three four-digit numbers, the SSE
procedure is able to convert four numbers.</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="21%" />
<col width="9%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" colspan="2">SSE procedure</th>
<th class="head" colspan="2">usage in parser</th>
<th class="head" colspan="2">converted numbers</th>
<th class="head" rowspan="2">average
utilization</th>
</tr>
<tr><th class="head">input size</th>
<th class="head">converted nums</th>
<th class="head">#</th>
<th class="head">%</th>
<th class="head">avg</th>
<th class="head">max</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>N/A</td>
<td>---</td>
<td>264</td>
<td>0.40%</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>1-digit</td>
<td>16</td>
<td>5799</td>
<td>8.85%</td>
<td>3.52</td>
<td>8</td>
<td>22%</td>
</tr>
<tr><td>2-digit</td>
<td>8</td>
<td>21241</td>
<td>32.41%</td>
<td>3.99</td>
<td>7</td>
<td>49%</td>
</tr>
<tr><td>4-digit</td>
<td>4</td>
<td>30924</td>
<td>47.18%</td>
<td>3.48</td>
<td>4</td>
<td>87%</td>
</tr>
<tr><td>8-digit</td>
<td>2</td>
<td>7308</td>
<td>11.15%</td>
<td>1.97</td>
<td>2</td>
<td>98%</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="parsing-and-conversion-of-signed-numbers">
<h1><a class="toc-backref" href="#toc-entry-18">5&nbsp;&nbsp;&nbsp;Parsing and conversion of signed numbers</a></h1>
<div class="contents local topic" id="topic-2">
<ul class="auto-toc simple">
<li><a class="reference internal" href="#algorithm" id="toc-entry-58">5.1&nbsp;&nbsp;&nbsp;Algorithm</a></li>
<li><a class="reference internal" href="#implementation-note" id="toc-entry-59">5.2&nbsp;&nbsp;&nbsp;Implementation note</a></li>
<li><a class="reference internal" href="#detecting-invalid-inputs-1" id="toc-entry-60">5.3&nbsp;&nbsp;&nbsp;Detecting invalid inputs</a><ul class="auto-toc">
<li><a class="reference internal" href="#avx512vbmi" id="toc-entry-61">5.3.1&nbsp;&nbsp;&nbsp;AVX512VBMI</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sse-algorithm-outline-1" id="toc-entry-62">5.4&nbsp;&nbsp;&nbsp;SSE algorithm outline</a></li>
</ul>
</div>
<div class="section" id="algorithm">
<h2><a class="toc-backref" href="#toc-entry-19">5.1&nbsp;&nbsp;&nbsp;Algorithm</a></h2>
<p>Similarly to the unsigned conversion, the signed conversion also requires <strong>a
span pattern</strong>. But in this case also the sign characters '+' and '-' are
included in the pattern. For this sample string:</p>
<pre class="literal-block">
input     = &quot;_+123_-45_78_-9_&quot;
</pre>
<p>the span pattern is:</p>
<pre class="literal-block">
span_mask = _dddd_ddd_dd_dd_
</pre>
<p>The conversion unfortunately requires two shuffles:</p>
<ol class="arabic simple">
<li>Shuffle spans onto proper vector elements &mdash; this is exactly the same
as in unsigned conversion.</li>
<li>Populate the first span characters, i.e. <strong>possibly sign character</strong>,
on the proper vector elements.</li>
</ol>
<p>For input:</p>
<pre class="literal-block">
input =

[ '_' | '-' | '1' | '2' | '3' | '_' | '+' | '4' | '5' | '_' | '-' | '6' | '_' | '7' | '8' | '_' ]
</pre>
<p>The conversion processes four four-digit numbers. After shuffling the
digit spans we have:</p>
<pre class="literal-block">
shuffled =

[ '-'   '1'   '2'   '3' | 0x00  '+'   '4'   '5' | 0x00  0x00  '-'   '6' | 0x00  0x00  '7'   '8' ]
</pre>
<p>and the vector of sign characters is:</p>
<pre class="literal-block">
shuffled_signs =

[ '-'   '-'   '-'   '-' | '+'   '+'   '+'   '+' | '-'   '-'   '-'   '-' | '7'   '7'   '7'   '7' ]
</pre>
<p>The <tt class="docutils literal">shuffled_signs</tt> vector does not necessarily contain only '+' or '-',
it might contain also digits, but this is not an error.</p>
<p>Then the conversion works as follows:</p>
<ul>
<li><p class="first">From the <tt class="docutils literal">shuffled</tt> vector the sign characters are removed and
ASCII characters are converted into values:</p>
<pre class="literal-block">
[  0     1     2     3  |  0     0     4     5  |  0     0     0     6  |  0     0     7     8  ]
</pre>
</li>
<li><p class="first">Thus we end up with a vector of unsigned numbers, and such an input
can be converted by the already defined SSE procedures:</p>
<pre class="literal-block">
[          123          |           45          |           6           |           78          ]
</pre>
</li>
<li><p class="first">Finally, negate appropriate elements; we use a well known equation <tt class="docutils literal">(~x + 1)</tt>,
which is expressed in the SSE code as <tt class="docutils literal">(x xor <span class="pre">(-1)</span> - <span class="pre">(-1))</span></tt>. The value <tt class="docutils literal"><span class="pre">-1</span></tt>
is obtained from comparing <tt class="docutils literal">shuffled_signs</tt> with the '-':</p>
<pre class="literal-block">
negated_mask = (shuffled_signs == packed_byte('-'))

[ ff    ff    ff    ff  | 00    00    00    00  | ff    ff    ff    ff  | 00    00    00    00  ]
</pre>
<p>or as vector of <tt class="docutils literal">int32_t</tt>:</p>
<pre class="literal-block">
[          -1           |           0           |          -1           |           0           ]
</pre>
</li>
</ul>
</div>
<div class="section" id="implementation-note">
<h2><a class="toc-backref" href="#toc-entry-20">5.2&nbsp;&nbsp;&nbsp;Implementation note</a></h2>
<p>Masking of the sign characters in <tt class="docutils literal">shuffled</tt> vector is done at no cost, as
the instruction <tt class="docutils literal">_mm_subs_epu8</tt> (<tt class="docutils literal">psubusb</tt>) is used to convert from ASCII to
numeric values:</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_subs_epu8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii0</span><span class="p">);</span>
</pre>
<p>The instruction performs <strong>subtract with saturation</strong>, i.e. calculates <tt class="docutils literal">max(0,
<span class="pre">a-b)</span></tt>. Since the ASCII codes of '-' and '+' are respectively 43 and 45 and the
ASCII code of '0' is 48, then the result of such expression is zero for both
sign characters.</p>
</div>
<div class="section" id="detecting-invalid-inputs-1">
<h2><a class="toc-backref" href="#toc-entry-21">5.3&nbsp;&nbsp;&nbsp;Detecting invalid inputs</a></h2>
<p>The characters '+' and '-' can be present only at the beginning of a digit
span, i.e. we want to reject inputs like &quot;++12&quot; or &quot;1234-,&quot;.</p>
<p>To properly validate the input we need four masks for:</p>
<ol class="arabic simple">
<li>separators,</li>
<li>digits,</li>
<li>the character '-',</li>
<li>the character '+'.</li>
</ol>
<p>The first phase is similar to the unsigned conversion, i.e. all masks are or'ed
together, then zero elements point at invalid characters.</p>
<p>The second phase checks if sign characters are placed properly.  For each span
combination we need to precalculate the mask of valid sign positions. Then,
after or'ing the masks for the '+' and '-' we simply verify if they are placed
on valid positions.</p>
<p>In practise the precalculated data has a bit-mask for invalid sign positions,
thanks to that validation require just a simple and. The snippet below shows
the schema of the second step.</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii_minus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'-'</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii_plus</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'+'</span><span class="p">);</span><span class="w">

</span><span class="c1">// ...
</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_plus</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii_plus</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_minus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii_minus</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_sign</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_or_si128</span><span class="p">(</span><span class="n">bytemask_plus</span><span class="p">,</span><span class="w"> </span><span class="n">bytemask_minus</span><span class="p">);</span><span class="w">

</span><span class="c1">// ...
</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">sign_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">bytemask_sign</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">bytemask_span</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="n">BlockInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blocks</span><span class="p">[</span><span class="n">span_mask</span><span class="p">];</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sign_mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">invalid_sign_mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;'+' or '-' at invalid position&quot;</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
<div class="section" id="avx512vbmi">
<h3><a class="toc-backref" href="#toc-entry-22">5.3.1&nbsp;&nbsp;&nbsp;AVX512VBMI</a></h3>
<p>AVX512VBMI defines the powerful instruction <tt class="docutils literal">_mm512_permutex2var_epi8</tt> (<tt class="docutils literal">vperm2b</tt>)
which does a lookup in a 128-byte table using as the indices the seven lowest bits of
each byte of a ZMM register. Invocation of the intrinsics function is weird:</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">lookup_lo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c1">// elements 0..63
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">lookup_hi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c1">// and 64..127 of the lookup
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">transformed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutex2var_epi8</span><span class="p">(</span><span class="n">lookup_lo</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">lookup_hi</span><span class="p">);</span>
</pre>
<p>If the set of valid character fits in the standard ASCII character set, i.e.
just seven lowest bits are set, then the validation step might quickly reject
extended ASCII (7th bit set) and then translate the input using single
invocation of <tt class="docutils literal">_mm512_permutex2var_epi8</tt>. When full 8-bit input
is allowed, then the instruction has to be called twice with two halves
of a 256-byte lookup.</p>
<p>An invocation (or two) of this instruction allows to classify <strong>at once</strong>
all 64 input bytes into required categories:</p>
<ul class="simple">
<li>separators &mdash; it doesn't matter how many separator chars are used;</li>
<li>digits;</li>
<li>and sign characters.</li>
</ul>
<p>Category is encoded as a bit at certain position, in sample implementation
following schema is used:</p>
<ul class="simple">
<li><tt class="docutils literal">separator = 0x01</tt>,</li>
<li><tt class="docutils literal">digit = 0x80</tt>,</li>
<li><tt class="docutils literal">sign = 0x80 | 0x40</tt>.</li>
</ul>
<p>If the transformed vector contains zero byte, it means there are invalid characters.</p>
<p>The span pattern is obtained from the most significant bits by the instruction
<tt class="docutils literal">_mm512_movepi8_mask</tt> (<tt class="docutils literal">vpmovb2m</tt>); it works exactly the same way as
<tt class="docutils literal">pmovmaskb</tt> from SSE.  The sign pattern is obtained by the instruction
<tt class="docutils literal">_mm512_test_epi8_mask</tt> (<tt class="docutils literal">vptestmb</tt>), by testing bit 7th (mask <tt class="docutils literal">0x40</tt>).</p>
<p>Below is a snippet from the implementation:</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">classes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutex2var_epi8</span><span class="p">(</span><span class="n">class_lo</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">class_hi</span><span class="p">);</span><span class="w">

</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_mm512_test_epi8_mask</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span><span class="w"> </span><span class="n">classes</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">uint64_t</span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&quot;invalid character&quot;</span><span class="p">);</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">span_mask64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_movepi8_mask</span><span class="p">(</span><span class="n">classes</span><span class="p">);</span><span class="w">
</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">sign_mask64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_test_epi8_mask</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="kt">int8_t</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)));</span>
</pre>
</div>
</div>
<div class="section" id="sse-algorithm-outline-1">
<h2><a class="toc-backref" href="#toc-entry-23">5.4&nbsp;&nbsp;&nbsp;SSE algorithm outline</a></h2>
<p>Below are major steps of the algorithm's loop, with snippets from the actual
implementation.</p>
<ol class="arabic simple">
<li>Load 16 characters into the input vector.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
</pre>
<ol class="arabic simple" start="2">
<li>Check for invalid characters (as described <a class="reference internal" href="#unsigned-invalid-inputs">above</a>).</li>
<li>Build the span pattern and fetch the conversion parameters.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii_minus</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'-'</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii_plus</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'+'</span><span class="p">);</span><span class="w">

</span><span class="c1">// ...
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_plus</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii_plus</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_minus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii_minus</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_sign</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_or_si128</span><span class="p">(</span><span class="n">bytemask_plus</span><span class="p">,</span><span class="w"> </span><span class="n">bytemask_minus</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_digit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimal_digits_mask</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask_span</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_or_si128</span><span class="p">(</span><span class="n">bytemask_digit</span><span class="p">,</span><span class="w"> </span><span class="n">bytemask_sign</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">bytemask_span</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="n">BlockInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_info</span><span class="p">[</span><span class="n">span_mask</span><span class="p">];</span>
</pre>
<ol class="arabic simple" start="4">
<li>Validate if the sign characters are properly placed.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">sign_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">bytemask_sign</span><span class="p">);</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sign_mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">invalid_sign_mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;'+' or '-' at invalid position&quot;</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
<ol class="arabic simple" start="5">
<li>If <tt class="docutils literal">sign_mask</tt> is zero, choose faster unsigned conversion path.</li>
<li>Otherwise prepare data for signed conversion.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii_minus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'-'</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">shuffle_digits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">bi</span><span class="p">.</span><span class="n">shuffle_digits</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">shuffle_signs</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">bi</span><span class="p">.</span><span class="n">shuffle_signs</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">shuffled</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">shuffle_digits</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">shuffled_signs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">shuffle_signs</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">negate_mask</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">shuffled_signs</span><span class="p">,</span><span class="w"> </span><span class="n">ascii_minus</span><span class="p">);</span>
</pre>
<ol class="arabic simple" start="7">
<li>And finally invoke proper conversion routine.</li>
</ol>
<pre class="code cpp literal-block">
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bi</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE1Digit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_1digit</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bi</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE2Digits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_2digits_signed</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">negate_mask</span><span class="p">,</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bi</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE4Digits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_4digits_signed</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">negate_mask</span><span class="p">,</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bi</span><span class="p">.</span><span class="n">conversion_routine</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Conversion</span><span class="o">::</span><span class="n">SSE8Digits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">convert_8digits_signed</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span><span class="w"> </span><span class="n">negate_mask</span><span class="p">,</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">element_count</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="c1">// scalar conversion
</span><span class="p">}</span>
</pre>
</div>
</div>
<div class="section" id="processing-larger-inputs">
<h1><a class="toc-backref" href="#toc-entry-24">6&nbsp;&nbsp;&nbsp;Processing larger inputs</a></h1>
<p>As it was stated in <a class="reference internal" href="#caveats">Caveats</a> section, a single step of algorithm validates the
whole input vector but rarely converts all bytes from the input.  Although
detecting digits and sign characters might be considered cheap, we saw that
validating against an arbitrary set of separators might be really time
consuming.</p>
<p>The idea is to separate the validation from the conversion. In case of the
unsigned conversion only the <tt class="docutils literal">span_mask</tt> is needed; in case of the
signed conversion we need also <tt class="docutils literal">sign_mask</tt>.</p>
<p>In each iteration we process four 16-byte chunks. The result from this step are
64-bit masks. Then, we load 16 bytes into the input vector and use the lower
16-bit part of already calculated mask to get block info for the loaded code.</p>
<p>For unsigned conversion the main loop looks like this:</p>
<pre class="code cpp literal-block">
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span><span class="w">

    </span><span class="c1">// validate input and calculate span_mask
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_span_mask</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
    </span><span class="c1">// obtain block info
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">BlockInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_info</span><span class="p">[</span><span class="n">span_mask</span><span class="p">];</span><span class="w">
    </span><span class="c1">// convert
</span><span class="w">    </span><span class="n">convert</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">bi</span><span class="p">);</span><span class="w">

    </span><span class="c1">// advance pointer
</span><span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">total_processed</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>And after applying the proposed change:</p>
<pre class="code cpp literal-block">
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span><span class="w">

    </span><span class="c1">// validate input and calculate 4 x span_mask
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_span_mask</span><span class="p">(</span><span class="n">input0</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_span_mask</span><span class="p">(</span><span class="n">input1</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_span_mask</span><span class="p">(</span><span class="n">input2</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_span_mask</span><span class="p">(</span><span class="n">input3</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">span_mask64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">span_mask0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="mi">16</span><span class="p">))</span><span class="w">
                               </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">span_mask1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">16</span><span class="p">))</span><span class="w">
                               </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">span_mask2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">16</span><span class="p">))</span><span class="w">
                               </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">span_mask3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span><span class="w">

    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">16</span><span class="p">;</span><span class="w">
    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">span_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">span_mask64</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff</span><span class="p">;</span><span class="w">
        </span><span class="c1">// obtain block info
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">BlockInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_info</span><span class="p">[</span><span class="n">span_mask</span><span class="p">];</span><span class="w">

        </span><span class="c1">// read input
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="w"> </span><span class="mi">16</span><span class="o">-</span><span class="n">byte</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">data</span><span class="w">

        </span><span class="c1">// convert
</span><span class="w">        </span><span class="n">convert</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">bi</span><span class="p">);</span><span class="w">

        </span><span class="c1">// advance pointer
</span><span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">total_processed</span><span class="p">;</span><span class="w">

        </span><span class="c1">// shift the mas accordingly
</span><span class="w">        </span><span class="n">span_mask64</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">bi</span><span class="p">.</span><span class="n">total_processed</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The problem of this solution is multiple reading the input bytes. Moreover, the
looping schema is more complicated; especially in practice, where also scalar
fallback have to be considered (it is not shown here).</p>
</div>
<div class="section" id="scalar-hybrid-1">
<span id="scalar-hybrid"></span><h1><a class="toc-backref" href="#toc-entry-25">7&nbsp;&nbsp;&nbsp;Scalar hybrid</a></h1>
<p>The idea of separation the validation step from the actual conversion might
also be applied for scalar parser. The validation, i.e. building a <tt class="docutils literal">span_mask</tt>
is done by SIMD code. Then, each byte of the <tt class="docutils literal">span_mask</tt> is processed
by a precompiled code for each of 256 cases.</p>
<p>There are two major advantages:</p>
<p>1. Scalar conversions are called with compile-time constants, thanks to
that a compiler can perform as many optimizations as possible.</p>
<p>2. Digits spans that cross byte boundary can be processed seamlessly. When a
span ends at the byte's end, a conversion routine converts all characters from
the input's chunk and marks that the conversion is not completed.</p>
<p>When the next pattern is processed, the mark is checked: if the first
bit of the current pattern is zero, it means that the previously converted
number is ready and can be saved. If the first bit is one, it means that the
first span is continuation and thus conversion must be carried on from
the saved point.</p>
<div class="section" id="example-1">
<h2><a class="toc-backref" href="#toc-entry-26">7.1&nbsp;&nbsp;&nbsp;Example</a></h2>
<p>Let's convert following input 24-byte input (the space separates 8-byte chunks):</p>
<pre class="literal-block">
_12_3_45 6_7890_1 ___99___
</pre>
<p>The first chunk of input is <tt class="docutils literal">_12_3_45</tt>, i.e. the <tt class="docutils literal">span_pattern = 0b01101011
= 0x6b</tt>. The digit spans are [(1,2), (4,4), (6,7)], following code handles them:</p>
<pre class="code cpp literal-block">
<span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="n">val</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w">
</span><span class="n">has_val</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</pre>
<p>The template <tt class="docutils literal">convert</tt> is parametrized by the number of digits to convert and
gets a pointer to the first character. The important fact is such code doesn't need
to validate pointers, sizes etc. All is known in the compile-time.</p>
<p>The next input's chunk is <tt class="docutils literal">6_7890_1</tt>, the digit spans are [(0,0), (2,5), (7,7)].
A variant of template <tt class="docutils literal">convert</tt> that accepts two parameters simple starts
conversion from the saved state (<tt class="docutils literal">val</tt>).</p>
<pre class="code cpp literal-block">
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">has_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">continue</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="n">val</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w">
</span><span class="n">has_val</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</pre>
<p>The last, third chunk, is <tt class="docutils literal">___99___</tt>, and there is just one digit span [(3,4)]:</p>
<pre class="code cpp literal-block">
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">has_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w">
    </span><span class="n">has_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="n">has_val</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</pre>
</div>
</div>
<div class="section" id="appendix-a-conversion-of-three-digit-numbers">
<span id="convert-3digits"></span><h1><a class="toc-backref" href="#toc-entry-27">8&nbsp;&nbsp;&nbsp;Appendix A &mdash; conversion of three-digit numbers</a></h1>
<p>When the input vector contains an array of three-digit numbers, like
&quot;123;456;789;123;&quot;, we still use four-digit conversion routine. But we might
utilize the fact that the most significant digit is always zero.</p>
<p>We use <tt class="docutils literal">_mm_maddubs_epi16</tt>, but with weights 1, 10, 100, 0: two lower digits
are converted and the most significant digit is properly scaled. Then simple
horizontal add <tt class="docutils literal">_mm_hadd_epi16</tt> adds the intermediate results.</p>
<pre class="code cpp literal-block">
<span class="c1">// t0 = [   0 |   5 |   7 |   9 |   0 |   1 |   2 |   3 |   0 |   9 |   2 |   5 |   0 |   3 |   2 |   7 ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii0</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_subs_epu8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii0</span><span class="p">);</span><span class="w">

</span><span class="c1">// t1 = [    500    |     79    |    100    |    23     |    900    |    25     |    300    |    27     ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">mul_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_setr_epi8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_maddubs_epi16</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">mul_all</span><span class="p">);</span><span class="w">

</span><span class="c1">// t2 = [    579    |    123    |    925    |   327     |    579    |    123    |    925    |   327     ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_hadd_epi16</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span>
</pre>
</div>
<div class="section" id="appendix-b-conversion-of-two-four-digit-numbers">
<span id="conversion-2digit"></span><h1><a class="toc-backref" href="#toc-entry-28">9&nbsp;&nbsp;&nbsp;Appendix B &mdash; conversion of two four-digit numbers</a></h1>
<p>Where two four-digits are going to be converted, a faster approach can be used.
Instead of storing each digit on separate bytes, digits are stored on 16-bit
values. Then a single <tt class="docutils literal">_mm_madd_epi16</tt> is used to multiply all digits by
weights 1, 10, 100, 1000. Then the result's halves are added with <tt class="docutils literal">_mm_hadd_epi32</tt>
(<tt class="docutils literal">phaddd</tt>).</p>
<pre class="code cpp literal-block">
<span class="c1">// input = &quot;12345678&quot;
</span><span class="w">
</span><span class="c1">// t0 = [   0 |   1 |   0 |   2 |   0 |   3 |   0 |   4 |   0 |   5 |   0 |   6 |   0 |   7 |   0 |   8 ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">ascii0</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_subs_epu8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">ascii0</span><span class="p">);</span><span class="w">

</span><span class="c1">// t0 = [         1 |         2 |         3 |         4 |         5 |         6 |         7 |         8 ]
//    * [      1000 |       100 |        10 |         1 |      1000 |       100 |        10 |         1 ]
</span><span class="w">
</span><span class="c1">// t1 = [         1200          |           34          |          5600         |          78           ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">mul_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_setr_epi16</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_madd_epi16</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">mul_all</span><span class="p">);</span><span class="w">

</span><span class="c1">// t2 = [         1234          |         5678          |         1234          |          5678         ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_hadd_epi32</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span>
</pre>
</div>
<div class="section" id="reference-scalar-procedures">
<span id="reference-implementation"></span><h1><a class="toc-backref" href="#toc-entry-29">10&nbsp;&nbsp;&nbsp;Reference scalar procedures</a></h1>
<p>There are two reference scalar implementations:</p>
<ul class="simple">
<li>a fully specialized, handcrafted parser;</li>
<li>parser based on two standard functions: <tt class="docutils literal">strspn</tt> and <tt class="docutils literal">strtol</tt>.</li>
</ul>
<p>The handcrafted source:</p>
<pre class="code cpp literal-block">
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">INSERTER</span><span class="o">&gt;</span><span class="w">
</span><span class="kt">void</span><span class="w"> </span><span class="n">parse_signed</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">separators</span><span class="p">,</span><span class="w"> </span><span class="n">INSERTER</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">enum</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">Separator</span><span class="p">,</span><span class="w">
        </span><span class="n">Plus</span><span class="p">,</span><span class="w">
        </span><span class="n">Minus</span><span class="p">,</span><span class="w">
        </span><span class="n">Digit</span><span class="w">
    </span><span class="p">};</span><span class="w">

    </span><span class="n">State</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Separator</span><span class="p">;</span><span class="w">
    </span><span class="n">State</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Separator</span><span class="p">;</span><span class="w">
    </span><span class="kt">bool</span><span class="w"> </span><span class="n">negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">
    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'+'</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Plus</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'-'</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Minus</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">'0'</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">'9'</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Digit</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">contains</span><span class="p">(</span><span class="n">separators</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Separator</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Wrong character (scalar)&quot;</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">case</span><span class="w"> </span><span class="no">Plus</span><span class="p">:</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Separator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Invalid syntax ('+' follows a non-separator character)&quot;</span><span class="p">);</span><span class="w">
                </span><span class="p">}</span><span class="w">
                </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
                </span><span class="n">negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">
                </span><span class="k">break</span><span class="p">;</span><span class="w">

            </span><span class="k">case</span><span class="w"> </span><span class="no">Minus</span><span class="p">:</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Separator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Invalid syntax ('-' follows a non-separator character)&quot;</span><span class="p">);</span><span class="w">
                </span><span class="p">}</span><span class="w">
                </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
                </span><span class="n">negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">
                </span><span class="k">break</span><span class="p">;</span><span class="w">

            </span><span class="k">case</span><span class="w"> </span><span class="no">Digit</span><span class="p">:</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Separator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">'0'</span><span class="p">;</span><span class="w">
                    </span><span class="n">negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">*</span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">'0'</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
                </span><span class="k">break</span><span class="p">;</span><span class="w">

            </span><span class="k">case</span><span class="w"> </span><span class="no">Separator</span><span class="p">:</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Digit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">negative</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                        </span><span class="o">*</span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">number</span><span class="p">;</span><span class="w">
                    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
                        </span><span class="o">*</span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number</span><span class="p">;</span><span class="w">
                    </span><span class="p">}</span><span class="w">
                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Separator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Invalid syntax ('-' or '+' not followed by any digit)&quot;</span><span class="p">);</span><span class="w">
                </span><span class="p">}</span><span class="w">
                </span><span class="k">break</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="c1">// switch
</span><span class="w">
        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="c1">// for
</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Separator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Digit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">negative</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="o">*</span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">number</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="o">*</span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number</span><span class="p">;</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Separator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Invalid syntax ('-' or '+' not followed by any digit)&quot;</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>And implementation based on standard functions:</p>
<pre class="code cpp literal-block">
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">INSERTER</span><span class="o">&gt;</span><span class="w">
</span><span class="kt">void</span><span class="w"> </span><span class="n">parse_signed</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">separators</span><span class="p">,</span><span class="w"> </span><span class="n">INSERTER</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w">
    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">

    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">endptr</span><span class="p">;</span><span class="w">
    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">ptr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">strspn</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">separators</span><span class="p">);</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">break</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="n">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">strtol</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">

        </span><span class="c1">// the following check comes from &quot;man 3 strtol&quot;
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">errno</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ERANGE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LONG_MAX</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LONG_MIN</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&quot;invalid input&quot;</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">endptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&quot;no digits&quot;</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">endptr</span><span class="p">;</span><span class="w">
        </span><span class="o">*</span><span class="n">output</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="experiments">
<h1><a class="toc-backref" href="#toc-entry-30">11&nbsp;&nbsp;&nbsp;Experiments</a></h1>
<p>This part presents evaluation of algorithms in terms of running time
(performance tests) and also some statistical measurements that might
help in understanding run-time properties.</p>
<div class="contents local topic" id="topic-3">
<ul class="auto-toc simple">
<li><a class="reference internal" href="#sse-conversion-execution-statistics-1" id="toc-entry-63">11.1&nbsp;&nbsp;&nbsp;SSE conversion &mdash; execution statistics</a><ul class="auto-toc">
<li><a class="reference internal" href="#overview" id="toc-entry-64">11.1.1&nbsp;&nbsp;&nbsp;Overview</a></li>
<li><a class="reference internal" href="#sse-routines-calls" id="toc-entry-65">11.1.2&nbsp;&nbsp;&nbsp;SSE routines calls</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sse-conversion-runtime-analysis" id="toc-entry-66">11.2&nbsp;&nbsp;&nbsp;SSE conversion &mdash; runtime analysis</a><ul class="auto-toc">
<li><a class="reference internal" href="#input-size-4-096-bytes" id="toc-entry-67">11.2.1&nbsp;&nbsp;&nbsp;Input size 4,096 bytes</a></li>
<li><a class="reference internal" href="#input-size-65-536-bytes" id="toc-entry-68">11.2.2&nbsp;&nbsp;&nbsp;Input size 65,536 bytes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-comparison" id="toc-entry-69">11.3&nbsp;&nbsp;&nbsp;Performance comparison</a><ul class="auto-toc">
<li><a class="reference internal" href="#tested-procedures" id="toc-entry-70">11.3.1&nbsp;&nbsp;&nbsp;Tested procedures</a></li>
<li><a class="reference internal" href="#tests-setup" id="toc-entry-71">11.3.2&nbsp;&nbsp;&nbsp;Tests setup</a></li>
<li><a class="reference internal" href="#core-i7-results-1" id="toc-entry-72">11.3.3&nbsp;&nbsp;&nbsp;Core i7 results</a><ul class="auto-toc">
<li><a class="reference internal" href="#input-size-4096-bytes" id="toc-entry-73">11.3.3.1&nbsp;&nbsp;&nbsp;Input size 4096 bytes</a></li>
<li><a class="reference internal" href="#input-size-65536-bytes" id="toc-entry-74">11.3.3.2&nbsp;&nbsp;&nbsp;Input size 65536 bytes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>Following parameters of the input data are being changed:</p>
<ul class="simple">
<li>Input size in bytes.</li>
<li>Distribution of number of digits:<ul>
<li>fixed size from 1 to 8 digits [only in overall performance tests];</li>
<li>uniform distribution over range 1 to k, where k = 1..8;</li>
<li>Gaussian distribution with mu = 1..8 (sigma = 1.0).</li>
</ul>
</li>
<li>Distribution of count of separators between numbers:<ul>
<li>exactly one separator character,</li>
<li>uniform distribution of 1 to 6 separators.</li>
</ul>
</li>
<li>Uniform distribution of the set: no-sign-char, '+' and '-'.</li>
</ul>
<div class="section" id="sse-conversion-execution-statistics-1">
<span id="sse-conversion-execution-statistics"></span><h2><a class="toc-backref" href="#toc-entry-31">11.1&nbsp;&nbsp;&nbsp;SSE conversion &mdash; execution statistics</a></h2>
<p><a class="reference internal" href="#caveats">Caveats</a> shows statistics of 1) average processed bytes and 2) SSE
utilization. This section presents real numbers gathered during
conversion of 1000000 bytes containing 1-8 digit signed numbers.</p>
<div class="section" id="overview">
<h3><a class="toc-backref" href="#toc-entry-32">11.1.1&nbsp;&nbsp;&nbsp;Overview</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="16%" />
<col width="16%" />
</colgroup>
<tbody valign="top">
<tr><td>loops</td>
<td>90'790</td>
<td>&nbsp;</td>
</tr>
<tr><td>... different span patterns</td>
<td>1'315</td>
<td>&nbsp;</td>
</tr>
<tr><td>total numbers converted</td>
<td>162'228</td>
<td>100.00%</td>
</tr>
<tr><td>conversion handled by scalar fallbacks</td>
<td>13'601</td>
<td>8.38%</td>
</tr>
<tr><td>conversions done by SSE procedures</td>
<td>148'627</td>
<td>91.62%</td>
</tr>
<tr><td>... unsigned SSE parser</td>
<td>6'222</td>
<td rowspan="2">N/A</td>
</tr>
<tr><td>... signed SSE parser</td>
<td>142'405</td>
</tr>
</tbody>
</table>
<p>As we see, most conversions were done by the SSE code; moreover, most
conversions went through the signed parser, which is slower than unsigned
counterpart.</p>
<p>Another important number, which may give a hint about possible cache misses
to the <tt class="docutils literal">block_info</tt> structure, is the count of different span patterns.
It is 1315 (~2% of the whole table size, 65536), but only 120 of them were
processed in 75% iterations. The <a class="reference internal" href="#sse-conversion-span-pattern-usage">next section</a>
shows this parameter in details.</p>
</div>
<div class="section" id="sse-routines-calls">
<h3><a class="toc-backref" href="#toc-entry-33">11.1.2&nbsp;&nbsp;&nbsp;SSE routines calls</a></h3>
<p>Below are detailed statistics for SSE routines:</p>
<ul class="simple">
<li>calls &mdash; how many times the procedure was called;</li>
<li>converted &mdash; how many numbers were parsed;</li>
<li>conv/call &mdash; average utilization.</li>
</ul>
<p>Conversions 1-/2-/4-/8-digits are described in section <a class="reference internal" href="#sse-conversion-capabilites">SSE conversion
capabilities</a>, the 3-digit procedure in
<a class="reference internal" href="#appendix-a-conversion-of-three-digit-numbers">Appendix A &mdash; conversion of three-digit numbers</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" rowspan="2">procedure</th>
<th class="head" colspan="3">unsigned path</th>
<th class="head" colspan="3">signed path</th>
</tr>
<tr><th class="head">calls</th>
<th class="head">converted</th>
<th class="head">conv/call</th>
<th class="head">calls</th>
<th class="head">converted</th>
<th class="head">conv/call</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1-digit conversion</td>
<td>325</td>
<td>410</td>
<td>1.26</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr><td>2-digit conversion</td>
<td>21</td>
<td>48</td>
<td>2.29</td>
<td>1949</td>
<td>3521</td>
<td>1.81</td>
</tr>
<tr><td>3-digit conversion</td>
<td>21</td>
<td>43</td>
<td>2.05</td>
<td>1409</td>
<td>2246</td>
<td>1.59</td>
</tr>
<tr><td>4-digit conversion</td>
<td>239</td>
<td>581</td>
<td>2.43</td>
<td>10569</td>
<td>26255</td>
<td>2.48</td>
</tr>
<tr><td>8-digit conversion</td>
<td>2887</td>
<td>5140</td>
<td>1.78</td>
<td>59769</td>
<td>110383</td>
<td>1.85</td>
</tr>
</tbody>
</table>
<p>The table below shows how many bytes from the input vector were processed
in single iteration. It is pretty close to average numbers showed in <a class="reference internal" href="#caveats">Caveats</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="20%" />
<col width="16%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">bytes processed</th>
<th class="head">patterns</th>
<th class="head">%</th>
<th class="head">cumulative %</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>0</td>
<td>0.00%</td>
<td>0.00%</td>
</tr>
<tr><td>1</td>
<td>0</td>
<td>0.00%</td>
<td>0.00%</td>
</tr>
<tr><td>2</td>
<td>197</td>
<td>0.26%</td>
<td>0.26%</td>
</tr>
<tr><td>3</td>
<td>583</td>
<td>0.76%</td>
<td>1.01%</td>
</tr>
<tr><td>4</td>
<td>773</td>
<td>1.00%</td>
<td>2.01%</td>
</tr>
<tr><td>5</td>
<td>1137</td>
<td>1.47%</td>
<td>3.48%</td>
</tr>
<tr><td>6</td>
<td>1841</td>
<td>2.39%</td>
<td>5.87%</td>
</tr>
<tr><td>7</td>
<td>2544</td>
<td>3.30%</td>
<td>9.17%</td>
</tr>
<tr><td>8</td>
<td>5305</td>
<td>6.87%</td>
<td>16.04%</td>
</tr>
<tr><td>9</td>
<td>9135</td>
<td>11.83%</td>
<td>27.87%</td>
</tr>
<tr><td>10</td>
<td>7163</td>
<td>9.28%</td>
<td>37.15%</td>
</tr>
<tr><td>11</td>
<td>8834</td>
<td>11.44%</td>
<td>48.60%</td>
</tr>
<tr><td>12</td>
<td>10102</td>
<td>13.09%</td>
<td>61.68%</td>
</tr>
<tr><td>13</td>
<td>9342</td>
<td>12.10%</td>
<td>73.79%</td>
</tr>
<tr><td>14</td>
<td>8221</td>
<td>10.65%</td>
<td>84.44%</td>
</tr>
<tr><td>15</td>
<td>6743</td>
<td>8.74%</td>
<td>93.17%</td>
</tr>
<tr><td>16</td>
<td>5269</td>
<td>6.83%</td>
<td>100.00%</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="sse-conversion-runtime-analysis">
<span id="sse-conversion-span-pattern-usage"></span><h2><a class="toc-backref" href="#toc-entry-34">11.2&nbsp;&nbsp;&nbsp;SSE conversion &mdash; runtime analysis</a></h2>
<p>The lookup table is quite large: in the sample implementation single record
occupies 38 bytes, it gives almost 2,5 MiB. This section presents analysis of
<tt class="docutils literal">span_pattern</tt> usage during conversion of various inputs. Following parameters
are collated:</p>
<ol class="arabic simple">
<li>The number of <strong>different span patterns</strong> that appear during conversion.
This is explained in details below.</li>
<li>The number of <strong>CPU clocks per input byte</strong> (on Skylake); the results were
directly get from <a class="reference internal" href="#performance-comparison">Performance comparison</a>.</li>
<li>Both <strong>cache miss</strong> and <strong>branch miss</strong> ratios (the same Skylake); these
results were obtained by running separate <tt class="docutils literal"><span class="pre">bin/benchmark-hwevents</span></tt> tool.
The ratios should give a hint about real-workload penalties.</li>
</ol>
<p>During a conversion a histogram is build. The histogram contains <tt class="docutils literal">span_pattern</tt>
and the number of its occurrences; the histogram is sorted by the frequency.
Having such a sorted histogram it is easy to estimate how many <strong>distinct
patterns</strong> appear in most iterations.</p>
<p>Let's analyse sample, made up, histogram:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="34%" />
<col width="27%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">#</th>
<th class="head">span pattern</th>
<th class="head">frequency</th>
<th class="head">cumulative</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td>0xaaaa</td>
<td>1</td>
<td>1</td>
</tr>
<tr><td>2</td>
<td>0xbbbb</td>
<td>1</td>
<td>2</td>
</tr>
<tr><td>3</td>
<td>0x4444</td>
<td>1</td>
<td>3</td>
</tr>
<tr><td>4</td>
<td>0xdddd</td>
<td>1</td>
<td>4</td>
</tr>
<tr><td>5</td>
<td>0xeeee</td>
<td>2</td>
<td>6</td>
</tr>
<tr><td>6</td>
<td>0xffff</td>
<td>2</td>
<td>8</td>
</tr>
<tr><td>7</td>
<td>0x1111</td>
<td>3</td>
<td>11</td>
</tr>
<tr><td>8</td>
<td>0x3333</td>
<td>5</td>
<td>16</td>
</tr>
<tr><td>9</td>
<td>0x5555</td>
<td>10</td>
<td>26</td>
</tr>
<tr><td>10</td>
<td>0x7777</td>
<td>17</td>
<td>43</td>
</tr>
</tbody>
</table>
<p>There are <strong>10</strong> different patterns that were used in <strong>43</strong> loops. We can read
from the table that in 1/4 of iterations (11 of 43) were used even seven
patterns. Most of processing uses just three patterns. It means that only a
small portion of the large lookup is actually touched.</p>
<p>The tables in following sections have got data processed in this way. Each column
contains number of distinct patterns that take part in given percentage of the
iterations (25%, 50%, 75%, 95% and all, 100%).</p>
<p>The results for various input sizes are available in the <a class="reference external" href="https://github.com/WojciechMula/parsing-int-series/tree/master/experiments/runtime-comparison/">repository</a>, below
are shown only 4kB and 64kB inputs.</p>
<div class="section" id="input-size-4-096-bytes">
<h3><a class="toc-backref" href="#toc-entry-35">11.2.1&nbsp;&nbsp;&nbsp;Input size 4,096 bytes</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="4%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="10%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">parameters</th>
<th class="head" colspan="5">distinct span masks count</th>
<th class="head" colspan="2">cycles per byte</th>
<th class="head" colspan="3">branches</th>
<th class="head" colspan="3">cache references</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">&lt; 25%</th>
<th class="head">&lt; 50%</th>
<th class="head">&lt; 75%</th>
<th class="head">&lt; 95%</th>
<th class="head">100%</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">taken</th>
<th class="head">mispredicted</th>
<th class="head">ratio</th>
<th class="head">count</th>
<th class="head">missed</th>
<th class="head">ratio</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, single separator character</td>
<td>32</td>
<td>44</td>
<td>50</td>
<td>52</td>
<td>53</td>
<td>3.095</td>
<td>3.165</td>
<td>26085</td>
<td>633</td>
<td>2.43%</td>
<td>1531</td>
<td>415</td>
<td>27.11%</td>
</tr>
<tr><td>2 digits, single separator character</td>
<td>12</td>
<td>16</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>3.305</td>
<td>3.400</td>
<td>25270</td>
<td>485</td>
<td>1.92%</td>
<td>1333</td>
<td>114</td>
<td>8.55%</td>
</tr>
<tr><td>3 digits, single separator character</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>2.533</td>
<td>2.584</td>
<td>21809</td>
<td>247</td>
<td>1.13%</td>
<td>954</td>
<td>63</td>
<td>6.60%</td>
</tr>
<tr><td>4 digits, single separator character</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>3.193</td>
<td>3.231</td>
<td>24145</td>
<td>336</td>
<td>1.39%</td>
<td>926</td>
<td>49</td>
<td>5.29%</td>
</tr>
<tr><td>5 digits, single separator character</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>2.648</td>
<td>2.680</td>
<td>20788</td>
<td>241</td>
<td>1.16%</td>
<td>1067</td>
<td>24</td>
<td>2.25%</td>
</tr>
<tr><td>6 digits, single separator character</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>2.312</td>
<td>2.347</td>
<td>18289</td>
<td>233</td>
<td>1.27%</td>
<td>915</td>
<td>19</td>
<td>2.08%</td>
</tr>
<tr><td>7 digits, single separator character</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4.121</td>
<td>4.167</td>
<td>25682</td>
<td>313</td>
<td>1.22%</td>
<td>780</td>
<td>6</td>
<td>0.77%</td>
</tr>
<tr><td>8 digits, single separator character</td>
<td>1</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5.495</td>
<td>5.592</td>
<td>44188</td>
<td>837</td>
<td>1.89%</td>
<td>836</td>
<td>25</td>
<td>2.99%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, single separator character</td>
<td>42</td>
<td>54</td>
<td>60</td>
<td>62</td>
<td>63</td>
<td>3.162</td>
<td>3.288</td>
<td>25992</td>
<td>619</td>
<td>2.38%</td>
<td>1618</td>
<td>334</td>
<td>20.64%</td>
</tr>
<tr><td>1 .. 2 digits, single separator character</td>
<td>71</td>
<td>102</td>
<td>118</td>
<td>126</td>
<td>128</td>
<td>3.201</td>
<td>3.268</td>
<td>26561</td>
<td>465</td>
<td>1.75%</td>
<td>2118</td>
<td>655</td>
<td>30.93%</td>
</tr>
<tr><td>1 .. 3 digits, single separator character</td>
<td>72</td>
<td>112</td>
<td>134</td>
<td>146</td>
<td>148</td>
<td>2.891</td>
<td>2.941</td>
<td>24393</td>
<td>514</td>
<td>2.11%</td>
<td>2522</td>
<td>663</td>
<td>26.29%</td>
</tr>
<tr><td>1 .. 4 digits, single separator character</td>
<td>87</td>
<td>135</td>
<td>159</td>
<td>170</td>
<td>172</td>
<td>3.398</td>
<td>3.463</td>
<td>25831</td>
<td>906</td>
<td>3.51%</td>
<td>2480</td>
<td>667</td>
<td>26.90%</td>
</tr>
<tr><td>1 .. 5 digits, single separator character</td>
<td>92</td>
<td>136</td>
<td>163</td>
<td>177</td>
<td>179</td>
<td>3.495</td>
<td>3.553</td>
<td>25865</td>
<td>806</td>
<td>3.12%</td>
<td>2509</td>
<td>548</td>
<td>21.84%</td>
</tr>
<tr><td>1 .. 6 digits, single separator character</td>
<td>90</td>
<td>144</td>
<td>168</td>
<td>178</td>
<td>180</td>
<td>3.494</td>
<td>3.557</td>
<td>24943</td>
<td>639</td>
<td>2.56%</td>
<td>2591</td>
<td>627</td>
<td>24.20%</td>
</tr>
<tr><td>1 .. 7 digits, single separator character</td>
<td>86</td>
<td>125</td>
<td>143</td>
<td>151</td>
<td>153</td>
<td>3.259</td>
<td>3.324</td>
<td>23730</td>
<td>579</td>
<td>2.44%</td>
<td>2137</td>
<td>476</td>
<td>22.27%</td>
</tr>
<tr><td>1 .. 8 digits, single separator character</td>
<td>95</td>
<td>135</td>
<td>157</td>
<td>166</td>
<td>167</td>
<td>3.828</td>
<td>3.894</td>
<td>28964</td>
<td>859</td>
<td>2.97%</td>
<td>2074</td>
<td>318</td>
<td>15.33%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, single separator character</td>
<td>76</td>
<td>133</td>
<td>161</td>
<td>174</td>
<td>176</td>
<td>3.218</td>
<td>3.264</td>
<td>25990</td>
<td>485</td>
<td>1.87%</td>
<td>2658</td>
<td>799</td>
<td>30.06%</td>
</tr>
<tr><td>max at 2 digit, single separator character</td>
<td>77</td>
<td>129</td>
<td>157</td>
<td>170</td>
<td>173</td>
<td>3.122</td>
<td>3.189</td>
<td>24951</td>
<td>686</td>
<td>2.75%</td>
<td>2803</td>
<td>455</td>
<td>16.23%</td>
</tr>
<tr><td>max at 3 digit, single separator character</td>
<td>76</td>
<td>103</td>
<td>115</td>
<td>120</td>
<td>122</td>
<td>3.192</td>
<td>3.246</td>
<td>24812</td>
<td>799</td>
<td>3.22%</td>
<td>3038</td>
<td>256</td>
<td>8.43%</td>
</tr>
<tr><td>max at 4 digit, single separator character</td>
<td>43</td>
<td>57</td>
<td>63</td>
<td>65</td>
<td>66</td>
<td>3.134</td>
<td>3.215</td>
<td>23754</td>
<td>414</td>
<td>1.74%</td>
<td>1650</td>
<td>106</td>
<td>6.42%</td>
</tr>
<tr><td>max at 5 digit, single separator character</td>
<td>32</td>
<td>38</td>
<td>41</td>
<td>43</td>
<td>44</td>
<td>2.822</td>
<td>2.875</td>
<td>21380</td>
<td>346</td>
<td>1.62%</td>
<td>1320</td>
<td>93</td>
<td>7.05%</td>
</tr>
<tr><td>max at 6 digit, single separator character</td>
<td>25</td>
<td>30</td>
<td>33</td>
<td>34</td>
<td>35</td>
<td>2.887</td>
<td>2.935</td>
<td>21765</td>
<td>496</td>
<td>2.28%</td>
<td>1223</td>
<td>79</td>
<td>6.46%</td>
</tr>
<tr><td>max at 7 digit, single separator character</td>
<td>20</td>
<td>22</td>
<td>24</td>
<td>24</td>
<td>25</td>
<td>3.921</td>
<td>3.983</td>
<td>29234</td>
<td>794</td>
<td>2.72%</td>
<td>1096</td>
<td>40</td>
<td>3.65%</td>
</tr>
<tr><td>max at 8 digit, single separator character</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>4.825</td>
<td>4.887</td>
<td>37274</td>
<td>1015</td>
<td>2.72%</td>
<td>944</td>
<td>44</td>
<td>4.66%</td>
</tr>
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, 1 .. 6 separator characters</td>
<td>65</td>
<td>131</td>
<td>197</td>
<td>223</td>
<td>227</td>
<td>3.331</td>
<td>3.404</td>
<td>18979</td>
<td>677</td>
<td>3.57%</td>
<td>3111</td>
<td>1581</td>
<td>50.82%</td>
</tr>
<tr><td>2 digits, 1 .. 6 separator characters</td>
<td>67</td>
<td>135</td>
<td>175</td>
<td>195</td>
<td>198</td>
<td>3.473</td>
<td>3.529</td>
<td>20588</td>
<td>799</td>
<td>3.88%</td>
<td>2858</td>
<td>1287</td>
<td>45.03%</td>
</tr>
<tr><td>3 digits, 1 .. 6 separator characters</td>
<td>68</td>
<td>119</td>
<td>147</td>
<td>157</td>
<td>158</td>
<td>2.747</td>
<td>2.806</td>
<td>18629</td>
<td>481</td>
<td>2.58%</td>
<td>2728</td>
<td>1150</td>
<td>42.16%</td>
</tr>
<tr><td>4 digits, 1 .. 6 separator characters</td>
<td>69</td>
<td>101</td>
<td>118</td>
<td>124</td>
<td>125</td>
<td>2.641</td>
<td>2.695</td>
<td>18672</td>
<td>488</td>
<td>2.61%</td>
<td>1919</td>
<td>613</td>
<td>31.94%</td>
</tr>
<tr><td>5 digits, 1 .. 6 separator characters</td>
<td>53</td>
<td>71</td>
<td>78</td>
<td>81</td>
<td>82</td>
<td>2.748</td>
<td>2.824</td>
<td>19009</td>
<td>530</td>
<td>2.79%</td>
<td>1638</td>
<td>372</td>
<td>22.71%</td>
</tr>
<tr><td>6 digits, 1 .. 6 separator characters</td>
<td>43</td>
<td>50</td>
<td>53</td>
<td>55</td>
<td>56</td>
<td>2.958</td>
<td>3.002</td>
<td>19989</td>
<td>450</td>
<td>2.25%</td>
<td>1304</td>
<td>208</td>
<td>15.95%</td>
</tr>
<tr><td>7 digits, 1 .. 6 separator characters</td>
<td>12</td>
<td>14</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>3.316</td>
<td>3.341</td>
<td>20881</td>
<td>300</td>
<td>1.44%</td>
<td>1058</td>
<td>52</td>
<td>4.91%</td>
</tr>
<tr><td>8 digits, 1 .. 6 separator characters</td>
<td>33</td>
<td>46</td>
<td>54</td>
<td>57</td>
<td>58</td>
<td>4.302</td>
<td>4.346</td>
<td>34811</td>
<td>728</td>
<td>2.09%</td>
<td>1377</td>
<td>206</td>
<td>14.96%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, 1 .. 6 separator characters</td>
<td>66</td>
<td>132</td>
<td>198</td>
<td>232</td>
<td>237</td>
<td>3.197</td>
<td>3.268</td>
<td>19319</td>
<td>685</td>
<td>3.55%</td>
<td>2972</td>
<td>1273</td>
<td>42.83%</td>
</tr>
<tr><td>1 .. 2 digits, 1 .. 6 separator characters</td>
<td>66</td>
<td>132</td>
<td>198</td>
<td>238</td>
<td>243</td>
<td>3.025</td>
<td>3.081</td>
<td>19752</td>
<td>842</td>
<td>4.26%</td>
<td>3186</td>
<td>1247</td>
<td>39.14%</td>
</tr>
<tr><td>1 .. 3 digits, 1 .. 6 separator characters</td>
<td>67</td>
<td>135</td>
<td>203</td>
<td>233</td>
<td>238</td>
<td>3.070</td>
<td>3.150</td>
<td>19453</td>
<td>743</td>
<td>3.82%</td>
<td>3357</td>
<td>1216</td>
<td>36.22%</td>
</tr>
<tr><td>1 .. 4 digits, 1 .. 6 separator characters</td>
<td>70</td>
<td>140</td>
<td>210</td>
<td>250</td>
<td>256</td>
<td>3.390</td>
<td>3.477</td>
<td>19640</td>
<td>897</td>
<td>4.57%</td>
<td>3586</td>
<td>1226</td>
<td>34.19%</td>
</tr>
<tr><td>1 .. 5 digits, 1 .. 6 separator characters</td>
<td>71</td>
<td>142</td>
<td>213</td>
<td>242</td>
<td>247</td>
<td>3.338</td>
<td>3.401</td>
<td>19580</td>
<td>823</td>
<td>4.20%</td>
<td>3170</td>
<td>940</td>
<td>29.65%</td>
</tr>
<tr><td>1 .. 6 digits, 1 .. 6 separator characters</td>
<td>71</td>
<td>143</td>
<td>207</td>
<td>233</td>
<td>237</td>
<td>3.288</td>
<td>3.375</td>
<td>19457</td>
<td>785</td>
<td>4.03%</td>
<td>2916</td>
<td>807</td>
<td>27.67%</td>
</tr>
<tr><td>1 .. 7 digits, 1 .. 6 separator characters</td>
<td>74</td>
<td>148</td>
<td>208</td>
<td>228</td>
<td>230</td>
<td>3.304</td>
<td>3.375</td>
<td>19268</td>
<td>761</td>
<td>3.95%</td>
<td>2985</td>
<td>904</td>
<td>30.28%</td>
</tr>
<tr><td>1 .. 8 digits, 1 .. 6 separator characters</td>
<td>79</td>
<td>159</td>
<td>209</td>
<td>227</td>
<td>230</td>
<td>3.692</td>
<td>3.766</td>
<td>23045</td>
<td>881</td>
<td>3.82%</td>
<td>2946</td>
<td>727</td>
<td>24.68%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, 1 .. 6 separator characters</td>
<td>66</td>
<td>133</td>
<td>200</td>
<td>244</td>
<td>249</td>
<td>3.154</td>
<td>3.216</td>
<td>19347</td>
<td>900</td>
<td>4.65%</td>
<td>3515</td>
<td>1060</td>
<td>30.16%</td>
</tr>
<tr><td>max at 2 digit, 1 .. 6 separator characters</td>
<td>67</td>
<td>135</td>
<td>203</td>
<td>241</td>
<td>246</td>
<td>3.155</td>
<td>3.229</td>
<td>19299</td>
<td>786</td>
<td>4.07%</td>
<td>3340</td>
<td>892</td>
<td>26.71%</td>
</tr>
<tr><td>max at 3 digit, 1 .. 6 separator characters</td>
<td>69</td>
<td>139</td>
<td>205</td>
<td>229</td>
<td>233</td>
<td>3.202</td>
<td>3.278</td>
<td>19382</td>
<td>804</td>
<td>4.15%</td>
<td>3188</td>
<td>661</td>
<td>20.73%</td>
</tr>
<tr><td>max at 4 digit, 1 .. 6 separator characters</td>
<td>70</td>
<td>141</td>
<td>180</td>
<td>198</td>
<td>201</td>
<td>2.914</td>
<td>2.978</td>
<td>18669</td>
<td>611</td>
<td>3.27%</td>
<td>2775</td>
<td>692</td>
<td>24.94%</td>
</tr>
<tr><td>max at 5 digit, 1 .. 6 separator characters</td>
<td>74</td>
<td>131</td>
<td>156</td>
<td>164</td>
<td>166</td>
<td>3.147</td>
<td>3.217</td>
<td>19276</td>
<td>586</td>
<td>3.04%</td>
<td>2291</td>
<td>552</td>
<td>24.09%</td>
</tr>
<tr><td>max at 6 digit, 1 .. 6 separator characters</td>
<td>70</td>
<td>93</td>
<td>101</td>
<td>105</td>
<td>106</td>
<td>3.196</td>
<td>3.257</td>
<td>20806</td>
<td>493</td>
<td>2.37%</td>
<td>1719</td>
<td>237</td>
<td>13.79%</td>
</tr>
<tr><td>max at 7 digit, 1 .. 6 separator characters</td>
<td>64</td>
<td>80</td>
<td>87</td>
<td>91</td>
<td>92</td>
<td>3.597</td>
<td>3.646</td>
<td>24974</td>
<td>622</td>
<td>2.49%</td>
<td>1599</td>
<td>251</td>
<td>15.70%</td>
</tr>
<tr><td>max at 8 digit, 1 .. 6 separator characters</td>
<td>56</td>
<td>74</td>
<td>82</td>
<td>87</td>
<td>88</td>
<td>3.994</td>
<td>4.055</td>
<td>29874</td>
<td>848</td>
<td>2.84%</td>
<td>1587</td>
<td>231</td>
<td>14.56%</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="input-size-65-536-bytes">
<h3><a class="toc-backref" href="#toc-entry-36">11.2.2&nbsp;&nbsp;&nbsp;Input size 65,536 bytes</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="4%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="10%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">parameters</th>
<th class="head" colspan="5">distinct span masks count</th>
<th class="head" colspan="2">cycles per byte</th>
<th class="head" colspan="3">branches</th>
<th class="head" colspan="3">cache references</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">&lt; 25%</th>
<th class="head">&lt; 50%</th>
<th class="head">&lt; 75%</th>
<th class="head">&lt; 95%</th>
<th class="head">100%</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">taken</th>
<th class="head">mispredicted</th>
<th class="head">ratio</th>
<th class="head">count</th>
<th class="head">missed</th>
<th class="head">ratio</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, single separator character</td>
<td>61</td>
<td>74</td>
<td>81</td>
<td>84</td>
<td>85</td>
<td>3.619</td>
<td>3.655</td>
<td>393175</td>
<td>6529</td>
<td>1.66%</td>
<td>13469</td>
<td>974</td>
<td>7.23%</td>
</tr>
<tr><td>2 digits, single separator character</td>
<td>13</td>
<td>17</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>3.727</td>
<td>3.754</td>
<td>374164</td>
<td>3451</td>
<td>0.92%</td>
<td>11212</td>
<td>286</td>
<td>2.55%</td>
</tr>
<tr><td>3 digits, single separator character</td>
<td>4</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>2.839</td>
<td>2.852</td>
<td>328065</td>
<td>829</td>
<td>0.25%</td>
<td>7539</td>
<td>101</td>
<td>1.34%</td>
</tr>
<tr><td>4 digits, single separator character</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>3.495</td>
<td>3.507</td>
<td>361605</td>
<td>2429</td>
<td>0.67%</td>
<td>7148</td>
<td>89</td>
<td>1.25%</td>
</tr>
<tr><td>5 digits, single separator character</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>2.921</td>
<td>2.935</td>
<td>313419</td>
<td>849</td>
<td>0.27%</td>
<td>7335</td>
<td>119</td>
<td>1.62%</td>
</tr>
<tr><td>6 digits, single separator character</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>2.545</td>
<td>2.555</td>
<td>272684</td>
<td>741</td>
<td>0.27%</td>
<td>8704</td>
<td>58</td>
<td>0.67%</td>
</tr>
<tr><td>7 digits, single separator character</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4.407</td>
<td>4.417</td>
<td>386099</td>
<td>2206</td>
<td>0.57%</td>
<td>5224</td>
<td>27</td>
<td>0.52%</td>
</tr>
<tr><td>8 digits, single separator character</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>7.094</td>
<td>7.135</td>
<td>666950</td>
<td>13453</td>
<td>2.02%</td>
<td>5192</td>
<td>75</td>
<td>1.44%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, single separator character</td>
<td>59</td>
<td>72</td>
<td>80</td>
<td>82</td>
<td>83</td>
<td>3.627</td>
<td>3.693</td>
<td>393231</td>
<td>6582</td>
<td>1.67%</td>
<td>14582</td>
<td>973</td>
<td>6.67%</td>
</tr>
<tr><td>1 .. 2 digits, single separator character</td>
<td>236</td>
<td>280</td>
<td>299</td>
<td>308</td>
<td>310</td>
<td>3.908</td>
<td>3.935</td>
<td>397134</td>
<td>5214</td>
<td>1.31%</td>
<td>19011</td>
<td>2176</td>
<td>11.45%</td>
</tr>
<tr><td>1 .. 3 digits, single separator character</td>
<td>355</td>
<td>420</td>
<td>450</td>
<td>466</td>
<td>469</td>
<td>3.565</td>
<td>3.590</td>
<td>361819</td>
<td>4669</td>
<td>1.29%</td>
<td>21347</td>
<td>1858</td>
<td>8.70%</td>
</tr>
<tr><td>1 .. 4 digits, single separator character</td>
<td>416</td>
<td>493</td>
<td>523</td>
<td>537</td>
<td>540</td>
<td>5.329</td>
<td>5.387</td>
<td>391117</td>
<td>12854</td>
<td>3.29%</td>
<td>24169</td>
<td>1621</td>
<td>6.71%</td>
</tr>
<tr><td>1 .. 5 digits, single separator character</td>
<td>444</td>
<td>510</td>
<td>543</td>
<td>556</td>
<td>558</td>
<td>5.270</td>
<td>5.328</td>
<td>390345</td>
<td>11393</td>
<td>2.92%</td>
<td>19020</td>
<td>1568</td>
<td>8.24%</td>
</tr>
<tr><td>1 .. 6 digits, single separator character</td>
<td>423</td>
<td>492</td>
<td>525</td>
<td>535</td>
<td>537</td>
<td>4.589</td>
<td>4.633</td>
<td>372174</td>
<td>7872</td>
<td>2.12%</td>
<td>19917</td>
<td>1282</td>
<td>6.44%</td>
</tr>
<tr><td>1 .. 7 digits, single separator character</td>
<td>392</td>
<td>462</td>
<td>481</td>
<td>491</td>
<td>493</td>
<td>4.174</td>
<td>4.218</td>
<td>355907</td>
<td>6263</td>
<td>1.76%</td>
<td>15979</td>
<td>949</td>
<td>5.94%</td>
</tr>
<tr><td>1 .. 8 digits, single separator character</td>
<td>519</td>
<td>598</td>
<td>620</td>
<td>630</td>
<td>631</td>
<td>5.217</td>
<td>5.273</td>
<td>423108</td>
<td>11289</td>
<td>2.67%</td>
<td>16635</td>
<td>695</td>
<td>4.18%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, single separator character</td>
<td>481</td>
<td>587</td>
<td>630</td>
<td>645</td>
<td>648</td>
<td>4.150</td>
<td>4.189</td>
<td>395482</td>
<td>6382</td>
<td>1.61%</td>
<td>25467</td>
<td>1620</td>
<td>6.36%</td>
</tr>
<tr><td>max at 2 digit, single separator character</td>
<td>454</td>
<td>534</td>
<td>570</td>
<td>586</td>
<td>589</td>
<td>4.104</td>
<td>4.143</td>
<td>371930</td>
<td>6882</td>
<td>1.85%</td>
<td>25775</td>
<td>739</td>
<td>2.87%</td>
</tr>
<tr><td>max at 3 digit, single separator character</td>
<td>300</td>
<td>330</td>
<td>344</td>
<td>350</td>
<td>352</td>
<td>4.990</td>
<td>5.050</td>
<td>375961</td>
<td>11571</td>
<td>3.08%</td>
<td>15877</td>
<td>351</td>
<td>2.21%</td>
</tr>
<tr><td>max at 4 digit, single separator character</td>
<td>132</td>
<td>147</td>
<td>153</td>
<td>155</td>
<td>156</td>
<td>3.760</td>
<td>3.814</td>
<td>356129</td>
<td>4522</td>
<td>1.27%</td>
<td>10634</td>
<td>220</td>
<td>2.07%</td>
</tr>
<tr><td>max at 5 digit, single separator character</td>
<td>84</td>
<td>90</td>
<td>93</td>
<td>95</td>
<td>96</td>
<td>3.031</td>
<td>3.045</td>
<td>318232</td>
<td>1548</td>
<td>0.49%</td>
<td>8123</td>
<td>177</td>
<td>2.18%</td>
</tr>
<tr><td>max at 6 digit, single separator character</td>
<td>54</td>
<td>59</td>
<td>62</td>
<td>64</td>
<td>65</td>
<td>3.479</td>
<td>3.499</td>
<td>328097</td>
<td>6041</td>
<td>1.84%</td>
<td>8491</td>
<td>366</td>
<td>4.31%</td>
</tr>
<tr><td>max at 7 digit, single separator character</td>
<td>36</td>
<td>39</td>
<td>41</td>
<td>41</td>
<td>42</td>
<td>5.520</td>
<td>5.560</td>
<td>444157</td>
<td>11932</td>
<td>2.69%</td>
<td>5814</td>
<td>124</td>
<td>2.13%</td>
</tr>
<tr><td>max at 8 digit, single separator character</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>6.897</td>
<td>6.946</td>
<td>562307</td>
<td>15610</td>
<td>2.78%</td>
<td>5449</td>
<td>120</td>
<td>2.20%</td>
</tr>
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, 1 .. 6 separator characters</td>
<td>1052</td>
<td>1626</td>
<td>1870</td>
<td>1950</td>
<td>1958</td>
<td>4.371</td>
<td>4.408</td>
<td>280108</td>
<td>7580</td>
<td>2.71%</td>
<td>34860</td>
<td>8289</td>
<td>23.78%</td>
</tr>
<tr><td>2 digits, 1 .. 6 separator characters</td>
<td>693</td>
<td>909</td>
<td>995</td>
<td>1026</td>
<td>1029</td>
<td>5.044</td>
<td>5.108</td>
<td>308039</td>
<td>12071</td>
<td>3.92%</td>
<td>26297</td>
<td>4481</td>
<td>17.04%</td>
</tr>
<tr><td>3 digits, 1 .. 6 separator characters</td>
<td>354</td>
<td>438</td>
<td>480</td>
<td>494</td>
<td>496</td>
<td>3.334</td>
<td>3.358</td>
<td>273155</td>
<td>3865</td>
<td>1.41%</td>
<td>17568</td>
<td>2647</td>
<td>15.07%</td>
</tr>
<tr><td>4 digits, 1 .. 6 separator characters</td>
<td>177</td>
<td>224</td>
<td>246</td>
<td>252</td>
<td>254</td>
<td>3.311</td>
<td>3.335</td>
<td>277306</td>
<td>4944</td>
<td>1.78%</td>
<td>10967</td>
<td>1361</td>
<td>12.41%</td>
</tr>
<tr><td>5 digits, 1 .. 6 separator characters</td>
<td>100</td>
<td>126</td>
<td>134</td>
<td>137</td>
<td>138</td>
<td>3.648</td>
<td>3.677</td>
<td>284172</td>
<td>7099</td>
<td>2.50%</td>
<td>7727</td>
<td>742</td>
<td>9.60%</td>
</tr>
<tr><td>6 digits, 1 .. 6 separator characters</td>
<td>69</td>
<td>77</td>
<td>80</td>
<td>82</td>
<td>83</td>
<td>3.675</td>
<td>3.703</td>
<td>297939</td>
<td>5210</td>
<td>1.75%</td>
<td>6470</td>
<td>402</td>
<td>6.21%</td>
</tr>
<tr><td>7 digits, 1 .. 6 separator characters</td>
<td>46</td>
<td>49</td>
<td>51</td>
<td>53</td>
<td>54</td>
<td>3.662</td>
<td>3.673</td>
<td>315611</td>
<td>2311</td>
<td>0.73%</td>
<td>6077</td>
<td>308</td>
<td>5.07%</td>
</tr>
<tr><td>8 digits, 1 .. 6 separator characters</td>
<td>30</td>
<td>45</td>
<td>54</td>
<td>58</td>
<td>59</td>
<td>5.735</td>
<td>5.782</td>
<td>532039</td>
<td>10908</td>
<td>2.05%</td>
<td>6292</td>
<td>438</td>
<td>6.96%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, 1 .. 6 separator characters</td>
<td>1053</td>
<td>1643</td>
<td>1896</td>
<td>1973</td>
<td>1981</td>
<td>4.364</td>
<td>4.396</td>
<td>279251</td>
<td>7676</td>
<td>2.75%</td>
<td>34478</td>
<td>6144</td>
<td>17.82%</td>
</tr>
<tr><td>1 .. 2 digits, 1 .. 6 separator characters</td>
<td>1066</td>
<td>1792</td>
<td>2104</td>
<td>2212</td>
<td>2221</td>
<td>5.090</td>
<td>5.154</td>
<td>288339</td>
<td>12133</td>
<td>4.21%</td>
<td>39995</td>
<td>5781</td>
<td>14.45%</td>
</tr>
<tr><td>1 .. 3 digits, 1 .. 6 separator characters</td>
<td>1084</td>
<td>1802</td>
<td>2120</td>
<td>2226</td>
<td>2236</td>
<td>4.974</td>
<td>5.031</td>
<td>286026</td>
<td>10029</td>
<td>3.51%</td>
<td>44877</td>
<td>5187</td>
<td>11.56%</td>
</tr>
<tr><td>1 .. 4 digits, 1 .. 6 separator characters</td>
<td>1120</td>
<td>1808</td>
<td>2084</td>
<td>2173</td>
<td>2182</td>
<td>5.332</td>
<td>5.395</td>
<td>287345</td>
<td>11700</td>
<td>4.07%</td>
<td>42918</td>
<td>3871</td>
<td>9.02%</td>
</tr>
<tr><td>1 .. 5 digits, 1 .. 6 separator characters</td>
<td>1141</td>
<td>1713</td>
<td>1959</td>
<td>2031</td>
<td>2039</td>
<td>5.078</td>
<td>5.153</td>
<td>287785</td>
<td>10589</td>
<td>3.68%</td>
<td>40253</td>
<td>2950</td>
<td>7.33%</td>
</tr>
<tr><td>1 .. 6 digits, 1 .. 6 separator characters</td>
<td>1142</td>
<td>1617</td>
<td>1803</td>
<td>1856</td>
<td>1860</td>
<td>4.888</td>
<td>4.960</td>
<td>286913</td>
<td>10124</td>
<td>3.53%</td>
<td>35625</td>
<td>2229</td>
<td>6.26%</td>
</tr>
<tr><td>1 .. 7 digits, 1 .. 6 separator characters</td>
<td>1091</td>
<td>1503</td>
<td>1646</td>
<td>1678</td>
<td>1681</td>
<td>4.970</td>
<td>5.033</td>
<td>287420</td>
<td>11059</td>
<td>3.85%</td>
<td>30932</td>
<td>3218</td>
<td>10.40%</td>
</tr>
<tr><td>1 .. 8 digits, 1 .. 6 separator characters</td>
<td>1109</td>
<td>1476</td>
<td>1598</td>
<td>1619</td>
<td>1622</td>
<td>5.650</td>
<td>5.711</td>
<td>339596</td>
<td>14223</td>
<td>4.19%</td>
<td>28870</td>
<td>2243</td>
<td>7.77%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, 1 .. 6 separator characters</td>
<td>1070</td>
<td>1975</td>
<td>2405</td>
<td>2551</td>
<td>2565</td>
<td>5.389</td>
<td>5.456</td>
<td>285670</td>
<td>12734</td>
<td>4.46%</td>
<td>46840</td>
<td>6140</td>
<td>13.11%</td>
</tr>
<tr><td>max at 2 digit, 1 .. 6 separator characters</td>
<td>1094</td>
<td>1862</td>
<td>2174</td>
<td>2283</td>
<td>2293</td>
<td>5.125</td>
<td>5.177</td>
<td>288202</td>
<td>10818</td>
<td>3.75%</td>
<td>43779</td>
<td>3228</td>
<td>7.37%</td>
</tr>
<tr><td>max at 3 digit, 1 .. 6 separator characters</td>
<td>1021</td>
<td>1440</td>
<td>1610</td>
<td>1666</td>
<td>1672</td>
<td>4.927</td>
<td>4.986</td>
<td>284545</td>
<td>10542</td>
<td>3.70%</td>
<td>34647</td>
<td>1690</td>
<td>4.88%</td>
</tr>
<tr><td>max at 4 digit, 1 .. 6 separator characters</td>
<td>715</td>
<td>905</td>
<td>985</td>
<td>1010</td>
<td>1013</td>
<td>4.072</td>
<td>4.129</td>
<td>280545</td>
<td>8310</td>
<td>2.96%</td>
<td>20920</td>
<td>931</td>
<td>4.45%</td>
</tr>
<tr><td>max at 5 digit, 1 .. 6 separator characters</td>
<td>445</td>
<td>534</td>
<td>567</td>
<td>575</td>
<td>577</td>
<td>4.127</td>
<td>4.167</td>
<td>286377</td>
<td>8569</td>
<td>2.99%</td>
<td>14319</td>
<td>651</td>
<td>4.55%</td>
</tr>
<tr><td>max at 6 digit, 1 .. 6 separator characters</td>
<td>296</td>
<td>336</td>
<td>346</td>
<td>351</td>
<td>352</td>
<td>4.025</td>
<td>4.054</td>
<td>312734</td>
<td>6394</td>
<td>2.04%</td>
<td>11762</td>
<td>402</td>
<td>3.42%</td>
</tr>
<tr><td>max at 7 digit, 1 .. 6 separator characters</td>
<td>185</td>
<td>207</td>
<td>214</td>
<td>219</td>
<td>220</td>
<td>4.481</td>
<td>4.520</td>
<td>376654</td>
<td>8042</td>
<td>2.14%</td>
<td>7924</td>
<td>452</td>
<td>5.70%</td>
</tr>
<tr><td>max at 8 digit, 1 .. 6 separator characters</td>
<td>110</td>
<td>133</td>
<td>141</td>
<td>146</td>
<td>148</td>
<td>5.532</td>
<td>5.576</td>
<td>448317</td>
<td>12621</td>
<td>2.82%</td>
<td>7779</td>
<td>821</td>
<td>10.55%</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="performance-comparison">
<h2><a class="toc-backref" href="#toc-entry-37">11.3&nbsp;&nbsp;&nbsp;Performance comparison</a></h2>
<div class="section" id="tested-procedures">
<h3><a class="toc-backref" href="#toc-entry-38">11.3.1&nbsp;&nbsp;&nbsp;Tested procedures</a></h3>
<p>Following procedures are tested:</p>
<ul class="simple">
<li><tt class="docutils literal">scalar</tt> &mdash; the hand-coded validating <a class="reference internal" href="#reference-implementation">scalar parser</a>;</li>
<li><tt class="docutils literal">scalar (std)</tt> &mdash; also the <a class="reference internal" href="#reference-implementation">hand-coded parser</a>,
but use only standard functions <tt class="docutils literal">strtol</tt> and <tt class="docutils literal">strspn</tt>;</li>
<li><tt class="docutils literal">scalar hybrid</tt> &mdash; the implementation of <a class="reference internal" href="#scalar-hybrid">Scalar hybrid</a>;</li>
<li><tt class="docutils literal">SSE</tt> &mdash; the implementation of the base SSE algorithm;</li>
<li><tt class="docutils literal">SSE (block)</tt> &mdash; the implementation of variant described in <a class="reference internal" href="#processing-larger-inputs">Processing
larger inputs</a></li>
<li><tt class="docutils literal">SSE (simplified)</tt> &mdash; the SSE variant with relaxed delimiters definition.</li>
</ul>
</div>
<div class="section" id="tests-setup">
<h3><a class="toc-backref" href="#toc-entry-39">11.3.2&nbsp;&nbsp;&nbsp;Tests setup</a></h3>
<p>There are two tests approaches:</p>
<ul>
<li><p class="first"><strong>Overall</strong>, where rather huge input data is parsed (a few megabytes) and
the wall clock is used to measure the time of the whole procedure. Procedures
are repeated several times (10, 100, 1000 or more), the <strong>minimum running
time</strong> is noted.</p>
<p>To run these tests type <tt class="docutils literal">make <span class="pre">report-overall.rst</span></tt>; the tests suite uses executable
<tt class="docutils literal">bin/benchmark</tt>.</p>
<p>The results from various computers are available in the <a class="reference external" href="https://github.com/WojciechMula/parsing-int-series/tree/master/experiments/overalltests/results/">repository</a>.</p>
<blockquote>
</blockquote>
</li>
<li><p class="first"><strong>Microbenchmarks</strong>, where small inputs are parsed and exact number of CPU
cycles is obtained. Procedures are also repeated many times (1000) and then
<strong>minumum</strong> and <strong>average</strong> cycles to process a single input byte are calculated.</p>
<p>To run these tests type <tt class="docutils literal">make microbenchmarks.rst</tt>; the tests suite uses
executable <tt class="docutils literal"><span class="pre">bin/benchmark-cpuclocks</span></tt>.</p>
<p>The all results from various computers are available in the <a class="reference external" href="https://github.com/WojciechMula/parsing-int-series/tree/master/experiments/microbenchmarks/results/">repository</a>,
below are only the measurements from the Skylake computer.</p>
<blockquote>
</blockquote>
</li>
</ul>
</div>
<div class="section" id="core-i7-results-1">
<span id="core-i7-results"></span><h3><a class="toc-backref" href="#toc-entry-40">11.3.3&nbsp;&nbsp;&nbsp;Core i7 results</a></h3>
<p>Compiler: GCC 7.3.0</p>
<p>CPU: Intel(R) Core(TM) i7-6700 CPU &#64; 3.40GHz</p>
<hr class="docutils" />
<p>The table below compares speedup to the reference procedure for various
input sizes and data distributions. Detailed measurements for each size and
different distribution parameters are presented in the subsequent sections.</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="17%" />
<col width="7%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" colspan="3">&nbsp;</th>
<th class="head" colspan="15">speedup over scalar procedure</th>
</tr>
<tr><th class="head" colspan="3">&nbsp;</th>
<th class="head" colspan="3">scalar (std)</th>
<th class="head" colspan="3">scalar (hybrid)</th>
<th class="head" colspan="3">SSE</th>
<th class="head" colspan="3">SSE (block)</th>
<th class="head" colspan="3">SSE (simplified)</th>
</tr>
<tr><th class="head">size [B]</th>
<th class="head">distribution</th>
<th class="head">samples</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">max</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">max</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">max</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">max</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">max</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1024</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.45</td>
<td>0.87</td>
<td>1.29</td>
<td>1.65</td>
<td>2.36</td>
<td>3.26</td>
<td>1.53</td>
<td>3.21</td>
<td>5.44</td>
<td>1.66</td>
<td>3.16</td>
<td>4.97</td>
<td>1.58</td>
<td>3.37</td>
<td>5.78</td>
</tr>
<tr><td>1024</td>
<td>Fixed length</td>
<td>16</td>
<td>0.42</td>
<td>0.87</td>
<td>1.29</td>
<td>1.63</td>
<td>2.41</td>
<td>3.53</td>
<td>1.28</td>
<td>3.32</td>
<td>5.23</td>
<td>1.47</td>
<td>3.30</td>
<td>5.05</td>
<td>1.30</td>
<td>3.54</td>
<td>5.79</td>
</tr>
<tr><td>1024</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.40</td>
<td>0.86</td>
<td>1.32</td>
<td>1.64</td>
<td>2.41</td>
<td>3.36</td>
<td>2.04</td>
<td>3.70</td>
<td>5.54</td>
<td>2.22</td>
<td>3.53</td>
<td>4.97</td>
<td>2.13</td>
<td>3.88</td>
<td>5.79</td>
</tr>
<tr><td>4096</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.39</td>
<td>0.69</td>
<td>1.24</td>
<td>1.69</td>
<td>3.01</td>
<td>4.67</td>
<td>1.91</td>
<td>4.56</td>
<td>7.21</td>
<td>2.13</td>
<td>4.88</td>
<td>7.84</td>
<td>2.01</td>
<td>4.77</td>
<td>7.68</td>
</tr>
<tr><td>4096</td>
<td>Fixed length</td>
<td>16</td>
<td>0.36</td>
<td>0.69</td>
<td>1.39</td>
<td>1.94</td>
<td>2.87</td>
<td>4.32</td>
<td>1.60</td>
<td>4.44</td>
<td>6.86</td>
<td>1.71</td>
<td>4.66</td>
<td>8.34</td>
<td>1.62</td>
<td>4.70</td>
<td>7.83</td>
</tr>
<tr><td>4096</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.43</td>
<td>0.78</td>
<td>1.38</td>
<td>2.07</td>
<td>3.24</td>
<td>4.55</td>
<td>3.19</td>
<td>5.33</td>
<td>7.40</td>
<td>3.36</td>
<td>5.61</td>
<td>7.87</td>
<td>3.27</td>
<td>5.61</td>
<td>7.79</td>
</tr>
<tr><td>65536</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.45</td>
<td>0.77</td>
<td>1.30</td>
<td>1.40</td>
<td>1.74</td>
<td>2.13</td>
<td>1.73</td>
<td>4.46</td>
<td>5.88</td>
<td>1.76</td>
<td>4.57</td>
<td>6.00</td>
<td>1.77</td>
<td>4.60</td>
<td>6.25</td>
</tr>
<tr><td>65536</td>
<td>Fixed length</td>
<td>16</td>
<td>0.40</td>
<td>0.75</td>
<td>1.36</td>
<td>1.55</td>
<td>1.87</td>
<td>2.37</td>
<td>1.46</td>
<td>4.68</td>
<td>6.72</td>
<td>1.48</td>
<td>5.00</td>
<td>7.31</td>
<td>1.50</td>
<td>4.95</td>
<td>7.53</td>
</tr>
<tr><td>65536</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.55</td>
<td>0.86</td>
<td>1.36</td>
<td>1.38</td>
<td>1.75</td>
<td>2.34</td>
<td>3.32</td>
<td>4.98</td>
<td>6.39</td>
<td>3.29</td>
<td>5.01</td>
<td>6.52</td>
<td>3.43</td>
<td>5.20</td>
<td>6.89</td>
</tr>
<tr><td>102400</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.46</td>
<td>0.77</td>
<td>1.26</td>
<td>1.38</td>
<td>1.71</td>
<td>2.03</td>
<td>1.78</td>
<td>4.28</td>
<td>5.66</td>
<td>1.81</td>
<td>4.44</td>
<td>5.81</td>
<td>1.82</td>
<td>4.42</td>
<td>6.00</td>
</tr>
<tr><td>102400</td>
<td>Fixed length</td>
<td>16</td>
<td>0.40</td>
<td>0.75</td>
<td>1.36</td>
<td>1.53</td>
<td>1.84</td>
<td>2.31</td>
<td>1.29</td>
<td>4.59</td>
<td>6.49</td>
<td>1.46</td>
<td>4.91</td>
<td>6.99</td>
<td>1.31</td>
<td>4.85</td>
<td>7.16</td>
</tr>
<tr><td>102400</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.54</td>
<td>0.86</td>
<td>1.38</td>
<td>1.35</td>
<td>1.71</td>
<td>2.32</td>
<td>3.22</td>
<td>4.78</td>
<td>6.38</td>
<td>3.21</td>
<td>4.83</td>
<td>6.43</td>
<td>3.31</td>
<td>4.97</td>
<td>6.85</td>
</tr>
</tbody>
</table>
<div class="section" id="input-size-4096-bytes">
<h4><a class="toc-backref" href="#toc-entry-41">11.3.3.1&nbsp;&nbsp;&nbsp;Input size 4096 bytes</a></h4>
<p><strong>Gaussian distribution (max at 8 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>8.782</td>
<td>9.103</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.874</td>
<td>23.586</td>
<td>0.38</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.005</td>
<td>5.148</td>
<td>1.75</td>
</tr>
<tr><td>SSE</td>
<td>4.898</td>
<td>4.974</td>
<td>1.79</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.603</td>
<td>4.651</td>
<td>1.91</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.687</td>
<td>4.730</td>
<td>1.87</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 8 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>12.729</td>
<td>13.130</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>17.501</td>
<td>18.150</td>
<td>0.73</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.067</td>
<td>4.273</td>
<td>3.13</td>
</tr>
<tr><td>SSE</td>
<td>4.002</td>
<td>4.069</td>
<td>3.18</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.903</td>
<td>3.945</td>
<td>3.26</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.914</td>
<td>3.970</td>
<td>3.25</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>8.836</td>
<td>9.191</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.365</td>
<td>24.139</td>
<td>0.38</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.104</td>
<td>5.250</td>
<td>1.73</td>
</tr>
<tr><td>SSE</td>
<td>4.129</td>
<td>4.195</td>
<td>2.14</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.476</td>
<td>3.518</td>
<td>2.54</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.975</td>
<td>4.039</td>
<td>2.22</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>13.646</td>
<td>14.115</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.029</td>
<td>18.596</td>
<td>0.76</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.042</td>
<td>4.274</td>
<td>3.38</td>
</tr>
<tr><td>SSE</td>
<td>3.591</td>
<td>3.644</td>
<td>3.80</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.294</td>
<td>3.334</td>
<td>4.14</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.431</td>
<td>3.481</td>
<td>3.98</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>9.434</td>
<td>9.852</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>24.766</td>
<td>25.547</td>
<td>0.38</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.571</td>
<td>5.728</td>
<td>1.69</td>
</tr>
<tr><td>SSE</td>
<td>2.833</td>
<td>2.882</td>
<td>3.33</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.977</td>
<td>3.024</td>
<td>3.17</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.738</td>
<td>2.786</td>
<td>3.45</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>14.200</td>
<td>14.750</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>17.992</td>
<td>18.563</td>
<td>0.79</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.091</td>
<td>4.330</td>
<td>3.47</td>
</tr>
<tr><td>SSE</td>
<td>3.207</td>
<td>3.266</td>
<td>4.43</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.885</td>
<td>2.932</td>
<td>4.92</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.058</td>
<td>3.113</td>
<td>4.64</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>10.384</td>
<td>10.864</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>25.763</td>
<td>26.495</td>
<td>0.40</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.102</td>
<td>6.273</td>
<td>1.70</td>
</tr>
<tr><td>SSE</td>
<td>2.786</td>
<td>2.827</td>
<td>3.73</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.710</td>
<td>2.744</td>
<td>3.83</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.699</td>
<td>2.752</td>
<td>3.85</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>15.168</td>
<td>15.622</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.088</td>
<td>18.872</td>
<td>0.84</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.244</td>
<td>4.442</td>
<td>3.57</td>
</tr>
<tr><td>SSE</td>
<td>3.023</td>
<td>3.096</td>
<td>5.02</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.864</td>
<td>2.934</td>
<td>5.30</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.908</td>
<td>2.984</td>
<td>5.22</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>18.091</td>
<td>18.877</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.484</td>
<td>35.258</td>
<td>0.52</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>7.037</td>
<td>7.275</td>
<td>2.57</td>
</tr>
<tr><td>SSE</td>
<td>3.160</td>
<td>3.213</td>
<td>5.72</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.282</td>
<td>3.352</td>
<td>5.51</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.120</td>
<td>3.194</td>
<td>5.80</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>21.390</td>
<td>22.112</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.566</td>
<td>19.088</td>
<td>1.15</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.160</td>
<td>5.286</td>
<td>4.15</td>
</tr>
<tr><td>SSE</td>
<td>3.067</td>
<td>3.126</td>
<td>6.97</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.904</td>
<td>2.963</td>
<td>7.37</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.961</td>
<td>3.022</td>
<td>7.22</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>11.966</td>
<td>12.550</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>26.982</td>
<td>27.705</td>
<td>0.44</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.896</td>
<td>6.082</td>
<td>2.03</td>
</tr>
<tr><td>SSE</td>
<td>3.234</td>
<td>3.284</td>
<td>3.70</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.026</td>
<td>3.074</td>
<td>3.95</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.117</td>
<td>3.183</td>
<td>3.84</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>16.371</td>
<td>16.967</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>17.832</td>
<td>18.445</td>
<td>0.92</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.173</td>
<td>4.395</td>
<td>3.92</td>
</tr>
<tr><td>SSE</td>
<td>2.909</td>
<td>3.001</td>
<td>5.63</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.760</td>
<td>2.813</td>
<td>5.93</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.848</td>
<td>2.908</td>
<td>5.75</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>13.280</td>
<td>13.948</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>29.238</td>
<td>30.157</td>
<td>0.45</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.225</td>
<td>6.450</td>
<td>2.13</td>
</tr>
<tr><td>SSE</td>
<td>3.225</td>
<td>3.309</td>
<td>4.12</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.963</td>
<td>3.012</td>
<td>4.48</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.238</td>
<td>3.286</td>
<td>4.10</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>18.193</td>
<td>18.831</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.642</td>
<td>19.287</td>
<td>0.98</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.119</td>
<td>4.246</td>
<td>4.42</td>
</tr>
<tr><td>SSE</td>
<td>3.126</td>
<td>3.190</td>
<td>5.82</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.016</td>
<td>3.090</td>
<td>6.03</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.000</td>
<td>3.048</td>
<td>6.06</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>15.942</td>
<td>16.733</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>32.551</td>
<td>33.334</td>
<td>0.49</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.372</td>
<td>6.605</td>
<td>2.50</td>
</tr>
<tr><td>SSE</td>
<td>3.130</td>
<td>3.190</td>
<td>5.09</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.041</td>
<td>3.121</td>
<td>5.24</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.020</td>
<td>3.082</td>
<td>5.28</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>20.088</td>
<td>20.800</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.382</td>
<td>19.013</td>
<td>1.09</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.574</td>
<td>4.835</td>
<td>4.39</td>
</tr>
<tr><td>SSE</td>
<td>3.184</td>
<td>3.264</td>
<td>6.31</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.018</td>
<td>3.069</td>
<td>6.66</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.988</td>
<td>3.042</td>
<td>6.72</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>18.677</td>
<td>19.206</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.479</td>
<td>35.207</td>
<td>0.54</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>7.953</td>
<td>8.184</td>
<td>2.35</td>
</tr>
<tr><td>SSE</td>
<td>3.014</td>
<td>3.099</td>
<td>6.20</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.117</td>
<td>3.172</td>
<td>5.99</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.977</td>
<td>3.062</td>
<td>6.27</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>21.981</td>
<td>22.621</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>16.860</td>
<td>17.391</td>
<td>1.30</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.285</td>
<td>5.481</td>
<td>4.16</td>
</tr>
<tr><td>SSE</td>
<td>3.029</td>
<td>3.085</td>
<td>7.26</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.942</td>
<td>3.000</td>
<td>7.47</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.099</td>
<td>3.179</td>
<td>7.09</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>17.695</td>
<td>18.444</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.917</td>
<td>35.633</td>
<td>0.51</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>7.245</td>
<td>7.401</td>
<td>2.44</td>
</tr>
<tr><td>SSE</td>
<td>3.324</td>
<td>3.387</td>
<td>5.32</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.323</td>
<td>3.398</td>
<td>5.33</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.236</td>
<td>3.321</td>
<td>5.47</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>21.164</td>
<td>21.860</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.567</td>
<td>19.126</td>
<td>1.14</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.937</td>
<td>5.156</td>
<td>4.29</td>
</tr>
<tr><td>SSE</td>
<td>2.940</td>
<td>2.995</td>
<td>7.20</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.924</td>
<td>2.975</td>
<td>7.24</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.785</td>
<td>2.826</td>
<td>7.60</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>16.385</td>
<td>17.254</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>33.359</td>
<td>34.075</td>
<td>0.49</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.877</td>
<td>7.145</td>
<td>2.38</td>
</tr>
<tr><td>SSE</td>
<td>2.892</td>
<td>2.947</td>
<td>5.67</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.088</td>
<td>3.158</td>
<td>5.31</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.752</td>
<td>2.844</td>
<td>5.95</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>20.530</td>
<td>21.221</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.995</td>
<td>19.580</td>
<td>1.08</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.647</td>
<td>4.811</td>
<td>4.42</td>
</tr>
<tr><td>SSE</td>
<td>3.037</td>
<td>3.089</td>
<td>6.76</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.941</td>
<td>2.992</td>
<td>6.98</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.914</td>
<td>2.972</td>
<td>7.05</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>14.926</td>
<td>15.613</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>31.275</td>
<td>32.210</td>
<td>0.48</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.445</td>
<td>6.677</td>
<td>2.32</td>
</tr>
<tr><td>SSE</td>
<td>3.393</td>
<td>3.458</td>
<td>4.40</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.126</td>
<td>3.184</td>
<td>4.77</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.293</td>
<td>3.344</td>
<td>4.53</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>19.047</td>
<td>19.920</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>19.500</td>
<td>20.130</td>
<td>0.98</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.539</td>
<td>4.723</td>
<td>4.20</td>
</tr>
<tr><td>SSE</td>
<td>3.325</td>
<td>3.383</td>
<td>5.73</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.132</td>
<td>3.193</td>
<td>6.08</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.182</td>
<td>3.235</td>
<td>5.99</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>13.748</td>
<td>14.405</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>30.105</td>
<td>30.941</td>
<td>0.46</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.144</td>
<td>6.413</td>
<td>2.24</td>
</tr>
<tr><td>SSE</td>
<td>3.475</td>
<td>3.533</td>
<td>3.96</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.171</td>
<td>3.238</td>
<td>4.34</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.293</td>
<td>3.356</td>
<td>4.17</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>18.297</td>
<td>19.010</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>19.209</td>
<td>19.845</td>
<td>0.95</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.477</td>
<td>4.652</td>
<td>4.09</td>
</tr>
<tr><td>SSE</td>
<td>3.293</td>
<td>3.352</td>
<td>5.56</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.135</td>
<td>3.188</td>
<td>5.84</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.182</td>
<td>3.230</td>
<td>5.75</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>12.912</td>
<td>13.548</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>29.511</td>
<td>30.337</td>
<td>0.44</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.958</td>
<td>6.253</td>
<td>2.17</td>
</tr>
<tr><td>SSE</td>
<td>3.430</td>
<td>3.487</td>
<td>3.76</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.201</td>
<td>3.265</td>
<td>4.03</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.283</td>
<td>3.337</td>
<td>3.93</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>17.288</td>
<td>17.956</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>19.250</td>
<td>19.841</td>
<td>0.90</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.356</td>
<td>4.481</td>
<td>3.97</td>
</tr>
<tr><td>SSE</td>
<td>3.205</td>
<td>3.276</td>
<td>5.39</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.990</td>
<td>3.046</td>
<td>5.78</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.116</td>
<td>3.172</td>
<td>5.55</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>11.974</td>
<td>12.552</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>27.884</td>
<td>28.562</td>
<td>0.43</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.214</td>
<td>6.385</td>
<td>1.93</td>
</tr>
<tr><td>SSE</td>
<td>3.253</td>
<td>3.309</td>
<td>3.68</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.057</td>
<td>3.100</td>
<td>3.92</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.119</td>
<td>3.167</td>
<td>3.84</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>16.583</td>
<td>17.366</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.947</td>
<td>19.528</td>
<td>0.88</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.265</td>
<td>4.401</td>
<td>3.89</td>
</tr>
<tr><td>SSE</td>
<td>3.248</td>
<td>3.311</td>
<td>5.11</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.989</td>
<td>3.048</td>
<td>5.55</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.165</td>
<td>3.215</td>
<td>5.24</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>11.637</td>
<td>12.165</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>27.107</td>
<td>27.851</td>
<td>0.43</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.079</td>
<td>6.231</td>
<td>1.91</td>
</tr>
<tr><td>SSE</td>
<td>3.821</td>
<td>3.870</td>
<td>3.05</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.492</td>
<td>3.550</td>
<td>3.33</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.688</td>
<td>3.745</td>
<td>3.16</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>15.739</td>
<td>16.589</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.875</td>
<td>19.563</td>
<td>0.83</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.335</td>
<td>4.463</td>
<td>3.63</td>
</tr>
<tr><td>SSE</td>
<td>3.611</td>
<td>3.667</td>
<td>4.36</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.337</td>
<td>3.400</td>
<td>4.72</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.490</td>
<td>3.538</td>
<td>4.51</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="input-size-65536-bytes">
<h4><a class="toc-backref" href="#toc-entry-42">11.3.3.2&nbsp;&nbsp;&nbsp;Input size 65536 bytes</a></h4>
<p><strong>Gaussian distribution (max at 8 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>11.852</td>
<td>11.971</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>26.589</td>
<td>26.792</td>
<td>0.45</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>8.336</td>
<td>8.411</td>
<td>1.42</td>
</tr>
<tr><td>SSE</td>
<td>6.911</td>
<td>6.956</td>
<td>1.71</td>
</tr>
<tr><td>SSE (block)</td>
<td>6.921</td>
<td>6.990</td>
<td>1.71</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>6.757</td>
<td>6.802</td>
<td>1.75</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 8 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>17.008</td>
<td>17.110</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>21.492</td>
<td>21.653</td>
<td>0.79</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>8.722</td>
<td>8.800</td>
<td>1.95</td>
</tr>
<tr><td>SSE</td>
<td>5.650</td>
<td>5.692</td>
<td>3.01</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.679</td>
<td>5.733</td>
<td>2.99</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.426</td>
<td>5.470</td>
<td>3.13</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>12.818</td>
<td>12.929</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>27.335</td>
<td>27.609</td>
<td>0.47</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>9.246</td>
<td>9.315</td>
<td>1.39</td>
</tr>
<tr><td>SSE</td>
<td>5.513</td>
<td>5.542</td>
<td>2.33</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.259</td>
<td>5.296</td>
<td>2.44</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.364</td>
<td>5.405</td>
<td>2.39</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>17.978</td>
<td>18.119</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>21.924</td>
<td>22.109</td>
<td>0.82</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>9.205</td>
<td>9.286</td>
<td>1.95</td>
</tr>
<tr><td>SSE</td>
<td>4.537</td>
<td>4.591</td>
<td>3.96</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.351</td>
<td>4.388</td>
<td>4.13</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.352</td>
<td>4.407</td>
<td>4.13</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>13.772</td>
<td>13.862</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>28.295</td>
<td>28.596</td>
<td>0.49</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.005</td>
<td>10.079</td>
<td>1.38</td>
</tr>
<tr><td>SSE</td>
<td>3.456</td>
<td>3.479</td>
<td>3.98</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.358</td>
<td>3.385</td>
<td>4.10</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.379</td>
<td>3.402</td>
<td>4.08</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>19.374</td>
<td>19.538</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.288</td>
<td>22.489</td>
<td>0.87</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>9.660</td>
<td>9.730</td>
<td>2.01</td>
</tr>
<tr><td>SSE</td>
<td>3.949</td>
<td>3.983</td>
<td>4.91</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.726</td>
<td>3.751</td>
<td>5.20</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.870</td>
<td>3.918</td>
<td>5.01</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>14.989</td>
<td>15.092</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>29.851</td>
<td>30.089</td>
<td>0.50</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.750</td>
<td>10.842</td>
<td>1.39</td>
</tr>
<tr><td>SSE</td>
<td>2.933</td>
<td>2.945</td>
<td>5.11</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.807</td>
<td>2.822</td>
<td>5.34</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.866</td>
<td>2.878</td>
<td>5.23</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>20.729</td>
<td>20.888</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.536</td>
<td>22.718</td>
<td>0.92</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.225</td>
<td>10.311</td>
<td>2.03</td>
</tr>
<tr><td>SSE</td>
<td>4.032</td>
<td>4.086</td>
<td>5.14</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.762</td>
<td>3.805</td>
<td>5.51</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.985</td>
<td>4.043</td>
<td>5.20</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>24.489</td>
<td>24.804</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>38.285</td>
<td>38.540</td>
<td>0.64</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>16.088</td>
<td>16.198</td>
<td>1.52</td>
</tr>
<tr><td>SSE</td>
<td>4.159</td>
<td>4.200</td>
<td>5.89</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.107</td>
<td>4.142</td>
<td>5.96</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.213</td>
<td>4.250</td>
<td>5.81</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>28.265</td>
<td>28.549</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.648</td>
<td>22.767</td>
<td>1.25</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.524</td>
<td>13.622</td>
<td>2.09</td>
</tr>
<tr><td>SSE</td>
<td>5.201</td>
<td>5.271</td>
<td>5.43</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.452</td>
<td>5.513</td>
<td>5.18</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.057</td>
<td>5.128</td>
<td>5.59</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>16.687</td>
<td>16.790</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>31.153</td>
<td>31.398</td>
<td>0.54</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.835</td>
<td>11.913</td>
<td>1.41</td>
</tr>
<tr><td>SSE</td>
<td>3.590</td>
<td>3.614</td>
<td>4.65</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.466</td>
<td>3.489</td>
<td>4.81</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.496</td>
<td>3.525</td>
<td>4.77</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>22.284</td>
<td>22.529</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.476</td>
<td>22.653</td>
<td>0.99</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.916</td>
<td>11.005</td>
<td>2.04</td>
</tr>
<tr><td>SSE</td>
<td>4.032</td>
<td>4.081</td>
<td>5.53</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.859</td>
<td>3.898</td>
<td>5.77</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.953</td>
<td>3.991</td>
<td>5.64</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>19.121</td>
<td>19.291</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>32.927</td>
<td>33.175</td>
<td>0.58</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.629</td>
<td>13.718</td>
<td>1.40</td>
</tr>
<tr><td>SSE</td>
<td>4.848</td>
<td>4.901</td>
<td>3.94</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.780</td>
<td>4.825</td>
<td>4.00</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.760</td>
<td>4.812</td>
<td>4.02</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>24.281</td>
<td>24.611</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.530</td>
<td>22.703</td>
<td>1.08</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.920</td>
<td>12.185</td>
<td>2.04</td>
</tr>
<tr><td>SSE</td>
<td>4.756</td>
<td>4.823</td>
<td>5.11</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.781</td>
<td>4.835</td>
<td>5.08</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.607</td>
<td>4.664</td>
<td>5.27</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>22.188</td>
<td>22.377</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>36.158</td>
<td>36.461</td>
<td>0.61</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>15.232</td>
<td>15.326</td>
<td>1.46</td>
</tr>
<tr><td>SSE</td>
<td>4.058</td>
<td>4.108</td>
<td>5.47</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.952</td>
<td>3.990</td>
<td>5.61</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.061</td>
<td>4.110</td>
<td>5.46</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>26.633</td>
<td>26.932</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.723</td>
<td>22.869</td>
<td>1.17</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.162</td>
<td>13.267</td>
<td>2.02</td>
</tr>
<tr><td>SSE</td>
<td>5.097</td>
<td>5.174</td>
<td>5.23</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.160</td>
<td>5.224</td>
<td>5.16</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.941</td>
<td>5.008</td>
<td>5.39</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>22.963</td>
<td>23.203</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>37.465</td>
<td>37.718</td>
<td>0.61</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.951</td>
<td>14.058</td>
<td>1.65</td>
</tr>
<tr><td>SSE</td>
<td>3.389</td>
<td>3.447</td>
<td>6.78</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.593</td>
<td>3.643</td>
<td>6.39</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.324</td>
<td>3.394</td>
<td>6.91</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>27.116</td>
<td>27.518</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>20.621</td>
<td>20.742</td>
<td>1.31</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.908</td>
<td>12.006</td>
<td>2.28</td>
</tr>
<tr><td>SSE</td>
<td>4.128</td>
<td>4.167</td>
<td>6.57</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.179</td>
<td>4.214</td>
<td>6.49</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.105</td>
<td>4.136</td>
<td>6.61</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>23.675</td>
<td>24.277</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>37.914</td>
<td>38.203</td>
<td>0.62</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>15.327</td>
<td>15.432</td>
<td>1.54</td>
</tr>
<tr><td>SSE</td>
<td>3.896</td>
<td>3.933</td>
<td>6.08</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.870</td>
<td>3.901</td>
<td>6.12</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.913</td>
<td>3.952</td>
<td>6.05</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>27.811</td>
<td>28.100</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.433</td>
<td>22.537</td>
<td>1.24</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.003</td>
<td>13.113</td>
<td>2.14</td>
</tr>
<tr><td>SSE</td>
<td>4.947</td>
<td>5.018</td>
<td>5.62</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.201</td>
<td>5.265</td>
<td>5.35</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.807</td>
<td>4.872</td>
<td>5.79</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>22.512</td>
<td>22.742</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>36.660</td>
<td>36.946</td>
<td>0.61</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>15.263</td>
<td>15.362</td>
<td>1.47</td>
</tr>
<tr><td>SSE</td>
<td>3.474</td>
<td>3.507</td>
<td>6.48</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.456</td>
<td>3.480</td>
<td>6.51</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.528</td>
<td>3.561</td>
<td>6.38</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>26.841</td>
<td>27.155</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.874</td>
<td>23.042</td>
<td>1.17</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.184</td>
<td>13.284</td>
<td>2.04</td>
</tr>
<tr><td>SSE</td>
<td>4.815</td>
<td>4.876</td>
<td>5.57</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.952</td>
<td>5.022</td>
<td>5.42</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.699</td>
<td>4.753</td>
<td>5.71</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>21.123</td>
<td>21.329</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>35.205</td>
<td>35.486</td>
<td>0.60</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>14.756</td>
<td>14.856</td>
<td>1.43</td>
</tr>
<tr><td>SSE</td>
<td>5.217</td>
<td>5.283</td>
<td>4.05</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.053</td>
<td>5.106</td>
<td>4.18</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.163</td>
<td>5.227</td>
<td>4.09</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>25.877</td>
<td>26.129</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.132</td>
<td>23.285</td>
<td>1.12</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.984</td>
<td>13.084</td>
<td>1.99</td>
</tr>
<tr><td>SSE</td>
<td>5.211</td>
<td>5.291</td>
<td>4.97</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.283</td>
<td>5.356</td>
<td>4.90</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.048</td>
<td>5.116</td>
<td>5.13</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>19.780</td>
<td>19.978</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.247</td>
<td>34.511</td>
<td>0.58</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>14.274</td>
<td>14.371</td>
<td>1.39</td>
</tr>
<tr><td>SSE</td>
<td>5.099</td>
<td>5.160</td>
<td>3.88</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.920</td>
<td>4.975</td>
<td>4.02</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.053</td>
<td>5.099</td>
<td>3.91</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>24.749</td>
<td>25.022</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.269</td>
<td>23.468</td>
<td>1.06</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.627</td>
<td>12.718</td>
<td>1.96</td>
</tr>
<tr><td>SSE</td>
<td>5.046</td>
<td>5.111</td>
<td>4.90</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.999</td>
<td>5.126</td>
<td>4.95</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.903</td>
<td>4.954</td>
<td>5.05</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>18.656</td>
<td>18.857</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>33.362</td>
<td>33.565</td>
<td>0.56</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.643</td>
<td>13.742</td>
<td>1.37</td>
</tr>
<tr><td>SSE</td>
<td>4.433</td>
<td>4.479</td>
<td>4.21</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.282</td>
<td>4.319</td>
<td>4.36</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.356</td>
<td>4.399</td>
<td>4.28</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>23.975</td>
<td>24.304</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.495</td>
<td>23.653</td>
<td>1.02</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.269</td>
<td>12.358</td>
<td>1.95</td>
</tr>
<tr><td>SSE</td>
<td>4.883</td>
<td>4.947</td>
<td>4.91</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.715</td>
<td>4.770</td>
<td>5.08</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.778</td>
<td>4.825</td>
<td>5.02</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>17.632</td>
<td>17.799</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>32.227</td>
<td>32.509</td>
<td>0.55</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.079</td>
<td>13.177</td>
<td>1.35</td>
</tr>
<tr><td>SSE</td>
<td>4.114</td>
<td>4.158</td>
<td>4.29</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.976</td>
<td>4.028</td>
<td>4.43</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.032</td>
<td>4.069</td>
<td>4.37</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>22.878</td>
<td>23.116</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.259</td>
<td>23.512</td>
<td>0.98</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.010</td>
<td>12.113</td>
<td>1.90</td>
</tr>
<tr><td>SSE</td>
<td>4.926</td>
<td>4.986</td>
<td>4.64</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.670</td>
<td>4.735</td>
<td>4.90</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.836</td>
<td>4.892</td>
<td>4.73</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) &mdash; single separator character</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>16.753</td>
<td>16.923</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>31.309</td>
<td>31.604</td>
<td>0.54</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.522</td>
<td>12.615</td>
<td>1.34</td>
</tr>
<tr><td>SSE</td>
<td>5.181</td>
<td>5.232</td>
<td>3.23</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.263</td>
<td>5.313</td>
<td>3.18</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.089</td>
<td>5.133</td>
<td>3.29</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) &mdash; 1 .. 6 separator characters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="24%" />
<col width="24%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head" colspan="2">cycles per one input byte</th>
<th class="head">speed-up</th>
</tr>
<tr><th class="head">procedure</th>
<th class="head">min</th>
<th class="head">avg</th>
<th class="head">(min)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>22.070</td>
<td>22.400</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.084</td>
<td>23.272</td>
<td>0.96</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.689</td>
<td>11.777</td>
<td>1.89</td>
</tr>
<tr><td>SSE</td>
<td>5.666</td>
<td>5.729</td>
<td>3.90</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.833</td>
<td>5.886</td>
<td>3.78</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.493</td>
<td>5.553</td>
<td>4.02</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="section" id="conclusions">
<h1><a class="toc-backref" href="#toc-entry-43">12&nbsp;&nbsp;&nbsp;Conclusions</a></h1>
<ul>
<li><p class="first">The vectorized algorithm can be faster from 2 to 5 times than the scalar base.</p>
</li>
<li><p class="first">Although SSE speed-up depends on the count of digits in numbers, negative
impact is visible when the numbers are separated by more than one character.
This is caused by greater number of distinct <a class="reference internal" href="#sse-conversion-span-pattern-usage">span patterns</a>: for &quot;Gaussian distribution &mdash; max at
1 digit, single separator character&quot; the number of distinct patterns is
approximately <strong>1000</strong>; for the same distribution, but variable number of
separator, this value raises almost 28 times, to <strong>28000</strong>.</p>
<p>It means touching more memory locations within the lookup table and, as a
result, more cache misses. Also amount of branch mispredictions is greater
due to processing greater variety of patterns.</p>
</li>
<li><p class="first"><strong>Scalar hybrid</strong> performs surprisingly well, it can be even 2 times faster than
the baseline. However, its compile time is terribly long.</p>
</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#toc-entry-44">13&nbsp;&nbsp;&nbsp;Acknowledgements</a></h1>
<p><strong>Nathan Kurz</strong> and <strong>Daniel Lemire</strong> gave incredibly valuable feedback and
comments on text and experiments. Thank you!</p>
</div>
<div class="section" id="see-also">
<h1><a class="toc-backref" href="#toc-entry-45">14&nbsp;&nbsp;&nbsp;See also</a></h1>
<p>External links:</p>
<ul class="simple">
<li>Daniel Lemire <a class="reference external" href="https://lemire.me/blog/2017/01/20/how-quickly-can-you-remove-spaces-from-a-string/">How quickly can you remove spaces from a string?</a></li>
</ul>
<p id="internal-links">Internal links:</p>
<ul class="simple">
<li><a class="reference external" href="2014-10-15-parsing-decimal-numbers-part-2-sse.html">Parsing decimal numbers — part 1: SWAR</a></li>
<li><a class="reference external" href="2014-10-12-parsing-decimal-numbers-part-1-swar.html">Parsing decimal numbers — part 2: SSE</a></li>
<li><a class="reference external" href="2016-12-21-swar-digits-validate.html">SWAR check if all chars are digits</a></li>
</ul>
</div>
<div class="section" id="source-code">
<h1><a class="toc-backref" href="#toc-entry-46">15&nbsp;&nbsp;&nbsp;Source code</a></h1>
<p>Source code is available on <a class="reference external" href="https://github.com/WojciechMula/parsing-int-series">github</a>.</p>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2018-04-19-simd-parsing-int-sequences.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:41 GMT -->
</html>
