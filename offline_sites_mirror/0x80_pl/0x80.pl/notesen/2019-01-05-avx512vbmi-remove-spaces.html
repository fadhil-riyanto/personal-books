<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2019-01-05-avx512vbmi-remove-spaces.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:38 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>AVX512VBMI &mdash; remove spaces from text</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="avx512vbmi-remove-spaces-from-text">
<h1 class="title">AVX512VBMI &mdash; remove spaces from text</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2019-01-05</td>
</tr>
<tr class="updated-on field"><th class="docinfo-name">Updated on:</th><td class="field-body">2019-01-13 (added Zach Wegner implementation, compare with fast AVX2 code by Michael Howard)</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#scalar-code" id="toc-entry-2">Scalar code</a></li>
<li><a class="reference internal" href="#sse-solution" id="toc-entry-3">SSE solution</a></li>
<li><a class="reference internal" href="#avx512vbmi-solution" id="toc-entry-4">AVX512VBMI solution</a><ul>
<li><a class="reference internal" href="#algorithm-outline" id="toc-entry-5">Algorithm outline</a><ul>
<li><a class="reference internal" href="#single-whitspace" id="toc-entry-6">Single whitspace</a></li>
<li><a class="reference internal" href="#more-isolated-whitspaces" id="toc-entry-7">More isolated whitspaces</a></li>
<li><a class="reference internal" href="#runs-of-whitespaces" id="toc-entry-8">Runs of whitespaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="toc-entry-9">Implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pext-based-algorithm" id="toc-entry-10">PEXT-based algorithm</a></li>
<li><a class="reference internal" href="#avx512vbmi2-algorithm" id="toc-entry-11">AVX512VBMI2 algorithm</a></li>
<li><a class="reference internal" href="#avx512vbmi-evaluation" id="toc-entry-12">AVX512VBMI evaluation</a><ul>
<li><a class="reference internal" href="#microbenchmark" id="toc-entry-13">Microbenchmark</a></li>
<li><a class="reference internal" href="#performance-test" id="toc-entry-14">Performance test</a></li>
<li><a class="reference internal" href="#conclusions" id="toc-entry-15">Conclusions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements" id="toc-entry-16">Acknowledgements</a></li>
<li><a class="reference internal" href="#see-also" id="toc-entry-17">See also</a></li>
<li><a class="reference internal" href="#source-code" id="toc-entry-18">Source code</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>Removing spaces from a string is a common task in text processing. Instead
of removing single character we often want to remove all the white space
characters or the punctuation characters etc.</p>
<p>In this article I show an AVX512VBMI implementation. The algorithm is
not faster than the scalar code for all cases. But for many it can be
significantly faster, and what is more important, in tests on real-world
texts it performs better.</p>
<p>Update <strong>2019-01-13</strong>: this article pop up on twitter and <a class="reference external" href="https://twitter.com/trav_downs/status/1081760561082392576">Hacker News</a>
where provoked an incredibly fruitful discussion. <a class="reference external" href="https://news.ycombinator.com/item?id=18834741">Travis Downs</a>
noticed that branch mispredictions can be compensated by unrolling the loop
in the initial algorithm. <strong>Zach Wegner</strong> came up with an algorithm
which works in constant time by using <strong>PEXT</strong> instruction. <strong>Michael
Howard</strong> shared with his scalar and AVX2 variants of &quot;despacing&quot; procedure.
I'd like to thank all people discussed this topic both on HN and twitter.</p>
</div>
<div class="section" id="scalar-code">
<span id="scalar"></span><h1>Scalar code</h1>
<p>A scalar code which does this task is really simple:</p>
<pre class="code cpp literal-block">
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">remove_spaces__scalar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">' '</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'\r'</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">)</span><span class="w">
            </span><span class="k">continue</span><span class="p">;</span><span class="w">

        </span><span class="o">*</span><span class="n">dst</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">dst</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The function returns the pointer to last written character. This
implementation work correctly also for an in-place scenario, i.e.
when <tt class="docutils literal">src</tt> and <tt class="docutils literal">dst</tt> point the same memory area.</p>
</div>
<div class="section" id="sse-solution">
<h1>SSE solution</h1>
<p>In SSE code we process 16 bytes of input text. We determine a byte-mask
for characters that must be removed &mdash; usually with a comparison:</p>
<pre class="code cpp literal-block">
<span class="c1">// indices      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
</span><span class="w">
</span><span class="c1">// input    = ['a'|' '|'c'|'a'|'t'|' '|'p'|'l'|'a'|'y'|'s'|' '|'w'|'i'|'t'|'h']
// bytemask = [ 00| ff| 00| 00| 00| ff| 00| 00| 00| 00| 00| ff| 00| 00| 00| 00]
</span><span class="kr">__m128i</span><span class="w"> </span><span class="n">bytemask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">' '</span><span class="p">));</span>
</pre>
<p>This mask is converted into a 16-bit number using instruction <tt class="docutils literal">PMOVMSKB</tt>
(intrinsic function <tt class="docutils literal">_mm_movemask_epi8</tt>). The number is used to fetch
a byte pattern from <strong>a precompiled set</strong>, which is the argument to <tt class="docutils literal">PSHUFB</tt>
(<tt class="docutils literal">_mm_shuffle_epi8</tt>). The shuffle instruction allows to change order
of bytes in an SSE register &mdash; in our case it skip all spaces.</p>
<pre class="code cpp literal-block">
<span class="c1">// input    = ['a'|' '|'c'|'a'|'t'|' '|'p'|'l'|'a'|'y'|'s'|' '|'w'|'i'|'t'|'h']
// shuffle  = [ 0 | 2 | 3 | 4 | 6 | 7 | 8 | 9 | 10| 12| 13| 14| 15| -1| -1| -1]
</span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">mask</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">bytemask</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">shuffle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup_table</span><span class="p">[</span><span class="n">mask</span><span class="p">];</span><span class="w">

</span><span class="c1">// output   = ['a'|'c'|'a'|'t'|'p'|'l'|'a'|'y'|'s'|'w'|'i'|'t'|'h'| 0 | 0 | 0 ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">output</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">shuffle</span><span class="p">);</span><span class="w">

</span><span class="c1">// write all 16 bytes
</span><span class="n">_mm_store_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">dst</span><span class="p">),</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">
</span><span class="n">dst</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">popcnt</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</pre>
<p>Please note that in the example the last three indices are -1 and bytes past
compressed characters are zeros. In practise it doesn't matter what will be
there.</p>
<p>A clear drawback of the SSE solution is a huge lookup table. It has 65536
entries, each entry occupies 16 bytes, thus all data has exactly 1MB.</p>
</div>
<div class="section" id="avx512vbmi-solution">
<span id="avx512vbmi-naive"></span><h1>AVX512VBMI solution</h1>
<p>AVX512 operates on 64-byte register. The extension AVX512VBMI introduced
instruction <tt class="docutils literal">VPERMB</tt> (<tt class="docutils literal">_mm512_permutexvar_epi32</tt>) which similarly to
<tt class="docutils literal">PSHUFB</tt> can change order of bytes within an AVX512 register. For readers
who are not familiar with AVX512 nuances, the extension AVX512BW also defines
a byte shuffling instruction, but it operates on the register lanes (16-byte
subvectors) not the whole register.</p>
<p>Since AVX512 registers are so wide, use of a lookup table to fetch
shuffle patterns is simply impossible. Such table would occupy
<span class="math">2<sup>70</sup></span> bytes (<span class="math">2<sup>40</sup></span> is 1TB).</p>
<p>Instead of precalculating shuffle patterns, I propose to build them in
<strong>runtime</strong>.  This might seem not optimal on the first sight, but the
evaluation shows that it's not that bad.</p>
<div class="section" id="algorithm-outline">
<h2>Algorithm outline</h2>
<p>In AVX512 code we process 64-byte block. From the input vector we obtain a
64-bit mask for spaces, and then modify <strong>the shuffle vector</strong> using this
mask.</p>
<p>Initially the shuffle vector defines identity transformation, i.e.
if applied to the shuffle instruction it would copy all i-th input
bytes onto i-th output byte. Technically, the vector contains sequence
of bytes from 0 to 63.</p>
<div class="section" id="single-whitspace">
<h3>Single whitspace</h3>
<p>Let's assume there's exactly one space in the input vector,
say at the position 5; this will be our <strong>building block</strong> for the
rest of algorithm.</p>
<p>The shuffle vector:</p>
<pre class="literal-block">
shuffle = [0, 1, 2, 3, 4, 5, 6, 7, 8, ...]
                          ^
</pre>
<p>must become:</p>
<pre class="literal-block">
shuffle = [0, 1, 2, 3, 4, 6, 7, 8, 9, ...]
</pre>
<p>In other words we must perform following vector addition:</p>
<pre class="literal-block">
[0, 1, 2, 3, 4, 5, 6, 7, 8, ...]  +
[0, 0, 0, 0, 0, 1, 1, 1, 1, ...]
</pre>
<p>To do this we use a nice AVX512 facility, <strong>the masked add</strong>.</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">addmask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ??? */</span><span class="w">

</span><span class="n">shuffle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_add_epi8</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span><span class="w"> </span><span class="n">addmask</span><span class="p">,</span><span class="w"> </span><span class="n">shuffle</span><span class="p">,</span><span class="w"> </span><span class="n">ones</span><span class="p">);</span>
</pre>
<p>But how to cheaply calculate a proper mask? From mask <tt class="docutils literal"><span class="pre">000...000100000</span></tt>,
we have to get <tt class="docutils literal"><span class="pre">111...111100000</span></tt>, i.e. all bits above the set bit must
also be ones. The input mask has exactly one bit set; we subtract 1:</p>
<pre class="literal-block">
000...00100000 - 1 = 000...000011111
</pre>
<p>Now all bits below become 1, thus a bit negation yields the required
bit pattern. The full expression in C is like this:</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">addmask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre>
</div>
<div class="section" id="more-isolated-whitspaces">
<h3>More isolated whitspaces</h3>
<p>Now let's consider a more complex case. The input vector contains two
non-adjacent spaces. Assume the first one is at index 2, and the
second one at 5, thus the bit mask is <tt class="docutils literal"><span class="pre">000...000100100</span></tt>.</p>
<p>First we isolate the lowest bit set using expression <tt class="docutils literal">(x &amp; <span class="pre">-x)</span></tt>,
or <tt class="docutils literal">x &amp; (~x + 1)</tt>; on an AVX512VBMI CPU this expression should be
compiled into single instruction <tt class="docutils literal">BLSI</tt>:</p>
<pre class="code cpp literal-block">
<span class="c1">// mask  = 000...00000100100
// first = 000...00000000100
</span><span class="w">
</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">-</span><span class="n">mask</span><span class="p">);</span>
</pre>
<p>Since the mask <tt class="docutils literal">first</tt> has exactly one bit set, we use the procedure
described in the previous section to modify the shuffle pattern:</p>
<pre class="literal-block">
shuffle = [0, 1, 2, 3, 4, 5, 6, 7, 8, ...]
        + [0, 0, 1, 1, 1, 1, 1, 1, 1, ...]
        = [0, 1, 3, 4, 5, 6, 7, 8, 9, ...]
</pre>
<p>Now, we reset the first bit set from mask:</p>
<pre class="code cpp literal-block">
<span class="c1">// mask  = 000...00000100100
//       ^ 000...00000000100
//       = 000...00000100000
</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
</pre>
<p>And we can again extract the lowest bit set. Hold on, can we? No, it's not
possible as the shuffle pattern has just been changed, thus our initial
5th bit doesn't indicate the space character. Since one character
was skipped, the another space character is at index 4.</p>
<p>To reflect this change the mask must be <strong>shifted right by 1</strong>:</p>
<pre class="code cpp literal-block">
<span class="n">mask</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre>
<p>Now, we might safely extract the lowest bit set and modify the shuffle
pattern:</p>
<pre class="literal-block">
shuffle = [0, 1, 3, 4, 5, 6, 7, 8, 9, ...]
        + [0, 0, 0, 0, 1, 1, 1, 1, 1, ...]
        = [0, 1, 3, 4, 6, 7, 8, 9, 10, ...]
</pre>
<p>Obviously, if there are more ones in the mask, we need to carry on the above
procedure (extract bit, reset, shift). If mask becomes zero we stop
modifying the shuffle vector.</p>
</div>
<div class="section" id="runs-of-whitespaces">
<h3>Runs of whitespaces</h3>
<p>There's still one problem to solve, what if there are more spaces in a row.
For instance, the run has three ones starts at index 2: <tt class="docutils literal"><span class="pre">000...00011100</span></tt>.</p>
<p>We need to modify shuffle vector starting from index 2, but increment is 3
not 1:</p>
<pre class="literal-block">
shuffle = [0, 1, 2, 3, 4, 5, 6, 7, 8, ...]
        + [0, 0, 3, 3, 3, 3, 3, 3, 3, ...]
        = [0, 1, 5, 6, 7, 8, 9, 10, 11, ...]
</pre>
<p>Firstly, we must save the position (mask) for the first bit of run.
Then we need detect if the next set bit (a) continues the run, or
(b) starts a new one. If it's a continuation, we increment by one
a vector that holds run's length. If it's a new run, the shuffle
vector is modified with length vector.</p>
<pre class="code cpp literal-block">
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w">
</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">

</span><span class="kr">__m128i</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ones</span><span class="p">;</span><span class="w">

</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">-</span><span class="n">mask</span><span class="p">);</span><span class="w">
</span><span class="n">mask</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">

</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="cm">/* some condition*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">-</span><span class="n">mask</span><span class="p">);</span><span class="w">
    </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">curr</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="cm">/* run continues */</span><span class="p">)</span><span class="w">
        </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_add_epi8</span><span class="p">(</span><span class="n">increment</span><span class="p">,</span><span class="w"> </span><span class="n">ones</span><span class="p">);</span><span class="w">
    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="cm">/* finalize the previous run */</span><span class="w">
        </span><span class="n">shuffle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_add_epi8</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">shuffle</span><span class="p">,</span><span class="w"> </span><span class="n">increment</span><span class="p">);</span><span class="w">

        </span><span class="cm">/* initialize a new one */</span><span class="w">
        </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="w">
        </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ones</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>How to detect the continuation? We need to keep the previously extracted
mask, if it's <strong>equal</strong> to the currently extracted mask, it's a
continuation. Equality works because after each extraction the mask is
shifted.</p>
<p>Below is sequence of values which appear during analysing the second
bit of a run; as we see the mask <tt class="docutils literal">curr</tt> is equal to <tt class="docutils literal">prev</tt>.</p>
<pre class="code cpp literal-block">
<span class="c1">// mask = 000...00011100
// prev = 000...00000100
</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">-</span><span class="n">mask</span><span class="p">)</span><span class="w">
</span><span class="c1">// mask = 000...00001100
</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">curr</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="c1">// curr = 000...00000100
</span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">-</span><span class="n">mask</span><span class="p">);</span>
</pre>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<p>Below is an actual AVX512VBMI code which implements all the techniques
presented above.</p>
<pre class="code cpp literal-block">
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">remove_spaces__avx512vbmi</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">assert</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">

    </span><span class="c1">// values 0..63
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">no_gaps_indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_setr_epi32</span><span class="p">(</span><span class="w">
        </span><span class="mh">0x03020100</span><span class="p">,</span><span class="w"> </span><span class="mh">0x07060504</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0b0a0908</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0f0e0d0c</span><span class="p">,</span><span class="w">
        </span><span class="mh">0x13121110</span><span class="p">,</span><span class="w"> </span><span class="mh">0x17161514</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1b1a1918</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1f1e1d1c</span><span class="p">,</span><span class="w">
        </span><span class="mh">0x23222120</span><span class="p">,</span><span class="w"> </span><span class="mh">0x27262524</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2b2a2928</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2f2e2d2c</span><span class="p">,</span><span class="w">
        </span><span class="mh">0x33323130</span><span class="p">,</span><span class="w"> </span><span class="mh">0x37363534</span><span class="p">,</span><span class="w"> </span><span class="mh">0x3b3a3938</span><span class="p">,</span><span class="w"> </span><span class="mh">0x3f3e3d3c</span><span class="w">
    </span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">ones</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">NL</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">CR</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">'\r'</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span><span class="w">

    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">input</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="o">*</span><span class="p">)(</span><span class="n">src</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="n">__m512i</span><span class="w"> </span><span class="n">output</span><span class="p">;</span><span class="w">

        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi8_mask</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">spaces</span><span class="p">)</span><span class="w">
                      </span><span class="o">|</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi8_mask</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">NL</span><span class="p">)</span><span class="w">
                      </span><span class="o">|</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi8_mask</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">CR</span><span class="p">);</span><span class="w">

        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__builtin_popcountll</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">
            </span><span class="n">__m512i</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">no_gaps_indices</span><span class="p">;</span><span class="w">
            </span><span class="n">__m512i</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ones</span><span class="p">;</span><span class="w">

            </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w">
            </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">prev</span><span class="p">;</span><span class="w">

            </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">-</span><span class="n">mask</span><span class="p">);</span><span class="w">
            </span><span class="n">prev</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w">
            </span><span class="n">mask</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w">
            </span><span class="n">mask</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">

            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">-</span><span class="n">mask</span><span class="p">);</span><span class="w">
                </span><span class="n">mask</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">
                </span><span class="n">mask</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">

                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">curr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_add_epi8</span><span class="p">(</span><span class="n">increment</span><span class="p">,</span><span class="w"> </span><span class="n">ones</span><span class="p">);</span><span class="w">
                    </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_add_epi8</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">increment</span><span class="p">);</span><span class="w">

                    </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">
                    </span><span class="n">prev</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">
                    </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ones</span><span class="p">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_add_epi8</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">increment</span><span class="p">);</span><span class="w">

            </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutexvar_epi8</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">;</span><span class="w">
            </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="n">_mm512_storeu_si512</span><span class="p">((</span><span class="n">__m512i</span><span class="o">*</span><span class="p">)(</span><span class="n">dst</span><span class="p">),</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">
        </span><span class="n">dst</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">dst</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
</div>
<div class="section" id="pext-based-algorithm">
<span id="avx512vbmi-pext"></span><h1>PEXT-based algorithm</h1>
<p><a class="reference external" href="https://github.com/zwegner/">Zach Wegner</a> proposed to utilize instruction <tt class="docutils literal">PEXT</tt> (<tt class="docutils literal">_pext_u64</tt>)
which does compression of bits based on given mask. Suppose we have a binary
value:</p>
<pre class="literal-block">
v = 0011_1111_0111_0101
</pre>
<p>and mask of whitespace characters:</p>
<pre class="literal-block">
m = 0100_0001_0110_1000
</pre>
<p><tt class="docutils literal">PEXT(v, m)</tt> yields:</p>
<pre class="literal-block">
0011_1111_0111_0101
0100_0001_0110_1000
 0      1  11  0     -&gt; 0000_0000_0000_1110
                                     ^ ^^^^
                              bits extracted from v
</pre>
<p>The idea is to compress in this way individual bits of indices
(&quot;layers&quot;) and then rebuild numeric values from these bits.
Let's start with an example for 4-bit indices:</p>
<div class="asciidiag"><pre class="none">
input           = [&apos;a&apos;|&apos; &apos;|&apos;c&apos;|&apos;a&apos;|&apos;t&apos;|&apos; &apos;|&apos;p&apos;|&apos;l&apos;|&apos;a&apos;|&apos;y&apos;|&apos;s&apos;|&apos; &apos;|&apos;w&apos;|&apos;i&apos;|&apos;t&apos;|&apos;h&apos;]
index           =   0   1   2   3   4   5   6   7   8   9  10   11  12  13  14  15
whitespace mask =   0   1   0   0   0   1   0   0   0   0   0   1   0   0   0   0  = 0x0822

bits #0 of index    <span style="font-weight: bold; color: red">0</span>   <span style="color: gray">1</span>   <span style="font-weight: bold; color: red">0</span>   <span style="font-weight: bold; color: red">1</span>   <span style="font-weight: bold; color: red">0</span>   <span style="color: gray">1</span>   <span style="font-weight: bold; color: red">0</span>   <span style="font-weight: bold; color: red">1</span>   <span style="font-weight: bold; color: red">0</span>   <span style="font-weight: bold; color: red">1</span>   <span style="font-weight: bold; color: red">0</span>   <span style="color: gray">1</span>   <span style="font-weight: bold; color: red">0</span>   <span style="font-weight: bold; color: red">1</span>   <span style="font-weight: bold; color: red">0</span>   <span style="font-weight: bold; color: red">1</span>  = 0x5555
bits #1 of index    <span style="color: blue; font-weight: bold">0</span>   <span style="color: gray">0</span>   <span style="color: blue; font-weight: bold">1</span>   <span style="color: blue; font-weight: bold">1</span>   <span style="color: blue; font-weight: bold">0</span>   <span style="color: gray">0</span>   <span style="color: blue; font-weight: bold">1</span>   <span style="color: blue; font-weight: bold">1</span>   <span style="color: blue; font-weight: bold">0</span>   <span style="color: blue; font-weight: bold">0</span>   <span style="color: blue; font-weight: bold">1</span>   <span style="color: gray">1</span>   <span style="color: blue; font-weight: bold">0</span>   <span style="color: blue; font-weight: bold">0</span>   <span style="color: blue; font-weight: bold">1</span>   <span style="color: blue; font-weight: bold">1</span>  = 0xcccc
bits #2 of index    &lt;font color=&quot;magenta&quot;&gt;0&lt;/font&gt;   &lt;font color=&quot;gray&quot;&gt;0&lt;/font&gt;   &lt;font color=&quot;magenta&quot;&gt;0   0   1&lt;/font&gt;   &lt;font color=&quot;gray&quot;&gt;1&lt;/font&gt;   &lt;font color=&quot;magenta&quot;&gt;1   1   0   0   0&lt;/font&gt;   &lt;font color=&quot;gray&quot;&gt;0&lt;/font&gt;   &lt;font color=&quot;magenta&quot;&gt;1   1   1   1&lt;/font&gt;  = 0xf0f0
bits #2 of index    <span style="font-weight: bold; color: magenta">0</span>   <span style="color: gray">0</span>   <span style="font-weight: bold; color: magenta">0</span>   <span style="font-weight: bold; color: magenta">0</span>   <span style="font-weight: bold; color: magenta">1</span>   <span style="color: gray">1</span>   <span style="font-weight: bold; color: magenta">1</span>   <span style="font-weight: bold; color: magenta">1</span>   <span style="font-weight: bold; color: magenta">0</span>   <span style="font-weight: bold; color: magenta">0</span>   <span style="font-weight: bold; color: magenta">0</span>   <span style="color: gray">0</span>   <span style="font-weight: bold; color: magenta">1</span>   <span style="font-weight: bold; color: magenta">1</span>   <span style="font-weight: bold; color: magenta">1</span>   <span style="font-weight: bold; color: magenta">1</span>  = 0xf0f0
bits #3 of index    &lt;font color=&quot;green&quot;&gt;0&lt;/font&gt;   &lt;font color=&quot;gray&quot;&gt;0&lt;/font&gt;   &lt;font color=&quot;green&quot;&gt;0   0   0&lt;/font&gt;   &lt;font color=&quot;gray&quot;&gt;0&lt;/font&gt;   &lt;font color=&quot;green&quot;&gt;0   0   1   1   1&lt;/font&gt;   &lt;font color=&quot;gray&quot;&gt;1&lt;/font&gt;   &lt;font color=&quot;green&quot;&gt;1   1   1   1&lt;/font&gt;  = 0xff00
bits #3 of index    <span style="font-weight: bold; color: green">0</span>   <span style="color: gray">0</span>   <span style="font-weight: bold; color: green">0</span>   <span style="font-weight: bold; color: green">0</span>   <span style="font-weight: bold; color: green">0</span>   <span style="color: gray">0</span>   <span style="font-weight: bold; color: green">0</span>   <span style="font-weight: bold; color: green">0</span>   <span style="font-weight: bold; color: green">1</span>   <span style="font-weight: bold; color: green">1</span>   <span style="font-weight: bold; color: green">1</span>   <span style="color: gray">1</span>   <span style="font-weight: bold; color: green">1</span>   <span style="font-weight: bold; color: green">1</span>   <span style="font-weight: bold; color: green">1</span>   <span style="font-weight: bold; color: green">1</span>  = 0xff00</pre></div><p>Each bit &quot;layer&quot; is then compressed with <tt class="docutils literal">PEXT</tt> according to <strong>negation
of whitespace mask</strong>:</p>
<div class="asciidiag"><pre class="none">
mask = ~0x0822 = 0xf7dd;

b0 = _pext_u64(0x5555, mask) = <span style="font-weight: bold; color: red">0b1_0100_1010_0100</span> = 0x14a4
b1 = _pext_u64(0xcccc, mask) = <span style="color: blue; font-weight: bold">0b1_1001_0011_0110</span> = 0x1936
b2 = _pext_u64(0xf0f0, mask) = <span style="font-weight: bold; color: magenta">0b1_1110_0011_1000</span> = 0x1e38
b3 = _pext_u64(0xff00, mask) = <span style="font-weight: bold; color: green">0b1_1111_1100_0000</span> = 0x1fc0</pre></div><p>The last step is reconstruction of index values from individual bits. This is
done by <strong>masked add</strong> of bit weights, which are 1, 2, 4, 8, 16, 32 etc.</p>
<p>Below is an actual implementation. Please just note that in case of AVX512
indices are 6-bit numbers.</p>
<pre class="code cpp literal-block">
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">remove_spaces__avx512vbmi__zach</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">assert</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">NL</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">CR</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">'\r'</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span><span class="w">

    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">index_masks</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="mh">0xaaaaaaaaaaaaaaaa</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xcccccccccccccccc</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xf0f0f0f0f0f0f0f0</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xff00ff00ff00ff00</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xffff0000ffff0000</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xffffffff00000000</span><span class="p">,</span><span class="w">
    </span><span class="p">};</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">index_bits</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w">
        </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w">
        </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="w">
        </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span><span class="w">
        </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="w">
        </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span><span class="w">
    </span><span class="p">};</span><span class="w">

    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">input</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="o">*</span><span class="p">)(</span><span class="n">src</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="n">__m512i</span><span class="w"> </span><span class="n">output</span><span class="p">;</span><span class="w">

        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi8_mask</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">spaces</span><span class="p">)</span><span class="w">
                      </span><span class="o">|</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi8_mask</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">NL</span><span class="p">)</span><span class="w">
                      </span><span class="o">|</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi8_mask</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">CR</span><span class="p">);</span><span class="w">

        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__builtin_popcountll</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">
            </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="n">mask</span><span class="p">;</span><span class="w">
            </span><span class="n">__m512i</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set1_epi8</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_pext_u64</span><span class="p">(</span><span class="n">index_masks</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span><span class="w">
                </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_add_epi8</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">index_bits</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutexvar_epi8</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">;</span><span class="w">
            </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="n">_mm512_storeu_si512</span><span class="p">((</span><span class="n">__m512i</span><span class="o">*</span><span class="p">)(</span><span class="n">dst</span><span class="p">),</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">
        </span><span class="n">dst</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">dst</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx512vbmi2-algorithm">
<h1>AVX512VBMI2 algorithm</h1>
<p>The extension AVX512VBMI2 defines&nbsp;instruction <tt class="docutils literal">VPCOMPRESSB</tt>
(<tt class="docutils literal">_mm512_mask_compress_epi8</tt>) that performs the operation we just
programmed.</p>
</div>
<div class="section" id="avx512vbmi-evaluation">
<h1>AVX512VBMI evaluation</h1>
<p>The AVX512VBMI code shown above was compared with the scalar implementation.</p>
<p>CPU: Intel(R) Core(TM) i3-8121U CPU &#64; 2.20GHz</p>
<p>GCC: 7.3.1 20180303 (Red Hat 7.3.1-5)</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">comments</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a class="reference internal" href="#scalar">scalar</a></td>
<td>a naive implementation</td>
</tr>
<tr><td><a class="reference internal" href="#avx512vbmi-naive">AVX512VBMI</a></td>
<td>input-sensitive implementation with unrolling as suggested by Travis Downs</td>
</tr>
<tr><td><a class="reference internal" href="#avx512vbmi-pext">AVX512VBMI-pext</a></td>
<td>Zach Wegners' implementation</td>
</tr>
<tr><td>AVX2</td>
<td>a vector implementation provided by Michael Howard, which calculates
prefixed sum without use any precalculated tables (procedure <tt class="docutils literal">despace_avx2_vpermd</tt>);
it's a very neat procedure</td>
</tr>
</tbody>
</table>
<div class="section" id="microbenchmark">
<h2>Microbenchmark</h2>
<p>Microbenchmark tests removing spaces in a 64-byte block.</p>
<p>Number of spaces in a block varies from 1 to 64. There were
10 random patterns, and for each patter a tested procedure
was executed 10.000 times.</p>
<p>The microbenchmark reports two pairs of measurements
(in CPU cycles/input byte):</p>
<ul class="simple">
<li>10 times: average number over 10.000 runs;</li>
<li>10 times: the best time.</li>
</ul>
<img alt="&quot;Plot of measurements from Cannon Lake&quot;" class="align-center" src="2019-01-05-avx512vbmi-remove-spaces/cnl.png" />
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="8%" />
<col width="5%" />
<col width="8%" />
<col width="8%" />
<col width="5%" />
<col width="8%" />
<col width="8%" />
<col width="5%" />
<col width="8%" />
<col width="8%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">number of spaces</th>
<th class="head" colspan="3">scalar [cycles/byte]</th>
<th class="head" colspan="3">AVX512VBMI [cycles/byte]</th>
<th class="head" colspan="3">AVX512VBMI-pext [cycles/byte]</th>
<th class="head" colspan="3">AVX2 [cycles/byte]</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">avg (min)</th>
<th class="head">avg (max)</th>
<th class="head">best</th>
<th class="head">avg (min)</th>
<th class="head">avg (max)</th>
<th class="head">best</th>
<th class="head">avg (min)</th>
<th class="head">avg (max)</th>
<th class="head">best</th>
<th class="head">avg (min)</th>
<th class="head">avg (max)</th>
<th class="head">best</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td>1.129</td>
<td>1.517</td>
<td>1.062</td>
<td>0.227</td>
<td>1.178</td>
<td>0.156</td>
<td>0.428</td>
<td>0.479</td>
<td>0.375</td>
<td>0.359</td>
<td>0.367</td>
<td>0.281</td>
</tr>
<tr><td>2</td>
<td>1.134</td>
<td>1.608</td>
<td>1.062</td>
<td>0.264</td>
<td>0.273</td>
<td>0.188</td>
<td>0.423</td>
<td>0.439</td>
<td>0.375</td>
<td>0.359</td>
<td>0.369</td>
<td>0.281</td>
</tr>
<tr><td>3</td>
<td>1.136</td>
<td>1.352</td>
<td>1.062</td>
<td>0.310</td>
<td>0.313</td>
<td>0.250</td>
<td>0.425</td>
<td>0.440</td>
<td>0.375</td>
<td>0.357</td>
<td>0.428</td>
<td>0.281</td>
</tr>
<tr><td>4</td>
<td>1.132</td>
<td>1.574</td>
<td>1.062</td>
<td>0.345</td>
<td>0.361</td>
<td>0.281</td>
<td>0.428</td>
<td>0.478</td>
<td>0.375</td>
<td>0.358</td>
<td>0.363</td>
<td>0.281</td>
</tr>
<tr><td>5</td>
<td>1.130</td>
<td>1.349</td>
<td>1.062</td>
<td>0.388</td>
<td>0.436</td>
<td>0.344</td>
<td>0.425</td>
<td>0.474</td>
<td>0.375</td>
<td>0.359</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>6</td>
<td>1.129</td>
<td>1.143</td>
<td>1.062</td>
<td>0.430</td>
<td>0.450</td>
<td>0.375</td>
<td>0.426</td>
<td>0.478</td>
<td>0.375</td>
<td>0.358</td>
<td>0.408</td>
<td>0.281</td>
</tr>
<tr><td>7</td>
<td>1.137</td>
<td>1.979</td>
<td>1.062</td>
<td>0.470</td>
<td>0.501</td>
<td>0.406</td>
<td>0.428</td>
<td>0.454</td>
<td>0.375</td>
<td>0.359</td>
<td>0.413</td>
<td>0.281</td>
</tr>
<tr><td>8</td>
<td>1.134</td>
<td>1.330</td>
<td>1.062</td>
<td>0.482</td>
<td>0.514</td>
<td>0.438</td>
<td>0.429</td>
<td>0.476</td>
<td>0.375</td>
<td>0.358</td>
<td>0.419</td>
<td>0.281</td>
</tr>
<tr><td>9</td>
<td>1.131</td>
<td>1.436</td>
<td>1.062</td>
<td>0.596</td>
<td>0.700</td>
<td>0.531</td>
<td>0.427</td>
<td>0.436</td>
<td>0.375</td>
<td>0.358</td>
<td>0.366</td>
<td>0.281</td>
</tr>
<tr><td>10</td>
<td>1.145</td>
<td>1.255</td>
<td>1.094</td>
<td>0.641</td>
<td>0.766</td>
<td>0.594</td>
<td>0.424</td>
<td>0.447</td>
<td>0.375</td>
<td>0.358</td>
<td>0.365</td>
<td>0.281</td>
</tr>
<tr><td>11</td>
<td>1.139</td>
<td>1.349</td>
<td>1.062</td>
<td>0.671</td>
<td>0.801</td>
<td>0.594</td>
<td>0.426</td>
<td>1.148</td>
<td>0.375</td>
<td>0.357</td>
<td>0.366</td>
<td>0.281</td>
</tr>
<tr><td>12</td>
<td>1.139</td>
<td>1.188</td>
<td>1.062</td>
<td>0.737</td>
<td>0.838</td>
<td>0.656</td>
<td>0.426</td>
<td>0.445</td>
<td>0.375</td>
<td>0.358</td>
<td>0.410</td>
<td>0.281</td>
</tr>
<tr><td>13</td>
<td>1.151</td>
<td>1.188</td>
<td>1.094</td>
<td>0.817</td>
<td>0.899</td>
<td>0.719</td>
<td>0.423</td>
<td>0.439</td>
<td>0.375</td>
<td>0.357</td>
<td>0.893</td>
<td>0.281</td>
</tr>
<tr><td>14</td>
<td>1.154</td>
<td>1.235</td>
<td>1.094</td>
<td>0.838</td>
<td>0.972</td>
<td>0.781</td>
<td>0.423</td>
<td>0.475</td>
<td>0.375</td>
<td>0.358</td>
<td>0.369</td>
<td>0.281</td>
</tr>
<tr><td>15</td>
<td>1.145</td>
<td>1.240</td>
<td>1.062</td>
<td>0.849</td>
<td>1.598</td>
<td>0.781</td>
<td>0.427</td>
<td>0.488</td>
<td>0.375</td>
<td>0.359</td>
<td>0.366</td>
<td>0.281</td>
</tr>
<tr><td>16</td>
<td>1.156</td>
<td>1.450</td>
<td>1.094</td>
<td>0.969</td>
<td>1.043</td>
<td>0.906</td>
<td>0.428</td>
<td>0.446</td>
<td>0.375</td>
<td>0.358</td>
<td>0.367</td>
<td>0.281</td>
</tr>
<tr><td>17</td>
<td>1.144</td>
<td>1.236</td>
<td>1.062</td>
<td>0.938</td>
<td>1.077</td>
<td>0.875</td>
<td>0.427</td>
<td>0.442</td>
<td>0.375</td>
<td>0.359</td>
<td>0.365</td>
<td>0.281</td>
</tr>
<tr><td>18</td>
<td>1.176</td>
<td>1.239</td>
<td>1.094</td>
<td>1.012</td>
<td>1.147</td>
<td>0.938</td>
<td>0.425</td>
<td>0.438</td>
<td>0.375</td>
<td>0.360</td>
<td>0.370</td>
<td>0.281</td>
</tr>
<tr><td>19</td>
<td>1.163</td>
<td>1.712</td>
<td>1.094</td>
<td>1.062</td>
<td>1.978</td>
<td>0.969</td>
<td>0.431</td>
<td>0.440</td>
<td>0.375</td>
<td>0.360</td>
<td>0.386</td>
<td>0.281</td>
</tr>
<tr><td>20</td>
<td>1.175</td>
<td>1.270</td>
<td>1.125</td>
<td>1.108</td>
<td>1.210</td>
<td>1.031</td>
<td>0.429</td>
<td>0.442</td>
<td>0.375</td>
<td>0.361</td>
<td>0.364</td>
<td>0.281</td>
</tr>
<tr><td>21</td>
<td>1.188</td>
<td>2.201</td>
<td>1.125</td>
<td>1.176</td>
<td>1.329</td>
<td>1.094</td>
<td>0.426</td>
<td>0.443</td>
<td>0.375</td>
<td>0.359</td>
<td>0.373</td>
<td>0.281</td>
</tr>
<tr><td>22</td>
<td>1.163</td>
<td>1.370</td>
<td>1.094</td>
<td>1.215</td>
<td>1.314</td>
<td>1.125</td>
<td>0.427</td>
<td>0.478</td>
<td>0.375</td>
<td>0.360</td>
<td>0.413</td>
<td>0.281</td>
</tr>
<tr><td>23</td>
<td>1.187</td>
<td>1.374</td>
<td>1.125</td>
<td>1.250</td>
<td>1.349</td>
<td>1.156</td>
<td>0.427</td>
<td>0.443</td>
<td>0.375</td>
<td>0.360</td>
<td>0.374</td>
<td>0.281</td>
</tr>
<tr><td>24</td>
<td>1.172</td>
<td>1.342</td>
<td>1.094</td>
<td>1.317</td>
<td>1.429</td>
<td>1.219</td>
<td>0.429</td>
<td>0.439</td>
<td>0.375</td>
<td>0.360</td>
<td>0.416</td>
<td>0.281</td>
</tr>
<tr><td>25</td>
<td>1.195</td>
<td>1.318</td>
<td>1.125</td>
<td>1.328</td>
<td>1.460</td>
<td>1.219</td>
<td>0.426</td>
<td>0.528</td>
<td>0.375</td>
<td>0.359</td>
<td>0.369</td>
<td>0.281</td>
</tr>
<tr><td>26</td>
<td>1.201</td>
<td>1.354</td>
<td>1.125</td>
<td>1.322</td>
<td>1.464</td>
<td>1.250</td>
<td>0.427</td>
<td>0.482</td>
<td>0.375</td>
<td>0.359</td>
<td>0.364</td>
<td>0.281</td>
</tr>
<tr><td>27</td>
<td>1.197</td>
<td>1.425</td>
<td>1.125</td>
<td>1.418</td>
<td>1.558</td>
<td>1.344</td>
<td>0.427</td>
<td>0.446</td>
<td>0.375</td>
<td>0.360</td>
<td>0.750</td>
<td>0.281</td>
</tr>
<tr><td>28</td>
<td>1.196</td>
<td>1.454</td>
<td>1.125</td>
<td>1.453</td>
<td>1.591</td>
<td>1.344</td>
<td>0.427</td>
<td>0.437</td>
<td>0.375</td>
<td>0.359</td>
<td>0.917</td>
<td>0.281</td>
</tr>
<tr><td>29</td>
<td>1.190</td>
<td>1.385</td>
<td>1.125</td>
<td>1.514</td>
<td>1.602</td>
<td>1.469</td>
<td>0.426</td>
<td>0.441</td>
<td>0.375</td>
<td>0.360</td>
<td>0.365</td>
<td>0.281</td>
</tr>
<tr><td>30</td>
<td>1.243</td>
<td>1.400</td>
<td>1.156</td>
<td>1.518</td>
<td>1.659</td>
<td>1.438</td>
<td>0.428</td>
<td>0.441</td>
<td>0.375</td>
<td>0.355</td>
<td>0.373</td>
<td>0.281</td>
</tr>
<tr><td>31</td>
<td>1.192</td>
<td>1.345</td>
<td>1.125</td>
<td>1.555</td>
<td>1.705</td>
<td>1.469</td>
<td>0.430</td>
<td>0.440</td>
<td>0.375</td>
<td>0.360</td>
<td>0.370</td>
<td>0.281</td>
</tr>
<tr><td>32</td>
<td>1.215</td>
<td>1.392</td>
<td>1.125</td>
<td>1.637</td>
<td>1.702</td>
<td>1.500</td>
<td>0.428</td>
<td>0.485</td>
<td>0.375</td>
<td>0.360</td>
<td>0.412</td>
<td>0.281</td>
</tr>
<tr><td>33</td>
<td>1.229</td>
<td>1.384</td>
<td>1.125</td>
<td>1.674</td>
<td>1.735</td>
<td>1.562</td>
<td>0.427</td>
<td>0.436</td>
<td>0.375</td>
<td>0.358</td>
<td>0.410</td>
<td>0.281</td>
</tr>
<tr><td>34</td>
<td>1.247</td>
<td>1.397</td>
<td>1.156</td>
<td>1.716</td>
<td>1.826</td>
<td>1.594</td>
<td>0.431</td>
<td>0.440</td>
<td>0.375</td>
<td>0.356</td>
<td>0.388</td>
<td>0.281</td>
</tr>
<tr><td>35</td>
<td>1.225</td>
<td>2.084</td>
<td>1.156</td>
<td>1.720</td>
<td>1.906</td>
<td>1.625</td>
<td>0.430</td>
<td>0.444</td>
<td>0.375</td>
<td>0.359</td>
<td>0.367</td>
<td>0.281</td>
</tr>
<tr><td>36</td>
<td>1.232</td>
<td>1.857</td>
<td>1.156</td>
<td>1.786</td>
<td>2.128</td>
<td>1.656</td>
<td>0.426</td>
<td>0.439</td>
<td>0.375</td>
<td>0.358</td>
<td>0.375</td>
<td>0.281</td>
</tr>
<tr><td>37</td>
<td>1.225</td>
<td>1.407</td>
<td>1.125</td>
<td>1.839</td>
<td>1.905</td>
<td>1.750</td>
<td>0.427</td>
<td>0.488</td>
<td>0.375</td>
<td>0.358</td>
<td>0.366</td>
<td>0.281</td>
</tr>
<tr><td>38</td>
<td>1.226</td>
<td>1.435</td>
<td>1.156</td>
<td>1.869</td>
<td>2.434</td>
<td>1.750</td>
<td>0.427</td>
<td>0.485</td>
<td>0.375</td>
<td>0.358</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>39</td>
<td>1.223</td>
<td>1.497</td>
<td>1.156</td>
<td>1.849</td>
<td>2.038</td>
<td>1.750</td>
<td>0.428</td>
<td>0.436</td>
<td>0.375</td>
<td>0.359</td>
<td>0.371</td>
<td>0.281</td>
</tr>
<tr><td>40</td>
<td>1.237</td>
<td>1.357</td>
<td>1.156</td>
<td>1.934</td>
<td>2.104</td>
<td>1.750</td>
<td>0.427</td>
<td>0.477</td>
<td>0.375</td>
<td>0.359</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>41</td>
<td>1.222</td>
<td>1.447</td>
<td>1.156</td>
<td>1.956</td>
<td>2.060</td>
<td>1.875</td>
<td>0.427</td>
<td>0.443</td>
<td>0.375</td>
<td>0.362</td>
<td>0.364</td>
<td>0.281</td>
</tr>
<tr><td>42</td>
<td>1.254</td>
<td>1.360</td>
<td>1.156</td>
<td>1.988</td>
<td>2.357</td>
<td>1.906</td>
<td>0.428</td>
<td>0.443</td>
<td>0.375</td>
<td>0.359</td>
<td>0.366</td>
<td>0.281</td>
</tr>
<tr><td>43</td>
<td>1.241</td>
<td>1.391</td>
<td>1.188</td>
<td>2.033</td>
<td>2.155</td>
<td>1.906</td>
<td>0.427</td>
<td>0.488</td>
<td>0.375</td>
<td>0.360</td>
<td>0.367</td>
<td>0.281</td>
</tr>
<tr><td>44</td>
<td>1.241</td>
<td>1.370</td>
<td>1.188</td>
<td>2.057</td>
<td>2.177</td>
<td>1.969</td>
<td>0.427</td>
<td>1.012</td>
<td>0.375</td>
<td>0.360</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>45</td>
<td>1.257</td>
<td>1.381</td>
<td>1.188</td>
<td>2.100</td>
<td>2.274</td>
<td>1.938</td>
<td>0.427</td>
<td>0.439</td>
<td>0.375</td>
<td>0.362</td>
<td>0.954</td>
<td>0.281</td>
</tr>
<tr><td>46</td>
<td>1.266</td>
<td>1.350</td>
<td>1.188</td>
<td>2.178</td>
<td>3.041</td>
<td>2.062</td>
<td>0.430</td>
<td>0.440</td>
<td>0.375</td>
<td>0.359</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>47</td>
<td>1.260</td>
<td>1.328</td>
<td>1.188</td>
<td>2.196</td>
<td>2.299</td>
<td>2.062</td>
<td>0.427</td>
<td>0.443</td>
<td>0.375</td>
<td>0.360</td>
<td>0.369</td>
<td>0.281</td>
</tr>
<tr><td>48</td>
<td>1.285</td>
<td>1.337</td>
<td>1.219</td>
<td>2.203</td>
<td>2.532</td>
<td>2.062</td>
<td>0.428</td>
<td>0.490</td>
<td>0.375</td>
<td>0.361</td>
<td>0.367</td>
<td>0.281</td>
</tr>
<tr><td>49</td>
<td>1.286</td>
<td>1.682</td>
<td>1.219</td>
<td>2.250</td>
<td>2.605</td>
<td>2.156</td>
<td>0.426</td>
<td>0.435</td>
<td>0.375</td>
<td>0.355</td>
<td>0.370</td>
<td>0.281</td>
</tr>
<tr><td>50</td>
<td>1.297</td>
<td>1.330</td>
<td>1.219</td>
<td>2.295</td>
<td>2.605</td>
<td>2.156</td>
<td>0.429</td>
<td>0.440</td>
<td>0.375</td>
<td>0.357</td>
<td>0.363</td>
<td>0.281</td>
</tr>
<tr><td>51</td>
<td>1.303</td>
<td>1.335</td>
<td>1.250</td>
<td>2.343</td>
<td>2.447</td>
<td>2.219</td>
<td>0.430</td>
<td>0.439</td>
<td>0.375</td>
<td>0.360</td>
<td>0.415</td>
<td>0.281</td>
</tr>
<tr><td>52</td>
<td>1.315</td>
<td>1.640</td>
<td>1.250</td>
<td>2.383</td>
<td>2.871</td>
<td>2.250</td>
<td>0.426</td>
<td>0.480</td>
<td>0.375</td>
<td>0.358</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>53</td>
<td>1.319</td>
<td>1.606</td>
<td>1.250</td>
<td>2.401</td>
<td>2.604</td>
<td>2.281</td>
<td>0.428</td>
<td>0.439</td>
<td>0.375</td>
<td>0.358</td>
<td>0.369</td>
<td>0.281</td>
</tr>
<tr><td>54</td>
<td>1.342</td>
<td>1.653</td>
<td>1.281</td>
<td>2.438</td>
<td>2.840</td>
<td>2.312</td>
<td>0.430</td>
<td>0.480</td>
<td>0.375</td>
<td>0.358</td>
<td>0.370</td>
<td>0.281</td>
</tr>
<tr><td>55</td>
<td>1.342</td>
<td>1.387</td>
<td>1.281</td>
<td>2.470</td>
<td>3.336</td>
<td>2.375</td>
<td>0.426</td>
<td>0.441</td>
<td>0.375</td>
<td>0.359</td>
<td>0.414</td>
<td>0.281</td>
</tr>
<tr><td>56</td>
<td>1.362</td>
<td>1.716</td>
<td>1.281</td>
<td>2.556</td>
<td>2.893</td>
<td>2.438</td>
<td>0.429</td>
<td>0.437</td>
<td>0.375</td>
<td>0.361</td>
<td>0.379</td>
<td>0.281</td>
</tr>
<tr><td>57</td>
<td>1.364</td>
<td>1.619</td>
<td>1.312</td>
<td>2.573</td>
<td>2.875</td>
<td>2.406</td>
<td>0.428</td>
<td>0.441</td>
<td>0.375</td>
<td>0.362</td>
<td>0.370</td>
<td>0.281</td>
</tr>
<tr><td>58</td>
<td>1.386</td>
<td>2.069</td>
<td>1.312</td>
<td>2.665</td>
<td>3.150</td>
<td>2.562</td>
<td>0.428</td>
<td>0.436</td>
<td>0.375</td>
<td>0.358</td>
<td>0.365</td>
<td>0.281</td>
</tr>
<tr><td>59</td>
<td>1.384</td>
<td>1.743</td>
<td>1.312</td>
<td>2.677</td>
<td>2.954</td>
<td>2.531</td>
<td>0.429</td>
<td>0.440</td>
<td>0.375</td>
<td>0.358</td>
<td>0.370</td>
<td>0.281</td>
</tr>
<tr><td>60</td>
<td>1.411</td>
<td>1.747</td>
<td>1.344</td>
<td>2.911</td>
<td>3.152</td>
<td>2.781</td>
<td>0.428</td>
<td>0.439</td>
<td>0.375</td>
<td>0.358</td>
<td>0.370</td>
<td>0.281</td>
</tr>
<tr><td>61</td>
<td>1.417</td>
<td>1.761</td>
<td>1.344</td>
<td>2.929</td>
<td>3.240</td>
<td>2.750</td>
<td>0.426</td>
<td>0.483</td>
<td>0.375</td>
<td>0.358</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>62</td>
<td>1.416</td>
<td>2.010</td>
<td>1.344</td>
<td>2.745</td>
<td>3.615</td>
<td>2.656</td>
<td>0.427</td>
<td>0.437</td>
<td>0.375</td>
<td>0.358</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>63</td>
<td>1.453</td>
<td>2.195</td>
<td>1.375</td>
<td>3.046</td>
<td>3.357</td>
<td>2.688</td>
<td>0.427</td>
<td>0.440</td>
<td>0.375</td>
<td>0.359</td>
<td>0.368</td>
<td>0.281</td>
</tr>
<tr><td>64</td>
<td>1.646</td>
<td>1.654</td>
<td>1.594</td>
<td>3.107</td>
<td>3.208</td>
<td>2.938</td>
<td>0.429</td>
<td>0.443</td>
<td>0.375</td>
<td>0.359</td>
<td>0.407</td>
<td>0.281</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="performance-test">
<h2>Performance test</h2>
<p>In performance tests several text files were loaded into memory, then the tested
procedure removed spaces 10 time, saving result to a separate memory region.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">file</th>
<th class="head" colspan="2">scalar</th>
<th class="head" colspan="2">AVX512VBMI</th>
<th class="head" colspan="2">AVX512VBMI-pext</th>
<th class="head" colspan="2">AVX2</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">time [us]</th>
<th class="head">speed-up</th>
<th class="head">time [us]</th>
<th class="head">speed-up</th>
<th class="head">time [us]</th>
<th class="head">speed-up</th>
<th class="head">time [us]</th>
<th class="head">speed-up</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tom-sawyer.txt</td>
<td>978</td>
<td>&nbsp;</td>
<td>267</td>
<td>3.66</td>
<td>39</td>
<td>25.08</td>
<td>52</td>
<td>18.81</td>
</tr>
<tr><td>moby-dick.txt</td>
<td>2881</td>
<td>&nbsp;</td>
<td>742</td>
<td>3.88</td>
<td>118</td>
<td>24.42</td>
<td>156</td>
<td>18.47</td>
</tr>
<tr><td>sherlock.txt</td>
<td>1402</td>
<td>&nbsp;</td>
<td>376</td>
<td>3.73</td>
<td>55</td>
<td>25.49</td>
<td>72</td>
<td>19.47</td>
</tr>
<tr><td>census-income.data</td>
<td>123950</td>
<td>&nbsp;</td>
<td>46847</td>
<td>2.65</td>
<td>13690</td>
<td>9.05</td>
<td>14574</td>
<td>8.50</td>
</tr>
<tr><td>weather_sept_85.csv</td>
<td>74037</td>
<td>&nbsp;</td>
<td>44637</td>
<td>1.66</td>
<td>9866</td>
<td>7.50</td>
<td>10523</td>
<td>7.04</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">book</th>
<th class="head">file</th>
<th class="head">file size [B]</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><a class="reference external" href="http://www.gutenberg.org/ebooks/74">The Adventures of Tom Sawyer</a></td>
<td><tt class="docutils literal"><span class="pre">tom-sawyer.txt</span></tt></td>
<td>428,104</td>
</tr>
<tr><td><a class="reference external" href="http://www.gutenberg.org/ebooks/1661">The Adventures of Sherlock Holmes</a></td>
<td><tt class="docutils literal">sherlock.txt</tt></td>
<td>594,933</td>
</tr>
<tr><td><a class="reference external" href="http://www.gutenberg.org/ebooks/2701">Moby Dick</a></td>
<td><tt class="docutils literal"><span class="pre">moby-dick.txt</span></tt></td>
<td>1,276,201</td>
</tr>
<tr><td><a class="reference external" href="https://github.com/lemire/RealisticTabularDataSets/tree/master/census-income">census-income.data</a></td>
<td>&nbsp;</td>
<td>16,022,599</td>
</tr>
<tr><td><a class="reference external" href="https://github.com/lemire/RealisticTabularDataSets/tree/master/weather">weather_sept_85.csv</a></td>
<td>&nbsp;</td>
<td>75,137,158</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="conclusions">
<h2>Conclusions</h2>
<ul class="simple">
<li>Both AVX2 by Michael and AVX512VBMI by Zach work at <strong>constant time</strong>.</li>
<li>Although in microbenchmarks the AVX2 variant performs better than the
AVX512VBMI code, the real-world cases are handled better by the latter one.</li>
<li>When spaces occupy more than 1/3 of an AVX512 register, the scalar code
performs better than the naive vectorized counterpart.</li>
</ul>
</div>
</div>
<div class="section" id="acknowledgements">
<h1>Acknowledgements</h1>
<p>As always this work wouldn't be possible without <a class="reference external" href="https://lemire.me/">Daniel Lemire</a>, who gave
ma access to a Cannon Lake machine.</p>
</div>
<div class="section" id="see-also">
<h1>See also</h1>
<ul class="simple">
<li><a class="reference external" href="https://lemire.me/blog/2017/01/20/how-quickly-can-you-remove-spaces-from-a-string/">How quickly can you remove spaces from a string?</a> by Daniel Lemire</li>
</ul>
</div>
<div class="section" id="source-code">
<h1>Source code</h1>
<p>Source code is available on <a class="reference external" href="https://github.com/WojciechMula/toys/tree/master/avx512-remove-spaces">github</a>.</p>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2019-01-05-avx512vbmi-remove-spaces.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:39 GMT -->
</html>
