<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2023-05-06-avx512-conflict-detection.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:32 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>AVX-512 conflict detection without resolving conflicts</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="avx-512-conflict-detection-without-resolving-conflicts">
<h1 class="title">AVX-512 conflict detection without resolving conflicts</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2023-05-06</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#core-avx-512-instructions" id="toc-entry-2">Core AVX-512 instructions</a></li>
<li><a class="reference internal" href="#histogram" id="toc-entry-3">Histogram</a><ul>
<li><a class="reference internal" href="#reference-intel-algorithm" id="toc-entry-4">Reference Intel algorithm</a></li>
<li><a class="reference internal" href="#downsides-of-intel-approach" id="toc-entry-5">Downsides of Intel approach</a></li>
<li><a class="reference internal" href="#alternative-algorithm" id="toc-entry-6">Alternative algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#experiment-results" id="toc-entry-7">Experiment results</a></li>
<li><a class="reference internal" href="#source-code" id="toc-entry-8">Source code</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>One of the hardest problem in <a class="reference external" href="http://en.wikipedia.org/wiki/SIMD">SIMD</a> is dealing with non-continuous
data accesses, that appear pretty common. Data structures based on
indices, like graphs or trees, are a good example. CPU vendors
introduced instructions <strong>GATHER</strong> and <strong>SCATTER</strong> to address these needs.
A gather instruction builds a SIMD vector from N values loaded
from N addresses. A scatter instruction stores N values from a SIMD
vector at N addresses. Both instructions allow <strong>repeated</strong> indices.</p>
<p>Repeated indices are the real issue if an algorithm uses
the <strong>SCATTER</strong> &mdash; that is, it either sets or updates values. Then
we need to define how to handle repeated stores.
To solve that particular problem <a class="reference external" href="http://en.wikipedia.org/wiki/AVX-512">AVX-512</a> introduced
a complex instruction called <strong>conflict detection</strong>. The instruction
builds a vector containing masks that mark repeated values in the
input vector.</p>
<p>Intel proposed a pattern that uses the gather, scatter and conflict
detection instructions to efficiently handle repeated indices. It
is described in the <a class="reference external" href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">freely available</a> &quot;Intel® 64 and IA-32 Architectures
Optimization Reference Manual&quot;, in chapter &quot;18.16.1 Vectorization with
Conflict Detection&quot;.  The problem of calculating a <a class="reference external" href="http://en.wikipedia.org/wiki/histogram">histogram</a>
is used there as an example.</p>
<p>The core of Intel's approach is a <em>conflict resolution loop</em> in
which the repeated values are aggregated into a single element.
The number of iterations varies, and <strong>depends on data</strong>: it
is 0 to 4, when we process 16-item vectors (32-bit elements).</p>
<p>We propose a modified approach, that avoids any additional looping
at the cost of additional storage. It is faster <strong>1.4 times</strong> than
the Intel algorithm when the input size is larger than 100,000
items.</p>
<p>The text contains a recap of AVX-512 instructions, a detailed
overview of the Intel algorithm, the presentation of our procedure,
and evaluation results.</p>
<p>All source codes are available.</p>
</div>
<div class="section" id="core-avx-512-instructions">
<h1>Core AVX-512 instructions</h1>
<p>Before we start, let's see how the crucial AVX-512 instructions are defined.
We are focused on instruction variants processing 32-bit items; there are
also 64-bit counterparts.</p>
<ol class="arabic">
<li><p class="first"><a class="reference external" href="https://hjlebbink.github.io/x86doc/html/VPGATHERDD_VPGATHERQD.html">GATHER</a> &mdash; vectorized load of N elements from given indices; its scalar
implementation for 32-bit items is below.</p>
<pre class="code go literal-block">
<span class="kd">type</span><span class="w"> </span><span class="nx">vector</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">uint32</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">vec_gather</span><span class="p">(</span><span class="nx">mem</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">,</span><span class="w"> </span><span class="nx">indices</span><span class="w"> </span><span class="nx">vector</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="nx">vector</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">indices</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mem</span><span class="p">[</span><span class="nx">indices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">return</span><span class="w">
</span><span class="p">}</span>
</pre>
</li>
<li><p class="first"><a class="reference external" href="https://hjlebbink.github.io/x86doc/html/VPSCATTERDD_VPSCATTERDQ_VPSCATTERQD_VPSCATTERQQ.html">SCATTER</a> &mdash; vectorized store N elements at given indices.
It is important that the hardware implementation performs
stores in the order of items in the vector.
For example if all indices are equal, the last, 15th value
will be stored.</p>
<pre class="code go literal-block">
<span class="kd">func</span><span class="w"> </span><span class="nx">vec_scatter</span><span class="p">(</span><span class="nx">values</span><span class="w"> </span><span class="nx">vector</span><span class="p">,</span><span class="w"> </span><span class="nx">mem</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">,</span><span class="w"> </span><span class="nx">indices</span><span class="w"> </span><span class="nx">vector</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">indices</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">mem</span><span class="p">[</span><span class="nx">indices</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
</li>
<li><p class="first"><a class="reference external" href="https://hjlebbink.github.io/x86doc/html/PCLMULQDQ.html">CONFLICTDETECTION</a> &mdash; build N bitmasks, where each bitmask points out
which <strong>previous</strong> elements are equal to the i-th element.</p>
<p>The following example shows conflict detection for an 8-element vector.</p>
<pre class="literal-block">
    7        6        5        4        3        2        1      item 0
┌────────┬────────┬────────┬────────┬────────┬────────┬────────┬────────┐
│     123│     123│       2│     123│       2│       2│     123│       2│ = input vector
└────────┴────────┴────────┴────────┴────────┴────────┴────────┴────────┘
┌────────┬────────┬────────┬────────┬────────┬────────┬────────┬────────┐
│01100010│00010010│00001101│00000010│00000101│00000001│00000000│00000000│ = conflicts mask
└────────┴────────┴────────┴────────┴────────┴────────┴────────┴────────┘
 │        │                 │                          │
 │        │                 │                          the first occurrence of 123
 │        │                 │
 │        │                 └─ value 123 in range [0:3] is present at indices: 1
 │        └─────────────────── value 123 in range [0:5] is present at indices: 1 and 4
 └──────────────────────────── value 123 in range [0:6] is present at indices: 1, 4 and 6
</pre>
<p>This procedure implements conflict detection for a 16-element vector.</p>
<pre class="code go literal-block">
<span class="kd">func</span><span class="w"> </span><span class="nx">vec_conflicts</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="nx">vector</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">res</span><span class="w"> </span><span class="nx">vector</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">mask</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="nx">bit</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">

        </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w">
        </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">v</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nx">mask</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="nx">bit</span><span class="w">
            </span><span class="p">}</span><span class="w">
            </span><span class="nx">bit</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mask</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">return</span><span class="w">
</span><span class="p">}</span>
</pre>
</li>
</ol>
</div>
<div class="section" id="histogram">
<h1>Histogram</h1>
<p>For the sake of completeness, there is a Go implementation of byte
histogram procedure. We assume that <tt class="docutils literal">input[i] &lt; 256</tt>.</p>
<pre class="code golang literal-block">
<span class="kd">func</span><span class="w"> </span><span class="nx">histogramReference</span><span class="p">(</span><span class="nx">input</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">output</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
<div class="section" id="reference-intel-algorithm">
<h2>Reference Intel algorithm</h2>
<p>In this section we show the reference implementation of Intel solution
for histogram computation. The implementation presented in the article
is the <a class="reference external" href="http://en.wikipedia.org/wiki/Go_(programming_language)">Go</a>. The assembly translation
is available in <a class="reference internal" href="#source">sources</a>.</p>
<pre class="code go literal-block">
<span class="kd">func</span><span class="w"> </span><span class="nx">HistogramIntelReference</span><span class="p">(</span><span class="nx">indices</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mem</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">output</span><span class="w">

    </span><span class="nx">zeros</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_set1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">
    </span><span class="nx">neg1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_set1</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">)</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">indices</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">chunk</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_load</span><span class="p">(</span><span class="nx">indices</span><span class="p">)</span><span class="w">
        </span><span class="nx">conflicts</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_conflicts</span><span class="p">(</span><span class="nx">chunk</span><span class="p">)</span><span class="w">

        </span><span class="nx">increment</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_set1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">

        </span><span class="nx">anyConflict</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_not_equals</span><span class="p">(</span><span class="nx">conflicts</span><span class="p">,</span><span class="w"> </span><span class="nx">zeros</span><span class="p">)</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="nx">anyConflict</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nx">position</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_lzcnt</span><span class="p">(</span><span class="nx">conflicts</span><span class="p">)</span><span class="w">
            </span><span class="nx">position</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_sub</span><span class="p">(</span><span class="nx">vec_set1</span><span class="p">(</span><span class="mi">31</span><span class="p">),</span><span class="w"> </span><span class="nx">position</span><span class="p">)</span><span class="w">

            </span><span class="nx">active</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">anyConflict</span><span class="w">
            </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nx">conflicted</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_permute_masked</span><span class="p">(</span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">
                </span><span class="nx">conflicted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_mask</span><span class="p">(</span><span class="nx">conflicted</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">

                </span><span class="nx">increment</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_add_masked</span><span class="p">(</span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">conflicted</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">

                </span><span class="nx">position</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_permute_masked</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">

                </span><span class="nx">active</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_not_equals</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">neg1</span><span class="p">)</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="nx">active</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="k">break</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="nx">oldValues</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_gather</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span><span class="w"> </span><span class="nx">chunk</span><span class="p">)</span><span class="w">
        </span><span class="nx">newValues</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_add</span><span class="p">(</span><span class="nx">oldValues</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="p">)</span><span class="w">
        </span><span class="nx">vec_scatter</span><span class="p">(</span><span class="nx">newValues</span><span class="p">,</span><span class="w"> </span><span class="nx">mem</span><span class="p">,</span><span class="w"> </span><span class="nx">chunk</span><span class="p">)</span><span class="w">

        </span><span class="nx">indices</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">indices</span><span class="p">[</span><span class="mi">16</span><span class="p">:]</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>The main loop of the algorithm works as follows.</p>
<ol class="arabic">
<li><p class="first">First we load 16 indices. For simplicity we assume that we already
have these bytes expanded into 32-bit values.</p>
<p>In our example we have a set of only three values: <tt class="docutils literal">{1, 22, 33}</tt>.</p>
<pre class="code go literal-block">
<span class="nx">chunk</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_load</span><span class="p">(</span><span class="nx">indices</span><span class="p">)</span>
</pre>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│   22│   22│    1│   33│    1│   33│   33│    1│    1│   22│   22│   22│   22│    1│    1│    1│ = chunk
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
dword 15                                                                                  dword 0
</pre>
</li>
<li><p class="first">Next, we perform the conflict detection on the loaded indices.</p>
<pre class="code go literal-block">
<span class="nx">conflicts</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_conflicts</span><span class="p">(</span><span class="nx">chunk</span><span class="p">)</span>
</pre>
<p>The contents of <tt class="docutils literal">conflicts</tt> is presented in binary.</p>
<pre class="literal-block">
conflicts[0]  = 00000000_00000000   // 1
conflicts[1]  = 00000000_00000001   // 1
conflicts[2]  = 00000000_00000011   // 1
conflicts[3]  = 00000000_00000000   // 22
conflicts[4]  = 00000000_00001000   // 22
conflicts[5]  = 00000000_00011000   // 22
conflicts[6]  = 00000000_00111000   // 22
conflicts[7]  = 00000000_00000111   // 1
conflicts[8]  = 00000000_10000111   // 1
conflicts[9]  = 00000000_00000000   // 33
conflicts[10] = 00000010_00000000   // 33
conflicts[11] = 00000001_10000111   // 1
conflicts[12] = 00000110_00000000   // 33
conflicts[13] = 00001001_10000111   // 1
conflicts[14] = 00000000_01111000   // 22
conflicts[15] = 01000000_01111000   // 22
</pre>
</li>
<li><p class="first">We initialize the <tt class="docutils literal">increment</tt> vector to all decimal ones. If there are no conflicts,
that is a ready to use increment value.</p>
<pre class="code go literal-block">
<span class="nx">increment</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_set1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│ = icrement
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</pre>
</li>
</ol>
<ol class="arabic" start="3">
<li><p class="first">When all words of <tt class="docutils literal">conflict</tt> vector are zeros, it means there are no
conflicts. We may skip a conflict resolution loop, and increment
counters (step 5). But in our example there are repeated
indices, thus we are entering the conflict resolution loop.</p>
<pre class="code go literal-block">
<span class="nx">anyConflict</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_not_equals</span><span class="p">(</span><span class="nx">conflicts</span><span class="p">,</span><span class="w"> </span><span class="nx">zeros</span><span class="p">)</span>
</pre>
<ol class="loweralpha">
<li><p class="first">The prerequisite to handle the repeated values is computing a
permutation vector. The permutation vector contains the indices
to the <strong>previous occurrence</strong> of the given element. The index
is -1 when the i-th element is the first occurrence of a value.</p>
<p>This calculation is possible with <a class="reference external" href="https://hjlebbink.github.io/x86doc/html/VPLZCNTD_Q.html">LZCNT (Leading Zeros Count)</a>
instruction. The previous index equals to <tt class="docutils literal">31 - LZCNT(conflicts[i])</tt>;
if there is no conflict (<tt class="docutils literal">conflicts[i] = 0</tt>), then the result
is -1.</p>
<pre class="code go literal-block">
<span class="nx">position</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_lzcnt</span><span class="p">(</span><span class="nx">conflicts</span><span class="p">)</span><span class="w">
</span><span class="nx">position</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_sub</span><span class="p">(</span><span class="nx">vec_set1</span><span class="p">(</span><span class="mi">31</span><span class="p">),</span><span class="w"> </span><span class="nx">position</span><span class="p">)</span>
</pre>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│   14│    6│   11│   10│    8│    9│   -1│    7│    2│    5│    4│    3│   -1│    1│    0│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</pre>
</li>
<li><p class="first">The next step is to set <strong>active</strong> elements. We are processing only the repeated
items &mdash; those having the previous element (<tt class="docutils literal">position[i] != <span class="pre">-1</span></tt>). Initially,
the active mask equals to the conflicts mask.</p>
<pre class="code go literal-block">
<span class="nx">active</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">anyConflict</span>
</pre>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│   14│    6│   11│   10│    8│    9│   -1│    7│    2│    5│    4│    3│   -1│    1│    0│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
     1     1     1     1     1     1     0     1     1     1     1     1     0     1     1     0  = active

                                                                             1111_1101_1111_0110  = active
</pre>
</li>
<li><p class="first">We repeat this step until <tt class="docutils literal">active</tt> mask is not zero.</p>
<p>We use the <tt class="docutils literal">position</tt> vector to pull previous values of <tt class="docutils literal">indices</tt>
to the vector <tt class="docutils literal">conflicted</tt>, zeroing non-active elements (lines 1 and 2).
Then we update only the active elements of <tt class="docutils literal">increment</tt> (line 3) &mdash; in
our case it is a single, masked addition. Finally, we pull the previous
positions of the <tt class="docutils literal">position</tt> vector itself (line 4), and update <tt class="docutils literal">active</tt>
mask accordingly (lines 5 to 8).</p>
<pre class="code go literal-block">
<span class="cm">/* 1 */</span><span class="w"> </span><span class="nx">conflicted</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_permute_masked</span><span class="p">(</span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">
</span><span class="cm">/* 2 */</span><span class="w"> </span><span class="nx">conflicted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_mask</span><span class="p">(</span><span class="nx">conflicted</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">

</span><span class="cm">/* 3 */</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_add_masked</span><span class="p">(</span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">conflicted</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">

</span><span class="cm">/* 4 */</span><span class="w"> </span><span class="nx">position</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_permute_masked</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">active</span><span class="p">)</span><span class="w">

</span><span class="cm">/* 5 */</span><span class="w"> </span><span class="nx">active</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_not_equals</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span><span class="w"> </span><span class="nx">neg1</span><span class="p">)</span><span class="w">
</span><span class="cm">/* 6 */</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">active</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="cm">/* 7 */</span><span class="w">     </span><span class="k">break</span><span class="w">
</span><span class="cm">/* 8 */</span><span class="w"> </span><span class="p">}</span>
</pre>
<p>Let's see in details how these vectors change across iterations. Because the <tt class="docutils literal">increment</tt>
vector is full of ones, we named elements of this vector as <tt class="docutils literal">i{index}</tt>. In the first iteration
we have:</p>
<pre class="literal-block">
   i15   i14   i13   i12   i11   i10    i9    i8    i7    i6    i5    i4    i3    i2    i1    i0
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│    1│ = increment
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│   14│    6│   11│   10│    8│    9│   -1│    7│    2│    5│    4│    3│   -1│    1│    0│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    1│    1│    1│    1│    1│    1│    0│    1│    1│    1│    1│    1│    0│    1│    1│    0│ = conflicted
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   i14    i6   i11   i10    i8    i9          i7    i2    i5    i4    i3          i1    i0
</pre>
</li>
</ol>
<blockquote>
<p>After updating the <tt class="docutils literal">increment</tt> vector (line 3) its content is:</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    2│    2│    2│    2│    2│    2│    1│    2│    2│    2│    2│    2│    1│    2│    2│    1│ = increment
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   i15   i14   i13   i12   i11   i10    i9    i8    i7    i6    i5    i4    i3    i2    i1    i0
  +i14   +i6  +i11  +i10   +i8   +i9         +i7   +i2   +i5   +i4   +i3         +i1   +i0
</pre>
<p>The permutation of <tt class="docutils literal">position</tt> yields the following vector. Note that now we have twice as much
-1 values.</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    6│    5│    8│    9│    7│   -1│   -1│    2│    1│    4│    3│   -1│   -1│    0│   -1│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
     1     1     1     1     1     0     0     1     1     1     1     0     0     1     0     0  = active
                                                                              1111_1001_1110_0100 = active
</pre>
<p>In the second iteration we have:</p>
<pre class="literal-block">
   i15   i14   i13   i12   i11   i10    i9    i8    i7    i6    i5    i4    i3    i2    i1    i0
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    2│    2│    2│    2│    2│    2│    1│    2│    2│    2│    2│    2│    1│    2│    2│    1│ = increment
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    6│    5│    8│    9│    7│   -1│   -1│    2│    1│    4│    3│   -1│   -1│    0│   -1│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    2│    2│    2│    1│    2│    0│    0│    2│    2│    2│    1│    0│    0│    1│    0│    0│ = conflicted
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
    i6    i5    i8    i9    i7                i2    i1    i4    i3                i0
</pre>
<p>After updating the <tt class="docutils literal">increment</tt> vector (line 3) its content is:</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    4│    4│    4│    3│    4│    2│    1│    4│    4│    4│    3│    2│    1│    3│    2│    1│ = increment
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   i15   i14   i13   i12   i11   i10    i9    i8    i7    i6    i5    i4    i3    i2    i1    i0
   +i6   +i5   +i8   +i9   +i7               +i2   +i1   +i4   +i3               +i0
</pre>
<p>The permutation of <tt class="docutils literal">position</tt> yields the following vector.</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    4│    3│    2│   -1│    1│   -1│   -1│    0│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
     1     1     1     0     1     0     0     1     0     0     0     0     0     0     0     0  = active
                                                                              1110_1001_0000_0000 = active
</pre>
<p>In the third iteration we have:</p>
<pre class="literal-block">
   i15   i14   i13   i12   i11   i10    i9    i8    i7    i6    i5    i4    i3    i2    i1    i0
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    4│    4│    4│    3│    4│    2│    1│    4│    4│    4│    3│    2│    1│    3│    2│    1│ = increment
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    4│    3│    2│   -1│    1│   -1│   -1│    0│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    2│    1│    3│    0│    2│    0│    0│    1│    0│    0│    0│    0│    0│    0│    0│    0│ = conflicted
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
    i4    i3    i2          i1                i0
</pre>
<p>After updating the <tt class="docutils literal">increment</tt> vector (line 3) its content is:</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    6│    5│    7│    3│    6│    2│    1│    5│    4│    4│    3│    2│    1│    3│    2│    1│ = increment
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   i15   i14   i13   i12   i11   i10    i9    i8    i7    i6    i5    i4    i3    i2    i1    i0
   +i4   +i3   +i2         +i1               +i0
</pre>
<p>The permutation of <tt class="docutils literal">position</tt> yields the vector full of -1. This means <tt class="docutils literal">active</tt> mask is zero,
and we finished the conflict resolution.</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│   -1│ = position
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</pre>
<p>Before moving to the final step, let's look closer on <tt class="docutils literal">increment</tt> collated with the input
vector <tt class="docutils literal">chunk</tt>.</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│   22│   22│    1│   33│    1│   33│   33│    1│    1│   22│   22│   22│   22│    1│    1│    1│ = chunk
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│    6│    5│    7│    3│    6│    2│    1│    5│    4│    4│    3│    2│    1│    3│    2│    1│ = increment
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
     │           │     │
     │           │     └─ the last occurrence of 33: 3 is the count
     │           └─────── the last occurrence of  1: 7 is the count
     └─────────────────── the last occurrence of 22: 6 is the count
</pre>
</blockquote>
</li>
</ol>
<ol class="arabic" start="5">
<li><p class="first">The last step is histogram update. First, we gather the counters for
the bytes we loaded in the step 1 (line 1).  Then, we update <strong>all</strong>
counters with the <tt class="docutils literal">increment</tt> vector calculated earlier (line 2).
Finally, we scatter the updated values back (line 3).</p>
<p>The real counts of repeated values are stored at position corresponding
the last occurrence of given value. The vector <tt class="docutils literal">newValues</tt> contains
garbage for earlier occurrences of a repeated value. It is not a problem,
as the scatter instruction guarantees that the value written to the memory
will be the correct, last one.</p>
<pre class="code go literal-block">
<span class="cm">/* 1 */</span><span class="w"> </span><span class="nx">oldValues</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_gather</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span><span class="w"> </span><span class="nx">chunk</span><span class="p">)</span><span class="w">
</span><span class="cm">/* 2 */</span><span class="w"> </span><span class="nx">newValues</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_add</span><span class="p">(</span><span class="nx">oldValues</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="p">)</span><span class="w">
</span><span class="cm">/* 3 */</span><span class="w"> </span><span class="nx">vec_scatter</span><span class="p">(</span><span class="nx">newValues</span><span class="p">,</span><span class="w"> </span><span class="nx">mem</span><span class="p">,</span><span class="w"> </span><span class="nx">chunk</span><span class="p">)</span>
</pre>
<p><strong>Note</strong>: due to high latency of the gather instructions, in the assembly
code the gather instruction is issued before the conflict resolution loop.
Here we put it closer just to make the algorithm more readable.</p>
</li>
</ol>
</div>
<div class="section" id="downsides-of-intel-approach">
<h2>Downsides of Intel approach</h2>
<ul class="simple">
<li>The core algorithm has to be repeated twice -- in the conflict
resolution loop and in the main loop. The histogram algorithm
requires just a simple addition, thus that is not that visible.
But when we need more operations, it becomes more significant.</li>
<li>Likewise, when the algorithm needs more than one variable,
then all variables have to be permuted in the same way we
permute the <tt class="docutils literal">increment</tt> vector.</li>
<li>Unpredictable number of iterations.</li>
<li>Underuse of available resources: in each iteration we process
fewer and fewer items. The following table shows how many active
elements were processed in the conflict resolution loop for
various inputs.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">input characteristics</th>
<th class="head">all elements</th>
<th class="head">active elements</th>
<th class="head">active [%]</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>constant value</td>
<td>40960</td>
<td>31360</td>
<td>76.56</td>
</tr>
<tr><td>random values from 0 to 3</td>
<td>31088</td>
<td>14754</td>
<td>47.46</td>
</tr>
<tr><td>random values from 0 to 14</td>
<td>19280</td>
<td>4888</td>
<td>25.35</td>
</tr>
<tr><td>random values from 0 to 63</td>
<td>9776</td>
<td>1155</td>
<td>11.81</td>
</tr>
<tr><td>random bytes</td>
<td>4000</td>
<td>294</td>
<td>7.35</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="alternative-algorithm">
<h2>Alternative algorithm</h2>
<p>The solution we propose completely rids of the conflict resolution loop.
The key observation is that in a single iteration of the main loop
we have up to 16 conflicts. Each input item might have assigned
the unique repetition id (from 0 to 15) within the subset of the same
values.</p>
<p>By extending the algorithm state by the factor of 16, we can update
<strong>without conflicts</strong> all values at once.  While the original algorithm
updates counters at indices <tt class="docutils literal">chunk[i]</tt>, we update a sub-counters
at <tt class="docutils literal">chunk[i] * 16 + subbucket</tt>, where <tt class="docutils literal">subbucket</tt> is a number from 0 to 15.</p>
<p>After the main loop completes, we finalize computations by merging these
sixteen sub-states into one.</p>
<p>Let's look how this approach would assign subbucket numbers in our
example input vector.</p>
<pre class="literal-block">
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│   22│   22│    1│   33│    1│   33│   33│    1│    1│   22│   22│   22│   22│    1│    1│    1│ = chunk
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
     │     │     |     │     │     │     │     │     │     │     │     │     │     │     │     │
     │     │     6     │     5     │     │     4     3     │     │     │     │     2     1     0
     5     4           │           │     │                 3     2     1     0
                       2           1     0
</pre>
<p>The following Go code shows how the histogram problem can be solved
with this new approach.</p>
<pre class="code go literal-block">
<span class="kd">func</span><span class="w"> </span><span class="nx">HistogramV2Reference</span><span class="p">(</span><span class="nx">indices</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">,</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mem</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">output</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">indices</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">chunk</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_load</span><span class="p">(</span><span class="nx">indices</span><span class="p">)</span><span class="w">
        </span><span class="nx">conflicts</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_conflicts</span><span class="p">(</span><span class="nx">chunk</span><span class="p">)</span><span class="w">

        </span><span class="nx">subbuckets</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_lzcnt</span><span class="p">(</span><span class="nx">conflicts</span><span class="p">)</span><span class="w">
        </span><span class="nx">subbuckets</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_sub</span><span class="p">(</span><span class="nx">vec_set1</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span><span class="w"> </span><span class="nx">subbuckets</span><span class="p">)</span><span class="w">

        </span><span class="nx">offsets</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_sll</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
        </span><span class="nx">offsets</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vec_add</span><span class="p">(</span><span class="nx">offsets</span><span class="p">,</span><span class="w"> </span><span class="nx">subbuckets</span><span class="p">)</span><span class="w"> </span><span class="c1">// 16 * index + subbucket</span><span class="w">

        </span><span class="nx">oldValues</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_gather</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span><span class="w"> </span><span class="nx">offsets</span><span class="p">)</span><span class="w">
        </span><span class="nx">newValues</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">vec_add</span><span class="p">(</span><span class="nx">oldValues</span><span class="p">,</span><span class="w"> </span><span class="nx">vec_set1</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w">
        </span><span class="nx">vec_scatter</span><span class="p">(</span><span class="nx">newValues</span><span class="p">,</span><span class="w"> </span><span class="nx">mem</span><span class="p">,</span><span class="w"> </span><span class="nx">offsets</span><span class="p">)</span><span class="w">

        </span><span class="nx">indices</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">indices</span><span class="p">[</span><span class="mi">16</span><span class="p">:]</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="c1">// finalize</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">bins</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">pos</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="w">
        </span><span class="nx">sum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nx">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">output</span><span class="p">[</span><span class="nx">pos</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="nx">output</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">sum</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
</div>
<div class="section" id="experiment-results">
<h1>Experiment results</h1>
<p>The assembler implementations of the Intel and new approach were tested using
the standard Go benchmarking tool. Various inputs were tested:</p>
<ul class="simple">
<li>constant value,</li>
<li>random values from 0 to 3,</li>
<li>random values from 0 to 14,</li>
<li>random values from 0 to 64,</li>
<li>random bytes,</li>
<li>all of above sorted.</li>
</ul>
<p>CPU: <a class="reference external" href="https://ark.intel.com/content/www/us/en/ark/products/125039/intel-xeon-w2104-processor-8-25m-cache-3-20-ghz.html">Xeon W-2104 Processor</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="29%" />
<col width="36%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">size [32-bit words]</th>
<th class="head">Intel algorithm [MB/s]</th>
<th class="head">Alternative algorithm [MB/s]</th>
<th class="head">Speedup</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="4">constant value</td>
</tr>
<tr><td>1,024</td>
<td>860.61</td>
<td>227.23</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.37</td>
<td>656.92</td>
<td>0.76</td>
</tr>
<tr><td>10,240</td>
<td>870.25</td>
<td>861.90</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>867.46</td>
<td>1182.99</td>
<td>1.36</td>
</tr>
<tr><td>512,000</td>
<td>850.11</td>
<td>1221.05</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>849.96</td>
<td>1226.56</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>838.58</td>
<td>1206.70</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>786.06</td>
<td>1118.72</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>777.66</td>
<td>1117.22</td>
<td>1.44</td>
</tr>
<tr><td colspan="4">sorted values from 0 to 3</td>
</tr>
<tr><td>1,024</td>
<td>860.67</td>
<td>227.21</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.26</td>
<td>657.08</td>
<td>0.76</td>
</tr>
<tr><td>10,240</td>
<td>870.47</td>
<td>861.83</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>866.41</td>
<td>1177.93</td>
<td>1.36</td>
</tr>
<tr><td>512,000</td>
<td>849.94</td>
<td>1220.74</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>849.05</td>
<td>1226.69</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>835.50</td>
<td>1200.06</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>784.94</td>
<td>1115.10</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>779.75</td>
<td>1114.16</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">sorted values from 0 to 14</td>
</tr>
<tr><td>1,024</td>
<td>860.75</td>
<td>227.22</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.33</td>
<td>657.22</td>
<td>0.76</td>
</tr>
<tr><td>10,240</td>
<td>862.62</td>
<td>849.14</td>
<td>0.98</td>
</tr>
<tr><td>102,400</td>
<td>868.60</td>
<td>1190.50</td>
<td>1.37</td>
</tr>
<tr><td>512,000</td>
<td>848.46</td>
<td>1219.15</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>850.39</td>
<td>1228.37</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>834.96</td>
<td>1198.63</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>782.96</td>
<td>1114.30</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>778.32</td>
<td>1112.89</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">sorted values from 0 to 63</td>
</tr>
<tr><td>1,024</td>
<td>860.72</td>
<td>227.22</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.31</td>
<td>641.37</td>
<td>0.74</td>
</tr>
<tr><td>10,240</td>
<td>870.51</td>
<td>861.93</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>863.03</td>
<td>1175.73</td>
<td>1.36</td>
</tr>
<tr><td>512,000</td>
<td>851.23</td>
<td>1224.23</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>851.38</td>
<td>1226.58</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>832.73</td>
<td>1194.05</td>
<td>1.43</td>
</tr>
<tr><td>5,242,880</td>
<td>782.41</td>
<td>1119.39</td>
<td>1.43</td>
</tr>
<tr><td>10,485,760</td>
<td>779.38</td>
<td>1112.67</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">sorted bytes</td>
</tr>
<tr><td>1,024</td>
<td>860.77</td>
<td>227.22</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.25</td>
<td>657.24</td>
<td>0.76</td>
</tr>
<tr><td>10,240</td>
<td>870.45</td>
<td>861.94</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>863.78</td>
<td>1180.33</td>
<td>1.37</td>
</tr>
<tr><td>512,000</td>
<td>849.81</td>
<td>1223.83</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>849.93</td>
<td>1225.23</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>831.93</td>
<td>1194.59</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>785.46</td>
<td>1116.25</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>778.15</td>
<td>1110.47</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">constant value</td>
</tr>
<tr><td>1,024</td>
<td>860.73</td>
<td>227.22</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.30</td>
<td>657.21</td>
<td>0.76</td>
</tr>
<tr><td>10,240</td>
<td>859.60</td>
<td>849.05</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>862.47</td>
<td>1180.54</td>
<td>1.37</td>
</tr>
<tr><td>512,000</td>
<td>849.13</td>
<td>1223.81</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>850.00</td>
<td>1227.04</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>835.06</td>
<td>1199.79</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>785.40</td>
<td>1117.14</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>779.17</td>
<td>1114.66</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">random values from 0 to 3</td>
</tr>
<tr><td>1,024</td>
<td>860.73</td>
<td>227.21</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>844.43</td>
<td>657.25</td>
<td>0.78</td>
</tr>
<tr><td>10,240</td>
<td>870.48</td>
<td>861.93</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>863.60</td>
<td>1180.64</td>
<td>1.37</td>
</tr>
<tr><td>512,000</td>
<td>850.54</td>
<td>1221.42</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>850.45</td>
<td>1227.06</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>834.29</td>
<td>1199.90</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>785.20</td>
<td>1117.01</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>777.80</td>
<td>1112.16</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">random values from 0 to 14</td>
</tr>
<tr><td>1,024</td>
<td>860.67</td>
<td>227.23</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.34</td>
<td>657.10</td>
<td>0.76</td>
</tr>
<tr><td>10,240</td>
<td>870.50</td>
<td>861.89</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>864.86</td>
<td>1182.81</td>
<td>1.37</td>
</tr>
<tr><td>512,000</td>
<td>846.93</td>
<td>1220.55</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>848.47</td>
<td>1227.36</td>
<td>1.45</td>
</tr>
<tr><td>2,097,152</td>
<td>834.09</td>
<td>1199.69</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>784.80</td>
<td>1118.62</td>
<td>1.43</td>
</tr>
<tr><td>10,485,760</td>
<td>779.74</td>
<td>1113.79</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">random values from 0 to 63</td>
</tr>
<tr><td>1,024</td>
<td>860.77</td>
<td>227.24</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.31</td>
<td>656.93</td>
<td>0.76</td>
</tr>
<tr><td>10,240</td>
<td>860.87</td>
<td>849.00</td>
<td>0.99</td>
</tr>
<tr><td>102,400</td>
<td>867.53</td>
<td>1182.82</td>
<td>1.36</td>
</tr>
<tr><td>512,000</td>
<td>849.01</td>
<td>1220.70</td>
<td>1.44</td>
</tr>
<tr><td>1,048,576</td>
<td>849.53</td>
<td>1226.27</td>
<td>1.44</td>
</tr>
<tr><td>2,097,152</td>
<td>832.92</td>
<td>1198.14</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>785.25</td>
<td>1116.44</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>779.28</td>
<td>1112.75</td>
<td>1.43</td>
</tr>
<tr><td colspan="4">random bytes</td>
</tr>
<tr><td>1,024</td>
<td>860.73</td>
<td>227.21</td>
<td>0.26</td>
</tr>
<tr><td>5,120</td>
<td>869.36</td>
<td>641.30</td>
<td>0.74</td>
</tr>
<tr><td>10,240</td>
<td>860.29</td>
<td>861.87</td>
<td>1.00</td>
</tr>
<tr><td>102,400</td>
<td>868.43</td>
<td>1190.52</td>
<td>1.37</td>
</tr>
<tr><td>512,000</td>
<td>846.36</td>
<td>1223.07</td>
<td>1.45</td>
</tr>
<tr><td>1,048,576</td>
<td>849.26</td>
<td>1228.86</td>
<td>1.45</td>
</tr>
<tr><td>2,097,152</td>
<td>834.57</td>
<td>1198.15</td>
<td>1.44</td>
</tr>
<tr><td>5,242,880</td>
<td>786.23</td>
<td>1120.11</td>
<td>1.42</td>
</tr>
<tr><td>10,485,760</td>
<td>779.94</td>
<td>1116.79</td>
<td>1.43</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="source-code">
<span id="source"></span><h1>Source code</h1>
<p>All sources are available on Github: <a class="reference external" href="https://github.com/WojciechMula/toys/tree/master/avx512-conflict-detection">https://github.com/WojciechMula/toys/tree/master/avx512-conflict-detection</a></p>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2023-05-06-avx512-conflict-detection.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:32 GMT -->
</html>
