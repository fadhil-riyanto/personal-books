<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2018-11-18-sse-sumbytes-part2.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:39 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>SIMDized sum of all bytes in the array &mdash; part 2: signed bytes</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="simdized-sum-of-all-bytes-in-the-array-part-2-signed-bytes">
<h1 class="title">SIMDized sum of all bytes in the array &mdash; part 2: signed bytes</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2018-11-18</td>
</tr>
<tr class="updated-on field"><th class="docinfo-name">Updated on:</th><td class="field-body">2019-02-04 (<a class="reference internal" href="#sadbw-variant">faster PSADBW approach</a> contributed by <a class="reference external" href="https://github.com/mayeut">Matthieu Darbois</a>, update results from GCC); 2019-02-03 (<a class="reference internal" href="#maddubs">new method</a> also contributed by <strong>Matthieu Darbois</strong>)</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction-1" id="toc-entry-1">Introduction</a><ul>
<li><a class="reference internal" href="#algorithm-used-by-gcc" id="toc-entry-2">Algorithm used by GCC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#explicit-casting" id="toc-entry-3">Explicit casting</a></li>
<li><a class="reference internal" href="#shift-based-casting" id="toc-entry-4">Shift-based casting</a></li>
<li><a class="reference internal" href="#avx2-specific-instruction-vpsadbw-naive-approach" id="toc-entry-5">AVX2-specific instruction VPSADBW &mdash; naive approach</a></li>
<li><a class="reference internal" href="#avx2-specific-instruction-vpsadbw-faster-algorithm" id="toc-entry-6">AVX2-specific instruction VPSADBW &mdash; faster algorithm</a></li>
<li><a class="reference internal" href="#avx2-specific-instruction-vpmaddubsw" id="toc-entry-7">AVX2-specific instruction VPMADDUBSW</a></li>
<li><a class="reference internal" href="#experiments" id="toc-entry-8">Experiments</a><ul>
<li><a class="reference internal" href="#haswell" id="toc-entry-9">Haswell</a></li>
<li><a class="reference internal" href="#skylake" id="toc-entry-10">Skylake</a></li>
<li><a class="reference internal" href="#skylakex" id="toc-entry-11">SkylakeX</a></li>
<li><a class="reference internal" href="#cannonlake" id="toc-entry-12">CannonLake</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conclusions" id="toc-entry-13">Conclusions</a></li>
<li><a class="reference internal" href="#acknowledgements" id="toc-entry-14">Acknowledgements</a></li>
<li><a class="reference internal" href="#source-code" id="toc-entry-15">Source code</a></li>
</ul>
</div>
<div class="section" id="introduction-1">
<span id="introduction"></span><h1>Introduction</h1>
<p>This is the second part of <a class="reference external" href="2018-10-24-sse-sumbytes.html">SIMDized sum of all bytes in the array</a>.  The
first part describes summing unsigned bytes, here we're going to experiment
with summing of signed bytes.</p>
<p>The baseline C implementation is:</p>
<pre class="code cpp literal-block">
<span class="kt">int32_t</span><span class="w"> </span><span class="nf">sumbytes</span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
        </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
<p>And the C++ implementation:</p>
<pre class="code cpp literal-block">
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span><span class="w">
</span><span class="kt">int32_t</span><span class="w"> </span><span class="nf">sumbytes</span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="p">}</span>
</pre>
<div class="section" id="algorithm-used-by-gcc">
<h2>Algorithm used by GCC</h2>
<p>Below is the assembly code of the main loop compiled for Skylake by
GCC 7.3.0 with flags <tt class="docutils literal"><span class="pre">-O3</span> <span class="pre">-march=skylake</span></tt>:</p>
<pre class="code nasm literal-block">
<span class="nf">vpmovsxbw</span><span class="w">       </span><span class="o">%</span><span class="nb">xmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm2</span><span class="w">
</span><span class="nf">vextracti128</span><span class="w">    </span><span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">xmm1</span><span class="w">
</span><span class="nf">vpmovsxwd</span><span class="w">       </span><span class="o">%</span><span class="nb">xmm2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm3</span><span class="w">
</span><span class="nf">vextracti128</span><span class="w">    </span><span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">xmm2</span><span class="w">
</span><span class="nf">vpmovsxbw</span><span class="w">       </span><span class="o">%</span><span class="nb">xmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm1</span><span class="w">
</span><span class="nf">vpaddd</span><span class="w">          </span><span class="o">%</span><span class="nb">ymm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm3</span><span class="w">
</span><span class="nf">vpmovsxwd</span><span class="w">       </span><span class="o">%</span><span class="nb">xmm2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm0</span><span class="w">
</span><span class="nf">vpaddd</span><span class="w">          </span><span class="o">%</span><span class="nb">ymm3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm2</span><span class="w">
</span><span class="nf">vpmovsxwd</span><span class="w">       </span><span class="o">%</span><span class="nb">xmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm0</span><span class="w">
</span><span class="nf">vextracti128</span><span class="w">    </span><span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">xmm1</span><span class="w">
</span><span class="nf">vpaddd</span><span class="w">          </span><span class="o">%</span><span class="nb">ymm2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm0</span><span class="w">
</span><span class="nf">vpmovsxwd</span><span class="w">       </span><span class="o">%</span><span class="nb">xmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm1</span><span class="w">
</span><span class="nf">vpaddd</span><span class="w">          </span><span class="o">%</span><span class="nb">ymm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">ymm0</span>
</pre>
<p>The approach used here by GCC is exactly the same as for summing unsigned
bytes. There are multiple 32-bit sub-accumulators in single register, i.e.
eight in case of AVX2 (four in SSE code), which are added together in
the end, forming the scalar result.</p>
<p>To get 32-bit values there's two-step casting from <tt class="docutils literal">int8_t</tt> to <tt class="docutils literal">int32_t</tt>:</p>
<ol class="arabic simple">
<li>First extend a vector of <tt class="docutils literal">int8_t</tt> into two vectors of <tt class="docutils literal">int16_t</tt>
numbers (<tt class="docutils literal">VPMOVSXBW</tt>).</li>
<li>Then, get four vectors of <tt class="docutils literal">int32_t</tt> from the vectors obtained in the
previous step (<tt class="docutils literal">VPMOVSXWD</tt>).</li>
</ol>
<p>The cast instruction <tt class="docutils literal">VPMOVSX</tt> extends the lower part of a register, in this
case the lower half. This is the reason why extractions of helves
(<tt class="docutils literal">VEXTRACTI128</tt>) are needed.</p>
</div>
</div>
<div class="section" id="explicit-casting">
<span id="casts"></span><h1>Explicit casting</h1>
<p>There's instruction <tt class="docutils literal">VPMOVSXBD</tt> which casts directly from <tt class="docutils literal">int8_t</tt> to
<tt class="docutils literal">int32_t</tt>. It get lower 64 bits of input register, thus to convert all bytes
from an AVX2 register the instruction has to be called 4 times and some shifting
is needed.</p>
<p>Below is sample implementation</p>
<pre class="code cpp literal-block">
<span class="kt">int32_t</span><span class="w"> </span><span class="nf">avx2_sumsignedbytes</span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">__m256i</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_setzero_si256</span><span class="p">();</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_extracti128_si256</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">hi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_extracti128_si256</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">

        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cvtepi8_epi32</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cvtepi8_epi32</span><span class="p">(</span><span class="n">hi</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cvtepi8_epi32</span><span class="p">(</span><span class="n">_mm_bsrli_si128</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cvtepi8_epi32</span><span class="p">(</span><span class="n">_mm_bsrli_si128</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span><span class="w">

        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">));</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="shift-based-casting">
<span id="shifts"></span><h1>Shift-based casting</h1>
<p>In this approach we also cast directly from 8 into 32-bit numbers, but we use
32-bit shifts.</p>
<p>To convert 3rd bytes in all 32-bit words of registers we simply do <strong>arithmetic</strong>
shift right by 24 bits right. This shift repeats the most significant (a sign
bit) of our 8-bit value.</p>
<p>However, to do the same for other bytes in a 32-bit we need two shifts. The
first one left, which places byte at 3rd position. Then arithmetic shift right
is used to extend the type.</p>
<p>Algorithm is:</p>
<ol class="arabic">
<li><p class="first">Load the input vector.</p>
<pre class="code cpp literal-block">
<span class="c1">// v   = [  5 | -1 |  2 | -3 |  7 |  1 |  2 |  3 | -6 | -1 | -3 |  8 | -7 | -12|  3 |  2 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Extend 3rd bytes.</p>
<pre class="code cpp literal-block">
<span class="c1">// v0  = [                 5 |                 7 |                -6 |                -7 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Extend 2nd bytes.</p>
<pre class="code cpp literal-block">
<span class="c1">// v1  = [ -1 |  2 | -3 |  0 |  1 |  2 |  3 |  0 | -1 | -3 |  8 |  0 | -12|  3 |  2 |  0 ] &gt;&gt;&gt; 24
//     = [                -1 |                 1 |                -1 |               -12 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Extend 1st bytes.</p>
<pre class="code cpp literal-block">
<span class="c1">// v2  = [  2 | -3 |  0 |  0 |  2 |  3 |  0 |  0 | -3 |  8 |  0 |  0 |  3 |  2 |  0 |  0 ] &gt;&gt;&gt; 24
//     = [                 2 |                 2 |                -3 |                 3 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
</pre>
</li>
</ol>
<ol class="arabic" start="2">
<li><p class="first">Extend 0th bytes.</p>
<pre class="code cpp literal-block">
<span class="c1">// v3  = [ -3 |  0 |  0 |  0 |  3 |  0 |  0 |  0 |  8 |  0 |  0 |  0 |  2 |  0 |  0 |  0 ] &gt;&gt;&gt; 24
//     = [                -3 |                 3 |                 8 |                 2 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
</pre>
</li>
</ol>
<ol class="arabic" start="4">
<li><p class="first">Update the accumulator.</p>
<pre class="code cpp literal-block">
<span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="p">);</span><span class="w">
</span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">);</span><span class="w">
</span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">);</span><span class="w">
</span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">);</span>
</pre>
</li>
</ol>
<p>Sample implementation:</p>
<pre class="code cpp literal-block">
<span class="kt">int32_t</span><span class="w"> </span><span class="nf">avx2_sumsignedbytes_variant2</span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="n">__m256i</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_setzero_si256</span><span class="p">();</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_srai_epi32</span><span class="p">(</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w">

        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">));</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx2-specific-instruction-vpsadbw-naive-approach">
<span id="sadbw"></span><h1>AVX2-specific instruction VPSADBW &mdash; naive approach</h1>
<p>AVX2 has got instruction <tt class="docutils literal">VPSADBW</tt> (<tt class="docutils literal">_mm256_sad_epu8</tt>) that calculates
<strong>Sum Of Absolute Differences</strong> (SAD) of unsigned bytes. Single SAD function
works on eight-element subvectors (64-bit slices), and stores the results on
corresponding 64-bit elements of the result vector; in case of AVX2 the
<tt class="docutils literal">VPSADBW</tt> yields four numbers.</p>
<p>And while the instruction is perfect for summing unsigned bytes, in case of
signed bytes it not that great. <tt class="docutils literal">VPSADBW</tt> has to be used twice: for positive
and negative elements of input vector, as it works only on unsigned bytes.</p>
<p>Below is the outline of algorithm:</p>
<ol class="arabic">
<li><p class="first">Load the input vector.</p>
<pre class="code cpp literal-block">
<span class="c1">// v   = [  5 | -1 |  2 | -3 |  7 |  1 |  2 |  3 | -6 | -1 | -3 |  8 | -7 | -12|  3 |  2 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Find mask for negative numbers.</p>
<pre class="code cpp literal-block">
<span class="c1">// m   = [ 00 | ff | 00 | ff | 00 | 00 | 00 | 00 | ff | ff | ff | 00 | ff | ff | 00 | 00 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">m</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cmplt_epi8</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Left positive elements.</p>
<pre class="code cpp literal-block">
<span class="c1">// pos = [  5 |  0 |  2 |  0 |  7 |  1 |  2 |  3 |  0 |  0 |  0 |  8 |  0 |  0 |  3 |  2 ]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_andnot_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Sum the positive elements.</p>
<pre class="code cpp literal-block">
<span class="c1">// t0  = [                14 |                13 |                 8 |                 5 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_sad_epu8</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Get the absolute value.</p>
<pre class="code cpp literal-block">
<span class="c1">// va  = [  5 |  1 |  2 |  3 |  7 |  1 |  2 |  3 |  6 |  1 |  3 |  8 |  7 |  12|  3 |  2 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_abs_epi8</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Left only the absolute values of negative elements.</p>
<pre class="code cpp literal-block">
<span class="c1">// neg = [  0 |  1 |  0 |  3 |  0 |  0 |  0 |  0 |  6 |  1 |  3 |  0 |  7 |  0 |  0 |  0 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">neg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_and_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">va</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Sum the negative elements.</p>
<pre class="code cpp literal-block">
<span class="c1">// t1  = [                 4 |                 0 |                10 |                 7 ]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_sad_epu8</span><span class="p">(</span><span class="n">neg</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Update the accumulators.</p>
<pre class="code cpp literal-block">
<span class="n">positive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">positive</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">);</span><span class="w">
</span><span class="n">negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_sub_epi32</span><span class="p">(</span><span class="n">negative</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span>
</pre>
</li>
</ol>
<p>Below is the actual implementation.</p>
<pre class="code cpp literal-block">
<span class="cp">#define _mm256_cmplt_epi8(a, b) _mm256_cmpgt_epi8(b, a)
</span><span class="w">
</span><span class="kt">int32_t</span><span class="w"> </span><span class="nf">avx2_sadbw_sumsignedbytes</span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_setzero_si256</span><span class="p">();</span><span class="w">
    </span><span class="n">__m256i</span><span class="w"> </span><span class="n">positive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">;</span><span class="w">
    </span><span class="n">__m256i</span><span class="w"> </span><span class="n">negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">;</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">m</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_cmplt_epi8</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_abs_epi8</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w">

        </span><span class="c1">// sum just positive numbers
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_sad_epu8</span><span class="p">(</span><span class="n">_mm256_andnot_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">),</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span><span class="w">

        </span><span class="c1">// sum just negative numbers
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_sad_epu8</span><span class="p">(</span><span class="n">_mm256_and_si256</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">va</span><span class="p">),</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span><span class="w">

        </span><span class="n">positive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">positive</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">);</span><span class="w">
        </span><span class="n">negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_sub_epi32</span><span class="p">(</span><span class="n">negative</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">positive</span><span class="p">,</span><span class="w"> </span><span class="n">negative</span><span class="p">);</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx2-specific-instruction-vpsadbw-faster-algorithm">
<span id="sadbw-variant"></span><h1>AVX2-specific instruction VPSADBW &mdash; faster algorithm</h1>
<p><strong>Matthieu Darbois</strong> <a class="reference external" href="https://github.com/WojciechMula/toys/pull/8">came up with</a> a way batter method that utilizing
<tt class="docutils literal">VPSADBW</tt>.  The input range of bytes is changed from <tt class="docutils literal">int8_t</tt> range, i.e.
-128 .. +128, into <tt class="docutils literal">uint8_t</tt> range by adding 128. This addition sets the
input range to 0 .. 255, and thanks to that  <strong>single invocation</strong> of
<tt class="docutils literal">VPSADBW</tt> is sufficient to add unsigned bytes. The input adjustment is done
with a cheap binary operation, thus the procedure is as fast as its unsigned
counterpart.</p>
<p>Due to the input adjustments, the final result is increased by 128 times the
number of bytes. This value must be extracted to get the real singed sum.</p>
<p>Below is the actual implementation.</p>
<pre class="code cpp literal-block">
<span class="kt">int32_t</span><span class="w"> </span><span class="nf">avx2_sadbw_variant_sumsignedbytes</span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">zero</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_setzero_si256</span><span class="p">();</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">addend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_set1_epi8</span><span class="p">(</span><span class="mi">-128</span><span class="p">);</span><span class="w">
    </span><span class="n">__m256i</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">;</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_xor_si256</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">addend</span><span class="p">);</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_sad_epu8</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">);</span><span class="w">

        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm256_extract_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="o">-</span><span class="w">
           </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx2-specific-instruction-vpmaddubsw">
<span id="maddubs"></span><h1>AVX2-specific instruction VPMADDUBSW</h1>
<p><strong>Matthieu Darbois</strong> also <a class="reference external" href="https://github.com/WojciechMula/toys/pull/8">proposed</a> to use instruction <tt class="docutils literal">VPMADDUBSW</tt>
(<tt class="docutils literal">_mm256_madd_epi16</tt>) to perform <em>horizontal additions</em> of bytes.</p>
<p>The instruction itself is more complex, as it multiplies vertically bytes and
then adds the pairs of intermediate signed 16-bit results, forming a new vector
of 16-bit values. If another vector is filled with 1, then efficiently we add
pair of bytes horizontally.</p>
<p>The inner loop of algorithm uses <tt class="docutils literal">VPMADDUBSW</tt> to obtain 16-bit counters which
update a 16-bit local accumulator. To avoid overflow, after a fixed number of
iterations (128), the local accumulator is extended to 32-bit values and added
to the global, 32-bit accumulator.</p>
<p>Below is the actual implementation.</p>
<pre class="code cpp literal-block">
<span class="kt">int32_t</span><span class="w"> </span><span class="nf">avx2_maddubs_sumsignedbytes</span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">zero</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_setzero_si256</span><span class="p">();</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">one_8</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_set1_epi8</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">one_16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_set1_epi16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
    </span><span class="n">__m256i</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">;</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">__m256i</span><span class="w"> </span><span class="n">local_accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">;</span><span class="w">
        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_maddubs_epi16</span><span class="p">(</span><span class="n">one_8</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w">
            </span><span class="n">local_accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi16</span><span class="p">(</span><span class="n">local_accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_madd_epi16</span><span class="p">(</span><span class="n">one_16</span><span class="p">,</span><span class="w"> </span><span class="n">local_accumulator</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span><span class="w">
        </span><span class="n">array</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">((</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">));</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">remainder</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">__m256i</span><span class="w"> </span><span class="n">local_accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">;</span><span class="w">
        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">remainder</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">v</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_loadu_si256</span><span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
            </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_maddubs_epi16</span><span class="p">(</span><span class="n">one_8</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w">
            </span><span class="n">local_accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi16</span><span class="p">(</span><span class="n">local_accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">);</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="n">__m256i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_madd_epi16</span><span class="p">(</span><span class="n">one_16</span><span class="p">,</span><span class="w"> </span><span class="n">local_accumulator</span><span class="p">);</span><span class="w">
        </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm256_add_epi32</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">accumulator128</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">_mm256_extracti128_si256</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">_mm256_extracti128_si256</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">accumulator128</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">accumulator128</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">accumulator128</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
           </span><span class="kt">int32_t</span><span class="p">(</span><span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">accumulator128</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="experiments">
<h1>Experiments</h1>
<table border="1" class="docutils">
<caption>Tested procedures</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>scalar</td>
<td><a class="reference internal" href="#introduction">plain loop</a></td>
</tr>
<tr><td>scalar (C++)</td>
<td><a class="reference internal" href="#introduction">std::accumulate</a></td>
</tr>
<tr><td>SSE</td>
<td><a class="reference internal" href="#casts">explicit casting</a></td>
</tr>
<tr><td>SSE (v2)</td>
<td><a class="reference internal" href="#shifts">shif-based casting</a></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td><a class="reference internal" href="#sadbw">two PSADBW instructions</a></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>the above procedure unrolled four times</td>
</tr>
<tr><td>AVX2</td>
<td><a class="reference internal" href="#casts">explicit casting</a></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td><a class="reference internal" href="#shifts">shift-based casting</a></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td><a class="reference internal" href="#sadbw">two VPSADBW instructions</a></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>the above procedure unrolled four times</td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td><a class="reference internal" href="#sadbw-variant">single VPSADBW instruction</a></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td><a class="reference internal" href="#maddubs">VPMADDUBSW instruction</a></td>
</tr>
</tbody>
</table>
<p>The procedures were run three times and minimum values were noted.</p>
<div class="section" id="haswell">
<h2>Haswell</h2>
<p>CPU: Intel(R) Core(TM) i7-4870HQ CPU &#64; 2.50GHz (Haswell)</p>
<p>Compiler: Apple LLVM version 10.0.0 (clang-1000.11.45.5)</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="9%" />
<col width="8%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="5">size 4096 items</td>
</tr>
<tr><td>scalar</td>
<td>0.132</td>
<td>0.153</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████████▋</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.122</td>
<td>0.131</td>
<td>1.08</td>
<td><tt class="docutils literal"><span class="pre">█████████▍</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.294</td>
<td>0.300</td>
<td>0.45</td>
<td><tt class="docutils literal"><span class="pre">███▉</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.294</td>
<td>0.317</td>
<td>0.45</td>
<td><tt class="docutils literal"><span class="pre">███▉</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.130</td>
<td>0.141</td>
<td>1.02</td>
<td><tt class="docutils literal"><span class="pre">████████▊</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.130</td>
<td>0.135</td>
<td>1.02</td>
<td><tt class="docutils literal"><span class="pre">████████▊</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.153</td>
<td>0.161</td>
<td>0.86</td>
<td><tt class="docutils literal"><span class="pre">███████▌</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.147</td>
<td>0.150</td>
<td>0.90</td>
<td><tt class="docutils literal"><span class="pre">███████▊</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.070</td>
<td>0.072</td>
<td>1.89</td>
<td><tt class="docutils literal"><span class="pre">████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.060</td>
<td>0.067</td>
<td>2.20</td>
<td><tt class="docutils literal"><span class="pre">███████████████████▏</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.043</td>
<td>0.048</td>
<td>3.07</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████▋</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.023</td>
<td>0.026</td>
<td>5.74</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td colspan="5">size 16384 items</td>
</tr>
<tr><td>scalar</td>
<td>0.118</td>
<td>0.127</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████████▋</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.121</td>
<td>0.127</td>
<td>0.98</td>
<td><tt class="docutils literal"><span class="pre">████████▍</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.295</td>
<td>0.298</td>
<td>0.40</td>
<td><tt class="docutils literal"><span class="pre">███▍</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.295</td>
<td>0.316</td>
<td>0.40</td>
<td><tt class="docutils literal"><span class="pre">███▍</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.130</td>
<td>0.136</td>
<td>0.91</td>
<td><tt class="docutils literal"><span class="pre">███████▉</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.131</td>
<td>0.134</td>
<td>0.90</td>
<td><tt class="docutils literal"><span class="pre">███████▊</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.154</td>
<td>0.158</td>
<td>0.77</td>
<td><tt class="docutils literal"><span class="pre">██████▋</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.147</td>
<td>0.149</td>
<td>0.80</td>
<td><tt class="docutils literal"><span class="pre">██████▉</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.068</td>
<td>0.072</td>
<td>1.74</td>
<td><tt class="docutils literal"><span class="pre">███████████████</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.065</td>
<td>0.070</td>
<td>1.82</td>
<td><tt class="docutils literal"><span class="pre">███████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.039</td>
<td>0.043</td>
<td>3.03</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████▎</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.021</td>
<td>0.023</td>
<td>5.62</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████████████████████████████▉</span></tt></td>
</tr>
<tr><td colspan="5">size 32768 items</td>
</tr>
<tr><td>scalar</td>
<td>0.121</td>
<td>0.129</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████████▋</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.122</td>
<td>0.131</td>
<td>0.99</td>
<td><tt class="docutils literal"><span class="pre">████████▋</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.296</td>
<td>0.296</td>
<td>0.41</td>
<td><tt class="docutils literal"><span class="pre">███▌</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.296</td>
<td>0.297</td>
<td>0.41</td>
<td><tt class="docutils literal"><span class="pre">███▌</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.132</td>
<td>0.133</td>
<td>0.92</td>
<td><tt class="docutils literal"><span class="pre">███████▉</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.132</td>
<td>0.133</td>
<td>0.92</td>
<td><tt class="docutils literal"><span class="pre">███████▉</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.156</td>
<td>0.157</td>
<td>0.78</td>
<td><tt class="docutils literal"><span class="pre">██████▊</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.148</td>
<td>0.148</td>
<td>0.82</td>
<td><tt class="docutils literal"><span class="pre">███████</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.068</td>
<td>0.069</td>
<td>1.78</td>
<td><tt class="docutils literal"><span class="pre">███████████████▌</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.064</td>
<td>0.064</td>
<td>1.89</td>
<td><tt class="docutils literal"><span class="pre">████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.040</td>
<td>0.040</td>
<td>3.02</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████▎</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.023</td>
<td>0.024</td>
<td>5.26</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████▊</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="skylake">
<h2>Skylake</h2>
<p>CPU: Intel(R) Core(TM) i7-6700 CPU &#64; 3.40GHz</p>
<p>GCC: g++-8 (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="9%" />
<col width="8%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="5">size 4096 items</td>
</tr>
<tr><td>scalar</td>
<td>0.264</td>
<td>0.265</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">███████████▉</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.263</td>
<td>0.265</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">███████████▉</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.404</td>
<td>0.407</td>
<td>0.65</td>
<td><tt class="docutils literal"><span class="pre">███████▊</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.233</td>
<td>0.235</td>
<td>1.13</td>
<td><tt class="docutils literal"><span class="pre">█████████████▌</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.191</td>
<td>0.193</td>
<td>1.38</td>
<td><tt class="docutils literal"><span class="pre">████████████████▍</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.191</td>
<td>0.193</td>
<td>1.38</td>
<td><tt class="docutils literal"><span class="pre">████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.206</td>
<td>0.208</td>
<td>1.28</td>
<td><tt class="docutils literal"><span class="pre">███████████████▎</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.128</td>
<td>0.129</td>
<td>2.06</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████▌</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.112</td>
<td>0.114</td>
<td>2.36</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.099</td>
<td>0.102</td>
<td>2.67</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.069</td>
<td>0.071</td>
<td>3.83</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████▋</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.063</td>
<td>0.065</td>
<td>4.19</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td colspan="5">size 16384 items</td>
</tr>
<tr><td>scalar</td>
<td>0.260</td>
<td>0.261</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">███████████▉</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.260</td>
<td>0.261</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">███████████▉</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.403</td>
<td>0.405</td>
<td>0.65</td>
<td><tt class="docutils literal"><span class="pre">███████▋</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.231</td>
<td>0.232</td>
<td>1.13</td>
<td><tt class="docutils literal"><span class="pre">█████████████▍</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.188</td>
<td>0.189</td>
<td>1.38</td>
<td><tt class="docutils literal"><span class="pre">████████████████▌</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.188</td>
<td>0.189</td>
<td>1.38</td>
<td><tt class="docutils literal"><span class="pre">████████████████▌</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.203</td>
<td>0.204</td>
<td>1.28</td>
<td><tt class="docutils literal"><span class="pre">███████████████▎</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.125</td>
<td>0.126</td>
<td>2.08</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.109</td>
<td>0.110</td>
<td>2.39</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.097</td>
<td>0.099</td>
<td>2.68</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.066</td>
<td>0.066</td>
<td>3.94</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.064</td>
<td>0.064</td>
<td>4.06</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████████████████████████████▍</span></tt></td>
</tr>
<tr><td colspan="5">size 32768 items</td>
</tr>
<tr><td>scalar</td>
<td>0.260</td>
<td>0.261</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">███████████▉</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.260</td>
<td>0.261</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">███████████▉</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.403</td>
<td>0.405</td>
<td>0.65</td>
<td><tt class="docutils literal"><span class="pre">███████▋</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.231</td>
<td>0.232</td>
<td>1.13</td>
<td><tt class="docutils literal"><span class="pre">█████████████▍</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.188</td>
<td>0.189</td>
<td>1.38</td>
<td><tt class="docutils literal"><span class="pre">████████████████▌</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.188</td>
<td>0.189</td>
<td>1.38</td>
<td><tt class="docutils literal"><span class="pre">████████████████▌</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.202</td>
<td>0.203</td>
<td>1.29</td>
<td><tt class="docutils literal"><span class="pre">███████████████▎</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.125</td>
<td>0.126</td>
<td>2.08</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.109</td>
<td>0.109</td>
<td>2.39</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.098</td>
<td>0.099</td>
<td>2.65</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████▋</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.066</td>
<td>0.066</td>
<td>3.94</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.063</td>
<td>0.064</td>
<td>4.13</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████████▏</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="skylakex">
<h2>SkylakeX</h2>
<p>CPU: Intel(R) Xeon(R) W-2104 CPU &#64; 3.20GHz</p>
<p>GCC: gcc (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="9%" />
<col width="8%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="5">size 4096 items</td>
</tr>
<tr><td>scalar</td>
<td>0.284</td>
<td>0.289</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████▎</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.285</td>
<td>0.288</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████▏</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.437</td>
<td>0.441</td>
<td>0.65</td>
<td><tt class="docutils literal"><span class="pre">██████</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.243</td>
<td>0.246</td>
<td>1.17</td>
<td><tt class="docutils literal"><span class="pre">██████████▊</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.177</td>
<td>0.186</td>
<td>1.60</td>
<td><tt class="docutils literal"><span class="pre">██████████████▊</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.177</td>
<td>0.185</td>
<td>1.60</td>
<td><tt class="docutils literal"><span class="pre">██████████████▊</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.222</td>
<td>0.224</td>
<td>1.28</td>
<td><tt class="docutils literal"><span class="pre">███████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.135</td>
<td>0.137</td>
<td>2.10</td>
<td><tt class="docutils literal"><span class="pre">███████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.106</td>
<td>0.109</td>
<td>2.68</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.104</td>
<td>0.109</td>
<td>2.73</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▎</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.055</td>
<td>0.059</td>
<td>5.16</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.061</td>
<td>0.066</td>
<td>4.66</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████████████████</span></tt></td>
</tr>
<tr><td colspan="5">size 16384 items</td>
</tr>
<tr><td>scalar</td>
<td>0.281</td>
<td>0.284</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████▎</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.282</td>
<td>0.283</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████▏</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.437</td>
<td>0.438</td>
<td>0.64</td>
<td><tt class="docutils literal"><span class="pre">█████▉</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.242</td>
<td>0.243</td>
<td>1.16</td>
<td><tt class="docutils literal"><span class="pre">██████████▋</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.176</td>
<td>0.182</td>
<td>1.60</td>
<td><tt class="docutils literal"><span class="pre">██████████████▊</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.176</td>
<td>0.182</td>
<td>1.60</td>
<td><tt class="docutils literal"><span class="pre">██████████████▊</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.219</td>
<td>0.220</td>
<td>1.28</td>
<td><tt class="docutils literal"><span class="pre">███████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.132</td>
<td>0.134</td>
<td>2.13</td>
<td><tt class="docutils literal"><span class="pre">███████████████████▋</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.103</td>
<td>0.105</td>
<td>2.73</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.102</td>
<td>0.104</td>
<td>2.75</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.052</td>
<td>0.053</td>
<td>5.40</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.055</td>
<td>0.057</td>
<td>5.11</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████████████████████▎</span></tt></td>
</tr>
<tr><td colspan="5">size 32768 items</td>
</tr>
<tr><td>scalar</td>
<td>0.281</td>
<td>0.283</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████▎</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.281</td>
<td>0.282</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████▎</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.437</td>
<td>0.438</td>
<td>0.64</td>
<td><tt class="docutils literal"><span class="pre">█████▉</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.242</td>
<td>0.243</td>
<td>1.16</td>
<td><tt class="docutils literal"><span class="pre">██████████▋</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.177</td>
<td>0.182</td>
<td>1.59</td>
<td><tt class="docutils literal"><span class="pre">██████████████▋</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.177</td>
<td>0.182</td>
<td>1.59</td>
<td><tt class="docutils literal"><span class="pre">██████████████▋</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.219</td>
<td>0.220</td>
<td>1.28</td>
<td><tt class="docutils literal"><span class="pre">███████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.133</td>
<td>0.134</td>
<td>2.11</td>
<td><tt class="docutils literal"><span class="pre">███████████████████▌</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.103</td>
<td>0.105</td>
<td>2.73</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.103</td>
<td>0.105</td>
<td>2.73</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.052</td>
<td>0.054</td>
<td>5.40</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.057</td>
<td>0.058</td>
<td>4.93</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████▌</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cannonlake">
<h2>CannonLake</h2>
<p>CPU: Intel(R) Core(TM) i3-8121U CPU &#64; 2.20GHz</p>
<p>Compiler: g++ (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5)</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="9%" />
<col width="8%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="5">size 4096 items</td>
</tr>
<tr><td>scalar</td>
<td>0.203</td>
<td>0.205</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████████▌</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.203</td>
<td>0.205</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████████▌</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.303</td>
<td>0.306</td>
<td>0.67</td>
<td><tt class="docutils literal"><span class="pre">█████████</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.175</td>
<td>0.177</td>
<td>1.16</td>
<td><tt class="docutils literal"><span class="pre">███████████████▋</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.154</td>
<td>0.155</td>
<td>1.32</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▊</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.154</td>
<td>0.155</td>
<td>1.32</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.153</td>
<td>0.155</td>
<td>1.33</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▉</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.102</td>
<td>0.104</td>
<td>1.99</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.089</td>
<td>0.091</td>
<td>2.28</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.072</td>
<td>0.075</td>
<td>2.82</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.061</td>
<td>0.062</td>
<td>3.33</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.055</td>
<td>0.058</td>
<td>3.69</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td colspan="5">size 16384 items</td>
</tr>
<tr><td>scalar</td>
<td>0.196</td>
<td>0.198</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████████▌</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.196</td>
<td>0.197</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████████▌</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.302</td>
<td>0.304</td>
<td>0.65</td>
<td><tt class="docutils literal"><span class="pre">████████▊</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.173</td>
<td>0.174</td>
<td>1.13</td>
<td><tt class="docutils literal"><span class="pre">███████████████▎</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.152</td>
<td>0.153</td>
<td>1.29</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▍</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.152</td>
<td>0.153</td>
<td>1.29</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.151</td>
<td>0.153</td>
<td>1.30</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▌</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.099</td>
<td>0.101</td>
<td>1.98</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.087</td>
<td>0.088</td>
<td>2.25</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████▌</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.071</td>
<td>0.073</td>
<td>2.76</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.058</td>
<td>0.059</td>
<td>3.38</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.054</td>
<td>0.056</td>
<td>3.63</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████████▏</span></tt></td>
</tr>
<tr><td colspan="5">size 32768 items</td>
</tr>
<tr><td>scalar</td>
<td>0.195</td>
<td>0.197</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████████▌</span></tt></td>
</tr>
<tr><td>scalar (C++)</td>
<td>0.195</td>
<td>0.197</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">█████████████▌</span></tt></td>
</tr>
<tr><td>SSE</td>
<td>0.302</td>
<td>0.305</td>
<td>0.65</td>
<td><tt class="docutils literal"><span class="pre">████████▋</span></tt></td>
</tr>
<tr><td>SSE (v2)</td>
<td>0.173</td>
<td>0.174</td>
<td>1.13</td>
<td><tt class="docutils literal"><span class="pre">███████████████▎</span></tt></td>
</tr>
<tr><td>SSE (sadbw)</td>
<td>0.151</td>
<td>0.153</td>
<td>1.29</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▍</span></tt></td>
</tr>
<tr><td>SSE (sadbw, unrolled)</td>
<td>0.151</td>
<td>0.153</td>
<td>1.29</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2</td>
<td>0.151</td>
<td>0.153</td>
<td>1.29</td>
<td><tt class="docutils literal"><span class="pre">█████████████████▍</span></tt></td>
</tr>
<tr><td>AVX2 (v2)</td>
<td>0.099</td>
<td>0.101</td>
<td>1.97</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████▋</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw)</td>
<td>0.087</td>
<td>0.087</td>
<td>2.24</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████▎</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, unrolled)</td>
<td>0.071</td>
<td>0.072</td>
<td>2.75</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX2 (sadbw, variant)</td>
<td>0.058</td>
<td>0.059</td>
<td>3.36</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████████████████▌</span></tt></td>
</tr>
<tr><td>AVX2 (maddubs)</td>
<td>0.055</td>
<td>0.057</td>
<td>3.55</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████████████████████████████</span></tt></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="conclusions">
<h1>Conclusions</h1>
<ul class="simple">
<li>On Skylake and SkylakeX architectures <a class="reference internal" href="#sadbw">VSADBW method</a> is fastest, 2.5
times faster than compiled code.</li>
<li>On Haswell <a class="reference internal" href="#maddubs">VPMADDUBSW method</a> significantly outperforms other approaches,
it's faster 1.7 times than <a class="reference internal" href="#sadbw-variant">single VPSADBW method</a>. However, on Skylake and
newer architectures both methods are comparable.</li>
<li>The results from GCC presented in this article before 2019-02-04 were worse
for SkylakeX &mdash; to my surprise the flag <tt class="docutils literal"><span class="pre">-O3</span></tt> doesn't enable <tt class="docutils literal"><span class="pre">-funroll-loops</span></tt>.
Thanks to <a class="reference external" href="https://twitter.com/richardstartin/status/1092146069037895682">Richard Startin</a> and <a class="reference external" href="https://twitter.com/trav_downs/status/1092152656641048576">Travis Downs</a> for pointing this out.</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<h1>Acknowledgements</h1>
<p>Big thanks to <a class="reference external" href="http://lemire.me/">Daniel Lemire</a> who provides access to Skylake, SkylakeX and
CannonLake machines, where I can run benchmarks.</p>
</div>
<div class="section" id="source-code">
<span id="sources"></span><h1>Source code</h1>
<p>Source code is available on <a class="reference external" href="https://github.com/WojciechMula/toys/tree/master/sse-sumbytes/int8_t">github</a>.</p>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2018-11-18-sse-sumbytes-part2.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:39 GMT -->
</html>
