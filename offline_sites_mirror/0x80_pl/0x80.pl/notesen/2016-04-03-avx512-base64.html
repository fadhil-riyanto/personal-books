<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from 0x80.pl/notesen/2016-04-03-avx512-base64.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:46 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="author" content="Wojciech Muła" />
<title>Base64 encoding &amp; decoding using AVX512BW instructions</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body><script src="../switch_theme.js" type="text/javascript"></script>
<div class="document" id="base64-encoding-decoding-using-avx512bw-instructions">
<h1 class="title">Base64 encoding &amp; decoding using AVX512BW instructions</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Wojciech Muła</td></tr>
<tr class="added-on field"><th class="docinfo-name">Added on:</th><td class="field-body">2016-04-03</td>
</tr>
<tr class="updated-on field"><th class="docinfo-name">Updated on:</th><td class="field-body">2018-12-08 (performance results from Cannon Lake [AVX512VL &amp; AVX512VBMI]),
2018-11-05 (performance results from SkylakeX [AVX512BW])</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#encoding" id="toc-entry-2">Encoding</a><ul>
<li><a class="reference internal" href="#steps-1-2-loading-data-and-splitting-bytes" id="toc-entry-3">Steps 1 &amp; 2 &mdash; Loading data and splitting bytes</a><ul>
<li><a class="reference internal" href="#avx512bw" id="toc-entry-4">AVX512BW</a></li>
<li><a class="reference internal" href="#avx512vbmi" id="toc-entry-5">AVX512VBMI</a></li>
</ul>
</li>
<li><a class="reference internal" href="#step-3-moving-6-bit-word-to-separate-bytes" id="toc-entry-6">Step 3 &mdash; moving 6-bit word to separate bytes</a><ul>
<li><a class="reference internal" href="#avx512f" id="toc-entry-7">AVX512F</a></li>
<li><a class="reference internal" href="#avx512bw-1" id="toc-entry-8">AVX512BW</a></li>
<li><a class="reference internal" href="#avx512vl" id="toc-entry-9">AVX512VL</a></li>
</ul>
</li>
<li><a class="reference internal" href="#step-4-conversion-to-ascii" id="toc-entry-10">Step 4 &mdash; conversion to ASCII</a><ul>
<li><a class="reference internal" href="#avx512bw-2" id="toc-entry-11">AVX512BW</a></li>
<li><a class="reference internal" href="#avx512vbmi-1" id="toc-entry-12">AVX512VBMI</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#decoding" id="toc-entry-13">Decoding</a><ul>
<li><a class="reference internal" href="#step-1-translation-from-ascii" id="toc-entry-14">Step 1 &mdash; translation from ASCII</a><ul>
<li><a class="reference internal" href="#avx512bw-3" id="toc-entry-15">AVX512BW</a></li>
<li><a class="reference internal" href="#avx512vbmi-2" id="toc-entry-16">AVX512VBMI</a></li>
</ul>
</li>
<li><a class="reference internal" href="#step-2-packing-bit-fields" id="toc-entry-17">Step 2 &mdash; Packing bit-fields</a><ul>
<li><a class="reference internal" href="#step-a" id="toc-entry-18">Step A</a></li>
<li><a class="reference internal" href="#step-b-avx512bw" id="toc-entry-19">Step B &mdash; AVX512BW</a></li>
<li><a class="reference internal" href="#step-b-avx512vbmi" id="toc-entry-20">Step B &mdash; AVX512VBMI</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#performance-evaluation" id="toc-entry-21">Performance evaluation</a><ul>
<li><a class="reference internal" href="#skylakex" id="toc-entry-22">SkylakeX</a><ul>
<li><a class="reference internal" href="#encoding-1" id="toc-entry-23">Encoding</a></li>
<li><a class="reference internal" href="#decoding-1" id="toc-entry-24">Decoding</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cannon-lake" id="toc-entry-25">Cannon Lake</a><ul>
<li><a class="reference internal" href="#encoding-2" id="toc-entry-26">Encoding</a></li>
<li><a class="reference internal" href="#decoding-2" id="toc-entry-27">Decoding</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#assembly-dumps" id="toc-entry-28">Assembly dumps</a><ul>
<li><a class="reference internal" href="#encoding-3" id="toc-entry-29">Encoding</a><ul>
<li><a class="reference internal" href="#avx512bw-4" id="toc-entry-30">AVX512BW</a></li>
<li><a class="reference internal" href="#avx512vbmi-3" id="toc-entry-31">AVX512VBMI</a></li>
<li><a class="reference internal" href="#avx512vl-1" id="toc-entry-32">AVX512VL</a></li>
</ul>
</li>
<li><a class="reference internal" href="#decoding-3" id="toc-entry-33">Decoding</a><ul>
<li><a class="reference internal" href="#avx512bw-5" id="toc-entry-34">AVX512BW</a></li>
<li><a class="reference internal" href="#avx512vbmi-4" id="toc-entry-35">AVX512VBMI</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#summary" id="toc-entry-36">Summary</a></li>
<li><a class="reference internal" href="#sample-code" id="toc-entry-37">Sample code</a></li>
<li><a class="reference internal" href="#changes" id="toc-entry-38">Changes</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1>Introduction</h1>
<p>The SIMD versions of base64 conversion algorithms were described in
<a class="reference external" href="2016-01-12-sse-base64-encoding.html">Base64 encoding with SIMD instructions</a> and <a class="reference external" href="2016-01-17-sse-base64-decoding.html">Base64 decoding with
SIMD instructions</a>.  I also described realization of both encoding and
decoding using <a class="reference external" href="2016-09-17-avx512-foundation-base64.html">AVX512F (Foundation)</a> instructions.</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/AVX-512">AVX512BW (Byte &amp; Word)</a> comes with a great number of new instructions;
following instructions can help base64-related problems:</p>
<ul class="simple">
<li><tt class="docutils literal">vpshufb</tt> (intrinsic <tt class="docutils literal">_mm512_shuffle_epi8</tt>) &mdash; does a lookup
in 128-bit lanes. For base64 algorithm it's sufficient;</li>
<li><tt class="docutils literal">vpermd</tt> (<tt class="docutils literal">_mm512_permutexvar_epi32</tt>) &mdash; moves 32-bit
words <strong>across</strong> the 128-bit lanes;</li>
<li><tt class="docutils literal">vpsllvw</tt> (<tt class="docutils literal">_mm512_sllv_epi16</tt>) and <tt class="docutils literal">vpsrlvw</tt> (<tt class="docutils literal">_mm512_srlv_epi16</tt>)
--- shifts individual 16-bit words by a variable amount, saved in a ZMM
register.</li>
</ul>
<p>The extension <strong>AVX512VBMI</strong> adds even more powerful instructions:</p>
<ul class="simple">
<li><tt class="docutils literal">vpermb</tt> (<tt class="docutils literal">_mm512_permutexvar_epi8</tt>) &mdash; does a lookup in a 64-byte table
(a ZMM register). Unlike <tt class="docutils literal">pshufb</tt> it doesn't destroy the lookup register;</li>
<li><tt class="docutils literal">vpermi2b</tt> (<tt class="docutils literal">_mm512_permutex2var_epi8</tt>) &mdash; does a lookup in a 128-byte
table formed by two ZMM registers.</li>
</ul>
<p>The extension <strong>AVX512VL</strong> adds just one, but really nice instruction:</p>
<ul class="simple">
<li><tt class="docutils literal">vpmultishiftqb</tt> (<tt class="docutils literal">_mm512_multishift_epi64_epi8</tt>) &mdash; moves 8-bit subwords
onto selected bytes.</li>
</ul>
<p><strong>2018-04-18</strong>: In the earlier versions of this text I wrongly assumed that
instructions <tt class="docutils literal">vpermb</tt> and <tt class="docutils literal">vpermi2b</tt> are part of AVX512BW. Sorry for
that.</p>
</div>
<div class="section" id="encoding">
<h1>Encoding</h1>
<p>The SIMD encoding consist following steps:</p>
<ol class="arabic simple">
<li>In each step 48 bytes are loaded (16 * 24 bit).</li>
<li>Split each 24-bit words into separate 32-bit lanes.</li>
<li>In each 32-bit lane move 6-bit words to separate bytes.</li>
<li>Convert 6-bit indices to ASCII, according to base64 lookup.</li>
</ol>
<div class="section" id="steps-1-2-loading-data-and-splitting-bytes">
<h2>Steps 1 &amp; 2 &mdash; Loading data and splitting bytes</h2>
<p>In a SSE code loading data and splitting 24-bit words into 32-bit lanes is done
by <tt class="docutils literal">pshufb</tt> instruction. In AVX2 the instruction operates on 128-bit lanes,
making this step more complicated.</p>
<div class="section" id="avx512bw">
<h3>AVX512BW</h3>
<p>In case of AVX512BW two shuffles are needed.</p>
<ol class="arabic" start="0">
<li><p class="first">Initial layout of the register after loading the data. We need only triplets
<tt class="docutils literal">A</tt> .. <tt class="docutils literal">P</tt>:</p>
<div class="asciidiag"><pre class="asciidiag">
[<span style="color: gray">????</span>|<span style="color: gray">????</span>|<span style="color: gray">????</span>|<span style="color: gray">????</span>|<span style="color: red; font-weight: bold">PPPO</span>|<span style="color: red; font-weight: bold">OONN</span>|<span style="color: red; font-weight: bold">NMMM</span>|<span style="color: green; font-weight: bold">LLLK</span>|<span style="color: green; font-weight: bold">KKJJ</span>|<span style="color: green; font-weight: bold">JIII</span>|<span style="color: blue; font-weight: bold">HHHG</span>|<span style="color: blue; font-weight: bold">GGFF</span>|<span style="color: blue; font-weight: bold">FEEE</span>|<span style="font-weight: bold; color: magenta">DDDC</span>|<span style="font-weight: bold; color: magenta">CCBB</span>|<span style="font-weight: bold; color: magenta">BAAA</span>]
|     lane 3        ╵     lane 2        ╵     lane 1        ╵     lane 0        |</pre></div></li>
<li><p class="first">Move 32-bit words across lanes using <tt class="docutils literal">vpermd</tt>:</p>
<div class="asciidiag"><pre class="asciidiag">
[<span style="color: gray">0000</span>|<span style="color: red; font-weight: bold">PPPO</span>|<span style="color: red; font-weight: bold">OONN</span>|<span style="color: red; font-weight: bold">NMMM</span>|<span style="color: gray">0000</span>|<span style="color: green; font-weight: bold">LLLK</span>|<span style="color: green; font-weight: bold">KKJJ</span>|<span style="color: blue; font-weight: bold">JIII</span>|<span style="color: gray">0000</span>|<span style="color: blue; font-weight: bold">HHHG</span>|<span style="color: blue; font-weight: bold">GGFF</span>|<span style="color: blue; font-weight: bold">FEEE</span>|<span style="color: gray">0000</span>|<span style="font-weight: bold; color: magenta">DDDC</span>|<span style="font-weight: bold; color: magenta">CCBB</span>|<span style="font-weight: bold; color: magenta">BAAA</span>]
|     lane 3        ╵     lane 2        ╵     lane 1        ╵     lane 0        |</pre></div></li>
<li><p class="first">Reshuffle bytes within 128-bit lanes to format required by the AVX512BW/AVX512VL
unpack procedure, which is shown in the next section.</p>
<p>The input layout of single lane (0th):</p>
<pre class="literal-block">
[00 00 00 00|D2 D1 D0 C2|C1 C0 B2 B1|B0 A2 A1 A0]
|  4 bytes  |
</pre>
<p>The layout of lane after shuffling; the order of bytes within 32-bit word is 1, 2, 0, 1:</p>
<pre class="literal-block">
[D1 D2 D0 D1|C1 C2 C0 C1|B1 B2 B0 B1|A1 A2 A0 A1]
 10 11 9  10 7  8  6  7  4  5  3  4  1  2  0  1
</pre>
</li>
</ol>
<p>First one moves data across the 128-bit lanes. Then in each lane bytes are
shuffled into desired positions.</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutexvar_epi32</span><span class="p">(</span><span class="w">
    </span><span class="n">_mm512_set_epi32</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
    </span><span class="n">tmp1</span><span class="w">
</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">tmp3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_shuffle_epi8</span><span class="p">(</span><span class="w">
    </span><span class="n">tmp2</span><span class="p">,</span><span class="w">
    </span><span class="n">_mm512_set4_epi32</span><span class="p">(</span><span class="mh">0x0a0b090a</span><span class="p">,</span><span class="w"> </span><span class="mh">0x07080607</span><span class="p">,</span><span class="w"> </span><span class="mh">0x04050304</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01020001</span><span class="p">)</span><span class="w">
</span><span class="p">);</span>
</pre>
</div>
<div class="section" id="avx512vbmi">
<span id="encode-step12-avx512vbmi"></span><h3>AVX512VBMI</h3>
<p>In case of AVX512VBMI the problem is solved with one invocation of
<tt class="docutils literal">vpermb</tt>.</p>
<pre class="code cpp literal-block">
<span class="c1">// load 48 bytes
// v = [...|DDDC|CCBB|BAAA]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_loadu_si512</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">

</span><span class="c1">// split 24-bit words to 32-bit lanes
// in = [...|0DDD|0CCC|0BBB|0AAA]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutexvar_epi8</span><span class="p">(</span><span class="n">shuffle_input</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
</pre>
</div>
</div>
<div class="section" id="step-3-moving-6-bit-word-to-separate-bytes">
<h2>Step 3 &mdash; moving 6-bit word to separate bytes</h2>
<p>Each 32-bit input word contains four 6-bit fields <tt class="docutils literal">a</tt>, <tt class="docutils literal">b</tt>, <tt class="docutils literal">c</tt>
and <tt class="docutils literal">d</tt>; the expected output from this step:</p>
<div class="asciidiag"><pre class="asciidiag">
[<span style="color: gray">00</span><span style="font-weight: bold; color: magenta">dddddd</span>|<span style="color: gray">00</span><span style="color: blue; font-weight: bold">cccccc</span>|<span style="color: gray">00</span><span style="color: green; font-weight: bold">bbbbbb</span>|<span style="color: gray">00</span><span style="color: red; font-weight: bold">aaaaaa</span>]</pre></div><div class="section" id="avx512f">
<h3>AVX512F</h3>
<p>Input order of fields is following:</p>
<div class="asciidiag"><pre class="asciidiag">
[????????|<span style="color: blue; font-weight: bold">cc</span><span style="font-weight: bold; color: magenta">dddddd</span>|<span style="color: green; font-weight: bold">bbbb</span><span style="color: blue; font-weight: bold">cccc</span>|<span style="color: red; font-weight: bold">aaaaaa</span><span style="color: green; font-weight: bold">bb</span>]</pre></div><p>Below is an AVX512F version from <a class="reference external" href="2016-09-17-avx512-foundation-base64.html">the article linked above</a>.  Lack of
byte-level instructions makes the procedure pretty complicated.</p>
<pre class="code cpp literal-block">
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask</span><span class="o">&gt;</span><span class="w">
</span><span class="n">__m512i</span><span class="w"> </span><span class="n">merge</span><span class="p">(</span><span class="n">__m512i</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">shifted</span><span class="p">;</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">shifted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_srli_epi32</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">shift</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">shifted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_slli_epi32</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">shift</span><span class="p">);</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">_mm512_ternarylogic_epi32</span><span class="p">(</span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span><span class="w"> </span><span class="n">shifted</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="mh">0xca</span><span class="p">);</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">__m512i</span><span class="w"> </span><span class="n">unpack</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="c1">// [00000000|00000000|00000000|00aaaaaa]
</span><span class="w">    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_and_si512</span><span class="p">(</span><span class="n">_mm512_srli_epi32</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">packed_dword</span><span class="p">(</span><span class="mh">0x0000003f</span><span class="p">));</span><span class="w">

    </span><span class="c1">// [00000000|00000000|00BB0000|00aaaaaa]
</span><span class="w">    </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">merge</span><span class="o">&lt;</span><span class="mi">-12</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00003000</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w">

    </span><span class="c1">// [00000000|00000000|00BBbbbb|00aaaaaa]
</span><span class="w">    </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">merge</span><span class="o">&lt;</span><span class="w">  </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00000f00</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w">

    </span><span class="c1">// [00000000|00CCCC00|00BBbbbb|00aaaaaa]
</span><span class="w">    </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">merge</span><span class="o">&lt;</span><span class="mi">-10</span><span class="p">,</span><span class="w"> </span><span class="mh">0x003c0000</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w">

    </span><span class="c1">// [00000000|00CCCCcc|00BBbbbb|00aaaaaa]
</span><span class="w">    </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">merge</span><span class="o">&lt;</span><span class="w">  </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00030000</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w">

    </span><span class="c1">// [00dddddd|00CCCCcc|00BBbbbb|00aaaaaa]
</span><span class="w">    </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">merge</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">-8</span><span class="p">,</span><span class="w"> </span><span class="mh">0x3f000000</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">indices</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx512bw-1">
<span id="encode-step3-avx512bw"></span><h3>AVX512BW</h3>
<p>The unpacking could be performed faster with help of <tt class="docutils literal">vpsllvw</tt> and
<tt class="docutils literal">vpsrlvw</tt> instructions. This require a change in the 32-bit lane format
from:</p>
<div class="asciidiag"><pre class="asciidiag">
[????????|<span style="color: blue; font-weight: bold">cc</span><span style="font-weight: bold; color: magenta">dddddd</span>|<span style="color: green; font-weight: bold">bbbb</span><span style="color: blue; font-weight: bold">cccc</span>|<span style="color: red; font-weight: bold">aaaaaa</span><span style="color: green; font-weight: bold">bb</span>]
           byte 2   byte 1   byte 0</pre></div><p>to:</p>
<div class="asciidiag"><pre class="asciidiag">
[<span style="color: green">bbbb</span><span style="color: blue; font-weight: bold">cccc</span>|<span style="color: blue; font-weight: bold">cc</span><span style="font-weight: bold; color: magenta">dddddd</span>|<span style="color: red; font-weight: bold">aaaaaa</span><span style="color: green; font-weight: bold">bb</span>|<span style="color: green; font-weight: bold">bbbb</span><span style="color: blue">cccc</span>]
 ^^^^                           ^^^^
 unused bits             unused bits

 byte 1    byte 2   byte 0   byte 1</pre></div><p>It does require only different vector passed to <tt class="docutils literal">vpshufb</tt> (AVX512BW) or
<tt class="docutils literal">vpermb</tt> (AVX512VBMI) used for splitting bytes.</p>
<p>Algorithm:</p>
<ol class="arabic simple">
<li>Isolate fields <tt class="docutils literal">a</tt> and <tt class="docutils literal">c</tt>.</li>
</ol>
<pre class="code cpp literal-block">
<span class="c1">// t0    = [0000cccc|cc000000|aaaaaa00|00000000]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_and_si512</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="mh">0x0fc0fc00</span><span class="p">));</span>
</pre>
<ol class="arabic simple" start="2">
<li>Shift right the field <tt class="docutils literal">a</tt> by 10 bits, and the field <tt class="docutils literal">c</tt> by 6 bits.</li>
</ol>
<pre class="code cpp literal-block">
<span class="c1">// t1    = [00000000|00cccccc|00000000|00aaaaaa]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_srlv_epi16</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="mh">0x0006000a</span><span class="p">));</span>
</pre>
<ol class="arabic simple" start="3">
<li>Shift left the field <tt class="docutils literal">b</tt> by 4 bits, and the field <tt class="docutils literal">d</tt> by 8 bits
(note that no masking is done.)</li>
</ol>
<pre class="code cpp literal-block">
<span class="c1">// t2    = [ccdddddd|00000000|aabbbbbb|cccc0000]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_sllv_epi16</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="mh">0x00080004</span><span class="p">));</span>
</pre>
<ol class="arabic simple" start="4">
<li>Finally copy the selected bits from <tt class="docutils literal">t2</tt> to <tt class="docutils literal">t1</tt>.</li>
</ol>
<pre class="code cpp literal-block">
<span class="c1">//         = [00dddddd|00cccccc|00bbbbbb|00aaaaaa]
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_ternarylogic_epi32</span><span class="p">(</span><span class="n">_mm512_set1_epi32</span><span class="p">(</span><span class="mh">0x3f003f00</span><span class="p">),</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="mh">0xca</span><span class="p">);</span>
</pre>
<p>The procedure costs just two shifts and two bitwise operations.</p>
</div>
<div class="section" id="avx512vl">
<span id="encode-step3-avx512vl"></span><span id="vpmultishift"></span><h3>AVX512VL</h3>
<p>AVX512VL defines the instruction <tt class="docutils literal">vpmultishiftqb</tt>, that may replace all variable
shift instructions from the previous point. Please note that the layout of
32-bit lanes require the same modification as described in the previous point.</p>
<p>The instruction builds a vector of bytes from octets located at <strong>any position</strong>
in a quadword. Following psudocode shows the algorithm:</p>
<pre class="code ada literal-block">
<span class="kr">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">7</span> <span class="kr">loop</span>
    <span class="n">qword</span> <span class="p">:=</span> <span class="n">input</span><span class="p">.</span><span class="n">qword</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="kr">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">7</span> <span class="kr">loop</span>
        <span class="n">index</span> <span class="p">:=</span> <span class="n">indices</span><span class="p">.</span><span class="kt">byte</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
        <span class="n">output</span><span class="p">.</span><span class="kt">byte</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">qword</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span><span class="n">xff</span><span class="p">;</span>
    <span class="kr">end</span> <span class="kr">loop</span>
<span class="nf">end</span> <span class="kr">loop</span>
</pre>
<p>Although <tt class="docutils literal">vpmultishiftqb</tt> produces a vector of bytes and the encoding needs just
6 lower bits, no masking is needed. The instruction <tt class="docutils literal">vpermb</tt> (described above)
does masking internally.</p>
<p>Below is a code snippet the shows the proper parameters for <tt class="docutils literal">vpmultishiftqb</tt>.</p>
<pre class="code cpp literal-block">
<span class="c1">// after multishift a single 32-bit lane has following layout:
// [bbbbcccc|bbcccccc|aabbbbbb|ddaaaaaa],
// i.e.: (a = [10:17], b = [4:11], c = [22:27], d = [16:21])
</span><span class="w">
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">shifts</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">packed_qword</span><span class="p">(</span><span class="mh">0x3036242a1016040alu</span><span class="p">);</span><span class="w"> </span><span class="c1">// 48, 54, 36, 42, 16, 22, 4, 10
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_multishift_epi64_epi8</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span>
</pre>
</div>
</div>
<div class="section" id="step-4-conversion-to-ascii">
<h2>Step 4 &mdash; conversion to ASCII</h2>
<p>The last part of the algorithm is converting, in parallel, all 6-bit
indices into ASCII codes.</p>
<div class="section" id="avx512bw-2">
<span id="encode-step4-avx512bw"></span><span id="avx512bw-encode-lookup"></span><h3>AVX512BW</h3>
<p>Although <tt class="docutils literal">vpshufb</tt> works on 128-bit lanes it is sufficient for conversion.
The <a class="reference external" href="2016-01-12-sse-base64-encoding.html#id4">fastest procedure</a> from SSE might be translated one-to-one:</p>
<pre class="code cpp literal-block">
<span class="n">__m512i</span><span class="w"> </span><span class="nf">lookup_pshufb_improved</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="c1">// reduce  0..51 -&gt; 0
</span><span class="w">    </span><span class="c1">//        52..61 -&gt; 1 .. 10
</span><span class="w">    </span><span class="c1">//            62 -&gt; 11
</span><span class="w">    </span><span class="c1">//            63 -&gt; 12
</span><span class="w">    </span><span class="n">__m512i</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_subs_epu8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">packed_byte</span><span class="p">(</span><span class="mi">51</span><span class="p">));</span><span class="w">

    </span><span class="c1">// distinguish between ranges 0..25 and 26..51:
</span><span class="w">    </span><span class="c1">//         0 .. 25 -&gt; remains 0
</span><span class="w">    </span><span class="c1">//        26 .. 51 -&gt; becomes 13
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">__mmask64</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpgt_epi8_mask</span><span class="p">(</span><span class="n">packed_byte</span><span class="p">(</span><span class="mi">26</span><span class="p">),</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w">
    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_mov_epi8</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">less</span><span class="p">,</span><span class="w"> </span><span class="n">packed_byte</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span><span class="w">

    </span><span class="cm">/* the SSE lookup is readable
        const __m128i shift_LUT = _mm_setr_epi8(
            'a' - 26, '0' - 52, '0' - 52, '0' - 52, '0' - 52, '0' - 52,
            '0' - 52, '0' - 52, '0' - 52, '0' - 52, '0' - 52, '+' - 62,
            '/' - 63, 'A', 0, 0
        );
    */</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">shift_LUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set4_epi32</span><span class="p">(</span><span class="w">
        </span><span class="mh">0x000041f0</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xedfcfcfc</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xfcfcfcfc</span><span class="p">,</span><span class="w">
        </span><span class="mh">0xfcfcfc47</span><span class="w">
    </span><span class="p">);</span><span class="w">

    </span><span class="c1">// read shift
</span><span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_shuffle_epi8</span><span class="p">(</span><span class="n">shift_LUT</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">_mm512_add_epi8</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx512vbmi-1">
<span id="encode-step4-avx512vbmi"></span><h3>AVX512VBMI</h3>
<p>The already introduced instruction <tt class="docutils literal">vpermb</tt> does lookup in an AVX512 64-byte
register. This is exactly the size of lookup table needed by the encoding
algorithm. Thus, just <strong>a single invocation</strong> of the instruction is needed.</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutexvar_epi8</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">lookup</span><span class="p">);</span>
</pre>
</div>
</div>
</div>
<div class="section" id="decoding">
<h1>Decoding</h1>
<p>The SIMD decoding consists following steps:</p>
<ol class="arabic simple">
<li>Translate in parallel from ASCII into 6-bit values saved on separate bytes.
At this stage the error detection is performed.</li>
<li>Pack 6-bit data into continuous bit stream &mdash; the result has 48 bytes.</li>
</ol>
<div class="section" id="step-1-translation-from-ascii">
<h2>Step 1 &mdash; translation from ASCII</h2>
<div class="section" id="avx512bw-3">
<span id="avx512bw-decode-lookup"></span><h3>AVX512BW</h3>
<p>In case of decoding the limitations of <tt class="docutils literal">vpshufb</tt> also are not the problem,
the <a class="reference external" href="2016-01-17-sse-base64-decoding.html#vector-lookup-pshufb-with-bitmask-new">fastest SSE decoding</a> solution can be applied. Below is the actual
implementation.</p>
<pre class="code cpp literal-block">
<span class="n">__m512i</span><span class="w"> </span><span class="nf">lookup_pshufb_bitmask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">higher_nibble</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_and_si512</span><span class="p">(</span><span class="n">_mm512_srli_epi32</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="n">packed_byte</span><span class="p">(</span><span class="mh">0x0f</span><span class="p">));</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">lower_nibble</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_and_si512</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">packed_byte</span><span class="p">(</span><span class="mh">0x0f</span><span class="p">));</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">shiftLUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set4lanes_epi8</span><span class="p">(</span><span class="w">
        </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">19</span><span class="p">,</span><span class="w">   </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">-65</span><span class="p">,</span><span class="w"> </span><span class="mi">-65</span><span class="p">,</span><span class="w"> </span><span class="mi">-71</span><span class="p">,</span><span class="w"> </span><span class="mi">-71</span><span class="p">,</span><span class="w">
        </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">maskLUT</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set4lanes_epi8</span><span class="p">(</span><span class="w">
        </span><span class="cm">/* 0        : 0b1010_1000*/</span><span class="w"> </span><span class="mh">0xa8</span><span class="p">,</span><span class="w">
        </span><span class="cm">/* 1 .. 9   : 0b1111_1000*/</span><span class="w"> </span><span class="mh">0xf8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf8</span><span class="p">,</span><span class="w">
                                    </span><span class="mh">0xf8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf8</span><span class="p">,</span><span class="w">
                                    </span><span class="mh">0xf8</span><span class="p">,</span><span class="w">
        </span><span class="cm">/* 10       : 0b1111_0000*/</span><span class="w"> </span><span class="mh">0xf0</span><span class="p">,</span><span class="w">
        </span><span class="cm">/* 11       : 0b0101_0100*/</span><span class="w"> </span><span class="mh">0x54</span><span class="p">,</span><span class="w">
        </span><span class="cm">/* 12 .. 14 : 0b0101_0000*/</span><span class="w"> </span><span class="mh">0x50</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50</span><span class="p">,</span><span class="w">
        </span><span class="cm">/* 15       : 0b0101_0100*/</span><span class="w"> </span><span class="mh">0x54</span><span class="w">
    </span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">bitposLUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_set4lanes_epi8</span><span class="p">(</span><span class="w">
        </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">,</span><span class="w"> </span><span class="mh">0x04</span><span class="p">,</span><span class="w"> </span><span class="mh">0x08</span><span class="p">,</span><span class="w"> </span><span class="mh">0x10</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="p">,</span><span class="w">
        </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="w">
    </span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w">   </span><span class="n">sh</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_shuffle_epi8</span><span class="p">(</span><span class="n">shiftLUT</span><span class="p">,</span><span class="w">  </span><span class="n">higher_nibble</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__mmask64</span><span class="w"> </span><span class="n">eq_2f</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_cmpeq_epi8_mask</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">packed_byte</span><span class="p">(</span><span class="mh">0x2f</span><span class="p">));</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w">   </span><span class="n">shift</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_mask_mov_epi8</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span><span class="w"> </span><span class="n">eq_2f</span><span class="p">,</span><span class="w"> </span><span class="n">packed_byte</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">M</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_shuffle_epi8</span><span class="p">(</span><span class="n">maskLUT</span><span class="p">,</span><span class="w">   </span><span class="n">lower_nibble</span><span class="p">);</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">bit</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_shuffle_epi8</span><span class="p">(</span><span class="n">bitposLUT</span><span class="p">,</span><span class="w"> </span><span class="n">higher_nibble</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">match</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_test_epi8_mask</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span><span class="w">

    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">match</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">uint64_t</span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// report error
</span><span class="w">    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">_mm512_add_epi8</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">shift</span><span class="p">);</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="avx512vbmi-2">
<span id="decode-step1-avx512vbmi"></span><h3>AVX512VBMI</h3>
<p>This step is a perfect place to utilize the instruction <tt class="docutils literal">vpermi2b</tt>,
it requires three registers:</p>
<ul class="simple">
<li>indices,</li>
<li>the lower &amp; higher halves of a 128-item lookup table.</li>
</ul>
<p>Valid input characters in base64 are always standard ASCII, so they
never have set the most significant bit (MSB). Thanks to that the seven
lowest bits of the input could be directly used as indices for
<tt class="docutils literal">vpermi2b</tt>.  (The instruction simply ignores MSB, so no masking is
required.)</p>
<p>The lookup table has to be precalculated. It translates from an ASCII
code into 6-bit data or an invalid character marker. The marker value is
0x80. Thanks to that both extended ASCII and invalid characters could
be easily identified in one step.</p>
<pre class="code cpp literal-block">
<span class="n">__m512i</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">lookup_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">precalc</span><span class="o">::</span><span class="n">lookup_0</span><span class="p">;</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">lookup_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">precalc</span><span class="o">::</span><span class="n">lookup_1</span><span class="p">;</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">translated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutex2var_epi8</span><span class="p">(</span><span class="n">lookup_0</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">lookup_1</span><span class="p">);</span><span class="w">

    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_movepi8_mask</span><span class="p">(</span><span class="n">translated</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w"> </span><span class="c1">// convert MSBs to the mask
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">report</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="n">translated</span><span class="p">;</span><span class="w">
</span><span class="p">}</span>
</pre>
</div>
</div>
<div class="section" id="step-2-packing-bit-fields">
<span id="avx512bw-decode-pack"></span><h2>Step 2 &mdash; Packing bit-fields</h2>
<p>The final stage of decoding is packing all 6-bit fields into a continues
array of 48 bytes. It is done in two steps:</p>
<ol class="upperalpha simple">
<li>Pack four fields within 32-bit words into 24-bit words.</li>
<li>Move these 3-byte words into the continuous array.</li>
</ol>
<div class="section" id="step-a">
<h3>Step A</h3>
<p>The first step is a direct translation of the SSE code. It uses twice
a multiply-add instruction that does, for given constants, two shifts
and one bitwise or at once.</p>
<pre class="code cpp literal-block">
<span class="c1">// input:  [00dddddd|00cccccc|00bbbbbb|00aaaaaa]
</span><span class="w">
</span><span class="c1">// merge:  [0000cccc|ccdddddd|0000aaaa|aabbbbbb]
</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="n">merge_ab_and_bc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_maddubs_epi16</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">packed_dword</span><span class="p">(</span><span class="mh">0x01400140</span><span class="p">));</span><span class="w">

</span><span class="c1">// result: [00000000|aaaaaabb|bbbbcccc|ccdddddd]
</span><span class="k">return</span><span class="w"> </span><span class="n">_mm_madd_epi16</span><span class="p">(</span><span class="n">merge_ab_and_bc</span><span class="p">,</span><span class="w"> </span><span class="n">packed_dword</span><span class="p">(</span><span class="mh">0x00011000</span><span class="p">));</span>
</pre>
</div>
<div class="section" id="step-b-avx512bw">
<span id="decode-step2b-avx512bw"></span><h3>Step B &mdash; AVX512BW</h3>
<ol class="arabic" start="0">
<li><p class="first">Initial layout of the register after step A:</p>
<pre class="literal-block">
[0PPP|0OOO|0NNN|0MMM|0LLL|0KKK|0JJJ|0III|0HHH|0GGG|0FFF|0EEE|0DDD|0CCC|0BBB|0AAA]
|     lane 3        |     lane 2        |     lane 1        |     lane 0        |
</pre>
</li>
<li><p class="first">Pack bytes within lanes using <tt class="docutils literal">vpshufb</tt>; 3rd doublewords in each lane are empty:</p>
<pre class="literal-block">
[0000|PPPO|OONN|NMMM|0000|LLLK|KKJJ|JIII|0000|HHHG|GGFF|FEEE|0000|DDDC|CCBB|BAAA]
|     lane 3        |     lane 2        |     lane 1        |     lane 0        |
</pre>
</li>
<li><p class="first">Move non-empty 32-bit words across lanes using <tt class="docutils literal">vpermd</tt> and form continuous 48-byte
array:</p>
<pre class="literal-block">
[0000|0000|0000|0000|PPPO|OONN|NMMM|LLLK|KKJJ|JIII|HHHG|GGFF|FEEE|DDDC|CCBB|BAAA]
|     lane 3        |     lane 2        |     lane 1        |     lane 0        |
</pre>
</li>
</ol>
<p>Below is a sample implementation.</p>
<pre class="code cpp literal-block">
<span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_shuffle_epi8</span><span class="p">(</span><span class="w">
    </span><span class="n">packed</span><span class="p">,</span><span class="w">
    </span><span class="n">_mm512_set4lanes_epi8</span><span class="p">(</span><span class="w">
         </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">
         </span><span class="mi">6</span><span class="p">,</span><span class="w">  </span><span class="mi">5</span><span class="p">,</span><span class="w">  </span><span class="mi">4</span><span class="p">,</span><span class="w">
        </span><span class="mi">10</span><span class="p">,</span><span class="w">  </span><span class="mi">9</span><span class="p">,</span><span class="w">  </span><span class="mi">8</span><span class="p">,</span><span class="w">
        </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w">
        </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w">
</span><span class="p">);</span><span class="w">

</span><span class="c1">// shuffle bytes
</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">s6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_setr_epi32</span><span class="p">(</span><span class="w">
     </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">2</span><span class="p">,</span><span class="w">
     </span><span class="mi">4</span><span class="p">,</span><span class="w">  </span><span class="mi">5</span><span class="p">,</span><span class="w">  </span><span class="mi">6</span><span class="p">,</span><span class="w">
     </span><span class="mi">8</span><span class="p">,</span><span class="w">  </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
    </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w">
    </span><span class="c1">// unused
</span><span class="w">     </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">

</span><span class="k">const</span><span class="w"> </span><span class="n">__m512i</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm512_permutexvar_epi32</span><span class="p">(</span><span class="n">s6</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">);</span><span class="w">

</span><span class="n">_mm512_storeu_si512</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">__m512i</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">),</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span>
</pre>
</div>
<div class="section" id="step-b-avx512vbmi">
<span id="decode-step2b-avx512vbmi"></span><h3>Step B &mdash; AVX512VBMI</h3>
<p>In case of AVX512VBMI this step uses just <strong>single</strong> <tt class="docutils literal">vpermb</tt>.</p>
</div>
</div>
</div>
<div class="section" id="performance-evaluation">
<h1>Performance evaluation</h1>
<p><a class="reference external" href="http://lemire.me/">Daniel Lemire</a> gave me access to machines that supports the AVX512BW,
AVX512VL and AVX512VBMI instruction sets. Below are performance results for
both encoding and decoding.</p>
<div class="section" id="skylakex">
<span id="avx512bw-performance"></span><h2>SkylakeX</h2>
<p>CPU: Intel(R) Xeon(R) W-2104 CPU &#64; 3.20GHz</p>
<p>Compiler: gcc (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0</p>
<div class="section" id="encoding-1">
<h3>Encoding</h3>
<table border="1" class="docutils">
<caption>Tested procedures</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>scalar (32 bit)</td>
<td>lookup-based method that loads four input bytes at once</td>
</tr>
<tr><td>scalar (64 bit)</td>
<td>similarly to the above one, but read 8 input bytes</td>
</tr>
<tr><td>AVX2 (lookup: pshufb improved)</td>
<td>code that uses <a class="reference internal" href="#avx512bw-encode-lookup">shuffle-based algorithm</a></td>
</tr>
<tr><td>AVX512BW (lookup: pshufb improved)</td>
<td>exactly the same <a class="reference internal" href="#avx512bw-encode-lookup">shuffle-based algorithm</a></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="7%" />
<col width="7%" />
<col width="6%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar (32 bit)</td>
<td>5.768</td>
<td>6.452</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">███▋</span></tt></td>
</tr>
<tr><td>scalar (64 bit)</td>
<td>5.537</td>
<td>5.599</td>
<td>1.04</td>
<td><tt class="docutils literal"><span class="pre">███▊</span></tt></td>
</tr>
<tr><td>AVX2 (lookup: pshufb unrolled improved)</td>
<td>0.681</td>
<td>0.698</td>
<td>8.47</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX512BW (lookup: optimized2)</td>
<td>0.726</td>
<td>0.734</td>
<td>7.94</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████▎</span></tt></td>
</tr>
<tr><td>AVX512BW (lookup: pshufb improved)</td>
<td>0.425</td>
<td>0.436</td>
<td>13.57</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
<tr><td>AVX512BW (lookup: pshufb improved, unrolled x 2)</td>
<td>0.425</td>
<td>0.441</td>
<td>13.57</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="decoding-1">
<h3>Decoding</h3>
<table border="1" class="docutils">
<caption>Tested procedures</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>scalar</td>
<td>naive lookup-based implementation</td>
</tr>
<tr><td>improved scalar</td>
<td>also lookup-based code, but detection of input errors is done for four input bytes at once</td>
</tr>
<tr><td>AVX2 (lookup: pshufb bitmask, pack: multiply-add)</td>
<td>uses the same algorithm as AVX512BW implementation</td>
</tr>
<tr><td>AVX512BW (lookup: N/A, pack: multiply-add)</td>
<td>implementation of the described above <a class="reference internal" href="#avx512bw-decode-lookup">lookup</a> and <a class="reference internal" href="#avx512bw-decode-pack">pack</a> algorithms</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="7%" />
<col width="7%" />
<col width="6%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>1.023</td>
<td>1.091</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">██████▉</span></tt></td>
</tr>
<tr><td>improved scalar</td>
<td>1.024</td>
<td>1.085</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">██████▉</span></tt></td>
</tr>
<tr><td>AVX2 (lookup: pshufb bitmask, pack: multiply-add)</td>
<td>0.222</td>
<td>0.225</td>
<td>4.61</td>
<td><tt class="docutils literal"><span class="pre">███████████████████████████████▊</span></tt></td>
</tr>
<tr><td>AVX512BW (lookup: N/A, pack: multiply-add)</td>
<td>0.141</td>
<td>0.144</td>
<td>7.26</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="cannon-lake">
<h2>Cannon Lake</h2>
<p>CPU: Intel(R) Core(TM) i3-8121U CPU &#64; 2.20GHz</p>
<p>GCC: gcc (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5)</p>
<div class="section" id="encoding-2">
<h3>Encoding</h3>
<table border="1" class="docutils">
<caption>Tested procedures</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>scalar (32 bit)</td>
<td>lookup-based method that loads four input bytes at once</td>
</tr>
<tr><td>scalar (64 bit)</td>
<td>similarly to the above one, but read 8 input bytes</td>
</tr>
<tr><td>AVX2 (lookup: pshufb improved)</td>
<td>code that uses <a class="reference internal" href="#avx512bw-encode-lookup">shuffle-based algorithm</a></td>
</tr>
<tr><td>AVX512BW (lookup: pshufb improved)</td>
<td>exactly the same <a class="reference internal" href="#avx512bw-encode-lookup">shuffle-based algorithm</a></td>
</tr>
<tr><td>AVX512BW (lookup: pshufb improved, unrolled x 2)</td>
<td>the above procedure unrolled two times</td>
</tr>
<tr><td>AVX512VBMI</td>
<td>step 1 &amp; 2: <a class="reference internal" href="#encode-step12-avx512vbmi">_mm512_permutexvar_epi8</a>,
step 3: <a class="reference internal" href="#encode-step3-avx512bw">AVX512BW code</a>,
step 4: again <a class="reference internal" href="#encode-step4-avx512vbmi">_mm512_permutexvar_epi8</a></td>
</tr>
<tr><td>AVX512VL</td>
<td>step 1 &amp; 2: <a class="reference internal" href="#encode-step12-avx512vbmi">_mm512_permutexvar_epi8</a>,
step 3: <a class="reference internal" href="#encode-step3-avx512vl">_mm512_multishift_epi64_epi8</a>,
step 4: again <a class="reference internal" href="#encode-step4-avx512vbmi">_mm512_permutexvar_epi8</a></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="7%" />
<col width="7%" />
<col width="6%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar (32 bit)</td>
<td>6.082</td>
<td>6.117</td>
<td>1.00</td>
<td><tt class="docutils literal">█▌</tt></td>
</tr>
<tr><td>scalar (64 bit)</td>
<td>6.096</td>
<td>6.134</td>
<td>1.00</td>
<td><tt class="docutils literal">█▌</tt></td>
</tr>
<tr><td>AVX2 (lookup: pshufb unrolled improved)</td>
<td>0.752</td>
<td>0.772</td>
<td>8.09</td>
<td><tt class="docutils literal"><span class="pre">████████████▉</span></tt></td>
</tr>
<tr><td>AVX512BW (lookup: pshufb improved)</td>
<td>0.391</td>
<td>0.405</td>
<td>15.55</td>
<td><tt class="docutils literal"><span class="pre">████████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX512BW (lookup: pshufb improved, unrolled x 2)</td>
<td>0.387</td>
<td>0.399</td>
<td>15.72</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████▏</span></tt></td>
</tr>
<tr><td>AVX512VBMI</td>
<td>0.227</td>
<td>0.233</td>
<td>26.79</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX512VL</td>
<td>0.195</td>
<td>0.202</td>
<td>31.19</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="decoding-2">
<h3>Decoding</h3>
<table border="1" class="docutils">
<caption>Tested procedures</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>scalar</td>
<td>naive lookup-based implementation</td>
</tr>
<tr><td>improved scalar</td>
<td>also lookup-based code, but detection of input errors is done for four input bytes at once</td>
</tr>
<tr><td>AVX2 (lookup: pshufb bitmask, pack: multiply-add)</td>
<td>uses the same algorithm as AVX512BW implementation</td>
</tr>
<tr><td>AVX512BW (lookup: N/A, pack: multiply-add)</td>
<td>implementation of the described above <a class="reference internal" href="#avx512bw-decode-lookup">lookup</a> and <a class="reference internal" href="#avx512bw-decode-pack">pack</a> algorithms</td>
</tr>
<tr><td>AVX512VBMI (lookup: N/A, pack: multiply-add)</td>
<td>lookup is done by <a class="reference internal" href="#decode-step1-avx512vbmi">_mm512_permutexvar_epi8</a> and pack by <a class="reference internal" href="#decode-step2b-avx512vbmi">_mm512_permutex2var_epi8</a></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="7%" />
<col width="7%" />
<col width="6%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">procedure</th>
<th class="head">best</th>
<th class="head">avg.</th>
<th class="head">speedup</th>
<th class="head">&nbsp;</th>
</tr>
<tr><th class="head">&nbsp;</th>
<th class="head">[cycles]</th>
<th class="head">[cycles]</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>scalar</td>
<td>1.030</td>
<td>1.044</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████▏</span></tt></td>
</tr>
<tr><td>improved scalar</td>
<td>1.031</td>
<td>1.043</td>
<td>1.00</td>
<td><tt class="docutils literal"><span class="pre">████▏</span></tt></td>
</tr>
<tr><td>AVX2 (lookup: pshufb bitmask, pack: multiply-add)</td>
<td>0.232</td>
<td>0.234</td>
<td>4.44</td>
<td><tt class="docutils literal"><span class="pre">██████████████████▋</span></tt></td>
</tr>
<tr><td>AVX512BW (lookup: N/A, pack: multiply-add)</td>
<td>0.128</td>
<td>0.131</td>
<td>8.05</td>
<td><tt class="docutils literal"><span class="pre">█████████████████████████████████▉</span></tt></td>
</tr>
<tr><td>AVX512VBMI (lookup: N/A, pack: multiply-add)</td>
<td>0.087</td>
<td>0.089</td>
<td>11.84</td>
<td><tt class="docutils literal"><span class="pre">██████████████████████████████████████████████████</span></tt></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="assembly-dumps">
<h1>Assembly dumps</h1>
<p>Just an inner loops was shown; in case of decoding exception handling
was omitted. Code generated by GCC 7.3.0.</p>
<div class="section" id="encoding-3">
<h2>Encoding</h2>
<div class="section" id="avx512bw-4">
<h3>AVX512BW</h3>
<pre class="code nasm literal-block">
<span class="nf">vpermd</span><span class="w">      </span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">%</span><span class="nb">zmm12</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqa64</span><span class="w">   </span><span class="o">%</span><span class="nb">zmm7</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm26</span><span class="w">
</span><span class="nf">add</span><span class="w">         </span><span class="kc">$</span><span class="mh">0x30</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span><span class="w">
</span><span class="nf">add</span><span class="w">         </span><span class="kc">$</span><span class="mh">0x40</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span><span class="w">
</span><span class="nf">vpshufb</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm11</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpandd</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm9</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpsllvw</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm6</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpsrlvw</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm8</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpternlogd</span><span class="w">  </span><span class="kc">$</span><span class="mh">0xca</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm26</span><span class="w">
</span><span class="nf">vpcmpgtb</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm26</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm4</span><span class="p">,</span><span class="o">%</span><span class="nb">k1</span><span class="w">
</span><span class="nf">vpsubusb</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm5</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm26</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vmovdqu8</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="p">{</span><span class="o">%</span><span class="nb">k1</span><span class="p">}</span><span class="w">
</span><span class="nf">vpshufb</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm10</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpaddb</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm26</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqu64</span><span class="w">   </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">-</span><span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="nb">rdx</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="avx512vbmi-3">
<h3>AVX512VBMI</h3>
<pre class="code nasm literal-block">
<span class="nf">vpermb</span><span class="w">     </span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm7</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqa64</span><span class="w">  </span><span class="o">%</span><span class="nb">zmm2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm16</span><span class="w">
</span><span class="nf">add</span><span class="w">        </span><span class="kc">$</span><span class="mh">0x30</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span><span class="w">
</span><span class="nf">add</span><span class="w">        </span><span class="kc">$</span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rdx</span><span class="w">
</span><span class="nf">vpandd</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm5</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpsllvw</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpsrlvw</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm4</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpternlogd</span><span class="w"> </span><span class="kc">$</span><span class="mh">0xca</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm16</span><span class="w">
</span><span class="nf">vpermb</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm6</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm16</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqu64</span><span class="w">  </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="nb">rdx</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="avx512vl-1">
<h3>AVX512VL</h3>
<pre class="code nasm literal-block">
<span class="nf">vpermb</span><span class="w">         </span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">add</span><span class="w">            </span><span class="kc">$</span><span class="mh">0x30</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span><span class="w">
</span><span class="nf">add</span><span class="w">            </span><span class="kc">$</span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rdx</span><span class="w">
</span><span class="nf">vpmultishiftqb</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpermb</span><span class="w">         </span><span class="o">%</span><span class="nb">zmm2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqu64</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="nb">rdx</span><span class="p">)</span>
</pre>
</div>
</div>
<div class="section" id="decoding-3">
<h2>Decoding</h2>
<div class="section" id="avx512bw-5">
<h3>AVX512BW</h3>
<pre class="code nasm literal-block">
<span class="nf">vmovdqu64</span><span class="w">   </span><span class="p">(</span><span class="o">%</span><span class="nb">rbx</span><span class="p">,</span><span class="o">%</span><span class="nb">r14</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">%</span><span class="nb">zmm3</span><span class="w">
</span><span class="nf">vpsrld</span><span class="w">      </span><span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpandd</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm4</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpcmpeqb</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm10</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="o">%</span><span class="nb">k1</span><span class="w">
</span><span class="nf">vpshufb</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm11</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpshufb</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm7</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vmovdqa64</span><span class="w">   </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm2</span><span class="w">
</span><span class="nf">vpandd</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm4</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqu8</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm9</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm2</span><span class="p">{</span><span class="o">%</span><span class="nb">k1</span><span class="p">}</span><span class="w">
</span><span class="nf">vpshufb</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm8</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vptestmb</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">k2</span><span class="w">
</span><span class="nf">kmovq</span><span class="w">       </span><span class="o">%</span><span class="nb">k2</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span><span class="w">
</span><span class="nf">cmp</span><span class="w">         </span><span class="kc">$</span><span class="mh">0xffffffffffffffff</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span><span class="w">
</span><span class="nf">je</span><span class="w">          </span><span class="nv">error_handling</span><span class="w">
</span><span class="nf">vpaddb</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm2</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpmaddubsw</span><span class="w">  </span><span class="o">%</span><span class="nb">zmm6</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpmaddwd</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm5</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpshufb</span><span class="w">     </span><span class="o">%</span><span class="nb">zmm13</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">add</span><span class="w">         </span><span class="kc">$</span><span class="mh">0x40</span><span class="p">,</span><span class="o">%</span><span class="nb">r14</span><span class="w">
</span><span class="nf">add</span><span class="w">         </span><span class="kc">$</span><span class="mh">0x30</span><span class="p">,</span><span class="o">%</span><span class="nb">rcx</span><span class="w">
</span><span class="nf">vpermd</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm12</span><span class="p">,</span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqu64</span><span class="w">   </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="o">-</span><span class="mh">0x30</span><span class="p">(</span><span class="o">%</span><span class="nb">rcx</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="avx512vbmi-4">
<h3>AVX512VBMI</h3>
<pre class="code nasm literal-block">
<span class="nf">vmovdqu64</span><span class="w">   </span><span class="p">(</span><span class="o">%</span><span class="nb">r14</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">r13</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vmovdqa64</span><span class="w">   </span><span class="o">%</span><span class="nb">zmm5</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vpermt2b</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm6</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="w">
</span><span class="nf">vporq</span><span class="w">       </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpmovb2m</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">k1</span><span class="w">
</span><span class="nf">kmovq</span><span class="w">       </span><span class="o">%</span><span class="nb">k1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span><span class="w">
</span><span class="nf">test</span><span class="w">        </span><span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span><span class="w">
</span><span class="nf">jne</span><span class="w">         </span><span class="nv">error_handling</span><span class="w">
</span><span class="nf">vpmaddubsw</span><span class="w">  </span><span class="o">%</span><span class="nb">zmm3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpmaddwd</span><span class="w">    </span><span class="o">%</span><span class="nb">zmm2</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">vpermb</span><span class="w">      </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm4</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">zmm0</span><span class="w">
</span><span class="nf">add</span><span class="w">         </span><span class="kc">$</span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">r13</span><span class="w">
</span><span class="nf">add</span><span class="w">         </span><span class="kc">$</span><span class="mh">0x30</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rdx</span><span class="w">
</span><span class="nf">vmovdqu64</span><span class="w">   </span><span class="o">%</span><span class="nb">zmm0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mh">0x30</span><span class="p">(</span><span class="o">%</span><span class="nb">rdx</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<div class="section" id="summary">
<h1>Summary</h1>
<ul class="simple">
<li>AVX512BW makes both base64 decoding and encoding much easier. The performance
tests shows this code is approx. 1.5-1.6 times faster than AVX2 implementations.</li>
<li>It was: <em>AVX512VBMI requires big lookups tables, which can't be simply inlined.
This require an additional setup code.</em> <strong>Update</strong>: this is not true, since
the lookup tables are known at compile time, they are just stored as regular
data and loaded on demand.</li>
<li>With AVX512VL the main loop of encoding can be coded using only five
instructions: load, permutexvar (lane layout), mutlishift,
permutexvar (lookup) and store.</li>
</ul>
</div>
<div class="section" id="sample-code">
<h1>Sample code</h1>
<p><a class="reference external" href="https://github.com/WojciechMula/base64simd">Repository</a> contains implementations of both encoding and decoding
procedures.</p>
</div>
<div class="section" id="changes">
<h1>Changes</h1>
<ul class="simple">
<li>2018-11-05 &mdash; performance results for AVX512BW implementation</li>
<li>2018-04-18 &mdash; show both AVX512BW and AVX512VBMI solutions</li>
<li>2017-11-29 &mdash; spelling</li>
<li>2017-05-01 &mdash; add info about <strong>VPMULTISHIFTQB</strong> from AVX512VL</li>
<li>2016-12-21 &mdash; fix pack and unpack procedures</li>
<li>2016-11-21 &mdash; change the title, simplified &quot;faster procedure&quot;, added link to the AV512F article</li>
</ul>
</div>
</div>
</body>

<!-- Mirrored from 0x80.pl/notesen/2016-04-03-avx512-base64.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 16:43:46 GMT -->
</html>
