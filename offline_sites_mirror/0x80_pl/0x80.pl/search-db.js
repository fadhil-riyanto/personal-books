TRIGRAMS = {
"$0x":[143,150],
"&*i":[109],
"***":[87],
"*16":[73],
"*25":[89],
"*4*":[89],
"*59":[2],
"*al":[12],
"*am":[82],
"*cd":[69],
"*cl":[82],
"*it":[109],
"*se":[162],
"*st":[117],
"---":[[0,6],8,[10,14],16,17,19,22,23,[26,31],[34,40],[42,44],47,48,50,52,54,55,[58,62],[64,71],[74,76],78,79,81,[83,85],[87,89],91,92,94,96,100,[103,106],[109,113],115,116,[118,120],122,[124,128],[130,132],134,135,[137,140],[143,147],150,152,154,155,[157,164],167,170,172,173],
"-01":[1,3,4,17,18,22,33,34,37,40,47,48,54,64,65,74,85,[87,89],91,94,100,104,[126,130],135,137,[144,152],[165,172]],
"-02":[5,12,24,25,32,35,37,66,88,100,104,124,[131,133],[137,140],150,[152,156],159,173],
"-03":[0,1,[3,6],[12,16],19,26,30,31,37,[49,58],60,64,70,[72,77],[88,91],102,104,[106,110],113,117,118,124,132,133,136,138,141,142,157,165],
"-04":[0,1,3,5,[17,21],[27,29],38,59,74,77,78,88,89,91,100,[111,115],124,131,158,159,170,173],
"-05":[0,1,2,12,22,31,66,74,77,79,91,109,113,115,116,126,[153,155],160,166],
"-06":[1,[3,12],23,30,36,37,67,87,149,156,157,160],
"-07":[0,7,30,32,39,41,60,66,74,89,104,113,127,167],
"-08":[8,9,13,20,27,30,77,91,95,96,104,128],
"-09":[23,28,30,[33,35],37,[50,52],[59,63],68,74,88,[92,94],158,162,171],
"-10":[1,30,31,36,[64,71],80,88,89,[95,99],[117,120],124,155,158,159],
"-11":[1,21,[29,31],[37,40],48,53,54,59,64,74,[81,83],88,89,91,94,96,100,[105,107],111,113,115,[121,125],141,142,155,[161,163],170,171],
"-12":[9,12,14,31,[40,46],55,69,77,[84,86],88,89,91,94,[100,103],113,124,134,142,143,[164,166],168],
"-13":[1,78,84,89,90,104,115,126],
"-14":[35,88,92,93,100,108,112,115,121,139,158],
"-15":[4,10,30,34,70,81,105,115,155],
"-16":[1,55,59,88,97,98,101,108,109,119,121,128,145],
"-17":[24,54,85,88,89,94,96,127,130,131,137,140,144],
"-18":[11,88,89,91,94,111,116,118,[122,124],131,137,139,140,169,170],
"-19":[56,57,59,88,89,113,135,150,155,166,171],
"-1u":[139,147],
"-20":[31,59,100,161],
"-21":[12,30,60,72,73,91,102,111,117,119,124,130,136,139,147,151,160,[164,166],170],
"-22":[1,58,59,70,71,[74,76],81,82,100,103,116,143,164],
"-23":[40,61,89,99,109,129,142],
"-24":[0,1,30,40,94,119,125,145],
"-25":[30,31,43,62,79,80,88,89,94,100,102,111,113,145,165,166,172],
"-26":[12,25,26,48,74,100,105,110],
"-27":[1,2,44,85,96,118],
"-28":[1,26,34,55,83,100,114,118,120,164],
"-29":[0,45,86,89,91,100,113,120,130,144,146,147],
"-30":[15,26,35,46,63,88,89,100,113,159,173],
"-31":[16,26,88,134,148,152],
"-32":[128,160,172,173],
"-39":[48],
"-3k":[173],
"-42":[109],
"-47":[1,88,89],
"-48":[124],
"-51":[94,116,149,160,162,[164,166],[169,173]],
"-52":[113],
"-5u":[91,119,124,130],
"-64":[1],
"-65":[89,90],
"-67":[1,12,30,70,88,89,111,113,115,117,119,124,130,147,158,159],
"-71":[89,90],
"-81":[88,89,91,100,101,124,126,130],
"-88":[87],
"-93":[132],
"-99":[113],
"-ac":[119,124,160,162],
"-ad":[89,91,113,126,162,167],
"-af":[105],
"-al":[12],
"-an":[12,45,55,59,60,66,68,69,71,78,[85,89],94,98,102,115,118,119,130,134,135,143,144,156,158,159,164,166],
"-ar":[46,74,94,104,115,119,141],
"-as":[3,10,121,163,173],
"-av":[94,116,166],
"-ax":[131],
"-ba":[0,1,16,26,59,88,89,91,94,101,104,119,124,126,130,135,159,161,173],
"-be":[162],
"-bi":[[1,4],8,[10,12],23,26,29,30,32,35,40,41,[44,47],52,54,55,[59,61],[66,68],70,72,74,[76,78],84,85,88,89,[91,95],[97,101],[103,105],111,113,[115,119],124,126,128,130,[133,136],138,139,[142,145],147,149,150,152,154,[156,160],[162,166],[169,171],173],
"-bl":[19,89],
"-br":[143],
"-bu":[32,131],
"-by":[0,1,2,16,39,40,59,69,71,73,85,88,89,91,94,100,104,111,113,115,118,126,130,134,142,144,145,147,150,157,158,171,173],
"-ca":[87,136,142],
"-ch":[100,104,113,140,170,172,173],
"-cl":[9,158,159],
"-co":[56,101,105,113,121,128,130,133,135,150,[157,160],162],
"-cp":[113],
"-cu":[122],
"-da":[37,81,120],
"-de":[113,137,160,162],
"-di":[14,30,37,[69,71],113,126,142,144,158,165],
"-do":[122],
"-dr":[122],
"-ed":[146,171],
"-ef":[114,128],
"-el":[26,88,89,92,111,[117,119],122,124,136,143,145,149,151,159,160,162,163],
"-em":[91,113,117],
"-en":[14,22,35,84,88,158,159,172,173],
"-eq":[92,119,170],
"-er":[164],
"-ex":[1,3,80,113,128,131,154,159,163,164,171],
"-ey":[146],
"-fe":[120],
"-ff":[121,131],
"-fi":[24,29,81,88,91,101,162,166],
"-fn":[120],
"-fo":[75,88,159,162,166],
"-fr":[2,26,35,54,66,96,100,105,128,141,170],
"-fu":[104,124],
"-ga":[166],
"-ge":[115,173],
"-gn":[163],
"-gr":[31],
"-ha":[142,173],
"-he":[144],
"-ho":[57],
"-hw":[113],
"-in":[2,35,64,86,101,110,114,122,126,159,[162,164],173],
"-is":[170],
"-it":[91,104,160],
"-iz":[77,88,133,136,142,158,164],
"-jo":[105],
"-ka":[2,54,100],
"-kn":[105],
"-la":[89,115,133,159,171],
"-le":[1,8,10,31,40,63,75,88,91,94,102,105,115,128,130,138,142,149,156,158,159,162,166,173],
"-li":[26,27,81,100,113,118,122,135,162,163,168],
"-lo":[1,26,32,99,101,115,124,155,173],
"-ma":[2,45,81,84,89,92,[99,101],113,[116,119],121,124,126,130,131,133,137,138,143,148,150,157,[164,166],[169,171],173],
"-me":[94,121,162],
"-mo":[14,100],
"-ms":[120],
"-mt":[35],
"-ne":[2,89,118,136],
"-ng":[163],
"-no":[94,117,122,162,171],
"-nu":[26,97],
"-o3":[12,30,58,63,86,92,119,120,124,130,131,137,141,143,148,157,[164,166],170,173],
"-of":[40,100,128,164],
"-ol":[120],
"-on":[7,56,59,88,91,115,123,143,162],
"-op":[1,31,80,119,123,134],
"-or":[12,24,40,54,55,59,60,66,68,69,85,86,88,89,92,94,100,115,118,134,144,157,164,166,170,171],
"-ov":[113,119],
"-pa":[1,35,49,78,87,105,113,122,144,150,158,172],
"-pe":[1,126],
"-pi":[115],
"-pl":[22,126],
"-po":[10,31,48,86,109,120,162,164,165,171],
"-pr":[81,94,100,120,159,[162,164]],
"-pu":[162],
"-ra":[2,54,86,100,165],
"-re":[26,48,75,81,91,128,143,151,159,162,169,[171,173]],
"-ri":[168,171],
"-ro":[170],
"-sa":[74,126],
"-sc":[88],
"-se":[1,24,29,74,80,94,101,126,130,133,154,157,159,161,162,171],
"-sh":[6,59,85,88,89,92,100,134,135,166],
"-si":[75,113,128,132,167,170],
"-so":[167,170],
"-sp":[22,100,105,111,119,124,128],
"-st":[26,49,58,75,76,88,120,124,128,159,160,173],
"-sw":[59,60,88,133],
"-ta":[30,66],
"-te":[105,143,167],
"-th":[23,32,44,47,68,93,95,120,126,135,143,150,158,[160,162],164,166,[169,171]],
"-ti":[81,97,105,113,115,128,135,150,159],
"-to":[26,35,75,88,91,123,143,159,168],
"-tr":[31,37,106,142],
"-tu":[6,159],
"-ty":[122,128],
"-ui":[165],
"-un":[1,35,80,119,163],
"-up":[48,88,89,94,100,103,111,113,126,127,130,139,159,[164,166],170,172,173],
"-va":[40,81,144,158,159],
"-ve":[100,121,131,138,171],
"-wa":[1,26,28,40,76,132],
"-wi":[1,2,54,88,90,97,100,130,138,139,162,166],
"-wo":[30,40,74,94,105,113,115,122,126,145,157,158,162,173],
"-wp":[110],
"-wr":[7,121,141,164],
"-ws":[110],
"-xa":[131],
"-xc":[116],
"-xo":[54,87,88,94,118,135,151,157,159],
"-ze":[51,65,89,100,103,116,118,133,134,139,149,151,152,156,157,169,171],
"0*c":[69],
"0*y":[69],
"0-0":[1,[15,23],30,36,[64,68],74,95,96,113,117,135,136,166],
"0-1":[4,9,30,69,70,[96,98],118,119,121,139,147,158,159],
"0-2":[1,14,30,31,71,80,99,100,[118,120],165,166],
"0-3":[88],
"0-4":[134],
"0-5":[91,119,124,130,[164,166],170,173],
"0-9":[88,89,94,118],
"0-b":[163,171],
"0-l":[173],
"00*":[69],
"000":[[0,3],6,19,23,26,30,31,37,39,40,61,64,70,76,86,98,100,108,113,115,117,121,122,124,126,128,132,134,142,143,145,147,149,150,[158,160],164,170,173],
"001":[1,40,61,64,67,100,104,113,118,126,134,135,145,150,154,158,159,164,166,170,173],
"002":[1,26,40,64,113,115,135,147,158,164,167,173],
"003":[1,61,111,113,136,164,173],
"004":[2,64,122,132,135,158,164,173],
"005":[1,26,35,113,158,162,164,166,170,173],
"006":[1,89,100,111,113,117,121,163,164,166,170,173],
"007":[1,61,89,111,173],
"008":[[0,14],16,26,51,61,64,89,100,111,113,132,135,150,158,164,170],
"009":[89,108,113,132,158,166],
"00_":[30,98,118,149,173],
"00a":[104,158],
"00b":[42,104],
"00c":[104],
"00d":[104,173],
"00f":[61,150,173],
"00g":[[164,166],170,173],
"00m":[132],
"00s":[2],
"00x":[4],
"00z":[23],
"01-":[1,34,37,47,48,54,74,85,[87,89],94,100,104,[126,130],135,137,[144,152],[165,172]],
"010":[1,2,[15,23],40,51,64,67,89,100,113,117,118,126,128,132,135,137,140,142,143,150,158,164,166,173],
"011":[1,[23,30],37,40,76,89,111,113,118,126,128,134,135,145,149,150,[157,159],164,170,173],
"012":[1,31,32,37,61,89,100,111,113,126,131,144,158,164,166],
"013":[26,30,31,[33,46],89,104,111,113,117,132,164,170,173],
"014":[[47,71],88,89,113,132,158,164,165],
"015":[1,5,12,47,55,59,[72,86],89,113,119,121,164],
"016":[0,1,3,4,6,12,54,59,60,74,77,85,[87,103],113,132,158,164,170,173],
"017":[1,4,31,34,35,88,89,91,94,100,102,104,105,121,127,164,173],
"018":[1,2,30,37,48,64,70,74,91,94,100,104,[106,126],130,131,158,164,170],
"019":[1,47,48,89,109,118,124,[126,134],140,164,166,173],
"01_":[118,173],
"01b":[42],
"01c":[173],
"01d":[173],
"01e":[173],
"01f":[61,173],
"02-":[24,25,35,37,100,104,124,[131,133],[137,140],150,[152,156],173],
"020":[1,2,16,64,74,89,111,113,[135,137],140,150,164,166,173],
"021":[89,111,113,117,121,124,131,135,[137,143],145,162,170,173],
"022":[31,48,89,111,113,117,126,132,135,[144,148],158,164,166],
"023":[1,2,48,61,89,91,113,124,131,140,142,[149,161],173],
"024":[[1,4],12,26,77,88,91,101,103,108,111,113,121,124,132,147,158,160,[162,167],170,171,173],
"025":[47,61,89,113,132,[164,173]],
"026":[1,40,47,77,89,113,124,164,166,170],
"027":[1,37,88,89,132,147,164,173],
"028":[26,47,48,88,89,113,121,127,132,158],
"029":[1,88,89,113,139,173],
"02a":[158],
"02c":[173],
"02d":[173],
"03-":[0,1,3,4,6,12,15,16,26,30,31,37,[49,58],60,64,70,[72,76],[88,90],102,[106,110],113,118,136,141,142,157],
"030":[2,66,67,88,91,124,126,130],
"031":[37,67,91,113,126,164],
"032":[1,26,40,61,89,111,113,132,136,139,164,165,173],
"033":[48,88,94,113,126,139,170,173],
"034":[88,111,113,127,173],
"035":[1,61,88,132,139,147,164,166],
"036":[26,88,111,117,173],
"037":[60,88,111,113,126,166,173],
"038":[1,31,87,88,111,113,126,132,143,166],
"039":[1,47,48,111,113,124,164],
"03f":[61,173],
"04-":[0,5,[17,21],[27,29],59,77,78,88,91,100,[111,114],158,159,170,173],
"040":[1,2,16,26,59,60,64,66,100,111,124,132,134,135,139,166,173],
"041":[1,40,113,119,126,132,158,173],
"042":[88,113,130,132,135,145,166,173],
"043":[60,70,77,85,88,91,111,113,119,124,126,166,173],
"044":[12,88,89,91,94,111,113,119,121,132,135,139,145,158,173],
"045":[1,88,113,119,166,173],
"046":[1,2,88,113,126,132,166],
"047":[88,89,113,132,173],
"048":[1,2,4,26,61,77,88,101,108,111,113,119,124,132,158,160,173],
"049":[1,47,61,88,89,119,130,164],
"04a":[158],
"04b":[173],
"04d":[173],
"04f":[173],
"05-":[0,1,2,12,22,31,77,79,91,109,115,116,160],
"050":[2,47,85,88,111,113,147,164,166,173],
"051":[1,4,47,94,119,127,132,166,173],
"052":[1,88,113,119,124,126,158,164,166],
"053":[61,111,113,124],
"054":[1,4,31,111,113,124,132,158],
"055":[1,88,113,124,130,164,166,173],
"056":[1,2,26,85,113,124,132,173],
"057":[1,87,100,104,113,124,126,139,162,173],
"058":[1,77,100,111,113,124,164,173],
"059":[12,47,88,108,111,113,124,127,145,164,173],
"05a":[173],
"05b":[173],
"06-":[1,[3,12],23,37],
"060":[2,26,85,88,100,111,113,119,124,126],
"061":[1,59,60,111,113,124,139,[164,166],170,173],
"062":[60,88,111,113,119,124,126,130,164,166,173],
"063":[1,59,88,89,100,113,119,121,124,173],
"064":[2,47,85,88,111,119,124,132,173],
"065":[1,4,111,113,119,124,130,132],
"066":[47,61,88,113,119,124,164],
"067":[1,47,59,88,111,113,119,124,132,173],
"068":[1,88,89,100,104,119,121,124],
"069":[37,100,113,115,124,126,139,164,166,173],
"06d":[163],
"07-":[32,113],
"070":[1,2,26,85,89,113,119,124,130,164,166],
"071":[47,111,113,119,121,124,139,158,164],
"072":[1,26,85,89,108,113,119,124,130,132,172,173],
"073":[85,119,124,130],
"074":[1,37,61,113,173],
"075":[77,100,113,119,124,127,130,166,173],
"076":[30,61,88,111,119,164],
"077":[1,30,59,111,113,119,126,130,132,145,164],
"078":[1,77,100,111,113,119,127,166,173],
"079":[1,113,119,145,166,173],
"07f":[61],
"08-":[[0,14]],
"080":[2,16,26,51,59,64,111,113,119,121,132,135,150,164],
"081":[47,59,61,77,89,111,113,130,132,164],
"082":[85,88,91,113,166],
"083":[47,88,94,119,164,170],
"084":[1,2,88,89,111,113,126,130,135,164,166],
"085":[61,88,89,91,113,130,132],
"086":[1,4,61,113,132,173],
"087":[88,91,124,127],
"088":[89,113,124,127,132,135,147,158,160,173],
"089":[61,89,91,113,119,124,147,164],
"08a":[158],
"09-":[[33,35],37,[59,63],74,88,[92,94],171],
"090":[2,47,89,113,119,130,164,173],
"091":[1,4,47,61,77,88,91,111,113,119,124,130,163,166,173],
"092":[26,61,88,89,108,113,119,158,165,173],
"093":[1,113,119,130,173],
"094":[1,88,100,111,113,119,126,128,130,158,164],
"095":[37,61,85,113,119,121,132,173],
"096":[26,66,77,89,91,101,108,111,113,117,119,121,124,132,160,170,173],
"097":[89,113,119,124,132,158,160,173],
"098":[1,26,47,89,124,130,166,170],
"099":[1,30,85,89,111,113,124,130,164,173],
"0_0":[30,98,118,173],
"0_1":[113,149],
"0_7":[118],
"0_f":[173],
"0a0":[173],
"0a2":[158],
"0a4":[158],
"0a6":[173],
"0a7":[173],
"0a8":[158],
"0aa":[104],
"0ab":[173],
"0b0":[76,100,113,134,149,150,157,158,170],
"0b1":[67,76,134,143,149,150,154,158],
"0bb":[104],
"0c5":[173],
"0c7":[173],
"0c8":[173],
"0cb":[173],
"0cc":[104,173],
"0cd":[173],
"0cf":[173],
"0d0":[173],
"0dd":[104],
"0de":[173],
"0e0":[164],
"0f0":[164],
"0f1":[164],
"0fa":[173],
"0fb":[173],
"0fd":[173],
"0ff":[61,150,172,173],
"0gh":[1,12,30,70,88,89,91,111,113,115,117,119,124,126,130,139,145,147,158,159,[164,166],170,173],
"0gi":[163],
"0hq":[124],
"0kb":[31,173],
"0mb":[132],
"0th":[59,89,91,104,113,119,124,138,142],
"0ub":[158,159],
"0x0":[51,60,89,113,118,135,142,144,149,150,157,159,162,164,173],
"0x1":[74,89,113,118,142,149,150,159,172,173],
"0x2":[4,59,89,118,135,150,158,173],
"0x3":[[66,68],74,89,102,113,118,[142,144],158,169,173],
"0x4":[4,68,89,113,118,144,150,157,173],
"0x5":[89,113,118,173],
"0x6":[4,68,74,89,113,118,142,144,173],
"0x7":[23,60,76,89,94,113,118,128,157,173],
"0x8":[16,60,74,91,94,113,118,128,134,135,149,150,157,164,173],
"0x9":[74,118],
"0xa":[113,118,150,156,158,173],
"0xb":[113,118,142,149,173],
"0xc":[74,118,150,173],
"0xd":[113,150,173],
"0xe":[67,74,113,150,158],
"0xf":[2,46,51,74,89,94,113,118,128,130,142,144,150,164,171,173],
"0zz":[23],
"1-0":[[24,31],[37,39],47,74,87,89,91,104,115,[126,128],131,[137,141],149,162,[165,167],171],
"1-1":[1,30,54,74,81,85,88,89,[121,124],126,127,130,135,137,[142,145],150,158,163,166,[168,171]],
"1-2":[1,30,34,40,48,59,[81,83],88,89,91,94,96,100,105,125,129,130,137,140,[142,147],151,161,[164,166],170,172,173],
"1-3":[100,148,152],
"1-5":[91,124,126,130,134,143,163],
"1-8":[113],
"1-a":[12],
"1-b":[39,78,94,145],
"1-d":[113,158],
"1-e":[26,118],
"1-s":[170],
"1-t":[170],
"1-u":[165],
"10*":[69],
"10-":[1,4,[14,23],30,31,36,[64,71],80,88,[95,100],[117,120],171],
"100":[[0,4],6,12,16,19,23,26,30,31,35,37,40,51,64,67,69,70,75,76,[85,87],89,98,100,108,111,113,118,122,124,126,130,132,134,135,142,143,145,147,149,150,154,[158,162],164,173],
"101":[3,40,47,51,76,111,113,118,124,131,132,137,140,142,143,150,158,159,170,173],
"102":[[1,4],12,26,77,88,101,103,108,111,113,121,124,132,154,159,160,170,173],
"103":[4,26,47,111,113,115,121,124,127,147,159,166,170,173],
"104":[91,108,111,113,117,119,121,124,126,130,132,139,145,147,160,[164,166],170,173],
"105":[1,31,37,104,113,124,126,132,147,159,166,173],
"106":[4,30,37,59,60,111,113,124,132,159,166,173],
"107":[1,2,26,30,31,37,47,61,89,100,111,113,119,126,127,130,132,159,172,173],
"108":[26,47,61,89,111,113,119,126,127,132,137,140,143,147,[158,160],164,173],
"109":[1,26,30,108,113,115,119,124,128,132,159,166,173],
"10_":[30,98],
"10a":[173],
"10b":[42,173],
"10c":[173],
"10d":[173],
"10e":[173],
"10f":[172,173],
"10m":[132],
"10s":[2],
"10u":[158,159],
"10x":[170],
"11-":[1,[24,31],[37,40],48,59,74,[81,83],89,91,94,96,100,105,115,118,[121,125],142,[161,163],170,171],
"110":[1,2,31,40,47,67,89,98,100,108,113,118,121,124,126,127,132,134,135,143,147,150,[158,160],162,164,166,170,173],
"111":[10,19,23,26,31,35,47,67,76,98,113,119,126,130,132,134,142,145,[148,150],[157,160],163,164,170,173],
"112":[1,4,37,66,77,108,111,113,121,124,132,142,148,158,160,173],
"113":[1,2,37,85,94,108,113,115,130,132,160,166,173],
"114":[2,4,26,77,111,113,124,127,128,147,158,160,173],
"115":[1,4,47,61,108,111,113,119,130,132,160,166,173],
"116":[1,111,113,132,159,160,165,173],
"117":[1,26,47,77,91,108,111,113,119,132,147,160,166,173],
"118":[1,2,26,37,47,108,113,121,124,126,130,132,147,159,160,166,173],
"119":[3,31,60,89,113,159,160,173],
"11_":[98,157,170],
"11a":[173],
"11b":[42,173],
"11c":[173],
"11d":[173],
"11e":[173],
"11f":[173],
"11z":[23],
"12-":[12,14,31,32,37,[40,46],55,66,[84,86],88,89,91,93,94,[100,103],115,134,143,155,160,[163,166]],
"120":[2,3,4,9,26,88,95,108,111,113,119,131,132,159,160,173],
"121":[1,2,40,48,61,85,88,89,91,113,119,124,126,130,132,142,147,160,166,173],
"122":[0,1,26,30,47,66,85,89,90,101,113,121,124,132,158,160,164,166,173],
"123":[30,77,82,94,111,113,119,121,126,127,132,144,158,159,166,170,173],
"124":[1,2,47,85,94,111,113,119,128,132,148,158,164,166,173],
"125":[2,70,88,89,94,111,113,119,121,124,126,132,[164,166],173],
"126":[1,26,37,111,113,119,124,132,136,147,159,173],
"127":[1,2,4,12,35,37,44,61,85,87,94,108,111,113,119,124,132,158,173],
"128":[1,2,3,26,31,40,55,60,66,70,72,77,85,[87,89],91,93,94,100,101,103,104,108,111,113,115,[119,121],124,126,130,132,136,138,147,158,161,162,164,166,171,173],
"129":[1,26,37,108,113,119,124,126,158,159,173],
"12_":[74,91,94,97,113,115,117,126,135,136,138,139,152],
"12a":[173],
"12b":[66,91,94,100,113,115,116,118,126,130,131,134,[137,140],173],
"12c":[99,173],
"12d":[116,131,137,173],
"12e":[173],
"12f":[74,91,[94,97],100,103,104,111,[115,117],131,137,138,173],
"12k":[172,173],
"12t":[165,166],
"12v":[91,113,115,126,131,137,140,145,149,164],
"13-":[30,31,[33,46]],
"130":[2,4,40,61,67,77,108,113,119,124,126,132,166,173],
"131":[40,67,70,77,91,100,111,113,121,124,126,132,166,172,173],
"132":[1,2,26,30,61,77,113,119,124,126,132,147,159,166,173],
"133":[0,1,2,26,35,47,61,77,111,113,119,124,132,161,166,173],
"134":[77,91,94,108,113,119,124,126,132,142,147,173],
"135":[1,4,37,66,111,113,119,124,173],
"136":[1,4,26,47,61,66,85,88,89,100,108,111,113,124,126,132,147,160,173],
"137":[1,4,61,113,119,121,124,126,132,147,158,170,173],
"138":[1,26,30,47,61,89,111,113,119,132,173],
"139":[1,47,61,77,104,111,113,126,132,158,173],
"13a":[173],
"13b":[173],
"13c":[173],
"13d":[173],
"13e":[173],
"13f":[173],
"13x":[48],
"14-":[[47,71],105],
"140":[2,47,89,100,113,119,123,126,173],
"141":[4,47,77,91,111,113,119,124,127,164,173],
"142":[1,26,47,104,113,119,147,164,170,172,173],
"143":[1,12,31,47,111,113,119,126,147,166,170,172,173],
"144":[4,91,108,111,113,126,131,132,147,158,173],
"145":[2,31,66,111,113,119,121,126,127,132,147,166,173],
"146":[31,37,66,85,108,113,119,132,166,173],
"147":[2,47,111,113,124,126,127,132,160,166,173],
"148":[1,2,47,70,100,108,113,121,124,126,128,158,173],
"149":[2,66,119,124,127,132,166],
"14a":[173],
"14b":[173],
"14c":[173],
"14d":[173],
"14e":[173],
"14f":[173],
"15-":[1,5,12,47,55,59,[72,86],158],
"150":[1,2,47,79,88,89,100,101,111,113,124,126,173],
"151":[4,35,37,61,100,113,119,124,126,127,173],
"152":[1,26,47,88,108,119,124,126,132,160,172,173],
"153":[2,30,60,113,119,124,132,166,173],
"154":[1,30,37,47,111,113,119,124,126,132,173],
"155":[1,2,30,47,113,124,126,132,160,166,173],
"156":[2,4,26,31,37,113,121,124,126,127,173],
"157":[1,26,77,100,104,111,113,124,132,166,173],
"158":[1,2,26,61,70,88,113,124,126,132,147,173],
"159":[61,108,111,113,119,121,132,164,166,173],
"15a":[173],
"15b":[4,173],
"15c":[173],
"15d":[173],
"15e":[173],
"15f":[173],
"15t":[160],
"15x":[48],
"16*":[73],
"16-":[0,1,3,4,6,12,30,54,55,59,60,66,70,71,74,77,85,[87,103],111,113,115,116,118,119,124,126,130,134,[142,145],149,150,[158,160],162,165,166,171,173],
"160":[2,26,47,111,113,121,132,166,173],
"161":[1,61,111,113,124,132,173],
"162":[1,4,26,47,60,113,132,147,164,166,173],
"163":[40,66,77,108,111,113,117,119,124,126,127,132,173],
"164":[2,26,61,85,88,89,111,113,117,119,147,165,170,173],
"165":[1,2,19,61,66,89,111,113,132,166,173],
"166":[4,31,47,61,89,100,111,113,164,170,173],
"167":[1,12,26,40,47,113,121,132,142,173],
"168":[1,37,66,77,89,108,113,132,170,173],
"169":[1,4,26,61,113,119,166,170,173],
"16_":[113,119,124],
"16a":[173],
"16b":[4,115,119,173],
"16c":[173],
"16d":[173],
"16e":[173],
"16f":[173],
"16k":[139,173],
"16m":[49],
"16x":[104],
"17-":[1,31,34,35,88,89,91,94,100,102,104,105,173],
"170":[1,2,47,59,61,66,89,100,108,113,119,132,173],
"171":[1,26,31,35,37,100,111,113,127,147,166,173],
"172":[2,19,37,85,87,113,121,126,166,173],
"173":[2,6,61,111,113,117,119,124,132,166,173],
"174":[2,77,108,111,113,119,124,132,166,173],
"175":[4,77,111,113,123,124,126,160,170,173],
"176":[1,26,47,61,70,111,113,119,121,124,126,127,132,147,173],
"177":[1,4,66,111,113,119,124,126,142,160,173],
"178":[2,47,77,89,108,113,121,126,132],
"179":[1,2,59,87,89,113,121,132],
"17a":[173],
"17b":[173],
"17c":[173],
"17d":[173],
"18-":[30,48,64,70,74,91,94,100,[106,125],170],
"180":[1,2,37,87,91,108,113,119,121,124,126,130,132,147,158,160,166,173],
"181":[1,2,31,37,61,108,111,113,119,131,165],
"182":[1,108,111,113,124,132,160,165],
"183":[1,37,47,61,108,113,132,165,173],
"184":[1,2,19,61,66,89,108,111,113,127,132,158,170,173],
"185":[1,2,4,108,113,124,165,173],
"186":[37,70,108,113,121,124,132,147,163],
"187":[61,89,94,108,113,126,127,132,147,164,170],
"188":[26,37,60,108,111,113,119,124,126,161,165,173],
"189":[1,2,26,108,113,119,124,132,166,173],
"18a":[104,173],
"18b":[173],
"18c":[173],
"18d":[173],
"18e":[173],
"18m":[31],
"19-":[109,118,124,[126,134],166],
"190":[1,2,19,60,70,85,89,108,113,119,126,131,160,170],
"191":[1,4,60,108,111,113,119,124,166,173],
"192":[1,4,45,77,88,101,108,111,113,119,121,126,132,[158,160],166,170,173],
"193":[26,77,88,108,111,113,121,124,132,173],
"194":[1,2,37,47,61,111,113,132,147,160,164,173],
"195":[1,91,108,113,119,121,124,126,158,164,166,173],
"196":[1,113,124,126,127,165,170,173],
"197":[1,26,30,40,89,108,111,113,119,121,124,126,127,132,165],
"198":[37,61,88,89,111,113,121,122,124,143,160,173],
"199":[1,59,89,108,111,113,121,122,160,164,166,173],
"19c":[173],
"19d":[173],
"19e":[173],
"19f":[173],
"1_0":[30,98,118,173],
"1_1":[98,118,157,170],
"1_2":[113],
"1__":[113],
"1_e":[94],
"1_f":[173],
"1a0":[128,173],
"1a1":[173],
"1a2":[173],
"1a3":[173],
"1a4":[173],
"1a5":[173],
"1a8":[173],
"1a9":[173],
"1ac":[173],
"1ad":[173],
"1b0":[173],
"1b1":[173],
"1b3":[173],
"1b4":[173],
"1b5":[173],
"1b6":[173],
"1b9":[173],
"1bc":[163,173],
"1bd":[173],
"1bf":[173],
"1c7":[173],
"1c8":[173],
"1c9":[173],
"1ca":[173],
"1cb":[173],
"1cc":[173],
"1cd":[173],
"1ce":[173],
"1cf":[173],
"1d0":[173],
"1d1":[173],
"1d2":[173],
"1d3":[173],
"1d4":[173],
"1d5":[173],
"1d6":[173],
"1d7":[173],
"1d8":[173],
"1d9":[173],
"1da":[173],
"1db":[173],
"1de":[173],
"1df":[173],
"1e0":[173],
"1e1":[173],
"1e2":[173],
"1e3":[173],
"1e4":[173],
"1e5":[173],
"1e6":[173],
"1e7":[173],
"1e8":[173],
"1e9":[173],
"1ea":[173],
"1eb":[173],
"1ec":[173],
"1ed":[173],
"1ee":[173],
"1ef":[173],
"1f0":[150,173],
"1f1":[173],
"1f2":[173],
"1f3":[173],
"1f4":[173],
"1f5":[173],
"1f6":[173],
"1f7":[173],
"1f8":[173],
"1f9":[173],
"1fa":[173],
"1fb":[173],
"1fc":[173],
"1fd":[173],
"1fe":[173],
"1ff":[61,172,173],
"1gb":[84],
"1kb":[2,94],
"1mb":[126,132,159,173],
"1ms":[42],
"1st":[69,94,104,119,124,173],
"1ub":[139,147],
"1zz":[23],
"1~1":[91,119,124,130,139,147],
"2*1":[73],
"2*h":[155],
"2*s":[162],
"2-0":[14,31,32,37,40,41,89,91,104,124,[131,133],138,[144,148],150,[152,156],173],
"2-1":[1,24,35,42,84,88,89,94,100,101,104,131,137,139,140,155],
"2-2":[1,12,25,[43,45],55,85,86,89,91,100,102,103,143,164,165],
"2-3":[46,88,119,134,143,173],
"2-4":[54],
"2-5":[14],
"2-6":[54,134],
"2-a":[74],
"2-b":[[1,4],10,11,23,26,30,35,40,41,44,46,47,52,54,55,[59,61],[66,68],70,73,74,76,77,84,85,88,89,[91,95],97,100,104,111,113,[115,117],119,124,130,133,134,142,145,147,149,150,152,156,[158,160],[162,164],166,170,171,173],
"2-c":[160],
"2-d":[[69,71],113,158],
"2-e":[172,173],
"2-g":[166],
"2-l":[1],
"2-n":[150],
"2-s":[100,111,119,124],
"2-u":[1],
"20-":[74,113,135,136,163,166],
"200":[[0,14],22,30,37,47,64,66,108,111,113,122,132,135,136,147,160,164,167,173],
"201":[0,1,[3,6],12,[15,135],140,158,165,166,170,173],
"202":[1,2,31,74,91,113,124,127,131,[135,173]],
"203":[31,47,60,108,111,113,124,126,127,147,166,173],
"204":[1,4,59,66,77,101,108,111,119,124,132,134,147,173],
"205":[1,4,108,113,121,124,132,173],
"206":[1,12,37,108,111,113,117,124,127,132,160,166,173],
"207":[2,19,77,111,113,119,127,132,166,173],
"208":[1,26,37,40,89,111,113,117,124,126,132,165,173],
"209":[26,89,113,132,164,173],
"20a":[173],
"20b":[173],
"20c":[173],
"20d":[173],
"20e":[173],
"20f":[173],
"20g":[91,111,117,119,124,126,130,139,147,[164,166],170],
"20k":[173],
"20s":[2],
"20x":[4],
"21-":[131,[137,143],165],
"210":[2,4,89,91,94,100,103,111,113,117,119,124,126,130,135,137,139,140,143,145,147,160,[164,166],170,173],
"211":[1,37,113,142,147,162,170,173],
"212":[2,47,113,127,165,173],
"213":[1,31,37,47,61,88,104,111,113,117,127,173],
"214":[2,4,88,113,119,127,132,173],
"215":[2,47,61,88,89,113,119,126,127,165,170,173],
"216":[1,2,4,26,61,89,108,111,113,119,142,164,173],
"217":[2,4,66,87,89,108,111,113,119,147,158,173],
"218":[19,26,61,89,113,119,127,132,147,158,164,173],
"219":[1,30,88,89,111,113,119,124,126,132,160,165,173],
"21a":[173],
"21b":[173],
"21c":[173],
"21d":[173],
"21e":[173],
"21f":[173],
"21u":[91,124,126,130],
"22-":[[144,148]],
"220":[1,2,37,66,113,124,127,132,135,160,164,166,170,173],
"221":[2,12,30,89,111,113,160,173],
"222":[1,59,91,111,113,124,126,132,158,164,173],
"223":[31,89,113,126,132,160,164,166,173],
"224":[1,26,100,108,113,124,132,158,160,166,173],
"225":[91,113,121,126,160,173],
"226":[1,37,47,59,111,113,126,132,160,173],
"227":[35,47,59,61,77,91,113,126,160,173],
"228":[12,47,61,89,94,101,113,127,132,158,160,170,173],
"229":[47,61,66,89,113,126,127,170,173],
"22a":[173],
"22b":[173],
"22c":[173],
"22d":[173],
"22e":[173],
"22f":[173],
"23-":[142,[149,161],173],
"230":[1,2,4,31,61,108,113,132,166,173],
"231":[1,37,66,89,113,124,173],
"232":[1,26,61,91,111,113,124,126,132,147,164,166,173],
"233":[1,47,61,91,113,124,166,173],
"234":[4,40,47,91,94,111,113,123,132,144,165,166],
"235":[26,47,111,113,124,126,132,158,165],
"236":[1,2,26,61,89,111,113,126,132,165,170],
"237":[1,31,47,89,111,113,126,147],
"238":[1,6,19,26,47,61,89,100,108,113,164],
"239":[1,30,61,111,113,126,132,158],
"23c":[173],
"23d":[173],
"23e":[84,173],
"24-":[44,89,91,104,113,[162,166],171],
"240":[1,2,19,40,108,111,113,126,132,159,160,[164,166],170,173],
"241":[1,2,19,47,77,113,126,128,163,173],
"242":[2,47,104,113,121,124,132,147,160,166,173],
"243":[19,37,47,61,111,113,121,124,126,173],
"244":[1,4,26,108,111,113,158,161,164,166,173],
"245":[2,113,173],
"246":[1,47,88,100,113,124,164,166,173],
"247":[47,70,94,104,113,126,173],
"248":[19,26,47,100,111,113,119,127,132,148,158,164,173],
"249":[2,26,89,113,119,164,173],
"24a":[173],
"24b":[173],
"24c":[173],
"24d":[163,173],
"24e":[173],
"24x":[4],
"25-":[[165,173]],
"250":[1,26,47,111,113,119,126,132,147,164,166],
"251":[1,2,26,89,113,119,132,158,166],
"252":[1,37,94,113,119,127,132,166,173],
"253":[1,2,26,111,113,173],
"254":[1,2,47,111,113,119,126,127,132,166],
"255":[1,6,12,47,61,78,89,90,111,113,118,119,124,126,130,132,134,139,150,158,[164,166],173],
"256":[0,1,4,6,12,26,29,42,59,61,66,69,72,77,88,89,93,94,100,101,103,108,111,113,119,121,124,130,132,138,139,142,145,158,160,164,171,173],
"257":[1,26,66,113,119,126,166,173],
"258":[108,111,113,132,158,173],
"259":[26,37,47,70,77,108,113,132,147,166,173],
"260":[1,2,26,113,124,126,147,166,173],
"261":[2,100,111,123,124,164,173],
"262":[1,4,66,89,111,113,121,132,147,164,166,173],
"263":[1,19,47,61,111,113,121,124,164,166,173],
"264":[26,40,47,88,113,124,126,132,166],
"265":[1,4,61,88,113,117,121,124,173],
"266":[1,37,61,77,111,113,126,132],
"267":[1,26,37,47,113,126,132,166],
"268":[26,77,111,113,117,132,166,173],
"269":[2,19,77,100,113,166],
"26c":[173],
"26f":[173],
"26k":[173],
"27*":[12],
"270":[1,2,4,113,126,131,132,140,166],
"271":[70,108,113],
"272":[26,61,70,113,117,132,166,173],
"273":[1,2,4,47,59,61,88,108,111,113,117,126,166,173],
"274":[47,59,61,88,94,108,111,113,121,126,173],
"275":[2,37,89,113,115,159,173],
"276":[1,12,26,30,47,88,111,113,117,119,124,126,132,166,170,173],
"277":[1,77,88,113],
"278":[1,2,59,100,113,119,158],
"279":[1,35,77,87,88,111,113,121,132,173],
"27d":[173],
"27k":[173],
"28-":[1,40,47,70,72,88,91,93,94,100,104,113,115,130,136,138,162,164,171],
"280":[2,19,26,30,31,108,113,119,127,130,132,160,164,166,170,173],
"281":[61,89,113,119,124,126],
"282":[111,113,119,124,132,159,164,166],
"283":[1,113,124],
"284":[30,111,113,119,124,173],
"285":[26,47,108,111,113,119,124,126,164],
"286":[26,47,61,66,89,111,113,119,126,147,164,166,170,173],
"287":[2,19,88,108,113,127,147,158,173],
"288":[4,61,77,89,100,101,111,113,121,124,126,130,132,158,164,173],
"289":[1,2,4,61,89,94,113,124,147,166,170],
"28_":[72],
"28c":[173],
"28d":[120],
"28i":[88,120],
"28k":[173],
"290":[1,2,26,30,37,61,166,173],
"291":[1,2,40,88,94,111,113,132],
"292":[19,108,113,117,119,173],
"293":[1,2,31,113,119,121,140,166],
"294":[1,61,88,113,119,124,131,132,160,166],
"295":[1,4,19,77,111,113,115,117,119,124,126,147,158,166,173],
"296":[2,26,37,47,66,104,113,124,132,166,173],
"297":[1,26,89,111,113,119,121,124,126,127,166,170],
"298":[1,47,100,104,113,117,124],
"299":[1,108,111,113,126,132],
"29e":[173],
"2_3":[113],
"2__":[113],
"2_a":[94,97,136],
"2_b":[12,115,138,152],
"2_c":[94,113,117,139],
"2_d":[10],
"2_e":[111],
"2_g":[135],
"2_i":[94],
"2_k":[138],
"2_l":[139],
"2_m":[46,91,94,113,115,117,126,139],
"2_p":[91,94,113,115,126],
"2_s":[30,91,94,115,136],
"2_t":[46,54,74,94,108,113,119,124,131],
"2_v":[126,152],
"2_x":[139],
"2aa":[164],
"2bi":[66],
"2bp":[3,4,6],
"2bw":[91,94,100,113,115,116,118,126,130,131,134,[137,140]],
"2c0":[173],
"2c2":[173],
"2c3":[173],
"2c5":[173],
"2c6":[173],
"2c7":[173],
"2c8":[173],
"2c9":[173],
"2ca":[173],
"2cb":[173],
"2cc":[173],
"2cd":[99,173],
"2ce":[173],
"2cf":[173],
"2d0":[173],
"2d2":[173],
"2dd":[163],
"2dq":[116,131,137,164,165],
"2e-":[48],
"2e8":[164],
"2ga":[94],
"2gb":[31,128],
"2gh":[30],
"2gz":[30],
"2i1":[72],
"2in":[10],
"2kb":[59,172,173],
"2ki":[73],
"2mb":[6],
"2nd":[89,94,104,119,124,173],
"2p8":[135,150,166],
"2ps":[11,150],
"2th":[128,165,166],
"2v2":[147],
"2va":[91,113,115],
"2vb":[91,113,115,126,131,137,140,145,164],
"2vl":[91,131,137,140],
"2vp":[149],
"2x1":[72],
"2x4":[115],
"2~1":[158,159],
"3*5":[2],
"3-0":[0,1,3,4,6,12,[33,35],37,[49,52],60,142,[149,160],173],
"3-1":[1,30,31,[36,46],[53,57],64,[88,90],[106,109],139,141,142,155,161],
"3-2":[1,26,30,58,70,[72,76],102,110,113,118,136],
"3-3":[15,16,26,89,113],
"3-5":[81],
"3-7":[134],
"3-8":[91,124,126,130],
"3-a":[74],
"3-b":[66,88,89,91,94,101,145,159,173],
"3-d":[113,158],
"3-g":[31],
"3-l":[31],
"3-u":[1],
"30-":[173],
"300":[2,31,40,113,117,124,128,132,158,163,173],
"301":[2,127,161,173],
"302":[108,111,113,121,124,132,162,165],
"303":[26,40,66,67,91,94,113,124,126,130,132],
"304":[2,26,88,100,113,124,132,173],
"305":[1,4,26,108,111,113,124,132,173],
"306":[1,26,47,113,124],
"307":[1,26,108,113],
"308":[4,61,113,159],
"309":[12,47,100,111,113,119,132,173],
"30k":[173],
"30s":[2],
"30u":[[164,166],170,173],
"310":[1,2,26,47,113,126,132,160,166,172,173],
"311":[40,111,113,119,166,173],
"312":[1,26,89,108,113,126,132,173],
"313":[47,61,67,108,111,113,126,132,160,164],
"314":[2,88,121,126,127,132,147,166],
"315":[1,12,47,113,121,126,147],
"316":[26,89,108,113,121,124,132],
"317":[1,2,77,113,124,126,166,173],
"318":[2,47,66,108,113,119,126,163,166],
"319":[37,70,108,113,126,132,159,173],
"32-":[[1,4],10,11,23,26,30,35,40,41,44,46,47,52,54,55,[59,61],[66,68],70,71,73,74,76,77,84,85,88,89,91,92,94,95,97,99,100,104,111,113,116,117,119,124,130,133,134,142,143,145,147,149,150,152,156,[158,160],[162,164],166,[170,173]],
"320":[1,2,4,26,108,113,119,132,136,147,173],
"321":[1,2,88,104,111,113,117,147,166,173],
"322":[19,26,40,61,89,113,117,126,132,166,173],
"323":[1,47,113,119,132,165,173],
"324":[26,89,108,113,121],
"325":[26,31,108,113,117,119,132,173],
"326":[47,100,108,113,117,119,121,132,159,173],
"327":[1,12,31,40,111,113,117,119,124,127,132,158,173],
"328":[47,61,113,119,121,126,132,158,164,170,173],
"329":[1,2,40,47,88,104,108,111,113,126],
"32_":[30,46,54,108,111,113,117,119,124,131],
"32b":[3,4,6],
"32g":[94],
"32t":[128],
"32v":[147],
"32x":[115],
"330":[1,2,61,113,121,126,132,145,166],
"331":[2,47,108,113,159,164],
"332":[1,26,94,111,113,164,166,173],
"333":[4,47,113,140,147,164,173],
"334":[1,31,108,113,147],
"335":[1,2,40,113,126,132],
"336":[26,37,88,108,111,113,126,127,132,159,173],
"337":[1,40,47,77,113,126,127,132,159],
"338":[26,35,113,132,[164,166],170,173],
"339":[1,2,40,88,113,132,147,166],
"34-":[113],
"340":[1,2,26,30,37,47,113,132,173],
"341":[40,108,113],
"342":[113,126,173],
"343":[1,126,166,173],
"344":[113,126,132,158,163,173],
"345":[4,19,111,113,126,132,144,173],
"346":[47,88,111,113,142],
"347":[88,113],
"348":[1,4,26,88,94,113,164,173],
"349":[1,26,47,88,108,111,126,132,166,173],
"34_":[113],
"350":[1,2,37,66,113,126,159,170,173],
"351":[37,108,113,159],
"352":[1,89,111,113,121,126,131,132,147,173],
"353":[2,88,111],
"354":[1,2,47,111,113,126],
"355":[2,19,47,113,126,170],
"356":[47,111,113,126,132,159,164,170],
"357":[1,113,121,126,132,147,173],
"358":[4,111,113,121,126,127,132],
"359":[2,47,113,121,126,132,161],
"360":[1,2,4,26,66,69,88,113,126,132,160,166],
"361":[108,113,126,132],
"362":[2,4,59,88,113,126,127,132],
"363":[1,75,100,111,126,173],
"364":[1,2,4,26,47,108,113,126,166,173],
"365":[2,37,40,47,89,108,111,113,126,127],
"366":[1,47,88,113,126],
"367":[77,111,126,173],
"368":[1,40,47,61,77,100,126,132,147,164,165],
"369":[26,40,61,111,126,132],
"370":[2,47,119,126,173],
"371":[1,2,4,88,89,113,119,126,159,173],
"372":[1,40,108,111,113,127,132,147,173],
"373":[1,40,47,113,126,159,173],
"374":[1,47,77,88,111,113,119,126,132,164],
"375":[88,89,100,113,119,126,145,147,158],
"376":[26,61,77,113,119,126,132,164,165,173],
"377":[1,47,70,100,111,113,119,132,173],
"378":[1,2,4,47,88,121],
"379":[1,47,111,113,126],
"37f":[173],
"380":[1,2,111,113,164],
"381":[1,61,88,111,126,127,166],
"382":[1,59,113,132],
"383":[40,88,89,100,113,126,166,173],
"384":[40,66,100,101,104,108,111,113,117,119,121,124,126,132,165,166,173],
"385":[40,47,108,113,119,126,145,158,166],
"386":[1,18,35,54,87,88,100,113,126,143,173],
"387":[1,2,40,89,91,100,111,113,126],
"388":[26,61,108,113,126,132,166,173],
"389":[2,30,47,111,113,165,173],
"38c":[173],
"38e":[164],
"390":[1,2,4,47,100,111,113,159,164,173],
"391":[77,91,108,111,113,126,132,173],
"392":[1,26,35,47,113,126,132,159,164,173],
"393":[1,12,26,30,113,132,173],
"394":[1,35,37,113,127,159,165,166],
"395":[1,2,19,35,111,113,126,159],
"396":[1,26,35,61,108,111,113],
"397":[1,2,35,88,111,113,126,159,166,173],
"398":[2,111,113,166],
"399":[1,47,91,111,113,132,166,173],
"3_4":[113],
"3__":[113],
"3_h":[71],
"3_l":[71],
"3_p":[1],
"3_t":[104],
"3a0":[173],
"3a1":[173],
"3a3":[173],
"3ab":[173],
"3b8":[164],
"3cf":[173],
"3d0":[173],
"3d1":[173],
"3d4":[164],
"3d5":[164,173],
"3d6":[164],
"3d7":[164,173],
"3d8":[164,173],
"3d9":[164,173],
"3da":[164,173],
"3db":[164,173],
"3dc":[164,173],
"3dd":[173],
"3de":[164,173],
"3df":[164,173],
"3e0":[164,173],
"3e1":[164,173],
"3e2":[164,173],
"3e3":[173],
"3e4":[164,173],
"3e5":[173],
"3e6":[173],
"3e7":[164,173],
"3e8":[164,173],
"3e9":[173],
"3ea":[164,173],
"3eb":[173],
"3ec":[173],
"3ed":[173],
"3ee":[173],
"3ef":[164],
"3f0":[164],
"3f4":[173],
"3f5":[173],
"3f7":[164,173],
"3f8":[164,173],
"3fb":[173],
"3fd":[173],
"3ff":[61,173],
"3gh":[0,1,4,6,12,30,60,70,88,89,119,121],
"3kb":[173],
"3mb":[31],
"3rd":[69,71,76,89,91,94,119,124,149,150,154],
"4*2":[89],
"4*4":[89],
"4*7":[111],
"4*9":[142],
"4*h":[155],
"4-0":[5,[17,20],27,28,[47,63],77,88,91,158,159],
"4-1":[21,29,59,[64,71],77,78,91,105,[111,113],145,[162,165],170,171],
"4-2":[0,6,12,100,111,113,114],
"4-3":[113,159,173],
"4-5":[1,89],
"4-6":[155],
"4-b":[1,2,3,8,10,12,30,40,41,45,54,55,59,60,68,70,74,[76,78],84,85,88,89,91,92,94,95,[99,101],103,104,113,115,116,118,119,124,126,128,130,[134,136],139,[142,145],147,149,150,152,154,[156,160],[162,164],166,169,171,173],
"4-d":[30,69,70,113],
"4-e":[84,136],
"4-g":[31],
"4-l":[31],
"4-r":[91],
"4-t":[44],
"4-u":[163],
"4-w":[30],
"400":[1,2,4,26,35,40,47,48,64,108,111,113,126,132,135,160,164,173],
"401":[1,4,113,126,165,166,173],
"402":[16,47,77,113,126,135,159,173],
"403":[1,2,4,111,124,126,132,159,164],
"404":[60,100,111,113,121,124,165,173],
"405":[1,4,37,60,77,89,91,100,111,113,124,165,173],
"406":[1,26,59,60,100,121,126,[164,166],170,173],
"407":[1,26,111,113,121,124,126,132,142,[164,166],173],
"408":[1,26,35,59,113,117,121,126,132,166,173],
"409":[1,47,66,77,101,108,111,113,117,119,121,124,132,160,166,170,173],
"40g":[1,12,30,70,88,89,111,113,115,117,119,124,130,147,158,159],
"40s":[2],
"40x":[4],
"410":[2,4,47,88,113,126,128,132,159,166,173],
"411":[1,4,35,47,113,126,128,159,163,164,166,173],
"412":[2,35,108,126,159,173],
"413":[47,77,113,126,132,165,173],
"414":[47,96,113,126,127,132,158,173],
"415":[1,35,113,126,165],
"416":[2,4,26,47,88,113,126,132,166,173],
"417":[1,47,111,113,126,159,164,173],
"418":[1,40,47,113,126,159,161],
"419":[1,2,26,40,113,121,126,127,132,159,166,173],
"420":[2,26,40,47,113,135,147,159],
"421":[4,88,111,127,147,159,166,173],
"422":[1,113,132,145,166,173],
"423":[1,37,47,113,126,132,172,173],
"424":[1,26,31,35,47,104,111,113,126,127,132,159,173],
"425":[2,91,121,126],
"426":[1,113,121,126,159,173],
"427":[40,47,126,159,164,173],
"428":[2,47,77,88,111,126,132,147,159,[164,166],173],
"429":[1,2,104,113,126,132,164,173],
"42_":[12],
"42f":[173],
"430":[1,2,31,47,61,113,117,126,159,173],
"431":[108,113,119,126,132,147,165,166,173],
"432":[1,26,104,113,127,132,147,159,164,166,172,173],
"433":[1,4,60,88,108,113,127,132,166,172,173],
"434":[47,60,111,113,119,126],
"435":[1,40,47,100,111,119,121,126,139,159,164],
"436":[1,91,119,126,132,164,173],
"437":[77,89,113,119,124,126,159,164,173],
"438":[1,4,35,108,111,113,124,126,127,158,159,166,173],
"439":[4,111,113,119,121,126,159,170,173],
"440":[1,2,35,47,48,111,113,119,126,132,135,159,165,173],
"441":[4,35,47,91,94,113,124,126,159,166],
"442":[35,47,77,88,113,119,126,132,159],
"443":[1,4,40,47,111,126,170,173],
"444":[1,35,77,111,113,126,132,158,159,170,173],
"445":[35,88,111,113,126,173],
"446":[1,111,126,130,166,170],
"447":[2,88,100,113,126,173],
"448":[26,89,113,127,132,158,159,166,173],
"449":[89,113,147,159,166,170,173],
"44f":[173],
"450":[2,35,54,59,88,100,104,113,126,132,173],
"451":[4,35,108,113,159,170,173],
"452":[2,4,26,66,91,113,130,132,166,170,173],
"453":[1,2,113,115,126],
"454":[1,35,113,126,132,159,170],
"455":[1,94,111,113,115,127,132],
"456":[1,77,113,132,144,159,173],
"457":[111,113,126,147,159,173],
"458":[1,47,88,100,113,127,139,147,158,159,173],
"459":[37,88,108,159],
"460":[1,2,4,19,26,100,121,126,132,159,173],
"461":[26,40,113,132,166,173],
"462":[1,60,88,100,113,173],
"463":[113,126,159,173],
"464":[2,47,111,113,126,132,147,159,166,173],
"465":[1,88,111,113,142,159,164,173],
"466":[113,121,147,159,173],
"467":[1,47,111,113,173],
"468":[1,2,60,66,88,113,126,159,173],
"469":[2,26,77,88,113,126,159,173],
"46a":[173],
"46b":[173],
"46c":[173],
"46d":[173],
"46e":[173],
"46f":[173],
"470":[2,26,77,100,111,113,126,132,173],
"471":[40,88,108,111,127,132,166,173],
"472":[1,48,89,94,111,132,159,166,173],
"473":[26,113,159,164,166,173],
"474":[1,88,113,126,127,164,173],
"475":[47,70,111,113,119,126,127,160,170,173],
"476":[1,2,26,47,113,126,132,159,164,166,173],
"477":[1,88,89,111,113,126,[164,166],173],
"478":[1,26,60,100,113,126,132,159,161,173],
"479":[47,113,126,132,159,166,173],
"47a":[173],
"47b":[173],
"47c":[173],
"47d":[173],
"47e":[173],
"47f":[173],
"48-":[91,94],
"480":[1,2,4,6,26,30,40,108,113,126,127,132,159,166,173],
"481":[1,47,61,88,113,148,159,166,173],
"482":[2,47,59,113,126,164,166,173],
"483":[1,4,19,111,113,126,159],
"484":[111,113,127,132,148,166],
"485":[4,37,88,89,108,113,126,132,147,159,160,164,173],
"486":[22,100,113,132],
"487":[2,70,113,124,159,173],
"488":[1,26,77,88,100,113,126,132,158,160,173],
"489":[1,113,132,159,173],
"48a":[173],
"48b":[173],
"48c":[173],
"48d":[173],
"48e":[173],
"48f":[173],
"490":[1,2,47,108,113,126,159,164,173],
"491":[1,2,66,104,113,158,159,165,166,173],
"492":[1,30,31,88,113,132,159,164,173],
"493":[4,70,111,113,173],
"494":[1,40,70,89,113,159,173],
"495":[1,26,88,113,132,173],
"496":[89,113,132,158,159,164,170,173],
"497":[113,126,132,164,166,170,173],
"498":[2,89,100,111,147,159,166,170,173],
"499":[1,61,86,88,113,132,159,164,170,173],
"49a":[173],
"49b":[173],
"49c":[173],
"49d":[173],
"49e":[173],
"49f":[173],
"4_5":[113],
"4__":[113],
"4_b":[12],
"4_e":[72,91,135],
"4_p":[72],
"4_s":[2,30],
"4_t":[46,59],
"4_w":[101],
"4a0":[173],
"4a1":[173],
"4a2":[173],
"4a3":[173],
"4a4":[173],
"4a5":[173],
"4a6":[173],
"4a7":[173],
"4a8":[173],
"4a9":[173],
"4aa":[173],
"4ab":[173],
"4ac":[173],
"4ad":[173],
"4ae":[173],
"4af":[173],
"4b0":[173],
"4b1":[173],
"4b2":[173],
"4b3":[173],
"4b4":[173],
"4b5":[173],
"4b6":[173],
"4b7":[173],
"4b8":[173],
"4b9":[173],
"4ba":[173],
"4bb":[173],
"4bc":[173],
"4bd":[173],
"4be":[173],
"4bf":[173],
"4c2":[173],
"4c3":[173],
"4c4":[173],
"4c5":[173],
"4c6":[173],
"4c7":[173],
"4c8":[173],
"4c9":[173],
"4ca":[173],
"4cb":[173],
"4cc":[164,173],
"4cd":[173],
"4cf":[173],
"4d0":[173],
"4d1":[173],
"4d2":[173],
"4d3":[173],
"4d4":[173],
"4d5":[173],
"4d6":[173],
"4d7":[163,173],
"4d8":[173],
"4d9":[173],
"4da":[173],
"4db":[173],
"4dc":[173],
"4dd":[173],
"4de":[173],
"4df":[173],
"4e0":[173],
"4e1":[173],
"4e2":[173],
"4e3":[173],
"4e4":[173],
"4e5":[173],
"4e6":[173],
"4e7":[173],
"4e8":[173],
"4e9":[173],
"4ea":[173],
"4eb":[173],
"4ec":[173],
"4ed":[173],
"4ee":[173],
"4ef":[173],
"4f0":[173],
"4f1":[173],
"4f2":[173],
"4f3":[173],
"4f4":[173],
"4f5":[173],
"4f6":[173],
"4f7":[163,173],
"4f8":[173],
"4f9":[173],
"4fa":[173],
"4fb":[173],
"4fc":[173],
"4fd":[173],
"4fe":[173],
"4ff":[173],
"4gb":[128],
"4kb":[89,94,113],
"4mb":[31],
"4th":[20,24,76,94,101],
"4x6":[72,135],
"4x7":[4],
"5-0":[1,5,12,22,59,[72,79],91,160,[165,173]],
"5-1":[12,55,[80,86],91,115,116],
"5-2":[0,1,2,31,79,109,116],
"5-4":[14],
"5-6":[119],
"5-7":[40],
"5-b":[88,101,158,162],
"5-t":[47],
"500":[1,2,37,54,89,111,113,121,126,147,164,173],
"501":[1,26,35,47,100,113,126,159,165,173],
"502":[1,26,88,89,111,147,159,173],
"503":[4,47,88,111,113,132,173],
"504":[26,77,100,111,121,132,159,164,173],
"505":[1,47,100,127,166,173],
"506":[1,2,26,88,159,173],
"507":[111,113,132,159,165,170,173],
"508":[1,26,40,59,147,166,173],
"509":[47,88,113,132,159,170,173],
"50a":[173],
"50b":[173],
"50c":[173],
"50d":[173],
"50e":[173],
"50f":[173],
"50g":[124],
"50k":[173],
"50s":[2],
"510":[2,108,113,132,159,166,173],
"511":[2,61,89,113,159,173],
"512":[1,26,73,74,77,88,91,[93,97],[99,104],108,111,113,[115,118],120,121,123,126,[130,132],[134,140],145,[149,152],156,160,162,[164,166],[169,173]],
"513":[100,113,159,164,173],
"514":[70,111,113,126,127,173],
"515":[4,26,113,159,166,173],
"516":[159,170,173],
"517":[35,47,126,132,166,173],
"518":[113,126,132,159,164,165,173],
"519":[94,113,159,173],
"51a":[128,173],
"51b":[173],
"51c":[173],
"51d":[173],
"51e":[173],
"51f":[173],
"520":[1,2,26,77,108,113,127,132,164,173],
"521":[47,94,113,173],
"522":[1,113,158,159,173],
"523":[113,126,159,173],
"524":[26,48,113,127,132,159,164,173],
"525":[1,4,111,113,159,172,173],
"526":[48,88,113,127,132,159,164,173],
"527":[77,100,113,159,166,173],
"528":[1,26,113,126,132,159,170,173],
"529":[1,37,113,131,159,170,173],
"52_":[10],
"52a":[173],
"52b":[173],
"52c":[173],
"52d":[173],
"52e":[173],
"52f":[173],
"530":[1,2,12,61,113,127,173],
"531":[77,113,126,147,159,165,170],
"532":[88,113,126,132,173],
"533":[2,30,60,113,121,159],
"534":[26,88,111,113,132,159,173],
"535":[1,26,47,113,119,132,173],
"536":[4,26,69,111,113,126,132,142,159,166,170,173],
"537":[1,40,91,111,113,121,132,159],
"538":[2,77,111,113,159,173],
"539":[1,2,37,113,161,170],
"53g":[0,1,4,6,12,30,60,70,88,89,119,121],
"53r":[154],
"540":[0,1,2,4,6,12,30,47,60,70,88,89,100,108,113,119,121,159],
"541":[1,132,159,166,170],
"542":[2,4,77,111,113,132,147,159,164,173],
"543":[1,4,26,35,100,113,132,159,166,170],
"544":[26,111,113,127,173],
"545":[1,113,159],
"546":[1,37,100,113,132,147,159],
"547":[1,111,113,132,159,170],
"548":[1,111,113,117,121,159,166,173],
"549":[2,31,37,108,111,113,159,166],
"550":[1,2,47,111,113,127,132,158,159,173],
"551":[26,113,121,132,159,170,173],
"552":[1,26,47,113,132,166],
"553":[1,4,69,111,113,119,126,127,132,142,159,173],
"554":[77,89,100,111,132,159,164,173],
"555":[113,126,159,164,170],
"556":[1,2,26,47,113,121,126,132,159,164,166,173],
"557":[88,113,159,173],
"558":[113,126,173],
"559":[47,61,100,113,132,159,166,173],
"55u":[165,166],
"56*":[69],
"56-":[0,72,93,100,113,130,138,145,171],
"560":[1,2,26,31,47,69,108,113,132,159,166,173],
"561":[2,40,69,113,159],
"562":[1,2,40,111,113,121,126,132,159,166,173],
"563":[26,113,117,170],
"564":[117,132,159],
"565":[1,2,113,132,159,166,173],
"566":[1,12,37,113,132,159,170],
"567":[1,94,113,117,144,159,170,173],
"568":[1,26,37,113,117,132,159,173],
"569":[1,2,47,100,113,132,159,173],
"56_":[72,88,111,113,119,124,130,138,139],
"56e":[113],
"570":[2,66,113,166,173],
"571":[1,111,113,159],
"572":[47,77,88,132,159,166,173],
"573":[26,87,126,159,173],
"574":[1,4,104,113,126,170],
"575":[47,113,159,166,173],
"576":[1,2,26,47,108,113,132,159,160,170,173],
"577":[100,113,121,132,159],
"578":[1,2,37,100,113,132,159,164],
"579":[1,111,113,121,132,147,159,164,173],
"57a":[173],
"57c":[173],
"580":[0,2,37,70,113,132,147,159,164,173],
"581":[113,132,159,173],
"582":[1,2,26,113,132,147,173],
"583":[77,113,147,159],
"584":[4,37,94,113,132,159,164,166,170,173],
"585":[1,159],
"586":[26,70,77,111,113,127,132,158,159],
"587":[1,111,113,132,159,164,173],
"588":[26,113,115,132,159,164,166,173],
"589":[47,100,111,113,127,159,164,173],
"58a":[173],
"58c":[173],
"59-":[87],
"590":[2,47,113,132,159,173],
"591":[113,126,132,159,173],
"592":[2,47,88,111,113,132,147,159,163,173],
"593":[2,47,88,111,113,132,173],
"594":[86,126,159,173],
"595":[111,121,173],
"596":[26,113,126],
"597":[1,47,61,70,113,127,132,159,166,173],
"598":[1,37,111,113,126,132,173],
"599":[2,91,100,113,126,132,159,173],
"5_6":[113],
"5_h":[70],
"5_l":[70],
"5a1":[173],
"5a3":[173],
"5b1":[142,173],
"5b3":[173],
"5b9":[173],
"5bb":[173],
"5bc":[173],
"5bp":[4],
"5gh":[31,35],
"5th":[70,80,87,94,118,126,133,135,144,160,173],
"5ub":[91,119,124,130],
"6*1":[73],
"6*x":[69],
"6-0":[0,1,[3,9],12,23,37,54,60,74,77,85,[87,94]],
"6-1":[1,10,11,59,74,88,89,91,[94,103]],
"6-2":[1,12],
"6-b":[0,1,12,30,55,59,60,66,[70,72],85,88,89,91,92,94,98,100,101,104,111,113,115,116,118,119,124,126,130,134,138,[142,145],158,159,165,166,171,173],
"6-d":[70,113],
"6-e":[88,92,118,145,149,160],
"6-i":[160],
"6-w":[1],
"60-":[9],
"600":[1,4,26,40,100,132,146,159,166,173],
"601":[1,47,69,88,113,132,158,159,161],
"602":[111,113,126,132,159],
"603":[113,159],
"604":[1,4,47,113,126,159,166,173],
"605":[1,47,111,113,117,126,132,159],
"606":[2,40,47,100,111,126,132,147,173],
"607":[26,47,88,113,173],
"608":[1,26,47,88,113,126,132,173],
"609":[111,113,121,159],
"60k":[31],
"60s":[2],
"610":[1,2,26,113,130,132,159,166],
"611":[1,47,113,132,159,[164,166],170,173],
"612":[113,132,159],
"613":[2,113,130,159],
"614":[1,100,108,113,115,132,159,173],
"615":[100,113,126,132,159],
"616":[26,100,111,113,123,132,159,166,173],
"617":[4,61,77,113,132,159,173],
"618":[1,113,121,132,159,173],
"619":[1,113,126,159,173],
"61e":[84],
"620":[1,2,26,47,113,127,132,159,164,166,170],
"621":[4,40,60,88,113,132,147,173],
"622":[26,47,59,77,113,117,166],
"623":[1,26,111,113,147,159,173],
"624":[26,37,117,132,159,164],
"625":[1,4,40,45,47,60,88,111,113,126,159,164,173],
"626":[1,47,89,100,111,113,132,159,165],
"627":[4,113,132],
"628":[4,132,147,165],
"629":[1,26,37,60,66,111,113,121],
"630":[2,26,47,66,100,111,113,121,132,159,165,170],
"631":[1,77,88,113,132,159,173],
"632":[1,26,77,113,117,132,159,164],
"633":[1,113,132,159,[164,166],170,173],
"634":[1,2,4,26,111,113,132,164],
"635":[89,113,132,159,173],
"636":[1,47,59,117,159,166,173],
"637":[1,47,61,88,111,113,126,159,166],
"638":[2,40,88,100,108,111,113,117,119,124,132,159,164,173],
"639":[1,75,113,121,132,159],
"63m":[31],
"64-":[1,3,8,10,12,30,41,45,54,55,59,60,68,70,74,[76,78],84,85,88,89,91,92,94,95,[99,101],103,104,113,115,116,119,124,126,128,130,[134,136],139,[142,145],147,149,150,152,154,156,157,159,160,[162,164],169,171],
"640":[0,2,4,6,47,77,108,111,113,117,126,132,159,164,173],
"641":[1,2,47,88,96,113,126,132,159,160,173],
"642":[111,113,147,159,173],
"643":[1,2,113,117,159,173],
"644":[26,113,166,173],
"645":[1,4,47,61,89,111,113,117,147,158,159,170,173],
"646":[88,113,126,132,159,170,173],
"647":[100,111,113,121,159,166,173],
"648":[2,26,111,113,159,173],
"649":[1,2,47,88,121,159,173],
"64_":[30,46,59,72,91,101,135],
"64a":[173],
"64b":[173],
"64c":[173],
"64d":[173],
"64e":[173],
"64f":[173],
"64k":[113],
"64x":[88,135],
"650":[1,2,47,66,100,113,132,147,164,173],
"651":[26,111,113,132,159,173],
"652":[1,26,40,61,113,117,159,173],
"653":[26,100,113,126,159,173],
"654":[4,37,77,113,126,132,159,166,173],
"655":[2,4,47,69,111,113,119,126,132,142,158,159,173],
"656":[26,37,77,89,113,117,121,126,132,159,160,164,173],
"657":[1,26,111,159,160,166,173],
"658":[1,26,88,111,113,132,159,173],
"659":[2,40,111,126,159,173],
"65a":[173],
"65b":[142,173],
"65c":[173],
"65d":[173],
"65e":[173],
"65f":[173],
"660":[2,26,47,88,89,111,113,121,132,159,173],
"661":[1,61,100,113,159,166,173],
"662":[1,4,47,113,132,159,173],
"663":[1,111,113,132,159,166,173],
"664":[1,2,26,88,96,111,113,132,159,161,173],
"665":[87,88,113,121,126,132,159,164,166,173],
"666":[26,61,100,108,113,159,164,173],
"667":[1,37,61,111,113,121,159,164,173],
"668":[1,47,159,173],
"669":[1,77,113,159,173],
"66a":[173],
"66b":[173],
"66c":[173],
"66d":[173],
"66m":[31],
"67-":[47],
"670":[1,2,12,30,70,88,89,100,108,111,113,115,117,119,124,130,132,147,158,159],
"671":[1,111,126,132],
"672":[26,47,108,113,132,159],
"673":[26,113,121,132,159,166,173],
"674":[1,94,108,113,126,159,173],
"675":[1,6,111,113,132,159],
"676":[1,26,111,113,132,159,173],
"677":[1,26,47,77,113,126,132,142,159,166,173],
"678":[47,113,132,144,159,166,173],
"679":[77,111,113,159],
"67_":[113],
"680":[2,26,60,66,111,113,121,132,159,173],
"681":[1,2,91,100,113,117,132,159,173],
"682":[113,126,159,164,173],
"683":[77,89,132,147,173],
"684":[1,12,26,89,108,113,126,132,159,173],
"685":[88,108,111,113,159,173],
"686":[113,159,166,173],
"687":[1,26,88,89,113,147,159,164,173],
"688":[1,26,37,47,104,111,113,126,127,132,159,173],
"689":[26,113,121,159,173],
"68a":[173],
"68b":[173],
"68c":[173],
"68d":[173],
"68e":[173],
"68f":[173],
"690":[1,77,108,113,126,159,173],
"691":[2,37,61,77,113,132,166,173],
"692":[77,111,113,127,147,159,164,173],
"693":[1,2,70,111,113,132,159,173],
"694":[1,147,159,173],
"695":[108,111,113,147,159,166,173],
"696":[2,4,37,77,111,132,159,173],
"697":[159,166,173],
"698":[2,70,91,100,108,121,159,173],
"699":[1,2,100,113,132,159,164,166,173],
"69a":[173],
"69b":[173],
"6_7":[113],
"6__":[113],
"6_a":[72,111],
"6_b":[72],
"6_c":[119,138,139],
"6_e":[113],
"6_m":[72,124],
"6_p":[72,111],
"6_s":[72,88,119,124,130,138],
"6_t":[119,124],
"6_u":[72],
"6a3":[163],
"6bi":[115,119],
"6bp":[4],
"6dd":[163],
"6e4":[173],
"6e5":[173],
"6e6":[173],
"6e7":[173],
"6ec":[113],
"6gh":[2,3,4,6,10,12,31],
"6in":[54,87],
"6kb":[139,173],
"6mb":[31,49],
"6x3":[104],
"7*a":[12],
"7-0":[1,31,32,34,35,88,91,94,100,102,104,113],
"7-1":[89,91,105,165,166],
"7-4":[1,88,89,124],
"7-6":[1,12,30,70,88,89,111,113,115,117,119,124,130,147,158,159],
"7-b":[12,59,94,157,173],
"7-t":[47,68],
"700":[1,2,12,30,47,70,88,89,100,108,111,113,115,117,119,124,126,130,147,158,159,166,173],
"701":[61,77,159],
"702":[12,47,126,131,132,140,147,159],
"703":[4,111,113,159],
"704":[1,30,70,108,113,132,159,166],
"705":[2,89,108,111,113,126,159,166,173],
"706":[111,132,159],
"707":[59,77,100,159,164,166],
"708":[1,59,121,173],
"709":[1,47,113,159,173],
"70e":[164],
"70f":[164],
"70h":[124],
"70s":[2],
"710":[2,113,159],
"711":[40,113,158,159,173],
"712":[70,95,126,132,158,159,173],
"713":[1,100,111,113,127,132,147],
"714":[2,111,113,132,164,165],
"715":[37,47,100,111,113,159,164,166],
"716":[1,4,26,100,108,113,126,132,158,159],
"717":[1,2,88,158,159],
"718":[88,111,113,132,158,159,173],
"719":[108,111,113,126,159,166],
"720":[2,47,87,89,126,132,147,166,173],
"721":[1,61,94,100,103,113,117,127,142,159,166,173],
"722":[1,47,89,111,113,121,132,147,166,173],
"723":[40,77,113,132,159,173],
"724":[47,77,100,108,111,121,132,173],
"725":[6,40,47,132,159,170,173],
"726":[91,111,113,132,159,173],
"727":[6,12,70,111,113,132,159,173],
"728":[12,26,30,111,113,132,159,161,173],
"729":[1,26,111,113,159,173],
"72a":[173],
"72b":[173],
"72c":[173],
"72d":[163,173],
"72e":[48,173],
"72f":[173],
"730":[2,4,47,108,113,[164,166],170,173],
"731":[37,113,132,159,163,173],
"732":[59,111,115,127,132,147,166,173],
"733":[1,47,88,113,132,159,173],
"734":[91,113,121,132,159,173],
"735":[111,113,126,159,166,173],
"736":[2,26,47,111,132,159,173],
"737":[2,4,61,126,132,159,173],
"738":[40,77,108,113,128,132,164,173],
"739":[113,132,159,173],
"73a":[173],
"73b":[173],
"73c":[173],
"73d":[173],
"73e":[173],
"73f":[173],
"740":[2,37,111,126,159,166,173],
"741":[108,113,128,166,173],
"742":[1,26,47,61,111,113,126,159,166,173],
"743":[40,59,61,113,121,126,159,173],
"744":[1,26,88,111,113,132,159,173],
"745":[1,2,12,88,94,100,113,115,126,158,159,173],
"746":[26,127,159,166,173],
"747":[1,2,48,113,126,132,166,173],
"748":[4,26,113,121,132,159,173],
"749":[1,47,113,127,147,159,173],
"74a":[173],
"74b":[173],
"74c":[173],
"74d":[173],
"74e":[173],
"74f":[173],
"750":[2,4,31,47,89,108,111,113,126,132,159,173],
"751":[70,111,113,121,132,159,173],
"752":[26,40,91,113,123,132,166,173],
"753":[1,2,26,47,89,113,147,164,173],
"754":[26,31,100,113,159,160,173],
"755":[1,127,132,159,166,173],
"756":[88,111,113,127,132,164,166,173],
"757":[1,113,159,173],
"758":[47,70,113,127,147,159,166,173],
"759":[1,111,113,132,159,164,165,173],
"75a":[173],
"75b":[173],
"75c":[145,158,173],
"75d":[173],
"75e":[173],
"75f":[173],
"760":[1,2,26,47,113,132,159,160,166,173],
"761":[1,113,126,132,158,159,173],
"762":[47,111,113,127,132,159,173],
"763":[4,47,113,132,173],
"764":[2,26,61,88,111,132,159,173],
"765":[1,47,61,113,132,173],
"766":[40,113,126,132,147,159,166,173],
"767":[1,2,12,26,77,113,121,159,173],
"768":[1,3,4,12,91,101,108,117,119,124,132,147,159,166,173],
"769":[70,111,113,132,159,164,166,173],
"76a":[173],
"76b":[173],
"76c":[173],
"76d":[173],
"76e":[173],
"76f":[173],
"770":[1,2,66,70,88,89,108,111,113,132,159,173],
"771":[100,108,147,173],
"772":[26,88,91,108,113,121,132,142],
"773":[113,121,132,159,[164,166],170,173],
"774":[26,48,108,111,132,159,166,173],
"775":[1,100,108,113,132,159],
"776":[4,26,111,132,159,160,164],
"777":[1,2,26,66,113,132,142,159,160,173],
"778":[40,111,113,[158,160],166],
"779":[1,26,47,100,111,113,[158,160],173],
"77a":[173],
"77b":[173],
"77c":[173],
"77f":[173],
"780":[0,1,2,26,40,108,113,127,132,159,166,173],
"781":[1,59,77,111,113,126,132,173],
"782":[1,26,108,111,113,159,160,166,173],
"783":[30,89,159,165,173],
"784":[4,26,30,77,108,111,132,159,160,164,173],
"785":[2,108,113,127,145,159,160,173],
"786":[4,37,88,100,108,113,126,160,173],
"787":[2,113,159,173],
"788":[4,40,77,100,113,132,164,166,173],
"789":[26,47,60,100,113,127,144,147,159,173],
"78_":[113],
"78b":[173],
"78c":[173],
"78d":[173],
"790":[1,2,88,89,111,113,159,166,173],
"791":[1,100,121,132,159,166,173],
"792":[100,111,113,121,132,145,158,159,173],
"793":[1,113,147,158],
"794":[1,2,111,113,132,164,173],
"795":[1,111,166,173],
"796":[26,47,48,59,108,111,121,159,173],
"797":[26,35,111,132,173],
"798":[1,2,4,132,159,166,173],
"799":[1,113,159,166,173],
"79a":[173],
"79b":[173],
"79c":[173],
"79d":[173],
"79e":[173],
"79f":[173],
"7_8":[113],
"7a0":[173],
"7a1":[173],
"7a2":[173],
"7a3":[173],
"7a4":[173],
"7a5":[173],
"7a6":[173],
"7a7":[173],
"7a8":[173],
"7a9":[173],
"7b0":[173],
"7b4":[173],
"7b5":[173],
"7b6":[173],
"7b7":[173],
"7b8":[173],
"7b9":[173],
"7ba":[173],
"7bb":[173],
"7bc":[173],
"7bd":[173],
"7be":[173],
"7bf":[173],
"7bi":[94],
"7c0":[173],
"7c1":[173],
"7c2":[173],
"7c3":[173],
"7c8":[173],
"7c9":[173],
"7ca":[173],
"7d0":[173],
"7d1":[173],
"7d6":[173],
"7d7":[173],
"7d8":[173],
"7d9":[173],
"7f5":[173],
"7f6":[173],
"7fa":[128],
"7ff":[23,61,76,128,164],
"7kb":[173],
"7th":[59,113,118,133,144,157],
"8-0":[[0,13],30,64,70,91,100,[106,116],170],
"8-1":[14,48,69,74,91,94,115,[117,125],155],
"8-3":[69],
"8-b":[1,16,29,32,40,59,70,72,74,88,91,92,94,98,100,101,104,105,113,115,119,124,130,[134,136],138,145,147,150,[157,159],162,[164,166],171,173],
"8-c":[173],
"8-d":[30,70,113,165],
"8-e":[160],
"8-i":[91],
"8-p":[115],
"8-t":[47],
"800":[2,4,19,26,64,105,113,128,132,135,145,150,159,164,173],
"801":[1,37,87,108,113,126,127,132,159,173],
"802":[1,108,113,121,127,166],
"803":[26,87,91,108,111,113,124,126,127,130,132,143,159],
"804":[16,70,113,121,135,159],
"805":[59,113,121,159],
"806":[1,37,40,77,111,113,132],
"807":[108,113,158,159,164,173],
"808":[30,51,111,113,132,145,150,164,173],
"809":[26,113,147],
"80s":[2],
"810":[2,31,100,111,131,132,173],
"811":[26,88,108,113,132,148,159],
"812":[1,26,30,88,91,113,124,126,130],
"813":[1,4,77,100,111,113,127,132,166],
"814":[26,113,115,117,121,132],
"815":[88,89,100,101,111,113,132,159,173],
"816":[26,47,61,89,108,132,166],
"817":[37,108,126,127,159,173],
"818":[1,108,113],
"819":[45,47,77,101,108,113,121,132,159,170,173],
"820":[0,1,2,4,9,10,12,22,26,30,108,113,121,147,159,173],
"821":[113,166,173],
"822":[1,37,77,100,113,132,159,164,166,173],
"823":[40,108,111,113,117,158,159,164],
"824":[26,37,59,108,113,121,132,159,164],
"825":[1,47,108,113,132,159,173],
"826":[1,12,59,113,126,132,159,173],
"827":[88,111,113,121,132],
"828":[1,26,113,173],
"829":[1,2,111,113,117,132],
"830":[1,2,4,108,117,121,132,164,173],
"831":[77,88,113,121,159,160,173],
"832":[26,88,94,113,132,159,160,166,173],
"833":[113,127,147,164],
"834":[1,4,113,132,147,159,160,164,166],
"835":[113,160,166],
"836":[1,26,100,108,113,173],
"837":[1,108,113,132,145,158,173],
"838":[88,126,132,160],
"839":[113,126,132,147,166,173],
"840":[2,113,121,126,132,135,159,173],
"841":[26,48,66,77,88,108,113,166,173],
"842":[1,61,86,89,113,127],
"843":[1,132,147,159],
"844":[26,108,113,132,160],
"845":[2,94,104,111,113,127,132,147,173],
"846":[66,88,121,132,160,166],
"847":[2,89,126],
"848":[89,113,121,132,148,159,160],
"849":[70,89,100,113,126,159,160],
"84f":[163],
"850":[2,4,111,132,160],
"851":[108,113,160,173],
"852":[26,47,77,89,113,127,166],
"853":[1,4,40,77,88,108,166],
"854":[26,88,111,113,127],
"855":[26,121],
"856":[26,47,88,113,132,142,173],
"857":[2,4,108,113,121,126,132,145,164,166,173],
"858":[48,111,113,132,159,173],
"859":[2,87,100,113,132,160,173],
"860":[2,111,113,160,166,173],
"861":[1,35,100,160,173],
"862":[4,70,89,113,159,160,166],
"863":[1,26,47,77,100,108,111,113,160,166],
"864":[26,108,113,132,160,164,173],
"865":[100,111,113,117,159,173],
"866":[1,26,47,113,126,132,160,173],
"867":[4,40,113,160],
"868":[61,147,160,173],
"869":[70,88,100,111,113,126,132,159,160,164],
"86a":[163],
"86i":[54,87],
"870":[2,88,111,113,121,124,127,132,160,166,173],
"871":[1,2,37,70,88,100,113,126,164],
"872":[30,111,113,132,142,147,173],
"873":[37,77,113,132,159,173],
"874":[113,127,159,173],
"875":[2,88,89,100,108,113,117,126,127,145,170,173],
"876":[61,108,113,117,147,166],
"877":[1,26,48,111,113,173],
"878":[61,87,108,113,127,132,164,166,173],
"879":[2,100,113,132,170,173],
"880":[2,26,30,77,108,121,132,135,160,164,173],
"881":[1,4,30,108,113,126,166,170,173],
"882":[111,113,132,147,164],
"883":[4,26,113,132,147,173],
"884":[1,30,60,111,113,132,173],
"885":[26,47,87,111,113,166,173],
"886":[47,100,108,113,132,170,173],
"887":[100,104,113,173],
"888":[26,47,89,108,111,113,132,158,160,164,173],
"889":[1,108,147,164,173],
"890":[1,2,113,173],
"891":[113,132,147,173],
"892":[2,40,89,108,113,121,132,170,173],
"893":[4,108,111,126,158,173],
"894":[26,111,113,127,164,166,173],
"895":[47,61,113,173],
"896":[26,108,111,113,132,166,173],
"897":[1,89,100,113,128,164,166,173],
"898":[61,113,173],
"899":[47,77,111,126,132,147,173],
"89_":[113],
"89a":[144],
"89d":[164],
"8_1":[118],
"8__":[113],
"8_e":[113,119],
"8_m":[113,139],
"8_s":[72],
"8_t":[1,26,119,124,131],
"8a0":[173],
"8af":[135,150,166],
"8bf":[173],
"8bi":[94,119],
"8c0":[173],
"8df":[173],
"8e3":[164],
"8kb":[173],
"8mb":[31],
"8mu":[135],
"8x1":[104],
"8x3":[111],
"8x8":[115],
"9-0":[33,37,74,88,109,118,124,[126,133]],
"9-1":[34,59,[92,94],134],
"9-2":[[59,62],87],
"9-3":[35,63],
"9-a":[166],
"9-b":[173],
"9-r":[171],
"900":[2,19,108,111,113,132,170,173],
"901":[1,26,113,131,132,173],
"902":[1,47,113,121,166,173],
"903":[113,132,173],
"904":[26,61,70,111,113,121,132,173],
"905":[1,2,60,77,113,126,164,166],
"906":[26,47,100,113,115,126,132,166],
"907":[47,77,113,132,173],
"908":[1,26,47,111,113,164],
"909":[1,113,164,166],
"90_":[113],
"90g":[145,158],
"90s":[2],
"910":[1,2,61,88,108,166,173],
"911":[1,2,113,126,166],
"912":[111,113,132,164],
"913":[88,108,113,132,147,173],
"914":[113,158,166,173],
"915":[104,113,132,166,173],
"916":[113],
"917":[2,35,47,77,111,113,126,173],
"918":[1,94,113,121,158,166,173],
"919":[100,111,113,147,173],
"91b":[163],
"920":[1,2,61,111,113,132,164,173],
"921":[2,4,47,108,113,132,147,173],
"922":[1,40,111,147,158,164,173],
"923":[1,35,47,113,164,166],
"924":[1,88,113,132,163,164,166,173],
"925":[113,164,166],
"926":[77,113,132],
"927":[1,2,26,47,89,108,111,113,132],
"928":[1,31,132,160,166,173],
"929":[2,88,113,126],
"930":[2,113],
"931":[2,113,147,166],
"932":[113,132,147],
"933":[1,2,26,70,111,113,126,127,132,140,173],
"934":[1,47,88,111,113,126,132,166,173],
"935":[111,113,132,166,173],
"936":[26,111,166,173],
"937":[2,4,111,113,132,166,173],
"938":[1,26,100,108,111,113,126,127,158,166,173],
"939":[1,12,37,88,113,132,164,166],
"940":[2,26,113,147,166],
"941":[1,26,35,113,127,173],
"942":[1,2,31,77,113,131,132,173],
"943":[1,26,113,132,164,166,173],
"944":[1,26,113,132,173],
"945":[70,88,111,113],
"946":[1,100,113,147,173],
"947":[1,88,100,111,113,166,173],
"948":[1,4,113,147,166,173],
"949":[61,111,113,127,173],
"950":[1,2,61,113,126,173],
"951":[1,4,35,111,113,121,132,164],
"952":[1,26,113,132,166,173],
"953":[37,88,113,132],
"954":[111,113,126,132,147,166,170,173],
"955":[127],
"956":[1,26,77,113,126,132,147,166,173],
"957":[166,173],
"958":[2,113,166,173],
"959":[1,113,132,163],
"960":[2,26,113,132,160,166,173],
"961":[113,132,166],
"962":[111,132,158],
"963":[26,35,113,166],
"964":[1,100,113,132],
"965":[2,26,89,111,170],
"966":[1,113,132,173],
"967":[1,47,89,113],
"968":[100,127,132,166],
"969":[111,126,127,164,166,173],
"96s":[48],
"970":[1,2,35,89,111,113,132,147],
"971":[89,113,127,132,173],
"972":[113,126,166],
"973":[89,111,113,121,127,128,164,173],
"974":[4,113,127,128,166],
"975":[1,113,164,173],
"976":[111,113,132,164,166,170],
"977":[89,100,113,160],
"978":[1,70,111,113,126,166,173],
"979":[1,35,113,126,132,166,173],
"980":[1,2,26,89,166],
"981":[37,100,113,166],
"982":[1,37,89,108,111,113,166,173],
"983":[1,113,121,122,132,166,173],
"984":[2,26,113,127,132],
"985":[1,100,111,113,132],
"986":[30,100,113,126,143,166],
"987":[113,132,164],
"988":[1,37,61,100,113,126,164,173],
"989":[1,113],
"990":[2,111,113,132,166,173],
"991":[1,35,111,113,173],
"992":[1,26,47,59,100,113,132,166],
"993":[111,132,164],
"994":[1,31,89,111,113,117,132,173],
"995":[6,108,113,121,122,132,164],
"996":[1,26,100,117,173],
"997":[1,111,121,132,147,164],
"998":[1,89,113,132,164,170],
"999":[1,30,77,86,113,158,164],
"99_":[30,113],
"9_9":[30],
"9__":[113],
"9ab":[144],
"9d8":[128,164],
"9d9":[164],
"9da":[128],
"<al":[170],
"<ch":[53],
"<in":[108],
"<st":[19],
"<t>":[82],
"<un":[82],
"_00":[30,98,118,173],
"_01":[118],
"_0_":[118],
"_10":[98,149],
"_11":[98,118,157,170],
"_12":[66,113],
"_15":[118],
"_1_":[113],
"_2_":[113],
"_32":[6],
"_34":[113],
"_3_":[113],
"_45":[113],
"_4_":[113],
"_56":[113],
"_5_":[113],
"_6_":[113],
"_78":[113],
"_85":[126],
"_89":[113],
"_8_":[118],
"_99":[30,113],
"__2":[113],
"__3":[113],
"__4":[113],
"__5":[113],
"__9":[113],
"___":[113,131,140],
"__b":[1,119,128,139,173],
"__d":[113],
"__i":[55],
"__m":[120],
"__s":[131,140],
"_ab":[100,131,137,140],
"_ac":[66],
"_ad":[94,119,136],
"_al":[72,94,97,111,138],
"_an":[2,128,143],
"_as":[22,27,87],
"_av":[1,115,126],
"_az":[89],
"_ba":[53],
"_be":[101],
"_bi":[58,101,104,143,152,166],
"_bl":[12,89,104,117,133],
"_bo":[108],
"_br":[115,138],
"_bs":[22,72],
"_bu":[1,119,128,139,173],
"_by":[54,58,94,104,135,157],
"_ca":[37,100,129,138],
"_ch":[24,109],
"_cl":[82,143],
"_cm":[94,113,117,138,139],
"_co":[113,126],
"_cu":[128,131,137,140],
"_cv":[113,119],
"_d_":[113],
"_da":[31,37],
"_dd":[113],
"_di":[113,121,142],
"_dj":[159],
"_do":[10],
"_dw":[94],
"_el":[117],
"_en":[43],
"_ep":[72,74,88,89,91,94,97,111,113,115,[117,120],124,126,130,131,[135,140]],
"_er":[128],
"_ex":[37,115,166,173],
"_ff":[173],
"_fi":[157],
"_fl":[125,150],
"_fu":[31,129],
"_ge":[128],
"_gf":[135],
"_ha":[101,113],
"_he":[60,170],
"_hi":[70,71,73],
"_ho":[82],
"_i3":[94,115],
"_if":[131,137,140],
"_im":[104,114],
"_in":[10,55,58,108,113,115,131,137,140],
"_it":[114,127],
"_ko":[138],
"_le":[2,83],
"_lo":[35,70,71,73,87,110,139],
"_m1":[88,120],
"_ma":[2,46,89,94,113,115,117,124,126,139,161,166],
"_mi":[48,139],
"_mm":[72,74,88,89,91,94,97,111,113,115,[117,120],124,126,130,135,136,138,139],
"_mo":[113,126],
"_mp":[72],
"_mt":[125],
"_mu":[2,91,121],
"_na":[64,104],
"_ne":[35,131,137,140],
"_ni":[118],
"_of":[53,65,131,137,140,157],
"_op":[42],
"_or":[37],
"_ov":[119],
"_pa":[72,111,113],
"_pc":[117],
"_pd":[72],
"_pe":[72,91,94,111,113,115,126],
"_pm":[82],
"_po":[1,45,65,120,129,139],
"_ps":[22,104],
"_pt":[105,114,158],
"_qu":[31],
"_qw":[16],
"_ra":[53],
"_re":[131,140],
"_ro":[113],
"_sa":[119,124,130],
"_sd":[159],
"_se":[27,80,88,94,101,120,126,128,157],
"_sh":[72,91,113,115,118,126,138],
"_si":[24,72,89,93,113,138,139,142],
"_sk":[113],
"_sl":[72,91,94],
"_so":[111,131,137,140],
"_sp":[39,168],
"_sr":[72,91,94],
"_ss":[22,30],
"_st":[2,26,53,67,96,109,120,131,140],
"_su":[87,113,136,139,159],
"_sw":[22,131,140],
"_t>":[108],
"_ta":[22],
"_te":[31,39,58,74,94,113],
"_ti":[125],
"_to":[60,147],
"_tr":[100,128,131,140],
"_tw":[65],
"_ty":[53,76],
"_u6":[126],
"_un":[22,72],
"_va":[76,128],
"_ve":[31,88,104,113,147],
"_vi":[105,109],
"_vl":[152],
"_vp":[126],
"_we":[101],
"_wo":[64],
"_xo":[139],
"_ze":[54,157],
"a-1":[42,74],
"a-2":[74],
"a-3":[160],
"a-b":[113],
"a-j":[118],
"a-l":[162],
"a-p":[159],
"a-r":[159],
"a-z":[88,89,94,118],
"a00":[158],
"a11":[100],
"a1m":[42],
"a25":[42],
"a28":[164],
"a2e":[164],
"a32":[30,99],
"a34":[163],
"a51":[128],
"a57":[100],
"a64":[30,139,173],
"a65":[173],
"a66":[173],
"a68":[173],
"a69":[173],
"a72":[173],
"a73":[173],
"a74":[173],
"a75":[173],
"a76":[173],
"a77":[173],
"a78":[173],
"a79":[173],
"a7a":[173],
"a7b":[173],
"a7c":[173],
"a7d":[173],
"a7f":[173],
"a80":[164],
"a_c":[100],
"a_s":[87],
"a_t":[76],
"aa0":[158],
"aa8":[164],
"aaa":[14,88,100,104,113,164],
"aab":[14,100,104,164],
"aac":[105],
"aar":[100],
"aas":[118],
"ab5":[173],
"ab_":[22],
"aba":[14,15,37,167],
"abb":[14,104,173],
"abc":[14,30,59,70,100,101,144],
"abe":[26,35,50,108,115,118,120,133],
"abi":[2,54,94,100,113,128,131,135,137,143,162,173],
"abl":[[1,4],6,7,10,13,16,19,22,23,[25,31],33,[35,37],39,40,[43,48],50,52,[54,56],[58,62],[66,71],[73,75],77,78,80,81,[84,98],[100,103],[105,111],[113,145],[147,150],[152,162],[164,167],[169,173]],
"abo":[1,3,9,10,12,14,26,28,31,[35,38],40,43,48,50,51,56,60,74,81,85,[88,94],100,105,[109,111],113,[115,119],122,124,126,[128,131],133,139,144,145,151,152,[157,160],[162,164],166,167,172,173],
"abr":[122],
"abs":[1,8,107,119,122,124,130,131,134,137,140,150,161,164,171],
"abu":[28,133],
"aby":[113,128],
"aca":[123,154],
"acc":[1,2,4,12,19,22,26,30,32,37,42,46,47,53,58,59,72,74,78,81,85,86,[88,91],94,97,100,101,104,105,108,[111,113],119,122,124,126,[130,132],137,[139,141],145,147,148,150,[158,160],162,166,168,170,171],
"ace":[3,4,10,12,16,22,31,34,40,60,63,69,70,74,77,81,85,88,89,91,92,94,95,100,104,105,113,115,116,122,124,126,128,131,132,134,137,140,142,144,147,148,150,154,158,161,162,164,167,168,170,172,173],
"ach":[1,4,6,10,12,16,19,23,24,26,[28,32],[34,37],40,41,46,49,[57,60],66,67,[69,71],73,74,[76,78],80,81,[84,92],94,97,100,101,104,105,108,111,113,115,[117,120],122,124,[126,128],[130,136],139,[142,149],[151,162],[164,170],172,173],
"aci":[81,101,104,105,109,119,126,158,162,168,173],
"ack":[1,6,12,16,19,21,24,26,[28,30],35,36,40,42,43,47,[51,54],57,66,[69,72],74,77,81,82,[85,89],91,92,94,96,97,100,104,105,111,113,115,[117,119],[122,124],126,128,129,136,138,139,142,143,[145,148],152,158,160,162,164,[170,173]],
"acq":[132],
"acr":[81,88,91,94,111,115,128,132,142,[146,148],160,162],
"acs":[105],
"act":[0,2,3,4,10,12,13,18,26,30,31,34,37,40,44,45,48,49,51,55,60,64,[67,69],71,74,75,79,81,[83,91],94,96,99,100,102,[104,109],112,113,115,118,119,[121,124],126,128,130,[132,136],138,139,[142,145],[147,162],164,166,167,[170,173]],
"acy":[53,86],
"ad-":[7,57,105,115,128],
"ad_":[83,119,124,130],
"ada":[26,32,76,94,105,122,128,148,157,159,160,173],
"adb":[1,2,16,54,72,96,100,119,124,130,134,149],
"adc":[46,47,59,77,94,95,99,113,115,133,135,138,149,150,162,171],
"add":[[0,173]],
"ade":[2,3,12,30,31,40,48,54,60,61,68,71,75,83,85,88,91,96,100,105,109,113,122,126,127,129,130,139,144,147,151,[159,162],[164,167],170,173],
"adi":[12,26,30,35,37,39,40,73,81,85,88,91,94,99,100,104,105,113,122,150,152,156,158,160,162,170,171],
"adj":[2,12,32,70,88,89,94,100,113,124,126,134,137,142,144,147,148,154,158,161,162,164,172],
"adl":[105,112,150,154],
"adm":[81,96,105,167],
"ado":[110],
"adp":[122],
"adr":[100,159],
"ads":[2,4,26,35,37,73,81,85,87,88,91,94,105,115,120,128,129,131,137,139,142,150,158,159,162,163,167,171],
"adu":[88,113,130,139],
"adv":[2,24,39,61,62,81,92,94,100,105,108,111,113,126,136,145,157,158,162,163],
"adw":[91,104],
"ady":[26,34,40,42,48,60,86,88,89,91,96,100,105,108,109,113,122,140,143,[158,160],167,168,171,173],
"ael":[118,122,126],
"aes":[123],
"afa":[12,24,122],
"afd":[128],
"afe":[22,26,30,32,44,84,89,100,105,107,120,126,142,145,173],
"aff":[105,135,150,166],
"afr":[83],
"aft":[10,14,24,26,30,31,40,45,46,54,69,70,72,75,76,81,84,88,89,91,94,100,104,105,108,113,115,124,126,128,134,142,144,152,[158,160],162,164,167,170],
"ag_":[115],
"aga":[1,23,26,34,40,58,69,76,84,85,88,89,91,94,100,104,108,113,117,122,126,135,142,144,151,163,166,171],
"age":[2,3,4,6,12,13,24,26,28,[31,33],39,40,43,50,53,54,[60,62],66,70,71,75,76,79,[81,85],87,89,91,92,94,99,100,105,108,109,[113,115],118,120,122,126,128,130,132,[134,136],139,142,146,[157,167],170,173],
"agg":[37,110,160],
"agi":[23,59,69,76,81,84,105,120,122,159],
"agl":[31],
"agm":[26,77,132,133,158,159,166],
"agn":[74,96,119,162,167],
"ago":[10,14,47,75,81,84,96,105,109,110,122,137,140,167],
"agr":[100,115,118,122],
"ags":[4,17,29,48,61,88,106,116,119,124,128,131,137,140,143,148,167],
"agu":[75,114],
"ahc":[132],
"ahf":[47],
"aho":[26,128],
"aic":[122],
"aid":[35,83,94,104,105,122,162,173],
"aig":[1,4,28,35,40,60,94,101,115,119,139,143,144,150,157,159,164,173],
"ail":[[1,4],10,14,16,22,28,30,31,35,39,40,[43,45],47,48,50,52,54,55,[59,62],[66,71],73,74,[77,79],81,[83,89],94,97,98,[100,109],[111,113],[115,124],[126,128],[130,140],[142,147],149,150,[152,162],[164,167],169,170,173],
"aim":[74,81,87,122],
"ain":[1,2,3,6,7,10,12,14,16,17,19,22,24,[26,28],30,31,34,36,37,40,48,49,54,[58,60],62,66,67,[69,71],74,75,77,80,81,[84,89],[91,96],100,101,104,105,108,111,113,115,[117,120],122,124,126,[128,130],[133,135],137,139,140,[142,147],[149,168],[170,173]],
"air":[14,24,31,40,100,101,111,115,116,124,126,134,136,[142,145],147,149,162,163,170],
"ais":[48,113,136],
"ait":[53,75,81,104,105,114,122,147,158,162,172],
"aiv":[3,4,12,34,35,[59,61],64,66,[68,70],78,80,[84,86],88,89,91,92,94,104,108,113,118,119,121,124,126,128,130,134,139,143,151,158,173],
"ajd":[105],
"aji":[171],
"ajo":[72,81,88,94,100,113,128,136,144,147,154,159,162,173],
"aka":[162],
"ake":[1,2,26,31,35,42,48,54,59,66,69,70,74,75,79,[81,84],88,89,91,92,94,96,100,104,105,[108,111],[113,115],[117,120],[122,124],126,[128,131],135,136,139,140,143,[145,148],150,151,154,[157,167],[170,173]],
"aki":[26,47,56,69,81,89,91,95,100,148,157,159,162,166,168,170],
"akn":[31],
"aks":[81,128],
"al-":[30,74,105,113,122,126,158,164,173],
"al<":[82],
"al_":[101,113,139],
"ala":[2,12,23,30,55,60,66,70,[87,89],91,92,94,100,[102,104],111,113,115,[117,119],121,124,126,130,131,136,137,139,142,144,152,[158,160],162,[164,166],[170,173]],
"alb":[100],
"alc":[1,2,16,17,22,23,30,31,34,37,40,42,44,45,48,52,60,62,66,69,70,73,74,76,78,84,88,91,94,97,100,101,103,106,107,113,115,118,119,121,124,126,130,[133,136],139,141,142,148,150,154,158,[160,162],164,[166,168],170,171,173],
"ald":[165,166],
"ale":[5,22,59,62,69,81,84,85,88,94,96,105,107,113,118,128,133,135,136,139,144],
"alf":[34,71,88,89,94,100,104,113,119,124,144,158,162,171],
"alg":[0,1,2,4,6,10,12,14,16,18,[22,24],28,30,34,35,40,42,45,52,54,[59,62],66,[68,71],74,77,78,[85,97],100,101,104,108,111,113,115,[117,119],121,122,124,126,128,130,131,[133,140],[142,145],147,149,150,[152,157],[159,161],164,165,167,168,170,173],
"ali":[1,2,10,12,22,26,31,39,40,[43,45],48,51,54,59,67,69,70,72,73,77,79,81,82,84,[88,91],94,95,97,100,102,104,105,108,[111,113],115,[118,120],122,126,128,129,131,136,138,139,144,147,148,150,154,[157,162],164,166,[170,173]],
"alk":[81,105,122],
"all":[[0,5],10,12,14,16,[22,24],[26,32],[34,40],42,[46,48],[50,61],63,64,[66,69],[72,78],[80,82],[84,102],[104,109],[111,154],[157,173]],
"alm":[4,12,47,77,100,104,105,113,115,119,122,123,127,133,137,139,141,143,146,154,156,158,162,164,170,172,173],
"aln":[161],
"alo":[113,135,150,166,167,173],
"alp":[3,6,12,26,161],
"alr":[26,34,40,42,48,60,88,89,91,96,100,105,108,109,113,122,140,143,[158,160],167,168,171,173],
"als":[1,2,5,6,14,[20,23],26,[29,32],35,40,42,[48,52],[54,56],[59,62],64,69,70,[74,76],78,80,81,[85,89],91,92,[94,96],98,100,102,[104,106],110,111,113,[115,119],121,122,124,126,128,129,[131,136],[138,144],148,150,154,155,[157,167],170,171,173],
"alt":[28,29,35,40,45,48,72,74,85,88,91,94,100,105,109,[113,116],118,119,122,[126,128],132,133,142,143,147,148,150,152,[158,163],167,[170,173]],
"alu":[0,1,2,6,8,9,10,12,14,17,20,21,23,26,[28,30],32,34,37,[39,41],[44,46],48,52,55,59,60,62,64,[67,70],[72,74],76,[78,84],[86,92],94,99,100,[103,105],[107,109],112,113,115,[117,121],[124,128],130,131,133,134,136,138,139,[141,144],[147,151],153,154,[156,164],166,[168,171],173],
"alv":[16,91,101,111,113,118,119,173],
"alw":[10,22,35,40,41,48,66,75,77,80,87,89,91,94,100,105,108,113,118,122,126,131,134,142,148,154,158,159,162,167,173],
"aly":[31,35,54,81,94,113,126,128,139,150,155,157,158,172,173],
"am-":[161],
"am_":[82],
"ama":[87,122,128,131,146],
"amb":[127,129],
"amd":[9,74,88,89,100,101,104,[164,166],170,171,173],
"ame":[[1,5],10,12,19,26,31,[33,35],37,38,40,41,47,50,55,56,60,64,66,69,74,[81,89],91,94,100,[103,105],110,111,113,[115,117],119,122,[124,126],128,[132,135],137,138,143,[145,148],150,154,155,[157,162],164,166,170,171,173],
"ami":[26,31,37,38,40,60,81,85,87,100,105,109,122,126,139,143,148,159,162,164],
"aml":[83,113,122],
"amm":[9,40,42,48,50,63,74,79,81,82,100,101,104,105,109,122,126,128,137,159,161,162],
"amo":[10,16,26,30,32,35,37,40,44,54,55,78,81,84,88,91,94,97,113,139,159,172,173],
"amp":[[1,6],[9,12],14,15,20,23,24,26,27,[30,32],35,37,[39,42],[44,49],52,[54,56],[59,62],[65,71],74,[78,81],[83,95],[97,101],[104,106],108,111,113,115,[118,122],124,126,128,[132,135],138,[142,145],147,149,150,[152,167],[169,173]],
"ams":[2,31,35,40,42,48,54,[59,62],81,84,88,89,94,100,[102,104],113,117,122,127,128,132,133,150,158,161,[164,167]],
"an-":[35],
"an_":[113],
"ana":[1,31,35,40,54,81,82,94,113,120,122,126,128,139,150,155,157,158,173],
"anc":[1,2,4,8,10,17,20,22,23,30,32,35,40,44,[58,61],63,68,75,81,85,87,88,91,92,[94,96],100,101,[103,105],108,110,111,[113,115],[117,122],[126,130],132,133,135,136,139,141,[143,145],147,150,151,154,155,[157,159],161,162,164,165,167,[169,173]],
"and":[[0,7],9,10,12,[14,24],[26,32],[34,51],[53,55],[57,62],64,[66,92],[94,164],[166,173]],
"ane":[34,72,88,91,94,100,111,113,115,118,119,126,134,135,138,[148,150],152,156,161,162,164,167,[171,173]],
"ang":[1,2,5,6,7,12,20,26,28,30,[32,34],37,39,45,47,53,57,59,60,62,64,70,[74,77],79,[81,83],[86,91],[93,95],97,100,102,105,108,109,111,[113,118],[120,122],[124,126],128,[130,133],[135,137],[139,144],146,148,150,[158,160],[162,164],167,[170,173]],
"anh":[2,100],
"ani":[1,26,31,40,47,[59,61],67,68,81,85,88,89,91,94,100,105,113,119,121,122,124,126,128,132,134,142,162,167],
"ank":[1,12,26,29,35,55,59,70,74,77,78,80,81,84,85,[87,89],91,94,100,[104,106],108,110,111,[113,115],[117,119],124,126,128,133,134,145,150,158,164],
"anl":[30],
"ann":[3,30,42,81,91,96,105,124,126,128,130,131,142,147,148,150,154,158,162,[164,166],168,170,171,173],
"ano":[1,4,10,12,24,32,34,42,47,56,60,66,[68,71],76,77,[81,83],89,90,94,100,107,108,[110,113],115,118,119,[122,126],128,132,133,135,136,143,147,149,151,159,161,162,170,173],
"ans":[3,10,12,16,22,23,26,28,31,37,40,45,47,60,62,64,68,80,81,85,[87,92],94,96,97,99,100,[102,105],[107,109],111,[113,115],[117,119],[121,123],126,128,130,131,[133,137],139,140,[142,145],147,149,150,152,154,[158,164],166,172,173],
"ant":[1,2,6,10,12,15,18,[22,24],26,30,34,35,[38,40],42,44,[47,49],51,55,[59,62],66,67,69,70,72,74,[76,78],81,[84,100],[102,105],108,109,[111,116],[118,122],124,[126,136],138,139,[141,145],[147,164],[166,170],172,173],
"anu":[1,43,57,75,85,97,128,137,146,147,160,164],
"any":[2,4,6,10,[12,14],16,17,22,26,28,29,31,34,37,38,40,42,43,45,47,50,51,53,54,58,60,72,79,81,82,84,[86,89],91,92,94,[98,101],104,105,[109,111],113,116,117,119,122,123,[126,131],133,[137,142],144,145,[147,151],[156,160],[162,164],[166,168],[171,173]],
"aot":[122],
"ap-":[26,46,94,119],
"ap2":[22],
"ap<":[19],
"ap_":[22,118],
"apa":[100,101,109,113,119,129,143,146,154,158,159,165,173],
"apc":[161],
"ape":[1,28,40,86,101],
"aph":[40,122,128,160,[164,166],168,170,173],
"api":[26,81,83,88,100,105,109,114,127,128,161],
"apl":[126],
"apo":[26],
"app":[1,2,4,10,[12,14],16,20,22,23,26,28,29,[31,34],[36,38],42,43,47,55,59,60,68,69,71,73,75,76,[80,82],84,[86,89],91,94,98,100,[103,105],108,109,[111,113],115,[117,119],122,124,126,128,[131,134],[138,140],[142,144],146,147,149,151,152,[154,162],[164,167],170,172,173],
"aps":[19,22,42,81,82,87,88,92,110,118,128,130,133,143,159,167,170],
"apt":[31,35,81,131,140,150,152,160],
"ar*":[79,82],
"ar-":[2,35,96,100],
"ar2":[59],
"ar3":[59,147],
"ar6":[100,147],
"ar8":[111],
"ar_":[91,94,113,115,126,143],
"ara":[0,1,2,16,23,26,30,31,34,35,37,40,49,54,56,59,60,[66,69],71,74,78,[81,83],85,[87,91],94,95,[99,102],104,105,109,110,113,114,118,119,122,124,126,128,[134,136],139,[142,145],[147,149],[156,162],[164,166],169,170,172,173],
"arb":[40,66,71,87,89,104,113,118,122,124,135,145,158,160,166,171],
"arc":[1,2,19,24,26,29,31,32,34,35,40,41,48,54,62,77,81,84,88,89,94,96,98,100,[103,105],108,109,118,119,123,124,130,131,133,134,140,143,147,148,[157,162],[164,167],170,171,173],
"ard":[[0,4],17,22,[26,28],31,32,35,40,42,43,48,53,57,[60,62],71,74,77,81,82,86,88,89,91,94,100,101,104,105,108,109,[113,115],[117,120],[122,124],[126,128],131,133,139,143,144,147,150,152,154,155,[157,160],162,164,169,170,172,173],
"are":[[0,7],10,12,14,[16,24],26,[28,35],[37,40],42,44,45,[47,49],51,52,54,55,[57,66],[68,78],80,81,[83,105],[108,111],[113,124],[126,152],[154,168],[170,173]],
"arg":[1,4,22,23,26,28,30,31,37,40,42,[45,47],49,58,62,[65,67],[71,75],[77,82],84,85,88,94,100,103,108,113,115,116,119,120,122,123,126,[128,137],140,141,143,144,[148,150],[158,164],170,171],
"ari":[1,2,4,6,7,12,18,19,22,23,[26,31],33,35,37,38,40,[42,45],47,48,52,54,56,[58,62],64,66,69,70,[73,78],81,84,85,[87,92],[94,97],[100,105],[107,111],[113,116],[118,120],124,126,128,[130,140],142,144,145,[147,149],151,153,154,[156,162],164,166,[169,173]],
"ark":[1,29,30,36,40,66,74,79,83,87,89,91,94,100,101,105,113,115,118,119,122,124,126,128,142,145,154,157,158,160,161,164,165,167,170,173],
"arl":[1,3,10,22,26,37,40,49,59,70,71,74,78,84,85,89,91,94,100,101,104,112,113,115,118,[126,128],135,138,144,[158,160],162,166,171,173],
"arm":[2,81,88,100,104,162,164],
"arn":[40,54,56,75,76,83,105,110,122,137,140,158,173],
"aro":[1,4,9,12,16,19,30,36,46,47,54,60,77,86,88,94,101,105,119,122,131,132,140,150,152,167],
"arp":[2,54,100],
"arq":[134],
"arr":[0,18,23,26,31,32,35,40,46,55,58,59,62,72,[74,77],[79,82],91,92,94,100,[103,105],108,111,113,115,[117,119],121,124,126,130,131,142,143,145,[149,151],158,159,162,164,166,170,173],
"ars":[2,10,26,36,47,49,54,67,[69,71],84,86,88,94,100,102,103,105,109,113,118,122,128,133,137,139,140,144,147,[157,159],162,167,170,172,173],
"art":[1,2,10,13,22,26,28,30,31,34,37,39,40,44,45,50,53,54,57,58,60,62,[64,66],69,70,[73,75],77,78,81,82,84,[86,91],[93,95],100,101,104,105,[108,110],113,115,[117,119],122,[124,129],[134,136],[138,140],143,144,146,147,150,154,156,[158,162],[164,170],172,173],
"aru":[145],
"ary":[0,2,3,7,14,15,19,23,24,26,28,31,32,35,37,40,[42,44],47,54,59,61,62,67,74,76,77,[84,89],91,94,95,100,104,108,111,[113,115],117,118,120,124,[126,128],131,[133,135],137,140,[144,150],153,154,[157,160],162,[164,166],[169,171],173],
"as_":[27,54,157],
"asa":[167],
"asc":[23,30,39,40,59,60,62,[66,71],81,[87,89],91,94,102,104,105,113,122,142,144,148,[157,159],161,167,169,172,173],
"ase":[0,1,3,4,5,10,[14,16],22,24,26,28,30,31,34,37,40,42,44,45,47,49,53,54,59,60,62,66,69,70,72,76,81,82,84,85,[87,91],94,97,[100,102],[104,106],108,112,113,[115,136],[138,140],142,144,145,[147,155],[158,168],[170,173]],
"ash":[2,28,42,54,74,75,79,88,94,100,135,147,158,159,173],
"asi":[1,4,6,26,28,29,34,42,44,47,50,53,55,60,62,65,66,68,71,75,77,81,84,85,[87,91],[94,96],[100,102],104,105,113,115,116,118,122,125,127,128,[130,134],137,138,[140,142],144,145,147,149,152,154,[156,159],161,162,[164,167],170,171,173],
"ask":[2,10,12,14,16,18,23,40,45,48,50,51,55,[59,61],[66,69],71,73,[75,77],[85,95],[99,101],104,105,111,113,[115,119],121,122,124,126,130,[133,135],138,139,[143,145],[149,151],[156,160],162,164,166,167,[169,173]],
"asm":[7,22,50,143,152,167],
"asn":[40,100,122],
"aso":[14,37,48,62,75,81,86,88,105,109,115,119,122,124,125,128,140,141,145,158],
"asp":[31,81,85,100,104,105,128,162],
"ass":[2,3,10,12,[27,29],31,33,34,40,44,46,47,55,[58,60],68,74,79,81,[87,92],94,96,100,[104,106],[108,116],[118,124],126,128,129,132,133,135,138,139,[142,144],147,148,150,151,154,155,[157,164],[168,170],172,173],
"ast":[1,2,4,5,6,10,12,14,16,19,21,23,26,[28,31],[34,37],[39,41],43,48,49,51,52,54,[58,61],66,70,[73,78],[80,84],[86,89],91,92,94,95,[99,106],108,[110,113],115,116,118,119,121,122,124,[126,136],138,139,[141,150],152,154,[156,162],[164,167],[170,173]],
"asu":[0,1,2,4,30,48,54,62,81,88,89,94,100,105,113,117,126,130],
"asw":[1,88,89,96,100,124],
"asy":[10,40,66,70,75,81,[86,88],107,108,113,122,128,139,142,145,155,159,[161,164],173],
"asz":[28,51,137],
"at!":[162],
"at&":[47],
"at2":[10],
"at3":[150],
"at6":[154],
"at_":[100,125,161],
"ata":[1,14,15,19,[22,24],26,28,31,37,40,43,47,49,58,60,62,[76,78],80,81,84,85,88,89,91,92,94,100,104,105,113,115,[118,120],122,123,[126,128],139,142,145,[158,160],162,[166,168],[170,173]],
"atc":[2,37,40,75,81,89,94,100,113,115,118,119,122,128,130,133,146,147,157,158,161,167],
"atd":[170],
"ate":[[0,6],9,10,12,14,[16,18],22,23,26,[28,37],40,42,[44,48],[50,55],[57,61],[64,66],[68,70],[72,82],[84,92],[94,145],[147,152],[154,173]],
"atf":[88,89,100,128,167],
"ath":[1,28,34,35,49,55,59,72,73,75,76,81,[87,89],94,96,100,104,113,115,118,[120,123],126,128,131,132,134,135,138,145,147,148,154,158,160,162,[164,166],170,172,173],
"ati":[[0,6],[9,14],[16,18],[22,24],26,[28,31],[34,37],39,40,42,44,45,47,48,50,[54,56],[59,62],64,[66,75],77,78,[80,92],94,95,[97,102],104,105,[107,173]],
"atm":[81],
"ato":[1,6,26,27,31,37,42,53,81,82,100,105,109,[111,114],[117,119],122,124,127,128,132,136,139,153,158,159,162,170],
"atr":[135],
"ats":[4,10,26,31,35,47,54,70,81,109,113,118,120,124,125,145,154,159,162,164],
"att":[2,26,37,39,40,49,59,73,74,76,81,84,87,88,92,94,97,98,100,104,105,113,115,116,120,[122,124],126,135,136,138,[145,147],150,157,158,160,162,[164,167],170],
"atu":[4,6,10,12,31,80,82,83,88,89,92,105,107,113,114,116,119,120,122,127,129,131,136,137,140,144,158,161,162,167,[171,173]],
"atw":[157],
"atx":[115,139,150,152],
"auc":[81],
"aud":[28],
"aug":[122,131,147,157,167],
"aul":[1,22,31,48,77,83,109,112,125,128,131,133,137,140,154,162,164],
"aus":[1,3,10,12,14,23,26,28,[30,32],37,38,40,41,43,46,48,49,60,66,75,76,81,82,84,85,88,89,94,100,102,105,107,113,119,126,128,129,135,[138,140],160,162,164,166,167,173],
"aut":[1,14,28,59,75,84,100,104,111,112,115,117,121,128,131,137,140,162,164,167,173],
"aux":[28,115,120,127,145,154,159,164,173],
"av5":[91],
"ava":[[1,4],10,22,28,31,32,35,39,40,44,45,48,50,52,54,55,[59,62],[66,71],74,77,78,[85,89],94,97,98,[100,103],[105,108],111,113,[115,119],[121,124],126,127,[130,140],[142,145],147,149,150,[152,162],[164,167],169,170,173],
"ave":[[1,4],6,12,14,16,[18,20],[22,24],[26,34],[37,40],[42,48],52,54,55,[57,60],62,64,66,67,[69,76],80,81,84,85,[87,89],[91,96],[99,102],104,105,[108,110],[113,115],[118,122],125,126,[128,131],[133,136],138,139,[141,145],[147,151],[153,168],[170,173]],
"avg":[2,19,31,35,40,66,91,113,117,119,121,124,126,145,150,158],
"avi":[1,22,81,84,85,[87,89],94,95,97,98,100,104,113,114,120,[124,126],128,131,134,138,139,144,145,147,149,150,156,[158,160],[162,164],166,167,170,171,173],
"avl":[162],
"avo":[1,37,81,84,85,90,100,105,111,122,124,138,139,143,148,159,160,162,164,166,173],
"avx":[1,[72,74],76,77,88,89,91,[94,97],[99,104],107,108,111,113,[115,120],123,124,126,130,131,[133,140],145,[149,152],156,160,162,[164,166],[169,173]],
"avy":[163],
"awa":[47,62,90,105,114,118,122,132,173],
"awb":[6,12,19,30,36,54,85,86,88,126,139,145,147,173],
"awe":[105],
"awf":[105,109,122],
"awg":[28,128],
"awi":[168],
"aws":[146],
"awy":[120,126],
"ax2":[2],
"ax3":[2],
"ax_":[150,166],
"axa":[61,131],
"axe":[113],
"axi":[12,34,40,44,52,78,84,90,113,119,134,136,139,142,155,158,159,162,166,168,170,173],
"axu":[5],
"ay-":[26,170],
"ayb":[23,40,42,60,81,84,93,96,128,148,161,167],
"ayd":[109],
"aye":[105,122,126,162],
"ayi":[1,84,96,122,167],
"ayo":[12,26,44,45,55,66,86,88,89,91,94,104,113,115,134,138,144,145,154,158,170],
"ays":[10,14,22,26,35,37,[39,41],48,51,66,75,77,80,81,87,89,91,94,100,104,105,108,110,113,115,118,119,122,126,131,134,142,146,148,150,154,158,159,[161,164],167,169,173],
"azi":[122,128,131],
"azo":[31,146],
"azy":[128],
"ak":[122],
"b-a":[119,124],
"b-b":[88,89,118],
"b-c":[130,160],
"b-i":[104],
"b-p":[120],
"b-r":[86],
"b-s":[160,162],
"b-t":[31],
"b-v":[100],
"b-w":[145],
"b00":[134,149,150,170,173],
"b01":[76,100,113,134,149,157,158],
"b06":[173],
"b10":[76,149,154,158],
"b11":[67,134,143,149,150,158],
"b13":[173],
"b17":[173],
"b2m":[113],
"b2q":[99],
"b53":[173],
"b80":[164],
"b84":[163],
"b95":[163],
"b_a":[22],
"b_b":[22,104],
"b_e":[136,138],
"b_i":[104],
"b_p":[22],
"b_s":[22],
"b_t":[76],
"b_u":[22],
"ba2":[164],
"bab":[6,37,81,84,129,167],
"bac":[6,12,19,28,30,35,36,40,53,54,57,69,77,81,[85,88],94,96,100,111,113,123,126,128,129,136,139,142,143,145,147,158,160,164,[171,173]],
"bad":[59,60,64,100,105,119,122,126,130,139,158],
"bag":[66,71,87,89,122,158,160],
"bal":[26,81,124,134,159,162],
"ban":[59,105],
"bar":[10,77,81,94,111,113,122,129,130,162],
"bas":[0,1,3,4,6,10,[14,16],22,26,37,44,47,53,59,60,62,65,66,81,84,85,[87,91],94,96,100,101,104,105,113,[115,119],121,122,124,[126,128],130,131,[133,135],137,138,140,141,144,145,147,149,152,154,[157,162],[164,167],170,171,173],
"bat":[124],
"bb8":[163],
"bbb":[14,88,104,113],
"bbc":[104],
"bbe":[7,105,162],
"bbf":[173],
"bbl":[1,40,60,66,68,71,89,[100,102],118,134,142,144,145,149,150],
"bbu":[160],
"bc_":[100],
"bcb":[163],
"bcc":[104],
"bcd":[14,30,39,59,70,100,142,144],
"bda":[129],
"bdi":[2],
"bea":[4,10,35,54,63,83,119,135,147],
"bec":[1,3,10,12,14,23,26,28,30,31,37,40,41,43,46,48,60,66,75,81,82,84,88,100,102,104,105,107,108,113,121,126,128,129,135,[138,140],144,150,152,158,160,162,164,166,167,173],
"bed":[1,3,4,14,24,28,30,37,40,70,71,74,80,81,85,86,88,89,91,94,100,104,105,108,113,118,122,126,128,130,134,136,142,[158,160],162],
"bee":[1,2,10,26,30,31,35,46,47,96,109,122,126,128,162],
"bef":[14,29,54,72,76,84,86,94,99,100,111,124,128,152,154,[158,160],162,164,166],
"beg":[4,31,37,113,117,128,139,144,150,170],
"beh":[22,40,43,84,114,120,128,131,143],
"bei":[100,113,128,146,162,173],
"bel":[1,10,16,19,26,30,34,35,50,59,72,81,84,88,89,91,93,94,98,100,[105,108],111,113,[115,121],124,[126,130],133,135,136,[138,140],[142,147],150,151,154,[158,160],164,170,171,173],
"ben":[1,30,32,84,94,101,113,115,118,119,121,124,126,128,136,145,154,157,158,160,164,165,170,173],
"ber":[[0,4],7,8,[10,12],19,21,23,24,[27,31],34,35,37,[39,42],44,45,47,48,52,53,55,[58,62],[65,71],77,78,81,[83,86],[88,95],97,98,100,[102,111],113,115,118,119,[121,126],[128,130],132,133,135,136,138,139,[141,148],[150,156],[158,167],[169,171],173],
"bes":[6,12,30,31,37,40,55,59,74,86,[89,91],94,105,113,115,[117,119],122,124,126,130,139,145,155,158,159,[164,166],170,173],
"bet":[2,10,12,14,22,26,31,34,35,40,58,60,66,68,73,76,[81,83],88,89,92,94,96,100,104,105,108,109,113,[115,119],121,122,[126,128],130,[137,143],[147,149],151,152,154,158,159,[162,164],168,173],
"bex":[85,94],
"bey":[100,105,162],
"bfi":[158],
"bi-":[143],
"bia":[31,35,44,47,88,89,96,100,[119,121],137,140,143,154,157,[164,166],170,173],
"bib":[40],
"bic":[31,173],
"bie":[81],
"big":[4,6,22,26,30,37,38,41,49,59,60,66,68,73,81,85,86,88,89,91,92,94,100,105,119,122,124,128,140,144,149,158,162,164,170,172,173],
"bil":[40,81,94,100,105,113,118,128,131,135,137,144,158,159],
"bin":[0,2,3,[22,24],26,32,35,40,44,47,54,[59,62],67,74,76,77,[84,86],88,94,98,100,104,108,113,117,122,124,126,128,[133,136],144,[147,150],153,154,[158,160],162,164,[169,171],173],
"bis":[161],
"bit":[[1,4],8,[10,12],16,18,21,23,26,29,30,32,35,40,41,[44,47],51,52,54,55,[58,61],[64,72],74,[76,78],80,81,[84,89],[91,108],111,113,[115,119],[122,124],126,128,130,[133,136],138,139,[142,145],[147,154],[156,166],[169,173]],
"biz":[81,82],
"bjd":[47,154],
"bje":[[25,27],31,40,[79,81],104,122,[127,129],132,159,167,[171,173]],
"bj":[30],
"bla":[19,83,105,113,115],
"ble":[[0,4],6,7,10,[12,14],[16,20],[22,31],[33,37],[39,41],[43,52],[54,56],[58,62],[66,71],[73,78],[80,98],[100,145],[147,150],[152,173]],
"bli":[1,24,31,40,47,48,73,83,109,122,128,167,168,171],
"blk":[132],
"blo":[37,50,84,92,100,104,105,113,115,126,132,133,141,157,159,167,173],
"bls":[106,126],
"blu":[3,118,173],
"bly":[2,6,29,37,46,55,58,74,81,84,91,92,96,104,106,113,115,116,[119,121],124,126,129,130,133,138,139,141,148,150,151,157,159,160,162,164,167,169,173],
"bmi":[[59,61],[66,68],85,88,89,91,106,113,115,126,131,137,140,143,145,148,164,166],
"bod":[75,84,105,122,128,131,132,146,162],
"boi":[104,124],
"bol":[40,105,120,131,137,140],
"boo":[24,29,31,74,77,[80,82],85,[87,89],113,119,122,[125,127],147,162],
"bor":[37,75,115,122,128,162,167,168,173],
"bos":[129,147],
"bot":[5,10,12,19,26,[30,32],34,40,62,68,70,[88,91],94,95,100,101,104,105,108,109,113,116,118,119,122,124,[126,128],130,136,138,139,[143,145],148,150,151,155,[158,160],[162,164],167,170,171],
"bou":[9,10,14,26,28,31,35,36,38,40,43,48,50,51,56,74,77,81,88,90,91,94,100,105,[108,110],113,118,122,128,134,139,142,144,158,159,162,164,167,168,170,172,173],
"bov":[1,3,12,37,48,50,60,74,85,88,89,[91,94],100,111,113,[115,119],124,126,[129,131],133,139,144,145,151,152,[157,160],162,163,166,173],
"box":[0,1,30,122,147,168],
"boy":[40,100],
"bpp":[3,4,6],
"bpr":[18,100],
"bra":[2,8,10,14,17,20,23,26,30,32,42,43,60,61,63,68,74,75,77,[87,90],94,95,97,[103,105],108,109,113,114,117,122,126,128,131,133,134,137,140,141,143,144,147,157,161,171,173],
"bre":[20,122,128,159,166,173],
"bri":[1,6,26,85,113,122,128,132,140,159,162,170,173],
"bro":[40,59,77,94,95,99,100,105,113,115,133,135,138,149,150,157,162,171],
"bru":[88],
"bs_":[113,131,137,140],
"bsc":[81,147,148],
"bsd":[113],
"bse":[1,2,3,30,31,40,[47,49],60,68,84,87,88,94,99,100,108,113,118,123,134,135,142,144,147,149,152,154,[157,160],162,170,173],
"bsf":[21,103,152],
"bsi":[167],
"bsl":[72,74],
"bso":[1,2,8,54,107,119,124,130,134,150,161,164,171],
"bsp":[77],
"bsq":[8],
"bsr":[21,72],
"bst":[2,26,39,54,70,75,95,96,100,158],
"bsu":[122],
"bsw":[12,22,59,60,66,[69,71],88,89,113,124,144,158],
"bsx":[21],
"bsy":[75,81],
"bta":[6,14,26,30,31,48,62,81,86,101,113,119,124,126,128,129,133,142,144,145,150,159,173],
"btc":[47],
"btr":[10,18,30,34,40,44,45,60,69,81,88,90,94,102,107,113,126,136,[142,144],147,148,152,153,156,158,162,168,171],
"bts":[83],
"btw":[75,122,137],
"buc":[160],
"bud":[87],
"buf":[39,84,88,104,127,128,145],
"bug":[35,75,81,84,86,96,100,112,116,128,131],
"bui":[1,2,26,31,35,37,40,45,59,70,75,81,85,88,89,91,92,94,97,[99,101],104,105,110,111,113,115,119,122,126,128,[130,132],134,135,138,139,141,147,150,[157,160],162,167,169,170,173],
"bul":[28,88,89,100,133],
"bum":[112,114,167],
"bun":[88,89,91,96,100,119,124,130,139,147,158,159],
"bur":[86],
"bus":[9,107,113,122],
"but":[1,2,3,6,10,12,[14,16],19,23,24,26,[29,35],37,40,42,43,[46,49],51,55,[58,62],[64,66],[69,73],75,81,82,84,[86,89],[91,96],[99,102],104,[108,113],[115,120],122,[124,128],[130,134],136,137,[139,141],[145,150],152,153,[157,160],[162,164],166,167,[170,173]],
"buy":[122,162],
"bve":[73,99,119,124,126,162],
"bvi":[12,24,30,35,73,75,77,81,82,[84,86],88,89,94,100,103,108,113,116,117,121,122,126,128,130,139,143,145,147,149,150,152,156,158,161,162,165,167,172,173],
"bw-":[100],
"bw_":[72],
"bwo":[31,66,88,91,113,134,158,159,171],
"by-":[69,100,126],
"byt":[[0,6],12,16,18,22,23,26,30,35,39,40,42,51,54,55,[58,60],[66,71],73,77,78,85,[87,92],94,97,[99,102],104,111,113,115,[117,119],124,126,128,[130,132],[134,136],138,139,142,144,145,147,149,150,152,[156,162],[164,166],[169,173]],
"bz2":[31],
"c-e":[113,131],
"c-l":[81,118,128,135,162],
"c-p":[162],
"c-s":[26],
"c-v":[81,[162,164],171],
"c00":[64,164,173],
"c0":[157],
"c11":[128],
"c2d":[9,10],
"c2f":[173],
"c30":[173],
"c32":[1],
"c5f":[173],
"c60":[173],
"c61":[173],
"c64":[105],
"c67":[173],
"c68":[173],
"c69":[173],
"c6a":[173],
"c6b":[173],
"c6c":[173],
"c72":[173],
"c73":[173],
"c75":[173],
"c76":[173],
"c80":[173],
"c81":[173],
"c82":[173],
"c83":[173],
"c84":[173],
"c85":[173],
"c86":[173],
"c87":[173],
"c88":[173],
"c89":[173],
"c8a":[173],
"c8b":[173],
"c8c":[173],
"c8d":[173],
"c8e":[173],
"c8f":[173],
"c90":[173],
"c91":[173],
"c92":[173],
"c93":[173],
"c94":[173],
"c95":[173],
"c96":[173],
"c97":[173],
"c98":[173],
"c99":[17,173],
"c9a":[173],
"c9b":[173],
"c9c":[173],
"c9d":[173],
"c9e":[173],
"c9f":[173],
"c_a":[100],
"c_b":[101],
"c_e":[74,94,131,137,140],
"c_o":[42],
"c_s":[26,53,96,109],
"c_v":[76],
"ca0":[173],
"ca1":[173],
"ca2":[173],
"ca3":[173],
"ca4":[173],
"ca5":[173],
"ca6":[173],
"ca7":[173],
"ca8":[173],
"ca9":[173],
"caa":[173],
"cab":[28,31,133,138,162,173],
"cac":[4,26,30,35,37,58,59,66,77,81,85,94,100,105,113,136,159,172,173],
"cad":[100,109,173],
"cae":[173],
"caf":[173],
"cal":[1,2,4,12,13,16,17,22,23,26,[29,31],34,35,37,40,42,44,45,47,48,52,54,55,57,60,62,66,69,70,[73,78],[80,82],84,[87,89],91,92,94,97,[100,108],110,111,113,[115,124],[126,137],[139,144],147,148,150,152,154,[157,162],[164,168],[170,173]],
"cam":[84,105,111,122,124,126,132,145,148],
"can":[[1,7],10,12,14,16,18,21,22,26,28,30,31,[33,35],37,40,42,44,46,[48,50],54,55,59,60,[62,64],66,[69,71],73,74,[76,78],[80,89],91,92,[94,97],[99,111],[113,122],124,[126,131],[133,136],[138,145],[147,152],[154,160],[162,173]],
"cap":[42,81,88,100,101,113,119,134,154,[158,161]],
"car":[18,23,31,32,46,55,71,74,76,79,88,89,94,100,105,109,110,113,114,119,126,142,143,149,157,159,162,166],
"cas":[4,5,16,24,26,28,31,34,37,[40,42],44,45,47,49,54,59,60,62,70,72,76,77,81,82,84,85,[87,89],91,94,95,99,102,105,106,108,112,113,115,[117,126],[128,130],[133,136],138,139,142,144,[148,150],[152,155],[158,167],[170,173]],
"cat":[1,2,3,6,10,[12,14],26,28,30,31,[34,37],[53,55],[58,62],64,66,69,70,[73,78],81,82,[84,86],88,89,91,94,96,97,99,100,[103,105],108,109,113,115,118,119,[122,126],128,131,132,[134,136],[138,140],[142,146],[148,150],152,154,155,[157,162],[164,167],170,171,173],
"cau":[1,3,10,12,14,23,26,28,[30,32],37,38,40,41,43,46,48,49,60,66,75,76,81,82,84,85,88,89,94,100,102,105,107,113,119,122,126,128,129,131,135,[138,140],147,154,157,160,162,164,166,167,173],
"cav":[113,114,162],
"cb0":[173],
"cb1":[173],
"cb2":[173],
"cb3":[173],
"cb4":[173],
"cb5":[173],
"cb6":[173],
"cb7":[173],
"cb8":[173],
"cb9":[163,173],
"cba":[173],
"cbb":[173],
"cbc":[173],
"cbd":[173],
"cbe":[173],
"cbf":[173],
"cc-":[131],
"cc0":[164,173],
"cc1":[173],
"cc2":[173],
"cc3":[173],
"cc4":[173],
"cc5":[173],
"cc6":[173],
"cc7":[173],
"cc8":[173],
"cc9":[173],
"cca":[173],
"ccb":[173],
"ccc":[88,104,164,173],
"ccd":[104,164,173],
"cce":[1,2,4,19,22,26,[30,32],42,58,72,86,88,89,91,94,97,100,104,105,108,111,113,119,122,124,126,128,132,[158,160],162,170,171,173],
"ccf":[173],
"cch":[28],
"cci":[46,112],
"cco":[12,37,47,59,74,81,85,88,89,91,94,97,100,101,104,105,113,119,122,126,130,145,147,148,150,[158,160],162,166,168,170,171],
"cct":[105],
"ccu":[2,26,37,40,44,48,49,53,66,76,78,84,86,89,90,100,101,113,119,124,126,130,131,137,[139,142],156,157,159,160],
"cc|":[104],
"cd0":[173],
"cd1":[173],
"cd2":[173],
"cd3":[173],
"cd4":[173],
"cd5":[173],
"cd6":[173],
"cd7":[173],
"cd8":[173],
"cd9":[173],
"cd_":[100],
"cda":[173],
"cdb":[173],
"cdc":[173],
"cdd":[104,173],
"cde":[59,70,100,144,173],
"cdf":[173],
"ce!":[39,171],
"ce-":[27],
"ce0":[173],
"ce1":[34,173],
"ce2":[34,173],
"ce3":[173],
"ce_":[126,131,137,140],
"cea":[48],
"ceb":[173],
"cec":[173],
"ced":[[1,6],12,16,22,26,[29,31],35,37,38,42,59,60,64,66,[68,71],[73,76],81,[84,89],91,92,94,96,97,100,101,[104,106],109,111,[113,117],[119,122],[124,126],[128,131],[133,140],142,143,145,147,149,150,[156,162],[164,166],168,[170,173]],
"cee":[32,46,134,142,159,164,173],
"ceg":[88],
"cel":[10,42,100,105,119,128,136,137,157,158,[164,166],169,173],
"cem":[1,27,95,173],
"cen":[12,22,35,37,39,40,42,57,62,70,75,81,84,88,89,94,96,100,105,109,111,113,114,[121,123],126,128,132,133,142,144,158,159,161,162,166,168,[170,173]],
"cep":[2,32,40,42,48,49,53,54,72,79,81,86,88,89,91,93,97,100,101,104,105,109,113,118,119,122,128,132,139,158,161,162],
"cer":[10,19,37,87,94,100,105,113,128,162,173],
"ces":[[1,6],12,14,16,18,19,22,24,26,[30,32],34,35,37,39,40,42,47,48,54,58,59,[62,64],69,70,74,[76,78],81,85,[87,89],91,92,94,97,100,101,[103,105],108,[111,113],[115,119],121,122,124,[126,128],130,[133,136],[140,142],145,146,150,151,155,[157,160],[162,164],167,168,[170,173]],
"cf2":[173],
"cf3":[173],
"cfs":[81],
"ch-":[8,10,133,141],
"ch6":[100,171],
"ch_":[2],
"cha":[1,2,3,7,19,20,26,28,30,31,36,37,47,49,53,54,57,59,60,71,[74,76],79,[81,83],[87,89],91,94,100,102,104,105,108,109,[113,115],118,122,[124,126],128,137,139,144,147,[157,162],172,173],
"che":[2,3,4,12,14,19,24,26,[28,31],34,37,40,54,58,59,62,63,65,66,69,77,81,82,85,[88,90],94,98,100,[102,106],108,111,113,115,[117,122],[124,126],[128,131],[133,136],[138,141],[143,148],150,151,154,155,[157,159],161,[164,167],[170,173]],
"chg":[47],
"chh":[122],
"chi":[1,2,6,12,19,24,26,28,30,31,35,37,40,41,46,48,49,54,57,77,81,84,85,[87,89],91,92,94,96,100,103,105,113,118,119,[122,124],[126,128],130,133,136,142,146,147,154,[156,162],[164,168],170,171,173],
"chl":[17,20,23,30,32,60,61,63,68,88],
"chm":[1,30,101,113,115,119,124,126,128,144,145,154,[157,160],164,165,170,173],
"chn":[30,40,[88,90],94,96,97,100,105,113,115,118,122,126,128,157,164,173],
"cho":[23,31,58,66,75,77,81,88,89,100,105,113,118,128,144,158,159,162,164,173],
"chr":[30,57,81,100,131,140,146],
"cht":[105],
"chu":[1,85,87,93,100,104,108,111,113,131,137,147,160,172],
"chw":[122],
"chy":[144,147],
"cia":[2,17,26,40,42,59,70,72,74,81,[85,90],94,100,105,110,112,113,115,118,119,121,122,127,128,131,132,135,136,138,152,[157,160],162,164,[170,173]],
"cid":[45,46,81,88,112,128,143,162,163,166,167],
"cie":[[0,173]],
"cif":[17,18,22,26,30,54,64,73,88,89,92,94,100,105,111,113,118,119,122,124,128,133,135,139,162,164,166],
"cii":[23,30,39,59,60,[66,71],81,[87,89],91,94,102,104,113,142,144,148,157,158,161,169,172,173],
"cil":[81,105,109,126],
"cim":[30,45,60,61,[68,71],86,105,113,142,144,150,154,158,160,161,164],
"cin":[62,70,71,81,85,89,99,104,105,113,122,126,128,156,162,168,173],
"cio":[81,105],
"cip":[30,74,81,119,122,164,165],
"cir":[108,123],
"cis":[24,30,45,76,81,95,100,105,115,122,140,162,164,167,171],
"cit":[10,29,37,44,75,79,[81,83],88,100,101,105,115,119,122,124,129,143,145,150,151,154,158,160,162,164,166,173],
"ck*":[72],
"ck-":[26],
"ck_":[82,113,128],
"cka":[111,128],
"cke":[1,2,12,15,16,26,30,31,35,40,42,47,54,[70,72],74,81,85,88,89,94,105,109,111,113,120,122,123,126,128,131,[136,138],140,[145,147],160,165,173],
"ckf":[105],
"ckg":[6],
"ckh":[6,72],
"cki":[26,31,34,58,71,72,81,88,89,91,94,96,100,105,110,113,131,138,143,147,148,167,172,173],
"ckl":[6,16,72,86,109,113,126,128,142,145,150,158,159],
"ckn":[1,89,94,100,113,[117,119],124,126],
"cko":[43],
"cks":[1,2,10,15,21,26,37,51,52,54,72,81,82,88,89,92,94,95,97,100,102,104,105,111,113,115,122,[132,134],152,159,170,173],
"ckt":[128],
"cku":[6,30,57,66,[70,72],113],
"ckw":[35,143],
"ckx":[6,12],
"cky":[30,48,79],
"cla":[2,7,27,28,33,37,64,74,81,87,100,102,105,110,111,113,114,[116,118],[120,122],124,128,129,131,137,138,140,141,143,144,148,150,158,159,[162,164],171],
"cle":[[1,4],9,22,26,29,31,34,40,[43,45],48,54,[59,62],64,66,70,[74,76],78,81,82,[84,87],[89,91],93,94,100,101,103,108,112,113,115,117,119,121,122,124,[126,128],130,[133,135],139,140,143,[145,148],150,152,154,[156,160],[164,167],170,173],
"cli":[74,122,128,161,167],
"clo":[2,7,9,18,35,40,57,59,60,62,66,82,105,113,122,128,145,[160,162],167],
"clt":[47],
"clu":[2,4,12,26,30,37,39,40,55,62,63,75,76,81,84,85,88,89,94,100,101,105,108,109,112,113,[117,121],124,126,128,130,132,133,135,136,139,140,148,158,159,161,162,173],
"cme":[73],
"cmo":[20,74,101],
"cmp":[2,16,35,47,59,60,94,100,113,116,117,123,138,139,143,149,159,166],
"cnt":[1,99,101,103,130,134,139,149,150,152,156,158,160],
"coa":[85],
"cod":[[0,3],5,6,8,10,12,14,16,[20,24],27,28,[30,32],34,40,42,43,[46,48],50,54,55,[58,71],73,74,[76,78],[80,82],[84,92],[94,96],98,[100,108],[110,113],[115,122],124,[126,145],[147,167],[169,173]],
"coe":[136,148],
"cof":[122],
"cog":[109],
"coi":[122,162],
"col":[5,12,31,37,40,74,75,89,108,[113,115],118,122,123,146,159,160,173],
"com":[[0,7],10,12,14,19,21,22,26,[29,31],34,35,37,39,40,[42,50],52,54,56,[58,66],69,71,[73,78],[80,85],[87,92],[94,97],[99,105],[108,111],113,[115,122],[124,131],[133,145],[147,167],[170,173]],
"con":[[0,7],[10,12],14,18,20,[22,24],26,28,[30,34],[37,41],44,[47,49],[54,56],[58,97],[99,102],104,105,[108,111],[113,173]],
"coo":[168,171],
"cop":[14,18,64,84,91,100,111,[113,115],122,125,126,128,131,135,137,140,147,158,159,162,164,166,[171,173]],
"cor":[[0,4],6,9,10,12,[22,24],26,[29,31],37,39,48,49,54,56,[58,60],66,70,71,74,75,[77,79],81,[84,86],88,89,91,94,95,97,100,101,104,105,108,[110,113],[115,119],121,122,124,126,128,130,132,134,136,140,144,145,147,150,152,[158,162],165,166,168,[170,173]],
"cos":[6,26,34,35,37,40,58,73,81,84,89,91,100,104,111,113,115,128,129,132,133,142,147,154,158,160,164,173],
"cou":[1,2,3,6,[9,12],14,26,[29,32],37,[40,42],44,46,47,50,51,54,55,57,60,61,64,[66,70],73,74,77,78,80,81,[83,95],[99,101],105,110,111,113,114,119,122,124,[126,128],[130,134],[136,140],[145,150],[152,154],[156,162],165,167,168,[171,173]],
"cov":[48,59,86,113,128,136,137,159,170,171],
"cow":[75],
"cox":[40],
"cpl":[159],
"cpp":[58,75,101,111,157,159,164,165],
"cpu":[0,1,4,9,12,16,22,26,30,35,46,54,59,60,66,70,81,84,85,[87,89],91,94,95,100,[104,106],111,113,115,117,119,[121,124],126,130,138,139,143,145,147,148,152,154,[157,160],[162,166],170,173],
"cpy":[122],
"cqb":[164],
"cqu":[132],
"cra":[37,75,79,105,113,128,158,167],
"crc":[1],
"cre":[1,9,26,29,31,35,37,40,42,46,51,60,84,85,88,89,94,96,105,113,116,119,120,122,124,126,128,131,137,140,148,151,152,154,159,160,164,167,170,173],
"cri":[[1,4],6,10,14,24,28,[30,32],37,40,47,51,59,70,71,[74,76],80,81,85,86,[88,91],94,100,104,105,108,113,115,118,[122,124],126,128,130,134,136,142,[146,148],[158,160],162,167,172,173],
"cro":[12,34,37,81,88,91,94,100,105,111,113,115,119,123,125,126,128,131,132,140,142,[146,148],157,160,162,163],
"cru":[72,74,87,88,122,128,135,138,157,160,170],
"cs-":[1,128],
"cso":[105],
"csr":[48],
"css":[105],
"csv":[118,126],
"ct-":[160],
"ct_":[115],
"cta":[66,148,160],
"ctd":[99,123,160],
"cte":[1,2,3,15,18,23,26,[30,33],40,45,49,67,71,75,81,83,84,[86,89],91,94,100,102,104,[109,111],113,120,122,124,126,128,130,132,133,135,[139,141],144,146,147,150,[157,162],166,167,[171,173]],
"cti":[[0,6],[10,13],[15,17],[19,24],[26,28],30,31,34,35,[37,48],[50,55],[58,74],[76,78],80,81,[85,92],[94,111],113,[115,124],[126,145],[147,167],[169,173]],
"ctl":[0,3,4,12,23,26,29,30,55,60,64,67,74,75,81,[84,86],88,89,91,94,[105,108],113,115,118,119,123,124,126,128,130,133,135,138,140,142,143,145,147,150,154,[157,159],162,165,166,168,170,173],
"ctn":[30,56,105],
"cto":[1,2,6,12,16,19,30,31,33,40,42,43,57,69,70,73,74,77,84,85,[87,92],[94,97],[99,101],104,105,108,111,[113,122],[124,126],128,130,131,[133,140],144,145,151,154,156,158,160,162,164,166,167,[170,173]],
"ctq":[99,123],
"ctr":[122],
"cts":[31,32,34,37,39,44,75,80,81,84,[88,90],100,105,107,110,113,117,118,122,128,132,136,142,144,147,153,159,160,162,167],
"ctu":[1,24,26,27,35,41,48,54,81,84,88,89,91,96,100,102,104,105,109,113,119,[121,124],126,128,132,134,136,139,143,[157,160],162,164,167,168,170,171,173],
"ctv":[105],
"ctw":[115],
"cue":[80],
"cui":[123],
"cul":[1,2,16,17,22,23,30,31,34,37,40,42,44,45,48,52,60,62,66,69,70,73,74,76,78,81,84,88,89,91,94,96,97,100,101,103,106,107,[113,115],118,119,121,122,[124,126],130,[133,136],139,141,142,[148,150],154,158,[160,162],164,[166,173]],
"cum":[39,40,50,54,74,78,87,90,94,101,108,109,113,119,124,128,130,131,137,[139,141],162,167,171],
"cup":[26,40,66,113,126,142],
"cur":[2,10,14,29,34,37,40,44,48,49,53,66,76,[79,81],84,86,89,97,100,102,105,109,[111,114],117,119,[121,123],126,128,130,139,[156,162],167,168],
"cus":[1,10,22,34,40,43,54,66,69,86,88,89,96,111,113,118,119,121,122,126,128,131,134,135,137,139,140,149,150,157,160,162,167,171,173],
"cut":[1,29,31,35,37,40,42,48,49,57,60,61,69,74,77,78,80,81,85,90,100,105,[113,115],119,120,122,126,128,133,134,139,170],
"cv-":[171],
"cv6":[163],
"cvt":[11,113,119,150,164,165],
"cwt":[47],
"cy!":[38],
"cyc":[[1,4],9,31,60,61,74,89,91,94,100,101,103,113,115,117,119,121,122,124,126,130,133,139,145,147,150,154,[157,159],[164,166],170,173],
"cyg":[14,19,57],
"cze":[173],
"czt":[2],
"c|a":[104],
"ca":[81,105,122],
"d-a":[105],
"d-b":[19,115],
"d-c":[113,121],
"d-d":[120],
"d-e":[164],
"d-f":[2,54,100,128,166],
"d-h":[57],
"d-i":[77,88,133,136,142,158,164,170],
"d-l":[113,115,173],
"d-m":[2],
"d-n":[94,117,162,171],
"d-o":[7,40],
"d-p":[86,105,144],
"d-r":[81,143],
"d-s":[128,132],
"d-u":[48,94,100,103,111,113,126,127,130,139,159,[164,166],170,172,173],
"d-v":[40,158,159],
"d-w":[7,76,115,121,141,164],
"d00":[173],
"d27":[173],
"d2d":[173],
"d4c":[164],
"d57":[164],
"d63":[164],
"d70":[164],
"d72":[163],
"d79":[173],
"d7d":[173],
"d7f":[164],
"d80":[164],
"d88":[164],
"d89":[128,164],
"d8e":[173],
"d92":[164],
"d97":[128],
"d9d":[128,164],
"d_0":[151],
"d_1":[66,151],
"d_3":[6],
"d__":[113],
"d_a":[66,100],
"d_b":[54,94],
"d_c":[143],
"d_d":[94,113],
"d_e":[94,113,119,124,130,131,136,137,140],
"d_i":[131,137,140,151],
"d_l":[83,110],
"d_n":[64,151],
"d_o":[119],
"d_p":[105,114],
"d_q":[16],
"d_r":[131,140],
"d_s":[113,128],
"d_v":[88,128],
"d_x":[30],
"d_y":[30],
"da-":[159],
"da5":[128],
"daa":[164],
"dab":[85,94,100,105,128,148,159,160],
"dad":[159],
"dag":[29],
"dai":[146],
"dak":[105],
"dal":[118,135,144],
"dam":[162],
"dan":[1,40,81,89,91,94,100,105,113,119,124,126,128,134,142],
"dar":[0,2,26,27,43,48,53,57,74,77,79,81,83,86,88,89,91,94,100,104,108,109,113,114,117,118,120,122,124,128,134,160,169,170,173],
"das":[129],
"dat":[0,1,[3,6],12,14,15,19,[22,24],26,28,30,31,34,35,37,40,43,[47,49],54,55,[58,60],62,64,66,70,74,[76,78],80,81,84,85,88,89,91,92,94,96,100,102,104,105,108,109,111,113,[115,120],[122,128],130,131,133,134,[137,140],142,144,145,150,152,[158,160],162,164,[166,168],[170,173]],
"dav":[164],
"daw":[28,128],
"day":[26,37,81,84,88,89,94,96,105,109,110,146,148,167],
"dba":[113,164],
"dbb":[163],
"dbl":[132],
"dbm":[159],
"dbo":[24,105,120,131,137,140],
"dbu":[127],
"dbw":[1,2,16,54,72,96,100,119,124,130,134,149],
"dca":[59,77,94,95,99,113,115,133,135,138,149,150,162,171],
"dcc":[164],
"dco":[3,42,147],
"dcr":[113],
"dcw":[47],
"dd_":[94,113,119,124,136],
"ddb":[1,66,94,163],
"ddd":[88,104,113,119,120,150,163],
"dde":[[0,173]],
"ddf":[163],
"ddh":[87],
"ddi":[1,2,3,6,10,16,19,26,28,31,32,34,35,37,40,46,50,51,54,55,59,60,66,68,69,72,74,76,78,81,84,87,89,91,94,98,100,111,113,117,119,120,123,124,126,128,134,136,140,142,143,147,149,152,[158,164],[169,173]],
"ddl":[1,21,22,29,47,51,52,54,62,100],
"ddo":[146],
"ddp":[47,162],
"ddr":[22,26,27,42,47,69,100,118,128,132,133,[158,160],173],
"dds":[12,47,60,69,89,91,94,109,113,124,128,135,149,159,162,163,166,167,170],
"ddu":[6,12,70,89,113,124,144,158,162],
"ddw":[66,70,89,113,162],
"ddy":[35],
"dd|":[104],
"de-":[114,128,172,173],
"de3":[164],
"de_":[133],
"dea":[0,1,2,6,10,12,19,30,46,65,73,77,78,81,[86,89],94,96,100,105,113,115,[117,123],[125,129],136,139,140,142,144,155,[158,160],162,166,167,173],
"deb":[31,35,47,59,81,86,88,89,96,100,[119,121],128,137,140,143,157,[164,166],170,173],
"dec":[0,2,7,14,30,33,37,40,45,47,60,61,[68,71],81,85,86,[88,91],94,100,104,105,[109,111],113,114,119,121,122,128,[142,145],150,151,154,[158,164],[166,168],170],
"ded":[[0,173]],
"dee":[24,81,110,159,162,168],
"def":[1,22,31,34,35,37,48,56,59,70,74,77,80,83,84,[89,91],94,100,101,109,[112,115],[118,120],122,125,126,128,[131,133],137,139,140,144,145,147,152,154,156,[159,164],168,170,171],
"deg":[26,35,48,135,168],
"del":[1,26,30,34,48,78,94,103,113,114,122,147,150,164],
"dem":[31,34,50,91,122,168],
"den":[6,10,12,16,40,46,48,55,60,61,76,77,81,88,89,91,94,99,100,104,105,112,113,119,126,127,133,136,139,141,148,[152,154],[156,159],161,162,164,166,[170,173]],
"deo":[81,[164,166],170,173],
"dep":[1,2,10,16,[22,24],26,[29,31],34,40,41,47,[59,61],66,74,77,85,87,88,94,100,104,113,118,127,128,133,[136,138],143,148,152,154,155,[158,160],162,164,166,168,170,173],
"der":[[1,6],10,12,14,15,[22,24],26,[29,31],34,37,40,44,47,48,55,60,61,63,66,[70,75],77,78,81,82,84,85,[87,91],94,96,100,101,105,108,109,111,113,115,116,[118,120],122,[126,135],137,139,140,142,143,147,148,150,152,154,[157,160],162,[164,166],168,170,171,173],
"des":[[1,4],6,10,12,14,16,24,26,[28,30],34,35,37,40,42,44,45,47,48,51,59,66,68,70,71,74,76,80,81,[83,86],[88,91],94,98,[100,102],104,105,108,109,111,113,[115,120],122,124,126,128,130,132,134,136,139,142,145,150,155,[158,164],[166,168],[170,173]],
"det":[1,10,14,16,21,30,[32,35],39,[45,48],51,54,65,66,70,76,81,83,84,[89,91],94,[98,100],104,105,109,110,113,115,[118,120],122,126,128,[132,134],138,140,[144,146],154,[157,160],162,164,172,173],
"dev":[10,30,81,96,104,105,122,128,132,167],
"dex":[1,3,4,19,31,35,37,40,51,58,60,62,66,73,74,77,79,85,88,90,92,100,101,113,115,117,118,126,133,135,143,157,[159,162],166,167,170,171,173],
"dfe":[163],
"dff":[164],
"dfs":[29],
"dge":[26,34,35,87,113,[117,119],124,126,132],
"dgm":[1,89,94,100],
"dhi":[87],
"dia":[2,14,22,28,42,55,73,88,89,94,100,105,113,115,118,124,136,150,158,162,163,167,171,173],
"dib":[96,113,116,126],
"dic":[1,2,15,19,26,28,31,35,37,42,54,77,85,88,89,91,94,100,101,105,113,115,117,118,123,126,128,133,138,140,144,145,147,149,150,[158,160],162,167,170,171,173],
"did":[1,3,14,31,34,75,81,88,89,105,109,116,121,122,125,128,131,137,140,143,146,167,171],
"die":[35,84,118],
"dif":[[1,4],6,14,16,22,26,30,31,37,39,40,47,54,59,62,66,70,73,75,77,78,80,81,[85,89],91,94,100,101,104,105,107,108,[113,115],118,119,121,122,[124,128],[130,136],139,140,142,143,[145,147],149,150,[158,162],164,166,[169,173]],
"dig":[23,30,39,60,66,[68,71],74,88,94,102,113,118,122,142,144,148,158,159,161,162,164],
"din":[1,2,6,10,12,14,16,23,26,30,31,34,35,[37,40],42,45,47,48,55,59,60,62,71,73,74,76,78,81,[84,92],[94,97],99,100,[103,105],112,113,[117,119],121,122,124,126,128,130,133,134,138,[141,143],145,147,150,152,[155,162],[164,171],173],
"dio":[28,109,143,150],
"dir":[2,26,43,55,57,82,88,89,91,94,100,107,113,114,119,[123,125],128,130,133,136,138,142,143,148,158,159,165,166,173],
"dis":[1,2,10,16,19,22,24,28,31,34,37,39,40,43,47,55,62,66,69,71,75,81,83,88,89,94,100,105,108,111,[113,115],[118,122],126,128,130,133,[135,137],139,[157,159],161,162,164,167,173],
"dit":[1,2,3,6,10,16,19,20,24,26,28,31,32,34,35,37,40,46,47,50,51,54,59,60,[63,66],68,69,71,72,74,76,78,81,84,[87,89],91,94,98,100,101,104,105,111,113,116,117,119,120,[122,124],126,128,129,133,134,136,[140,143],[147,149],152,[157,162],164,166,169,[171,173]],
"diu":[2],
"div":[6,12,30,32,34,48,81,84,88,91,94,105,113,115,122,126,132,136,138,142,[156,159],162,[164,166],171,173],
"diw":[163],
"dix":[113,158,173],
"diz":[74,118,119,124,130,131,133,139],
"dja":[12,70,88,89,100,113,126,142,144,158,161,162,172],
"djb":[159],
"dju":[2,32,88,94,124,134,137,144,147,148,154,164],
"dle":[4,22,29,31,43,48,58,62,74,97,100,106,[112,115],118,122,[126,128],130,131,140,145,147,150,154,[158,160],162,172,173],
"dli":[1,21,51,52,54,89,91,96,100,115,145,172,173],
"dll":[47],
"dlo":[105],
"dly":[2,22,54,66,88,89,96,100,105,109,112,122,127,128,132,162,170],
"dme":[96],
"dmi":[12,81,105,167],
"dne":[82],
"dni":[81],
"dno":[88,89,118],
"do-":[104,162,163],
"doa":[115,128,171],
"doc":[1,28,31,34,39,40,50,54,[59,61],73,74,76,87,[90,92],94,128,135,138,162,166,167,171],
"doe":[0,1,10,15,30,33,35,37,42,45,47,59,66,69,73,76,81,85,86,88,89,91,94,96,[99,101],104,105,108,[110,116],118,119,122,124,126,[128,131],133,135,136,138,139,142,144,148,149,155,159,162,[164,167],169,170,173],
"dog":[31],
"doi":[85,86,88,89,94,130,148,154,156,158,161,167],
"dom":[24,31,35,37,40,48,60,75,94,108,122,126,128,131,132,135,147,[158,160],163,170,172],
"don":[2,3,6,10,26,28,30,34,35,40,43,45,48,54,55,60,62,64,66,69,71,73,75,77,84,[88,91],94,95,100,104,105,[108,111],[113,115],119,120,122,124,126,128,130,134,135,137,138,[142,144],[147,149],155,156,158,159,162,164,166,167,169,173],
"dor":[160],
"dos":[122,140,146,162],
"dot":[10,45,55,60,66,81,105,118,154,158],
"dou":[3,10,37,39,45,83,91,93,95,104,105,113,119,128,131,134,159,162,164,170,171],
"dow":[2,3,19,24,31,35,37,40,48,49,54,59,66,73,81,87,88,96,97,105,110,122,124,126,128,131,[138,140],146,147,150,160,162,167,170],
"doz":[88,89,94,100,120,128],
"dpd":[123],
"dph":[122],
"dpp":[123],
"dps":[123,162,164],
"dq2":[11,150],
"dqa":[73,99,139],
"dqu":[73,89,123],
"dra":[6,12,19,30,36,54,85,86,88,100,105,126,139,145,147,159,167,168,173],
"dre":[22,26,27,35,42,47,58,69,81,100,109,118,122,128,132,133,[158,160],168,170,173],
"dri":[42,122,127,128],
"dro":[115,137,167],
"dry":[14],
"drz":[81],
"dsa":[120],
"dss":[162],
"dst":[126],
"dsw":[12,161],
"dta":[161],
"dte":[167],
"dth":[40,76,78,93,94,100,150,152,158,162,166,168,171,172],
"dto":[30],
"dts":[9],
"du_":[139],
"dua":[88,91,94,113,115,126,130,138,142,158,159,164,171,173],
"dub":[12,70,89,113,124,144,158],
"duc":[[1,6],10,12,24,26,30,31,34,35,37,40,48,[59,62],64,66,[68,71],[73,78],81,[85,92],94,95,97,[99,101],104,105,[108,111],[113,122],124,[126,145],147,[149,167],[170,173]],
"dud":[137],
"due":[22,37,84,85,100,104,105,112,113,115,124,130,143,147,158,160,172,173],
"dul":[26,30,75,81,82,88,94,122,125,128,132,158,159,171],
"dum":[7,14,47,91,96,128,154],
"duo":[[0,4],6,12,30],
"dup":[[0,4],6,12,19,22,30,31,35,37,[59,61],66,70,81,[85,89],91,99,100,104,113,115,117,119,121,124,[157,162]],
"dur":[[1,4],6,12,22,26,[29,31],35,37,38,54,59,60,64,66,[69,71],[74,76],81,[84,92],94,96,97,100,101,104,106,111,113,115,117,[119,122],124,126,128,130,131,[133,140],143,145,147,149,150,[156,160],162,[164,166],170,173],
"dus":[6,89],
"dut":[[171,173]],
"dv_":[89,117],
"dva":[2,24,39,61,62,81,92,94,100,105,108,111,113,128,136,145,157,158,162,163],
"dve":[105,126],
"dvi":[81],
"dwa":[1,17,22,32,42,48,61,77,81,94,105,122,123,154,160,162],
"dwd":[66,70,89,113,162],
"dwi":[122,128],
"dwo":[3,18,22,42,52,69,70,85,91,94,104],
"dy-":[89],
"dyb":[86],
"dym":[122],
"dyn":[26,40,81,122,162],
"dys":[31,35],
"d|b":[104],
"d|q":[99],
"e-3":[48,158],
"e-a":[3,10,74,116,121,141,158],
"e-b":[1,88,89,91,104,173],
"e-c":[9,100,105,122,136,140,142,150,158,159,172,173],
"e-d":[37,81,113,122,158],
"e-e":[22,88,89,114,122,128,159,162,172,173],
"e-f":[88,162],
"e-h":[144],
"e-l":[1,26,27,32,75,91,94,99,102,105,138,142,149,155,156,158,159,171],
"e-m":[84,99,100,[117,119],126,130,138,171],
"e-n":[2],
"e-o":[24,40,56,115],
"e-p":[31,150,154,164],
"e-r":[26,48],
"e-s":[59,60,74,75,88,100,111,120,133,134,154,157],
"e-t":[26,35,81,88,91,97,105,113,115,123,128,135,143,150,159],
"e-w":[1,54,88,90,94,97,130,139],
"e-x":[111,117,130,139,147,150,151,154,[164,166],170],
"e00":[64,164,173],
"e01":[173],
"e02":[14,173],
"e03":[173],
"e04":[173],
"e05":[173],
"e06":[173],
"e07":[173],
"e08":[173],
"e09":[163,173],
"e0a":[173],
"e0b":[173],
"e0c":[173],
"e0d":[173],
"e0e":[173],
"e0f":[173],
"e10":[173],
"e11":[173],
"e12":[164,173],
"e13":[173],
"e14":[173],
"e15":[173],
"e16":[162,173],
"e17":[173],
"e18":[173],
"e19":[173],
"e1a":[173],
"e1b":[173],
"e1c":[173],
"e1d":[173],
"e1e":[173],
"e1f":[173],
"e2-":[1],
"e20":[173],
"e21":[173],
"e22":[173],
"e23":[173],
"e24":[173],
"e25":[173],
"e26":[173],
"e27":[173],
"e28":[173],
"e29":[173],
"e2a":[164,173],
"e2b":[173],
"e2c":[173],
"e2d":[173],
"e2e":[173],
"e2f":[173],
"e2x":[72],
"e3-":[1],
"e30":[173],
"e31":[173],
"e32":[54,162,173],
"e33":[173],
"e34":[173],
"e35":[173],
"e36":[173],
"e37":[173],
"e38":[164,173],
"e39":[164,173],
"e3_":[1],
"e3a":[173],
"e3b":[173],
"e3c":[173],
"e3d":[173],
"e3e":[173],
"e3f":[173],
"e4-":[6,12],
"e40":[173],
"e41":[173],
"e42":[12,173],
"e43":[173],
"e44":[173],
"e45":[173],
"e46":[173],
"e47":[173],
"e48":[173],
"e49":[173],
"e4_":[2,12],
"e4a":[173],
"e4b":[173],
"e4c":[164,173],
"e4d":[173],
"e4e":[173],
"e4f":[173],
"e4x":[72],
"e50":[173],
"e51":[173],
"e52":[173],
"e53":[173],
"e54":[173],
"e55":[173],
"e56":[173],
"e57":[173],
"e58":[173],
"e59":[173],
"e5a":[173],
"e5b":[173],
"e5c":[173],
"e5d":[173],
"e5e":[173],
"e5f":[173],
"e60":[173],
"e61":[173],
"e62":[173],
"e63":[173],
"e64":[54,84,85,[88,91],94,104,162,173],
"e65":[173],
"e66":[173],
"e67":[173],
"e68":[173],
"e69":[173],
"e6a":[173],
"e6b":[173],
"e6c":[173],
"e6d":[173],
"e6e":[173],
"e6f":[173],
"e70":[173],
"e71":[173],
"e72":[173],
"e73":[173],
"e74":[173],
"e75":[173],
"e76":[173],
"e77":[173],
"e78":[173],
"e79":[173],
"e7a":[173],
"e7b":[173],
"e7c":[173],
"e7d":[173],
"e7e":[173],
"e7f":[164,173],
"e80":[164,173],
"e81":[173],
"e82":[0,1,2,4,9,10,12,22,30,173],
"e83":[173],
"e84":[173],
"e85":[173],
"e86":[173],
"e87":[173],
"e88":[173],
"e89":[173],
"e8a":[173],
"e8b":[173],
"e8c":[164,173],
"e8d":[173],
"e8e":[173],
"e8f":[173],
"e90":[173],
"e91":[173],
"e92":[173],
"e93":[173],
"e94":[173],
"e9e":[173],
"e_1":[131,140],
"e_2":[30],
"e_4":[131,140],
"e_a":[89,126],
"e_b":[101,104,133,135],
"e_c":[129,131,137,140],
"e_d":[37,113,121,142],
"e_e":[72,91,113,115,118,126,131,135,137,138,140],
"e_f":[129],
"e_g":[128],
"e_h":[101],
"e_i":[131,137,140],
"e_l":[35],
"e_m":[94,121],
"e_n":[35],
"e_o":[37,131,137,140],
"e_p":[105,129],
"e_s":[22,67],
"e_t":[53,60,84,131,140],
"e_u":[22],
"ea0":[173],
"ea1":[173],
"ea2":[173],
"ea3":[173],
"ea4":[173],
"ea5":[173],
"ea6":[173],
"ea7":[173],
"ea8":[173],
"ea9":[173],
"eaa":[164,173],
"eab":[48,173],
"eac":[1,4,6,12,16,19,24,26,[28,31],34,35,37,40,59,66,67,70,71,73,74,78,80,81,[85,91],94,97,100,101,104,105,108,111,113,115,[118,120],122,[126,128],[130,132],134,135,142,145,148,149,153,155,156,[158,162],[164,170],172,173],
"ead":[2,3,4,6,7,10,19,24,26,[28,31],34,35,37,39,40,42,43,[47,49],53,59,60,66,73,[75,77],[85,89],91,92,94,96,99,100,104,105,108,109,111,113,115,[118,120],122,123,[126,129],132,136,138,140,143,146,148,150,152,156,[158,160],162,[166,168],170,171,173],
"eae":[173],
"eaf":[24,26,144,173],
"eag":[31,75,114],
"eak":[31,54,81,100,105,122,128,159,166],
"eal":[1,23,26,30,35,[57,59],61,62,74,[80,82],84,86,[90,92],94,96,[99,102],104,105,107,109,113,114,[117,120],122,[124,129],[132,136],139,140,145,148,152,[158,160],162,164,166,167,173],
"eam":[83,91,109,112,113,118,127,130,134,139,140],
"ean":[29,31,37,64,74,75,80,81,89,94,95,97,99,100,107,108,111,113,114,118,119,[121,123],125,128,130,131,[133,135],[142,145],148,158,160,162,164,167,172,173],
"eap":[26,40,59,69,100,105,113,124,126,136,139,143,145,150,154,158,162,170,172,173],
"ear":[1,2,3,10,12,19,22,24,26,29,31,32,34,35,37,40,[42,45],[47,49],54,55,[59,62],68,71,[75,78],[81,85],87,89,91,[93,96],98,100,[103,105],108,109,112,113,115,122,[126,128],130,132,133,135,137,139,140,143,146,147,149,154,156,[158,162],164,166,167,170,172,173],
"eas":[0,1,2,4,10,14,24,26,[28,31],34,37,40,42,43,48,50,54,55,58,60,62,66,68,70,71,74,75,77,[81,92],94,95,97,100,102,[104,109],113,115,[117,119],[122,128],[130,135],[139,142],144,145,147,151,152,154,[156,159],[161,167],[170,173]],
"eat":[1,2,[4,7],9,10,12,23,26,29,31,35,37,40,44,46,47,51,54,60,63,66,70,73,77,[80,82],[84,89],91,[93,96],100,101,104,105,108,111,113,114,116,[118,120],122,124,126,128,[130,135],141,142,144,148,150,[158,162],164,166,167,170,171,173],
"eav":[1,12,16,47,60,72,104,133,135,145,149,163],
"eaw":[122],
"eax":[3],
"eb0":[173],
"eb1":[173],
"eb2":[173],
"eb3":[173],
"eb4":[173],
"eb5":[173],
"eb6":[173],
"eb7":[173],
"eb8":[173],
"eb9":[173],
"eba":[161,173],
"ebb":[173],
"ebc":[173],
"ebd":[173],
"ebe":[173],
"ebf":[173],
"ebi":[31,35,47,88,89,96,100,[119,121],137,140,143,157,[164,166],170,173],
"ebo":[84,105,146,162],
"ebr":[122,173],
"ebs":[167],
"ebu":[26,81,86,126,128],
"ec0":[100,101,173],
"ec1":[100,101,173],
"ec2":[100,173],
"ec3":[100,173],
"ec4":[173],
"ec5":[173],
"ec6":[105,173],
"ec7":[173],
"ec8":[173],
"ec9":[173],
"eca":[1,3,10,12,14,23,26,28,30,31,34,37,40,41,43,46,48,60,66,75,81,82,84,88,91,100,102,105,107,109,113,121,126,128,129,[133,135],[138,140],152,[158,160],162,164,173],
"ecb":[173],
"ecc":[173],
"ecd":[173],
"ece":[22,24,35,39,42,57,75,82,84,94,96,109,111,113,114,118,[121,123],128,158,159,161,162,164,168,170,171,173],
"ecf":[173],
"ech":[[0,173]],
"eci":[2,17,18,22,26,30,42,45,54,[59,61],64,[68,71],73,74,76,81,85,86,88,89,92,94,95,100,105,111,113,115,118,119,121,122,124,128,131,133,135,[138,140],[142,144],150,152,154,158,[160,167],[171,173]],
"eck":[12,24,30,31,34,40,54,58,63,65,69,77,81,82,88,89,94,100,102,105,106,111,113,118,120,125,128,129,131,136,138,140,141,143,144,147,151,[157,159],165,166,170,172,173],
"ecl":[2,7,33,110,114,128],
"eco":[0,1,2,5,14,18,26,31,37,40,[47,49],65,66,69,77,81,84,[88,92],94,96,100,102,104,105,108,109,111,[113,115],119,121,122,[124,126],128,130,135,[143,146],150,152,[158,162],164,[166,168],170,172,173],
"ecr":[37,40,60,85,100,119,128,151,154,164],
"ect":[[1,4],6,10,12,15,16,18,19,21,23,[25,35],37,[39,43],45,46,48,[54,58],60,66,67,[69,71],[73,77],[79,82],[84,92],[94,101],104,105,107,108,[110,149],151,152,154,[156,168],[170,173]],
"ecu":[1,29,31,35,37,42,48,49,57,60,61,69,74,77,78,80,81,85,90,100,105,[112,115],[118,120],122,126,128,133,134,139,159,170],
"ed!":[35],
"ed-":[19,48,81,86,94,100,103,111,113,126,127,130,132,139,159,[164,166],170,172,173],
"ed0":[173],
"ed1":[173],
"ed2":[91,173],
"ed3":[173],
"ed4":[173],
"ed5":[173],
"ed6":[173],
"ed7":[173],
"ed8":[173],
"ed9":[173],
"ed>":[82],
"ed_":[16,54,66,94,105,110,113,114,131,137,140],
"eda":[128,173],
"edb":[14,113,173],
"edc":[173],
"edd":[81,86,111,162,173],
"ede":[[1,4],6,10,16,20,24,26,39,45,46,54,57,59,69,85,86,88,90,91,94,100,101,104,105,113,115,118,119,122,124,128,132,142,147,159,162,164,167,168,170,173],
"edf":[173],
"edg":[1,26,34,35,87,89,94,100,113,[117,119],124,126,132],
"edi":[1,2,14,28,31,42,55,73,78,87,89,94,96,100,105,113,116,118,[121,124],126,133,136,138,140,142,147,150,[160,163],167,171,173],
"edl":[122,127],
"edo":[73,135,138,162,163],
"eds":[0,2,3,4,12,30,31,60,67,89,91,122,134,142,145,150,160,162,167,170,173],
"edt":[167],
"edu":[[0,4],6,12,19,22,26,[29,31],35,37,38,[59,61],64,66,[69,71],73,74,76,81,[84,89],91,92,94,96,97,100,101,[104,106],111,113,115,117,[119,121],124,126,128,130,131,[133,140],143,145,147,149,150,153,[156,162],[164,166],170,173],
"edx":[58],
"edy":[40,105],
"ee-":[74,88,100,104,113,133,141,162,172,173],
"ee0":[173],
"ee1":[173],
"ee2":[1,173],
"ee3":[173],
"ee4":[173],
"ee5":[173],
"ee6":[173],
"ee7":[173],
"ee8":[173],
"ee9":[173],
"eea":[173],
"eeb":[173],
"eec":[173],
"eed":[[0,4],6,10,12,14,16,19,20,[22,24],26,[30,32],35,37,39,40,42,45,46,48,52,54,[57,61],66,67,69,70,73,74,77,78,80,81,[85,89],91,[94,97],[100,105],107,[109,111],113,115,[117,119],121,122,[124,130],[132,135],[137,139],[142,145],[147,150],[153,155],[157,167],170,172,173],
"eee":[113,173],
"eef":[173],
"eei":[105,167],
"eek":[14,37,43,75,105,138,173],
"eel":[28,122,149,158,160,162],
"eem":[3,30,31,40,73,74,77,89,94,100,113,123,126,131,132,145,147,148,158,159,162,167,173],
"een":[1,2,3,10,14,22,26,30,31,35,40,46,47,74,[81,83],88,89,96,100,104,105,108,109,113,121,122,126,128,130,136,137,139,140,142,145,148,149,154,158,160,162,164,166,168,173],
"eep":[4,15,24,26,35,37,62,69,72,101,105,108,111,[113,115],[117,119],126,128,130,132,136,139,144,145,149,157,159,162,167,168,170,173],
"eer":[171],
"ees":[24,31,35,82,132,135,160,168,170],
"eet":[100,109,155],
"eez":[105],
"ef0":[173],
"ef1":[173],
"ef2":[173],
"ef3":[173],
"ef4":[173],
"ef5":[173],
"ef6":[173],
"ef7":[173],
"ef8":[173],
"ef9":[173],
"efa":[1,22,31,48,77,83,109,112,122,125,128,131,133,137,140,154,164,173],
"efb":[173],
"efc":[173],
"efd":[173],
"efe":[1,2,3,6,14,22,29,40,54,94,100,104,[113,115],122,128,136,140,[157,160],164,167,173],
"eff":[26,37,40,59,81,88,94,100,111,113,114,122,124,128,[130,132],134,136,148,158,160,162,164,173],
"efg":[30,59,70],
"efi":[2,14,31,34,35,37,56,74,77,80,84,[89,91],94,100,101,109,[113,115],[118,122],126,128,132,136,139,145,147,152,156,[160,163],168,170,171],
"efl":[116,126,159],
"efo":[14,29,54,72,76,84,86,94,99,100,105,111,124,128,152,154,[158,162],164,166],
"efr":[89,167],
"efs":[159],
"eft":[4,5,10,20,30,40,44,58,59,66,69,[82,84],88,91,94,115,124,142,143,148,150,154,163,164,168,170,171],
"efu":[28,31,42,47,81,100,104,105,109,114,116,122,128,129,135,162],
"eg_":[131,137,140],
"ega":[2,4,11,14,16,23,31,37,44,45,48,64,81,85,[87,89],98,107,113,118,124,126,128,131,132,[135,137],139,140,143,149,150,152,154,[156,158],160,162,164,166,171,173],
"ege":[10,21,26,30,32,35,[37,41],44,46,47,52,61,62,65,72,[79,81],83,84,86,92,95,99,105,107,109,111,113,116,117,120,125,131,135,136,141,142,145,148,150,153,154,162,164,165,170,171],
"egf":[128],
"egh":[84],
"egi":[[0,4],7,12,16,20,22,23,31,32,37,48,52,54,59,61,[70,72],74,81,[87,89],[91,95],100,101,[103,105],111,113,[115,119],122,124,126,128,[130,134],[136,139],141,[144,146],[148,151],158,[162,164],166,[169,173]],
"egl":[127,129,173],
"egn":[126,135],
"ego":[100,113,157],
"egr":[6,35,48,75,128,135,168],
"egu":[31,88,91,113,128,138,142,158,162,171,173],
"egy":[26,35,101,159],
"eha":[22,43,84,114,120,128,131,143,164],
"ehi":[40,72],
"eho":[76,105,122,142,159],
"eig":[2,26,37,74,100,101,111,113,118,119,124,126,130,[133,135],147,149,150,154,158,163,164,167,168,173],
"eim":[170],
"ein":[105,113,128,135,146,159,161,162,167,173],
"eir":[2,23,33,46,74,75,81,82,87,94,113,114,118,119,122,[127,129],133,136,142,145,150,155,158,159,161,162,164,167,168,170],
"eis":[43,122],
"eit":[89,99,100,105,108,113,115,[117,119],122,128,130,[132,134],136,142,144,147,148,150,158,160,162,164,166,173],
"eje":[31,75,113,158],
"ek_":[43],
"eki":[37],
"eks":[75],
"el-":[1,101],
"el1":[12],
"el2":[12],
"ela":[1,5,26,28,31,40,48,78,81,84,87,89,91,92,94,111,113,117,119,122,128,135,143,[157,159],162,[164,166],[170,173]],
"elc":[104,105],
"eld":[10,12,37,40,44,60,66,[76,78],88,89,91,92,94,95,100,101,[104,107],111,113,[117,119],124,126,130,132,[134,136],138,139,144,[149,151],[158,164],166,167,170,171,173],
"ele":[1,2,3,13,15,18,23,26,30,35,37,40,42,45,47,58,66,67,70,74,77,81,[87,89],91,92,94,95,99,100,104,108,111,[113,119],122,124,125,[128,130],133,135,136,138,139,141,143,145,147,149,151,[158,160],162,164,166,170,171,173],
"elf":[81,94,122,124,128,160,163,167],
"eli":[14,30,34,35,81,84,88,89,94,105,113,121,122,124,125,128,140,142,158,159,166],
"ell":[1,2,6,10,26,30,31,34,35,40,43,56,58,59,62,76,78,81,84,88,89,91,92,94,96,99,100,104,105,[112,114],118,120,122,124,128,130,136,143,149,150,154,158,159,161,162,166,[171,173]],
"elm":[85],
"elo":[1,10,16,19,30,59,72,88,89,91,93,94,96,98,100,[104,108],111,113,[115,119],121,122,124,[126,130],132,133,135,136,138,139,[142,147],150,151,154,[158,160],164,167,170,171,173],
"elp":[1,4,5,31,35,40,42,74,81,82,85,87,89,91,111,113,119,121,122,128,130,139,141,[157,159],162,[165,167],173],
"els":[3,4,6,12,20,42,75,81,115,132,162,164],
"elt":[122],
"elv":[94,100,115,119,124],
"ely":[1,2,10,16,21,[28,30],34,37,40,44,48,51,54,56,60,65,66,68,70,73,75,79,[84,86],88,89,92,94,95,98,100,101,[104,106],109,[111,116],[118,120],122,123,126,128,130,132,133,[135,140],144,147,149,150,152,[158,160],[162,165],167,169,170,173],
"el":[160],
"em_":[128],
"ema":[34,76,77,81,88,89,91,94,100,101,105,111,113,117,118,122,126,139,142,154,156,158,159,164],
"emb":[2,24,27,29,46,47,53,55,58,74,81,84,86,91,92,96,[104,106],109,110,115,116,[119,122],124,129,130,133,138,139,148,150,151,154,157,159,160,[162,164],169],
"emc":[2,100,131,140,159],
"eme":[[0,4],6,[9,14],16,17,19,22,24,[26,31],35,39,40,46,48,50,[53,55],[58,62],64,66,[68,71],[74,77],80,81,[83,92],[94,102],104,105,107,108,111,113,[115,122],124,[126,128],[130,134],[136,140],142,143,145,[147,149],151,152,154,[157,162],[164,167],[169,171],173],
"emi":[1,40,74,81,89,91,94,100,113,116,119,122,124,126,131,133,134,140,142,143,154,162,163,173],
"emn":[102,171],
"emo":[3,4,19,22,26,28,30,31,34,35,39,40,47,50,54,57,58,66,73,75,77,81,[84,90],94,95,100,104,105,[111,113],[120,123],126,128,131,132,137,140,145,148,150,155,[160,163],167,168,[170,173]],
"emp":[7,40,81,[88,91],94,96,104,111,113,116,117,119,122,128,164,166,167,170],
"ems":[14,15,34,35,40,41,69,73,[75,77],81,83,84,86,88,89,91,92,94,95,100,104,105,108,111,113,115,117,119,122,124,128,129,131,132,[136,138],140,145,147,148,[158,160],162,167,173],
"emu":[6,12,61,115,162,171],
"emy":[83],
"en-":[167],
"en0":[104],
"en3":[2],
"en4":[2,164],
"ena":[14,22,26,35,37,40,48,97,100,105,113,121,123,124,126,128,132,133,139,143,147,159,162,166,170,173],
"enb":[19,31,35,162],
"enc":[[1,6],9,14,16,20,22,[26,31],[37,40],42,46,47,52,60,61,64,67,74,80,81,84,85,[87,91],94,[98,101],104,105,107,108,[113,115],[117,119],121,122,124,[126,128],130,133,134,136,139,140,143,145,148,150,154,[156,165],167,[170,173]],
"end":[[1,4],6,10,12,14,16,[22,24],26,30,31,34,37,[40,43],47,50,54,[59,62],66,71,73,74,77,80,81,[83,85],[87,89],91,[94,96],100,101,104,105,109,113,114,[117,119],122,124,[127,133],136,138,143,146,148,152,154,[157,164],166,167,170,171,173],
"ene":[2,3,10,18,23,26,30,31,37,40,42,43,46,53,55,60,65,66,73,75,[82,84],87,91,94,100,102,104,105,107,110,111,113,115,116,[118,122],125,127,129,133,135,136,[138,141],143,146,147,149,150,[158,160],162,164,166,[170,173]],
"enf":[62,159],
"eng":[2,14,19,26,28,31,35,37,38,40,75,81,87,100,105,113,122,126,128,145,[157,159],162,167,[171,173]],
"enh":[1],
"eni":[113,122,147,162,171],
"enj":[105,122,167],
"enm":[162],
"enn":[105,173],
"eno":[6,10,12,26,48,55,76,89,94,99,100,113,122,125,136,153,[156,158],163,166,173],
"ens":[2,3,22,27,40,42,43,55,59,60,62,66,68,75,81,88,91,94,105,106,113,115,119,120,122,126,128,131,133,135,[137,140],143,148,149,152,154,158,159,161,162,164,166,[171,173]],
"ent":[[0,6],[9,17],20,[22,24],26,[28,32],[34,37],39,40,42,[44,48],50,[53,55],[57,62],[64,92],[94,102],104,105,[107,155],[157,173]],
"enu":[112,113,118,133,147,158,162],
"env":[30,81,122,128],
"eob":[27],
"eof":[26,75,118,135,144],
"eom":[168],
"eon":[40,74,91,100,104,111,117,119,124,130,138,139,145,147,158,160,162,[164,166],170,173],
"eop":[1,81,105,114,122,126,128,167],
"eor":[26,34,37,78,88,121,122,132,157,166,172],
"eos":[81],
"eou":[48,112,128],
"eov":[1,23,30,40,81,86,88,95,100,102,104,105,109,113,115,119,158],
"epa":[1,12,16,23,26,34,37,40,60,69,85,88,89,91,93,94,[100,102],105,113,118,119,122,126,[134,136],[142,145],147,156,158,159,162,164,165,167,169,170,173],
"epe":[1,2,6,10,16,[22,24],26,30,31,34,35,40,41,47,60,61,73,74,77,85,87,88,94,95,100,101,104,105,113,118,124,127,128,130,133,136,138,141,143,148,150,152,154,[158,160],162,164,166,168,170,173],
"epi":[72,74,88,89,91,94,97,111,113,115,[117,120],124,126,131,[135,140],144],
"epl":[40,60,69,74,85,88,91,94,95,100,105,116,122,131,137,140,148,161,173],
"epo":[0,1,2,37,48,57,59,60,81,82,88,89,[91,96],101,104,105,113,115,122,[125,129],132,142,145,151,[157,159],162,166,173],
"epp":[81],
"epr":[10,26,28,30,31,34,54,[58,61],66,81,83,86,89,104,105,108,113,118,122,128,133,136,142,150,154,158,161,168],
"eps":[4,30,37,40,59,62,66,[69,71],78,88,91,94,97,104,113,115,118,119,130,138,144,149,150,157,158,162,164,166,170,173],
"ept":[2,24,26,29,32,40,42,48,49,53,54,72,79,81,86,88,89,91,93,97,100,101,104,105,109,111,113,118,119,122,126,128,132,134,137,139,155,158,161,162,168],
"epu":[72,113,119,124,130,139],
"epz":[47],
"eq_":[138,139],
"eqb":[59,135,139,149,150,166],
"eqd":[116,166],
"equ":[2,4,5,12,14,16,[21,24],[26,28],[30,32],34,35,40,[45,48],[50,55],[58,61],[64,66],[68,70],72,74,77,78,81,[84,89],91,92,94,95,[97,100],102,104,105,107,108,113,115,[117,119],121,122,[126,133],135,136,138,139,[142,145],[147,151],[153,160],[162,164],166,167,170,173],
"er!":[12,81],
"er-":[59,66,87,88,94,105,113,114,122,131,162,167,172,173],
"er_":[65,87,94,108,118,126],
"era":[[0,6],10,12,16,18,[22,27],[30,32],[34,37],40,42,[44,48],51,[53,55],[59,62],[64,66],[68,70],[72,74],77,78,[80,82],[84,91],94,95,100,101,104,105,[107,109],[111,124],[126,133],135,136,[138,144],147,150,151,[153,155],[157,162],[164,166],[169,171],173],
"erb":[129,147,159],
"erc":[6,10,24,60,83,87,88,104,105,113,119,122,128,144,150,167,172,173],
"erd":[123,173],
"ere":[[0,7],[10,12],14,16,20,[22,24],[26,31],[33,41],43,44,[47,49],51,54,[59,64],66,68,70,[72,77],[80,82],[84,89],[91,94],96,[98,105],107,108,[111,140],[142,152],154,155,[157,162],[164,173]],
"erf":[[1,4],6,10,12,14,16,22,24,28,[30,32],35,37,43,44,48,54,55,58,59,[65,70],[75,78],81,[84,86],88,89,91,92,[94,97],[100,105],108,111,[113,120],122,124,126,127,[129,133],135,136,138,139,[142,144],[146,149],151,[158,160],162,[164,167],[169,173]],
"erg":[19,26,31,35,66,75,88,89,[93,95],97,100,101,107,113,115,118,130,144,[159,162],164,166,173],
"erh":[110,122,[127,129],132,166],
"eri":[1,2,16,23,26,[30,32],35,37,38,40,42,47,54,55,[59,62],66,68,70,77,78,81,84,[86,89],94,96,98,100,102,104,105,108,[111,113],115,117,119,122,[124,126],128,[130,133],135,136,139,142,143,[147,150],152,[158,167],170,171,173],
"erk":[47,122],
"erl":[12,26,31,45,60,72,81,85,94,100,[104,106],113,116,122,126,128,129,133,135,136,145,162,165],
"erm":[16,21,26,28,31,34,35,37,42,45,51,54,55,59,65,72,73,77,78,81,[88,91],94,100,108,111,113,115,118,119,122,124,126,131,133,134,[136,138],152,156,158,160,162,167,[171,173]],
"ern":[26,29,49,73,74,76,77,81,88,91,94,98,100,101,104,105,109,110,[113,115],118,122,123,[126,128],[132,135],143,145,146,[148,150],152,[157,164],166,167,170,171,173],
"ero":[1,2,3,11,16,21,29,30,39,47,48,51,54,55,[64,67],70,73,[88,90],94,[98,100],103,[105,108],111,113,115,116,118,119,123,126,128,130,133,134,139,141,142,144,147,[149,152],154,[156,160],162,164,166,167,[169,171]],
"erp":[12,33,62,67,81,94,113,124,[126,128],138,139,150,154,160,162,164,173],
"erq":[123],
"err":[32,38,39,43,48,56,75,81,82,84,88,89,91,94,100,104,105,109,112,113,115,128,129,144,158,164,170],
"ers":[[0,4],6,7,8,[10,12],16,20,[22,24],26,[28,37],[39,42],45,48,49,52,[54,56],[59,62],64,[66,92],[94,98],[100,109],111,113,[115,122],[124,126],[128,155],[157,167],[169,173]],
"ert":[2,4,10,11,13,19,23,24,26,28,30,31,34,35,37,[39,41],44,48,59,60,62,[65,71],81,[83,89],91,92,94,95,99,100,105,109,113,115,118,119,124,126,[128,130],135,138,140,[142,145],[149,151],153,154,[156,159],161,162,164,166,167,[169,171],173],
"eru":[113,128,160],
"erv":[1,3,26,31,[39,41],47,49,[56,58],60,68,73,81,84,[86,88],94,113,122,123,128,134,135,137,144,146,152,154,157,159,160,162,167,170,173],
"erw":[2,60,85,87,89,94,97,105,111,113,131,142,144,147,151,158,159,170,172],
"ery":[1,2,3,10,14,15,26,[29,31],33,[37,40],42,47,48,54,59,62,63,66,70,72,74,75,80,81,84,85,87,89,90,92,[94,96],99,100,104,105,110,120,122,123,125,126,[128,130],132,134,136,138,143,144,146,149,158,159,162,166,167,[171,173]],
"er":[135],
"es!":[28,82,146,147],
"esc":[1,3,4,6,10,14,24,28,30,37,40,51,59,70,71,74,76,80,81,85,86,[88,91],94,100,104,105,108,113,118,122,124,126,128,130,134,136,142,[158,160],162,172,173],
"ese":[[0,5],10,16,21,24,26,[28,31],34,35,37,39,40,42,45,47,48,52,54,[58,61],66,68,69,80,81,[83,86],88,89,91,92,94,95,97,[100,102],[104,106],[108,110],113,115,[117,120],122,124,126,128,130,[132,134],[136,138],140,[142,145],149,150,[152,154],[156,164],166,168,169,[171,173]],
"esh":[2,77,89,91,108,110,135,159,167],
"esi":[2,4,16,28,59,66,81,83,91,100,105,115,122,128,142,150,158,159,162,163,167,168,171,173],
"esk":[100,123],
"esn":[1,30,33,37,45,59,66,73,76,81,85,88,89,91,94,96,100,104,105,108,110,111,[113,115],122,124,126,138,139,165,173],
"eso":[12,81,105,110,121,125,128,130,133,147,160],
"esp":[21,30,31,48,66,81,84,88,89,94,97,100,104,113,114,117,119,121,122,124,126,128,134,145,148,[158,162],164,167,170,171,173],
"esq":[15,31,[36,38],41],
"ess":[1,2,4,5,6,8,10,13,14,[17,20],[22,24],26,27,[30,32],34,35,40,42,45,47,48,54,56,[58,63],66,[68,71],[73,76],[78,89],91,92,94,95,[99,105],[108,111],113,115,[117,119],121,122,124,126,128,[130,133],[136,145],[148,154],[157,160],162,164,[166,168],[170,173]],
"est":[[0,6],12,14,19,22,25,26,[29,32],34,35,37,39,40,43,44,[46,48],52,55,[58,60],62,[64,67],70,[74,77],80,81,[84,89],[91,96],[98,105],108,109,[111,113],[115,132],134,[136,141],143,145,147,149,151,155,[158,168],170,171,173],
"esu":[[0,4],6,10,12,14,16,19,22,23,26,30,31,35,39,40,47,48,51,52,54,55,[59,64],66,67,[69,71],74,[77,80],82,[84,89],[91,95],[99,101],[103,109],112,113,115,116,118,119,121,123,124,126,128,130,131,[133,137],139,140,142,144,145,[147,152],154,[156,167],171,173],
"esy":[114],
"esz":[122],
"et-":[14,162],
"et1":[94],
"et6":[101],
"et_":[58,88,104,108,118,120,125,128,157,158],
"eta":[1,10,14,16,30,47,66,70,76,81,83,84,94,104,105,109,113,115,118,120,122,128,134,145,146,[158,160],162,164,173],
"etb":[47],
"etc":[3,4,10,37,39,42,43,54,58,66,77,80,81,86,90,92,93,100,113,118,121,122,[126,128],131,[133,138],140,142,144,145,148,150,159,161,173],
"ete":[1,2,10,21,30,[32,35],37,39,[45,48],50,51,54,56,62,65,74,76,[81,84],[88,91],[98,100],104,105,110,113,114,[117,119],126,128,132,133,[138,141],143,144,147,150,154,[157,160],162,164,166,170,172,173],
"eth":[0,1,4,10,14,16,19,21,26,27,[29,32],34,35,40,42,54,55,59,66,69,70,74,76,78,[80,92],[94,96],100,101,104,108,109,111,[113,115],[118,120],122,124,125,[127,130],133,138,139,142,[144,150],152,154,[156,159],161,162,166,167,[169,173]],
"eti":[18,23,26,30,34,44,47,48,63,64,78,81,84,86,88,89,92,94,95,104,105,107,109,113,119,122,124,125,127,128,132,144,[146,149],153,[158,160],162,164,166,171],
"etn":[47,173],
"eto":[159],
"etr":[12,26,37,94,113,122,161,168,173],
"ets":[2,21,26,31,37,40,46,47,56,58,73,78,80,[88,91],94,98,100,[105,111],113,115,118,119,[122,124],128,[131,133],135,137,[139,142],144,145,151,152,[158,162],166,167,171,173],
"ett":[1,10,12,19,26,31,34,35,40,48,49,54,58,60,66,68,69,73,74,76,81,84,[87,89],91,92,94,96,100,101,104,105,108,109,[113,119],121,122,[125,130],133,[135,139],[141,144],[147,152],[158,164],166,167,[171,173]],
"etu":[1,26,31,34,35,41,43,58,73,88,90,91,100,103,109,111,113,117,125,126,128,132,133,135,136,147,157,159,162,164,173],
"etv":[162],
"etw":[2,14,22,26,40,82,83,88,89,100,104,105,108,113,121,128,130,137,139,140,142,148,154,162,164,168,173],
"ety":[113,129,145],
"eu_":[89],
"eud":[1,26,28,31,34,[59,61],76,77,90,92,94,104,135,163,166],
"eue":[105,122,136],
"eur":[31,122,173],
"eus":[105,122],
"eva":[23,32,34,74,79,82,88,91,94,108,111,113,115,117,118,120,121,126,127,130,136,141,149,151,154,160,161,173],
"eve":[[1,4],6,[10,12],14,18,19,22,26,[29,35],37,38,[40,42],[46,50],54,55,[57,60],62,63,66,[70,72],[74,76],[80,91],[94,97],[100,102],[104,111],[113,115],[117,120],122,[124,126],[128,140],[142,147],[149,152],[154,159],[161,164],[166,168],[170,173]],
"evi":[2,14,18,24,26,29,34,40,59,62,66,81,88,89,91,92,94,105,113,119,122,124,126,128,[156,160],162,164,168,173],
"evo":[167],
"ewb":[81],
"ewe":[0,10,34,81,96,100,113,118,124,131,137,159,160,162,173],
"ewh":[28],
"ewi":[5,16,22,30,31,59,73,94,95,100,113,115,118,144,150,159,160,162,163],
"ewo":[91,104],
"ewr":[63,80,82,84,87,89,94,104,131,141,148,151,157,162,164],
"ews":[1,88,89,105,111,122,126,142,146],
"ewt":[165],
"ewv":[160],
"ex-":[104],
"ex1":[88],
"ex2":[60,88,91,113,115],
"ex_":[157],
"exa":[[0,3],9,10,12,14,15,23,26,30,31,37,[40,42],[45,48],51,52,[54,56],59,60,64,[66,68],71,74,[78,81],[83,85],87,88,90,91,[93,95],[98,100],105,106,108,111,113,115,[118,120],[122,124],126,128,[132,135],138,[142,145],[147,150],152,[154,164],166,167,170,172,173],
"exc":[20,32,40,46,48,49,53,54,59,75,79,81,88,89,91,93,94,96,100,101,109,118,119,122,128,134,139,142,158,161,162,164,173],
"exe":[1,4,19,24,29,31,35,37,40,42,48,49,57,60,61,66,69,74,[77,81],85,90,100,105,[113,115],119,120,122,126,128,133,134,139,167,170],
"exi":[26,31,34,40,54,62,74,77,80,81,84,88,94,95,99,100,105,108,109,114,122,128,143,147,154,155,162,166,167,170,171],
"exp":[0,1,5,10,23,26,[31,33],35,37,39,40,42,44,45,47,54,[59,62],66,[68,71],73,74,[78,82],[84,89],91,94,96,100,102,104,105,108,111,113,115,[117,122],124,[126,133],136,138,139,[141,145],[147,154],[157,167],170,173],
"ext":[[1,4],6,12,14,16,19,[22,24],26,27,30,31,34,35,42,45,48,50,52,54,55,59,60,[66,69],71,75,80,81,[84,91],94,95,97,100,101,[104,106],108,[111,116],118,119,121,122,124,[126,129],[131,135],[137,140],[142,145],[148,152],[154,156],[158,160],[162,167],[170,173]],
"exv":[91,94,115,126],
"ey-":[1,74,101],
"ey_":[101],
"eye":[122,146],
"eyg":[123],
"eyo":[100,105,128],
"eys":[19,37,62,77,105,122,133,159],
"eyw":[105,159,162],
"eze":[105],
"f-3":[172,173],
"f-8":[40,128,157,173],
"f-a":[163],
"f-b":[124,143],
"f-c":[128],
"f-i":[35],
"f-l":[133,159],
"f-o":[100,128,164],
"f-p":[162],
"f-s":[76,88],
"f-w":[40],
"f00":[64,142,164,173],
"f01":[51,150],
"f08":[173],
"f0f":[164],
"f10":[173],
"f12":[88],
"f15":[173],
"f18":[173],
"f1d":[173],
"f1f":[150],
"f20":[173],
"f21":[173],
"f27":[173],
"f28":[173],
"f2f":[173],
"f2p":[135,150,166],
"f30":[173],
"f37":[173],
"f38":[173],
"f3a":[173],
"f3f":[173],
"f40":[173],
"f41":[173],
"f45":[173],
"f48":[173],
"f4d":[173],
"f50":[173],
"f57":[173],
"f59":[173],
"f5a":[173],
"f5b":[173],
"f5d":[173],
"f5f":[173],
"f60":[173],
"f67":[173],
"f70":[173],
"f73":[163],
"f7d":[173],
"f7f":[164],
"f80":[64,76,164,173],
"f88":[173],
"f8f":[173],
"f98":[173],
"f9f":[173],
"f_0":[173],
"f_d":[142],
"f_e":[131,137,140],
"f_f":[157,173],
"f_i":[127],
"f_r":[53],
"f_s":[142],
"f_t":[65],
"fa8":[173],
"fac":[34,37,40,55,79,81,84,85,88,92,94,96,99,100,105,108,109,113,121,122,126,128,130,132,134,136,138,139,142,147,148,151,154,157,158,160,164,167,172,173],
"fad":[12,47],
"faf":[128,173],
"fai":[24,43,100,112,128,143,162],
"fak":[81,105],
"fal":[2,5,29,31,52,69,77,87,111,113,118,157,158,163],
"fam":[32,38,54,84,126],
"fan":[35,40,85,94,100,113,118,122,167],
"far":[60,75,100,129,136],
"fas":[1,2,4,10,12,16,19,23,26,28,30,31,[34,37],39,40,52,54,[59,61],66,73,74,[76,78],80,81,[86,88],91,92,94,95,[100,102],104,108,113,115,118,119,121,122,124,126,128,130,131,133,134,136,139,145,[147,149],154,[157,162],[164,166],170,172,173],
"fau":[1,22,31,48,77,83,109,112,125,128,131,133,137,140,154,162,164],
"fav":[84,90,105,122,162],
"fa":[122],
"fb-":[88,89],
"fb0":[173],
"fb1":[173],
"fb4":[173],
"fb6":[173],
"fb7":[173],
"fb8":[173],
"fb_":[22,104],
"fbc":[173],
"fbe":[173],
"fbs":[39],
"fc0":[64],
"fc6":[173],
"fc7":[173],
"fc8":[173],
"fcc":[173],
"fd6":[173],
"fd7":[173],
"fd8":[173],
"fd9":[128],
"fdb":[173],
"fdd":[150],
"fe-":[120],
"fe0":[64,163,173],
"fe7":[173],
"fe8":[173],
"fea":[31,80,82,89,100,105,113,114,116,120,122,142,156,161,162,[165,167],171],
"fec":[3,4,26,28,30,37,58,67,75,81,84,85,91,105,114,122,124,128,130,132,142,143,147,148,159,162,167,173],
"fee":[37,42,113,122,162],
"fel":[44,89,100,122,126],
"fen":[47,122],
"fer":[[1,4],6,14,16,22,26,[29,31],37,39,40,47,54,70,73,74,80,81,[84,89],91,94,100,101,104,105,107,108,[113,115],118,119,121,122,124,125,127,128,[130,136],140,143,146,150,[157,160],162,164,166,167,169,[171,173]],
"fes":[32,128,167,173],
"fet":[3,4,54,58,66,77,90,100,105,113,118,121,126,[133,136],142,144,145,148,150,161,173],
"few":[1,2,10,22,31,34,37,40,42,44,47,53,58,59,75,81,84,86,100,104,110,113,115,118,122,128,131,134,137,140,143,146,150,[158,160],162,163,166,167,173],
"ff0":[51,64,142,164],
"ff1":[150],
"ff2":[173],
"ff3":[173],
"ff4":[173],
"ff5":[173],
"ff6":[23,173],
"ff7":[173],
"ff8":[64,76,173],
"ff_":[173],
"ffa":[121,131],
"ffc":[64,173],
"ffd":[150],
"ffe":[1,2,4,6,14,16,26,30,31,37,39,40,47,64,70,73,74,80,81,[84,89],91,94,100,101,104,105,107,108,[113,115],118,119,121,122,124,125,127,128,[130,136],140,143,146,150,158,159,162,164,166,167,169,[171,173]],
"fff":[2,23,46,61,64,76,113,128,150,164,[171,173]],
"ffi":[2,26,40,59,81,89,91,97,100,105,111,113,115,118,122,124,127,128,131,[134,136],144,[147,150],[158,161],166,[170,173]],
"ffl":[71,72,88,89,91,94,113,115,118,120,126,134,135,138,145,162,164,166,170,171,173],
"ffo":[81,88,94,100],
"ffs":[2,14,37,94,100,162,173],
"fge":[43],
"fgh":[30,59,70],
"fhw":[22,72],
"fic":[1,2,10,17,18,22,26,31,40,44,48,49,54,55,59,60,62,64,73,74,[76,78],81,85,[87,89],91,92,94,97,100,105,108,111,113,115,118,119,121,122,[124,128],131,[133,136],139,[142,145],[148,150],152,154,[157,160],162,164,166,[170,173]],
"fie":[10,22,26,30,32,37,40,44,59,66,76,78,81,85,[87,89],91,94,101,104,113,115,118,122,126,132,135,138,139,145,147,149,150,152,[158,162],164,166,170,173],
"fig":[75,81,120,125,128,148,162],
"fil":[1,2,14,16,18,23,26,31,37,40,47,49,54,58,62,64,71,73,76,81,87,88,93,94,100,101,104,105,108,111,113,114,116,118,120,122,[124,128],130,131,133,135,137,140,147,149,150,157,158,[161,163],166,167],
"fin":[1,4,10,[12,14],[26,28],30,31,34,35,37,40,46,48,51,54,56,59,60,64,66,70,74,75,77,78,80,81,84,[87,92],94,96,97,[99,101],[103,105],107,109,[111,115],[117,120],122,[124,126],[128,132],[134,141],[143,145],147,149,150,152,153,[155,164],[166,171],173],
"fir":[1,2,4,[10,12],14,16,18,19,21,24,26,[29,32],34,35,37,39,40,47,48,[53,55],59,60,64,66,81,84,[87,89],91,92,94,[98,105],108,110,111,[113,115],117,119,120,122,124,126,128,130,131,133,135,138,140,142,144,[147,150],152,[154,162],[166,171],173],
"fis":[47],
"fit":[2,4,30,41,84,85,102,108,113,115,118,119,133,134,136,158,159,170,172,173],
"fiv":[2,3,31,74,77,81,88,89,91,94,101,105,113,115,122,134,147,150,159],
"fix":[1,2,10,14,31,74,75,84,86,88,89,91,94,100,110,113,118,121,124,126,128,132,136,139,142,147,149,150,157,161,162,164],
"fla":[4,17,18,21,30,46,48,61,63,74,75,86,88,92,106,110,111,116,[119,121],124,128,131,137,138,140,143,148],
"fld":[47],
"fle":[72,81,88,89,91,94,109,113,115,118,120,126,134,135,138,145,162,164,170,173],
"fli":[71,72,87,91,94,99,113,115,123,126,134,135,160,164,166,170,171],
"flo":[1,[10,12],32,35,39,[43,45],47,48,62,69,76,78,81,84,86,95,105,109,113,116,119,122,124,125,131,135,136,139,142,149,150,154,158,162,164,165,167,171],
"flt":[48],
"flu":[35,48,89],
"flw":[22,72],
"fly":[81,159],
"fmu":[47],
"fni":[135],
"fno":[120],
"fns":[47],
"foc":[119,149,150,157,160,167],
"fog":[74,119],
"foi":[94],
"fol":[[1,4],6,10,12,14,19,[21,24],26,28,[30,32],35,37,38,40,42,44,46,48,49,51,54,59,[64,66],68,70,[73,75],77,[80,82],[84,86],[88,91],94,[97,101],105,106,111,113,115,[117,119],122,126,128,130,131,133,134,136,137,139,[141,145],[148,152],154,[156,162],[164,167],170,171,173],
"fon":[82,122],
"foo":[33,81,128,132],
"fop":[43],
"for":[[1,6],9,10,[12,16],[22,24],26,[28,32],[34,42],[44,48],[50,52],[54,62],[64,81],[83,109],[111,120],[122,152],[154,173]],
"fou":[3,6,10,12,22,26,30,34,35,40,51,74,77,81,84,85,88,89,91,94,100,104,105,110,113,[115,122],124,128,130,134,142,[145,148],151,153,[157,159],162,[164,167],171,173],
"fox":[105],
"fpe":[48],
"fpg":[105],
"fpl":[34],
"fps":[16],
"fpu":[10,44,45,47,62,86],
"fra":[26,44,45,77,83,86,128,132,133,153,154,158,159,162,166,173],
"fre":[2,26,28,35,40,43,47,81,88,89,94,104,105,110,113,122,127,128,132,133,135,141,149,158,160,162,163,167,173],
"fri":[2,22,42,54,66,73,81,88,96,100,105,109,117,128,132,162,167,170],
"frn":[10],
"fro":[[0,6],9,10,12,14,16,[18,22],24,26,28,[30,32],35,[37,40],43,[47,51],54,55,[58,62],[66,71],[73,75],77,78,80,81,[84,94],[96,98],[100,102],[104,106],[108,111],[113,115],[117,124],126,[128,140],[142,145],[147,150],[152,171],173],
"fru":[126],
"fse":[2,14,37,43,94,100,162,173],
"fst":[31,47],
"ft-":[124,142,162,164,166,168],
"ft_":[91],
"fte":[10,14,24,26,[30,32],40,[43,46],54,66,69,70,72,75,76,81,84,[87,89],91,94,97,100,101,104,105,108,111,113,115,121,122,124,[126,128],134,142,144,150,152,[158,160],[162,164],170,171],
"fti":[66,86,88,94,124,[142,144],150,156,164,166],
"ftq":[91],
"fts":[3,12,17,18,30,32,40,44,55,59,60,66,68,69,78,85,86,88,89,91,94,97,100,104,119,124,150,162,171],
"ftw":[1,61,97,105,113,122,166,167],
"fuc":[47,129],
"ful":[1,6,16,28,30,31,42,47,55,57,59,64,66,69,72,73,77,81,82,[86,88],91,94,95,100,101,104,105,[107,109],[113,116],119,120,122,126,[128,130],133,135,138,149,150,[157,160],162,167,[171,173]],
"fun":[1,2,3,5,22,24,26,27,30,31,33,35,38,41,43,[51,55],58,60,62,63,74,76,77,80,81,88,95,100,104,105,[108,111],113,114,117,[119,122],124,[126,129],132,133,135,138,140,141,143,147,154,[156,159],162,164,170,173],
"fur":[1,3,85,94,128,158,159],
"fus":[81,122,164],
"fut":[75,110],
"fwa":[122],
"fwd":[170],
"fx-":[88,89,100],
"fxc":[47],
"fyi":[126,142,158,159],
"g-1":[124],
"g-c":[157],
"g-e":[88,146,158],
"g-f":[162],
"g-n":[97],
"g-p":[10,48,86,109,162,164,165,171],
"g-s":[128,159],
"g<c":[53],
"g_e":[131,137,140],
"g_s":[115],
"g_t":[147],
"g_v":[105,109],
"g_w":[101],
"gab":[113,122,128],
"gai":[1,3,26,34,40,58,69,81,84,85,[87,89],91,94,100,104,108,113,117,126,128,135,137,144,146,151,[161,163],166,171],
"gal":[132,135,150,166],
"gam":[87],
"gan":[26,81,88,105,121,122,139,151,162,166],
"gar":[4,26,31,48,66,71,78,87,89,113,122,131,158,160,162,171],
"gas":[105],
"gat":[2,11,14,16,23,31,37,44,45,48,55,64,75,76,81,85,[87,89],94,98,107,113,118,120,123,124,126,128,131,[134,137],140,142,143,147,149,150,152,154,[156,158],160,162,164,166,[170,173]],
"gau":[113],
"gav":[1,40,59,89,91,94,100,105,113,122,126],
"gba":[3,6],
"gcc":[1,3,7,12,19,21,30,43,46,50,54,55,58,[63,65],75,86,88,89,91,92,[94,96],100,[102,104],110,111,[113,117],[119,121],124,126,[129,131],133,[137,141],143,145,147,148,[157,159],[163,166],[169,171],173],
"gco":[128],
"gda":[118,135,144],
"gdb":[128],
"ge_":[89,94],
"geb":[122],
"ged":[6,7,8,10,20,37,47,57,59,60,89,94,97,100,113,115,122,[124,126],137,173],
"gel":[1,30,88,89,115],
"gem":[81,113,[117,119],124,126],
"gen":[2,3,10,18,23,26,30,31,37,40,42,46,53,55,60,65,66,73,81,87,91,100,102,104,111,113,115,116,[118,123],127,129,133,135,[138,141],147,149,150,158,159,162,[164,166],171,173],
"geo":[118,135,144,168],
"ger":[1,2,6,10,21,22,26,[30,32],35,[37,41],[44,47],49,52,[60,62],65,72,73,[78,86],88,89,92,95,99,100,105,[107,109],111,113,116,117,119,120,122,125,127,128,131,132,[134,136],139,141,142,144,145,[147,150],153,154,158,[160,162],164,165,[170,173]],
"ges":[2,3,6,12,26,[30,32],37,39,40,43,53,74,76,81,[85,91],94,95,100,105,109,113,118,119,122,126,128,136,137,139,142,144,147,158,159,[161,163],170,172,173],
"get":[1,4,10,[14,16],23,24,26,30,38,40,42,43,54,55,60,66,67,[69,71],73,77,78,80,81,83,[88,90],96,100,101,104,105,[108,111],[113,115],118,119,[122,126],128,[130,137],[139,144],[146,151],154,155,158,159,162,164,167,[171,173]],
"gf2":[135,150,166],
"gfa":[128],
"gfn":[135],
"gfp":[48],
"gge":[6,31,32,37,49,60,[84,87],89,100,119,126,128,139,144,149,158,161,164,170,172,173],
"ggi":[86,128,162],
"ggl":[171,173],
"ggr":[37,110,160],
"gh-":[1],
"ghe":[1,4,6,20,55,[58,60],64,66,[69,71],73,76,84,[87,89],91,[100,102],104,115,118,119,125,134,142,144,150,158,167,173],
"ghi":[70],
"ghl":[31,35,84,88,89,118,127,128,136,158,162,171],
"gho":[162],
"ghp":[2,3,60,61,74,85,89,100,119,150,157],
"ght":[1,2,4,5,6,10,18,26,28,30,35,37,40,44,[59,61],64,66,68,69,74,75,78,79,81,82,[84,86],88,89,91,94,95,[100,103],105,108,109,[111,113],115,[117,119],121,122,124,126,[128,136],139,[142,145],[147,151],154,[156,160],[162,164],167,168,170,171,173],
"ghz":[[0,4],6,10,12,30,31,35,60,70,88,89,91,111,113,115,117,119,121,124,126,130,139,145,147,158,159,[164,166],170,173],
"gia":[81],
"gib":[127,129,173],
"gic":[23,42,59,69,74,76,81,88,94,100,104,115,119,120,122,128,134,149,150,159,162,164,171,173],
"gie":[122,132],
"gik":[88],
"gin":[1,2,4,31,37,38,41,69,74,81,84,[86,89],100,105,113,115,117,121,128,131,139,140,144,147,148,150,[157,162],164,[170,173]],
"gio":[87,126,128],
"gis":[[0,3],7,12,16,20,22,23,31,32,48,52,54,59,61,[70,72],74,81,88,89,[91,95],100,101,[103,105],111,113,115,116,118,119,124,126,130,131,133,134,[136,139],141,[144,146],[148,151],158,[162,164],166,169,[171,173]],
"git":[[0,4],23,30,35,39,40,57,[59,62],[66,71],74,77,78,[85,89],[92,98],[100,104],111,113,115,[117,119],121,124,126,127,[130,133],[135,140],142,144,[147,150],[152,161],[163,167],169,170,173],
"giv":[1,2,3,12,15,16,24,31,35,37,40,45,74,81,82,[87,91],93,94,99,100,105,111,113,115,118,123,126,128,[130,132],134,139,145,147,149,150,152,[155,160],162,163,167,168,[170,173]],
"gi":[122],
"gla":[94,105,110,122],
"gle":[[0,4],12,19,22,26,30,31,40,45,49,54,55,59,60,64,66,[68,70],[73,75],77,78,80,82,84,[86,89],91,92,94,95,97,100,105,108,111,[113,115],[117,119],122,124,126,128,130,133,134,136,142,144,145,147,149,150,153,154,[157,165],[170,173]],
"gli":[26,28,31,35,87,122,127,129,158,159,162,167,[171,173]],
"glo":[26,81,124,134,162],
"gly":[4,40,60,81,[87,89],91,94,97,104,105,109,113,119,128,[157,160],165,166],
"gma":[113],
"gme":[1,26,77,89,94,100,122,132,133,158,159,166],
"gn-":[113,163,171],
"gn_":[113],
"gna":[83,[127,129]],
"gne":[1,5,[10,12],22,27,[30,32],40,41,44,46,52,59,[68,70],73,74,79,81,82,[88,90],92,94,100,102,107,111,113,[117,119],121,122,124,126,135,139,143,144,147,148,150,156,158,160,[162,165],167,168,170,171],
"gni":[1,10,26,28,40,44,48,49,55,60,74,76,81,85,[87,89],91,94,96,108,109,113,118,124,126,127,143,145,149,150,152,154,[157,160],164,173],
"gnm":[26,162,164],
"gno":[84,91,143,162,167],
"gnr":[72,73,94,97,100,111,138,158],
"gns":[113,164],
"gnu":[17,26,49,96,100,128,132,147,159,163],
"goa":[100,117,139,149,158,159,162],
"god":[105,120,131,137,140],
"goe":[34,89,100,122,154],
"goi":[24,34,81,113,122,124,162,164],
"gol":[122,128,[164,166],170,173],
"gom":[30],
"gon":[12,34,105],
"goo":[4,12,23,30,40,47,56,63,66,77,80,81,84,86,89,96,100,109,122,125,127,142,145,147,[158,160],162,167,173],
"gor":[0,1,2,4,6,10,12,14,16,18,[22,24],28,30,34,35,40,42,45,52,54,[59,62],66,[68,71],74,77,78,[85,97],100,101,104,108,111,113,115,[117,119],121,122,124,126,128,130,131,[133,140],[142,145],147,149,150,[153,157],[159,161],164,165,167,168,170,173],
"got":[2,12,26,29,40,50,81,88,98,[100,102],104,105,108,113,115,119,124,125,128,133,134,137,146,161,173],
"gov":[105],
"gpc":[159],
"gpe":[147,159],
"gpr":[172],
"gpu":[74],
"gra":[[0,6],9,10,12,19,22,26,[30,32],35,39,40,[42,45],[47,50],52,54,[59,63],66,74,75,79,81,82,[84,89],[92,95],97,[99,106],109,113,[115,118],120,122,[126,128],130,[132,135],137,142,146,147,149,150,[158,162],[164,168],170,171,173],
"gre":[2,3,5,6,9,12,15,23,29,31,[35,38],40,41,44,60,66,77,80,81,84,87,89,91,94,100,104,105,108,110,111,113,118,122,124,128,[135,137],140,142,144,[158,162],[166,168],170,173],
"gri":[128],
"gro":[6,19,30,40,47,59,72,84,88,89,94,109,[145,147],158,162,168,172,173],
"gsi":[113,173],
"gso":[171],
"gsq":[31,36],
"gt_":[94],
"gtb":[60,94],
"gtd":[117],
"gth":[2,14,19,35,40,75,81,100,105,113,126,145,[157,159],162,173],
"gtr":[96],
"gtu":[113],
"gua":[2,26,28,32,33,79,[81,83],100,105,109,114,120,122,128,148,159,160,162,167,173],
"gue":[1,2,13,23,31,62,70,75,85,86,105,114,122,128,130,131,173],
"gui":[81,88,89,104,122,159,162,171,173],
"gul":[31,88,91,113,128,138,142,158,162,171,173],
"gum":[1,23,42,47,[65,67],[71,74],84,88,94,100,113,115,116,119,120,123,126,[128,130],[133,136],141,150,159,[161,164],170,171],
"guo":[77],
"gur":[75,81,120,125,128,148,162],
"gut":[19,31,35,122],
"guy":[38,81],
"gwi":[14,19,57],
"gyn":[122],
"gza":[115],
"gzi":[167],
"gn":[94],
"h-c":[133],
"h-f":[24,29,141],
"h-l":[8,10,26],
"h-m":[100],
"h-p":[1],
"h64":[100,171],
"h_d":[159],
"h_h":[170],
"h_m":[2],
"h_s":[159],
"ha-":[42,74],
"ha1":[42],
"ha2":[42],
"hab":[26,28],
"hac":[1,21,30,51,52,54,88,89,96,100,111,122,126,146,148],
"had":[12,75,81,88,110,113,122,132,147,149,162,167,173],
"hae":[118,126],
"hai":[59,100,173],
"hak":[31],
"hal":[16,34,53,71,88,91,100,101,111,113,118,119,124,128,144,158,162,171,173],
"ham":[85,101,161],
"han":[[1,4],6,7,10,12,20,22,24,26,[29,31],34,35,37,40,[43,45],47,49,54,55,[57,60],62,66,70,[74,82],[84,89],91,[94,97],[100,102],[104,106],[108,115],[117,119],121,122,[124,137],[139,145],147,[149,151],153,154,[158,162],[164,168],170,172,173],
"hao":[40,122],
"hap":[29,33,75,82,86,109,110,122,128,146,160],
"har":[1,2,3,12,14,17,19,22,26,[30,32],35,36,40,42,48,49,53,54,59,61,62,71,74,77,79,[81,83],[87,89],91,94,[100,102],104,105,[109,111],113,114,[122,124],[126,128],131,133,139,140,144,146,147,150,152,154,[157,162],164,172,173],
"has":[[1,4],10,12,15,16,22,23,[26,31],[35,37],[40,42],44,[46,51],54,55,[57,60],62,66,68,69,72,[74,77],79,[81,85],88,89,91,94,96,98,100,[104,106],[108,111],113,[115,120],[122,124],126,[128,130],[132,137],139,143,144,[147,149],153,154,[157,160],[162,164],166,168,172,173],
"hat":[[0,6],10,12,15,16,18,22,[26,31],[33,37],40,42,43,45,[47,49],54,55,57,59,60,62,[64,67],70,[74,92],94,96,97,[99,101],[104,126],[128,140],[142,167],[170,173]],
"hav":[[1,4],6,12,14,[18,20],[22,24],26,27,[29,31],33,34,37,38,40,[43,46],48,54,55,[57,60],64,66,67,[69,71],73,75,76,80,81,84,[87,89],[91,98],[100,102],104,105,109,110,[113,115],[118,122],125,126,[128,131],[133,136],138,139,[141,145],[147,151],153,154,[156,160],[162,164],[166,168],[170,173]],
"hax":[61],
"ha":[105],
"hbw":[6,72],
"hco":[132],
"hdq":[72],
"he-":[32],
"he_":[37],
"hea":[1,26,30,40,59,69,89,96,100,104,105,108,109,113,122,124,[126,129],132,136,139,143,145,146,150,154,158,163,166,170,172,173],
"heb":[173],
"hec":[12,24,30,31,34,40,54,58,63,65,69,77,81,82,88,89,94,100,102,106,111,113,118,120,125,128,129,131,136,138,140,141,143,144,147,151,[157,159],165,166,170,172,173],
"hed":[1,2,12,19,28,29,31,40,47,54,58,59,62,81,[88,90],94,98,100,104,108,109,113,115,118,119,122,130,134,135,147,148,160,167,171,173],
"hee":[105],
"hei":[2,33,74,87,94,114,118,119,122,127,128,133,145,150,155,158,159,161,162,164,167,168,170],
"hel":[1,4,5,31,35,40,42,74,81,82,85,87,89,91,100,105,111,113,115,119,121,122,124,128,130,139,141,[157,159],162,[165,167],173],
"hem":[1,2,3,14,19,24,26,30,34,37,40,48,55,59,60,69,75,81,84,85,88,89,94,100,104,105,107,111,113,115,117,126,128,130,134,136,142,145,150,154,158,159,164,167,170,173],
"hen":[1,2,4,7,[9,12],14,16,17,[19,24],[26,35],37,40,[42,45],48,54,[56,66],68,71,[73,82],[84,97],100,101,[103,111],[113,126],[128,136],138,139,[141,145],147,[149,152],[154,164],[166,173]],
"heo":[26,34,78,122,132,157,166,172],
"her":[[0,7],[10,12],14,16,20,23,24,[26,43],[47,49],51,54,55,[58,64],66,[68,78],[80,105],107,108,[110,113],[115,145],[147,152],[154,160],[162,173]],
"hes":[[2,5],21,24,26,28,31,35,37,42,47,48,52,54,[58,60],64,66,69,76,80,81,[83,85],[87,89],91,92,94,95,97,[100,105],[108,110],113,115,[117,122],124,126,128,130,[132,135],[137,140],[142,145],147,149,153,155,[157,164],[166,169],171,173],
"het":[111,120,125,128,130,132,133,138,145,147,166,167,170,172,173],
"hex":[0,23,60,68,71,89,98,118,144,148,158,164],
"hey":[1,10,48,71,72,74,81,88,91,94,105,109,113,[115,120],122,123,128,136,144,147,155,158,159,[161,164],[171,173]],
"hhi":[122],
"hi_":[72,118],
"hic":[1,2,21,29,30,34,40,45,48,58,59,68,74,75,77,80,81,84,[86,91],[93,96],100,101,[103,105],108,109,[111,116],[118,124],[126,136],138,143,145,146,148,152,155,[158,162],[164,168],170,172,173],
"hid":[81,100,139,173],
"hie":[28,30,37,40,100,104,105,124,142,156,164,170],
"hif":[3,4,6,10,12,17,18,23,30,32,40,44,45,55,[58,61],64,66,68,69,78,[84,86],[88,92],94,97,100,101,104,111,115,118,119,124,126,134,[142,144],[148,150],154,[156,158],[162,164],166,171],
"hig":[1,4,6,16,20,30,31,35,51,55,[58,60],64,66,[69,71],73,76,84,[87,89],91,[100,102],104,115,118,119,125,127,128,134,136,142,144,150,154,158,160,162,171,173],
"hij":[70],
"hik":[122],
"hil":[6,24,26,30,32,35,40,55,59,76,82,84,89,94,99,100,113,115,[120,122],124,125,127,128,131,132,135,136,139,144,147,150,[154,160],[162,164],166,168,[170,173]],
"him":[105,128],
"hin":[2,3,4,6,12,17,19,26,28,31,[33,35],37,38,[40,43],46,47,49,54,57,66,72,[74,77],81,[83,92],94,96,99,100,[103,105],[108,110],[113,116],[118,120],122,124,[126,131],133,[135,137],139,143,[146,148],152,154,[157,162],[164,167],[169,173]],
"hip":[43,105],
"hir":[1,19,49,76,89,104,105,113,115,135,139,160,162],
"his":[[0,4],6,7,10,12,[14,16],18,[21,24],[26,35],[37,40],[42,52],54,56,[58,71],[73,92],94,95,[97,101],[103,105],[108,122],[124,126],[128,154],[156,167],[169,173]],
"hit":[1,35,41,48,54,75,81,84,88,89,96,100,105,119,[122,124],126,135,139,144,146,157,[159,162],167,171,173],
"hlb":[89],
"hle":[17,20,23,32,60,61,63,68,88],
"hli":[35,88,89,118,162,171],
"hlp":[88],
"hlu":[30],
"hlx":[148],
"hly":[31,84,127,128,136,158,162],
"hm>":[170],
"hma":[1,30,101,113,115,119,124,126,128,145,154,157,158,160,164,165,170,173],
"hme":[18,23,44,47,64,84,88,92,94,104,107,119,124,149,153,162,164,171],
"hmi":[13,26,78],
"hms":[2,24,30,35,40,54,60,66,74,85,88,89,91,92,[94,96],100,104,113,118,135,136,140,144,167],
"hmu":[144,159,160],
"hnd":[100],
"hni":[30,40,[88,90],94,96,97,100,105,113,115,118,122,126,128,157,164,173],
"hno":[122],
"ho-":[128],
"hoc":[26,57,82,85,128],
"hod":[0,1,4,10,16,21,26,27,[29,32],34,35,40,54,59,66,70,74,76,78,[80,82],[84,92],[94,96],100,101,113,114,118,119,122,124,[127,129],142,150,152,154,[156,159],161,166,169,170,173],
"hoi":[31,58,66,88,162],
"hol":[2,3,16,34,40,47,59,62,70,72,77,78,81,82,88,90,94,95,100,[103,105],108,111,[113,116],118,119,122,126,127,129,130,134,138,142,144,146,147,150,158,159,162,170,171,173],
"hom":[96,122,146],
"hon":[2,14,24,25,27,32,55,87,88,100,105,115,122,125,128,161,167],
"hoo":[23,31,77,81,89,100,105,113,118,144,158,162,164,173],
"hop":[68,100,122,128],
"hor":[1,2,3,10,14,16,30,31,35,37,38,40,44,47,50,55,59,69,75,77,81,84,94,95,100,102,104,105,112,113,115,122,124,128,138,139,143,147,150,158,159,[161,164],167,168,171,173],
"hos":[31,57,75,81,128,144,149,159,160,167],
"hot":[73,84,100,130],
"hou":[1,3,4,7,10,12,14,24,32,33,40,[43,45],54,56,59,66,69,72,74,[77,79],[81,86],88,89,91,92,94,96,100,104,105,108,110,[113,115],[119,122],[126,128],136,142,143,[145,147],150,156,[158,160],162,164,167,170,172,173],
"how":[[0,4],6,10,12,14,16,22,23,26,30,31,34,35,37,40,[42,44],50,52,54,56,[58,62],66,70,[74,78],[81,91],94,95,[99,102],[104,106],109,110,[113,115],[117,119],[121,124],[126,145],[147,152],[154,164],166,167,170,172,173],
"hpu":[2,3,60,61,74,85,89,100,119,150,157],
"hqd":[72],
"hra":[31],
"hre":[0,2,5,14,16,34,40,47,48,52,59,66,[72,74],77,81,84,85,88,89,91,[100,102],104,105,108,113,115,[117,120],122,124,[126,128],130,135,136,139,141,144,145,150,[158,160],162,167,172,173],
"hri":[100],
"hro":[2,3,23,34,40,46,53,54,57,[59,61],74,76,81,85,89,100,105,113,119,122,129,146,150,157,159,162,173],
"hso":[165],
"ht-":[6,101,111,113,119,124,158],
"hte":[85,118,122,161],
"htf":[1,4,28,35,40,60,94,101,115,119,139,143,144,150,157,159,164,173],
"hti":[35,88,89,122],
"htl":[1,26,88,89,94,101,145,147,158],
"hto":[105],
"hts":[94,95,100,103,113,126,154,162,171],
"htt":[19,57,144,146,147,159,160,163],
"hty":[26],
"hua":[40],
"hub":[[0,4],35,39,40,[59,62],[66,68],71,77,78,[85,89],[92,98],[100,104],111,113,115,[117,119],121,124,126,127,[130,133],[135,140],142,144,147,149,150,[152,161],[163,167],169,170,173],
"huf":[0,1,3,6,16,22,23,42,60,71,72,[88,91],94,101,104,113,115,118,120,126,134,135,138,144,145,150,152,158,162,164,166,170,171,173],
"hug":[26,84,94,105,108,113,122,[126,128],132,158,162,172,173],
"hum":[122,128],
"hun":[1,47,58,75,85,87,93,100,104,108,111,113,131,137,147,160,172],
"hur":[122],
"hus":[2,10,21,26,30,40,44,45,59,78,81,84,85,[87,89],91,94,[98,100],102,104,105,110,[113,115],118,119,122,[124,126],128,[134,136],139,[142,145],[148,150],153,155,[158,160],162,164,167,170,173],
"huw":[6,30,66],
"hvi":[128],
"hwa":[122],
"hwd":[72],
"hwe":[113],
"hyb":[113],
"hyp":[118],
"hys":[31,37,162],
"i-b":[157],
"i-c":[173],
"i-p":[126],
"i-r":[143],
"i-t":[95,126,143,[160,162],164,169,171],
"i-w":[26,132,157,162],
"i12":[72,89,119,124,138],
"i16":[72,91,113,115,124],
"i25":[72,138],
"i2b":[91,173],
"i3-":[91,124,126,130],
"i32":[72,74,91,94,97,111,113,115,117,119,120,126,131,137,140],
"i51":[139],
"i64":[72,88,91,94,135],
"i7-":[1,12,30,70,88,89,111,113,115,117,119,124,130,147,158,159,165,166],
"i8_":[113,139],
"i_e":[72,94],
"i_n":[118],
"i_s":[72],
"ia-":[160],
"iab":[7,27,29,30,33,40,43,44,56,58,66,[73,75],81,84,88,91,97,100,105,110,113,118,125,128,132,135,148,[158,160],171],
"iac":[123],
"iad":[19,163],
"iag":[115,118],
"iaj":[171],
"ial":[1,2,14,17,24,26,30,35,42,59,66,70,72,74,78,81,[85,89],91,[93,95],100,105,111,113,115,[118,122],[126,128],131,[134,143],149,150,152,[156,158],160,162,164,167,[170,173]],
"iam":[105],
"ian":[1,6,22,30,31,35,38,47,61,66,70,74,81,85,88,89,[94,97],100,102,105,109,111,113,115,116,[118,121],124,126,134,[137,140],143,145,147,157,158,160,162,[164,166],169,170,172,173],
"iar":[28,38,66,114,115,118,126,145,159,173],
"ias":[22,44,111,138,154],
"iat":[40,42,55,73,89,90,94,100,103,110,112,113,117,118,122,124,128,132,133,136,142,150,159,162,163,171],
"iau":[164],
"ibb":[1,40,60,66,68,71,89,[100,102],118,134,142,144,145,149,150],
"ibc":[26,49,100,127,128,132,158],
"ibe":[1,3,4,6,14,24,28,30,37,40,59,70,71,74,80,81,85,86,[88,91],94,100,104,105,108,113,118,122,124,126,128,130,134,136,142,147,[158,160],162,172,173],
"ibi":[76,81,105,118,144,158,159,162],
"ibl":[0,2,3,6,12,14,16,20,23,24,26,[29,31],34,35,37,40,48,49,51,[54,56],60,66,70,78,81,82,[84,89],92,94,96,97,100,102,104,105,109,[111,116],[118,120],[125,129],131,132,135,137,[139,142],145,[148,150],154,156,[158,166],168,170,171,173],
"ibr":[2,14,26,42,43,74,88,89,95,104,105,108,109,114,117,128,131,134,137,140,147,157,171],
"ibs":[75,162],
"ibu":[1,40,62,94,113,124,128,159,167],
"ic-":[81,162],
"ic_":[42,53,74,76,94,96,101],
"ica":[1,2,4,6,10,[12,14],26,28,30,31,34,35,37,40,42,44,48,49,54,55,[58,62],64,66,69,70,[73,78],81,82,[84,89],91,94,99,100,104,105,108,113,115,116,118,120,[122,128],[131,133],135,136,[138,145],[147,152],154,[157,162],[164,168],170,171,173],
"icc":[111,116,131,137,141],
"ice":[1,6,12,14,29,31,34,37,40,42,47,48,58,63,66,68,75,81,82,85,86,88,89,91,94,101,104,105,[112,115],[117,119],121,122,[124,126],128,131,[135,137],139,140,145,146,150,154,155,[157,160],162,[164,167],[169,171],173],
"ich":[1,2,21,29,30,34,40,45,48,58,59,68,74,75,77,80,81,84,[86,91],[93,96],100,101,[103,105],108,109,[111,116],[118,124],[126,136],138,143,145,146,148,152,155,[158,162],[164,167],[170,173]],
"ici":[10,26,29,37,40,44,59,74,79,[81,83],88,89,91,94,97,100,105,111,113,115,118,121,122,124,[127,129],131,134,136,[143,145],[148,151],154,[158,160],162,164,166,171,173],
"ick":[1,2,10,15,22,23,30,31,34,40,48,57,60,69,73,76,77,79,81,86,88,89,94,95,100,106,109,111,113,115,118,122,123,126,128,131,133,134,137,140,142,[144,146],148,150,156,158,159,163,166,167,170,173],
"icl":[1,2,26,31,34,40,44,54,60,64,66,70,86,87,[89,91],94,100,101,113,117,122,124,126,134,135,139,140,146,150,156,158,160,167,173],
"ico":[81,128,172,173],
"icr":[113,119,123,125,126,131,140,157],
"ics":[1,26,31,35,40,47,66,72,104,113,116,119,120,122,132,139,160,162,[164,166],170,171,173],
"ict":[15,19,26,28,31,35,77,81,99,100,105,108,113,123,126,128,133,134,136,147,159,160,162,170,173],
"icu":[81,89,100,122,136,149,160,162,169,170,172,173],
"icy":[31,162],
"id!":[82],
"ida":[31,85,89,94,100,102,104,113,118,144,158,159],
"idd":[1,21,22,29,51,52,54,62,100,105,119,133],
"ide":[0,1,2,4,5,6,10,12,16,19,22,24,26,[29,32],34,35,37,40,[44,46],48,59,60,63,65,66,73,75,77,78,[81,89],91,94,96,97,100,101,104,105,[112,115],[117,122],124,[126,132],134,[136,145],148,150,152,[154,167],[170,173]],
"idi":[6,38,69,81,84,89,94,109,113,129,143,150,161,162,164,165],
"idl":[94],
"idn":[14,34,75,81,88,89,105,116,121,122,125,128,131,140,143,167],
"ids":[31,40,100,121,143,160,167],
"idt":[40,76,78,93,94,100,150,152,158,162,166,168,171,172],
"idu":[88,91,94,113,115,126,138,142,158,159,164,171,173],
"idx":[159],
"idy":[96],
"ie-":[26],
"ie_":[35],
"iec":[[0,173]],
"ied":[1,6,9,12,14,22,26,30,35,40,43,48,59,62,66,69,71,78,[85,87],91,96,105,[113,115],118,122,126,134,139,143,145,147,149,152,[158,162],164,170,172,173],
"ief":[128,159],
"iel":[1,10,12,37,40,44,60,66,[76,78],88,89,91,92,94,95,100,101,104,106,107,111,113,[117,119],122,124,126,130,132,[134,136],138,139,142,144,[149,151],[158,164],166,167,170,171,173],
"ien":[2,22,26,31,40,42,54,59,66,73,81,87,88,91,96,97,100,104,105,109,111,113,115,117,118,122,124,128,131,132,134,136,144,[148,150],[158,160],162,164,167,170],
"ier":[3,10,40,50,66,69,71,78,88,91,94,100,102,104,109,113,118,122,127,128,145,[158,162],164,166,173],
"ies":[1,4,6,[14,16],19,23,24,26,28,31,32,34,35,37,40,42,47,48,66,[73,75],77,81,84,85,[87,89],94,96,98,100,102,105,108,109,111,113,114,118,122,[124,126],128,[132,135],[137,139],142,144,147,148,150,154,[158,162],164,166,167,170,172,173],
"iet":[113,173],
"ieu":[104,124],
"iev":[26,30,34,37,40,81,84,105,140,142,156,159,164,170],
"iew":[1,9,105,109,111,113,122,128,134,157,160,162,167,173],
"if-":[76,88,124,133,143,159],
"if_":[131,137,140],
"ife":[31,81,105,122,128],
"iff":[1,2,4,6,14,16,26,30,31,37,39,40,47,70,73,80,81,[85,89],91,94,100,101,104,105,107,108,[113,115],118,119,121,122,124,125,127,128,[130,136],140,143,146,149,150,158,159,161,162,164,166,[169,173]],
"ifi":[1,2,10,17,18,22,26,[30,32],40,44,48,49,54,55,59,60,62,64,66,73,74,[76,78],81,85,[87,89],91,92,94,100,105,108,111,113,115,118,119,122,[124,128],133,135,139,[142,145],147,149,150,152,154,[157,162],164,166,170,173],
"ifo":[62,113],
"ifs":[94],
"ift":[3,4,6,10,12,17,18,23,30,32,40,44,45,55,[58,61],64,66,68,69,78,[84,86],[88,92],94,97,100,101,104,111,115,118,119,124,126,134,[142,144],[148,150],154,[156,158],[162,164],166,171],
"ify":[3,30,69,75,88,89,113,118,126,142,144,145,158,159,164,173],
"ig-":[22,88,158],
"iga":[31,75,147,172,173],
"ige":[81,122],
"igf":[48],
"igg":[6,31,32,37,49,60,[84,86],89,100,119,128,144,149,158,162,164,170,172,173],
"igh":[1,2,4,5,6,10,16,18,20,26,28,30,31,35,37,40,44,51,55,[58,61],64,66,[68,71],[73,76],78,81,82,[84,89],91,94,95,[100,105],108,109,[111,113],115,[117,119],121,122,[124,130],[132,136],139,[142,145],[147,151],154,[156,160],[162,164],167,168,170,171,173],
"igi":[1,2,23,30,38,39,41,60,66,[68,71],74,84,88,94,102,113,118,[127,129],131,139,142,144,147,148,[157,161],164,173],
"igl":[171],
"igm":[113],
"ign":[1,5,[10,12],17,22,[26,28],[30,32],34,37,[39,41],44,46,48,49,52,55,59,60,[68,70],[72,74],76,79,[81,85],[87,92],94,97,100,102,105,[107,109],111,113,[117,119],121,122,124,[126,129],138,139,[143,145],[147,150],152,154,[156,160],[162,165],167,168,170,171,173],
"igr":[31,40,167],
"igu":[75,77,81,120,125,128,148,162],
"igz":[115],
"ihm":[30],
"ijk":[70],
"ike":[2,5,17,22,27,[30,32],35,37,46,48,59,73,[79,81],[83,85],88,89,91,92,94,95,100,105,108,109,[112,119],122,123,126,128,[132,135],138,139,[142,150],[158,164],[167,170],172,173],
"iki":[2,14,28,36,162,167,171,173],
"ikm":[88],
"ikt":[122],
"ila":[[1,4],10,22,23,26,28,30,31,35,37,39,40,44,45,[48,50],52,54,55,[59,62],64,[66,71],74,77,78,81,[84,89],91,94,[96,98],[100,109],111,113,[115,121],123,124,[126,140],[142,145],147,149,150,[152,162],[164,167],[169,171],173],
"ild":[24,26,31,35,37,45,47,59,70,75,81,85,88,89,91,92,94,97,[99,101],104,105,111,113,115,122,126,128,[130,132],134,135,139,141,147,150,[157,160],162,[167,170]],
"ile":[[1,4],6,10,12,14,21,26,30,32,40,42,46,47,50,55,56,[58,60],[63,65],71,75,76,[80,82],84,[87,91],94,95,97,[99,105],[109,111],[113,122],[124,133],[135,137],[139,141],[143,148],150,[154,167],[170,173]],
"ili":[6,14,28,37,38,73,81,91,94,100,101,105,108,109,113,115,118,120,121,124,126,128,131,[134,137],144,145,150,152,154,[156,159],162,164,165,170,173],
"ilk":[105],
"ill":[4,14,16,18,19,22,23,26,29,31,33,37,40,42,44,46,47,49,51,54,58,60,62,64,[73,76],[79,82],84,86,88,89,93,94,100,102,104,105,[108,111],[113,116],[118,120],[122,124],[126,128],[130,135],137,139,140,[142,144],146,149,150,153,154,[157,167],172,173],
"ilo":[2,30,105,113,122,167],
"ils":[1,10,14,16,30,59,66,70,81,84,94,104,105,113,115,120,122,125,128,134,145,[158,160],162,164,171],
"ilt":[1,2,31,37,40,105,110,113,119,128,132,138,139,158,159,166,173],
"ilu":[128],
"ily":[1,28,29,34,55,60,68,71,77,84,85,88,91,94,95,100,104,105,113,131,134,138,142,[144,146],164,167,171],
"ima":[1,3,4,6,12,28,30,31,40,45,[60,62],[68,71],76,84,86,88,92,100,105,113,126,128,130,142,144,147,150,154,[158,162],164,165],
"imd":[0,2,4,6,16,23,52,54,59,60,68,74,76,77,85,[88,94],97,100,104,107,108,111,113,[117,121],123,124,130,131,133,134,[136,140],142,144,158,160,162,[164,166],[170,173]],
"ime":[[0,4],6,12,14,19,22,26,[29,31],[34,37],40,[47,49],54,59,60,62,63,66,70,73,75,77,78,[80,82],[85,89],91,[94,97],[100,102],104,105,108,109,111,113,115,117,119,121,122,[124,128],[130,137],139,143,[145,147],149,150,155,[158,167],170,173],
"imh":[81],
"imi":[[1,4],10,12,14,23,24,26,30,31,35,37,39,40,49,54,55,59,64,66,70,74,78,81,84,85,[88,91],94,96,[100,105],108,109,113,115,116,[118,122],126,128,131,133,134,136,138,140,143,144,[147,151],154,[158,162],166,167,[171,173]],
"imm":[14,36,42,73,74,100,135,150,162,163,171],
"imo":[122],
"imp":[[0,4],6,[10,17],19,22,24,26,[28,31],33,[35,40],43,44,[46,48],51,[54,66],[68,71],[74,77],[79,91],94,95,97,98,[100,102],104,105,[107,109],[111,115],[117,124],[126,142],[145,147],[149,154],[156,167],[169,173]],
"ims":[85],
"imu":[4,12,30,31,37,40,44,47,52,78,81,84,85,[88,90],94,100,108,113,115,117,119,124,130,134,136,139,141,142,144,148,153,155,[157,159],162,166,168,170,173],
"in-":[2,22,54,100,115,120,126,137,159,162,171,173],
"in1":[63],
"in_":[1,58,117,119,128,139,150,173],
"ina":[[1,4],10,12,14,[22,24],[26,28],[30,32],35,37,40,42,44,47,48,53,[59,62],64,66,67,69,70,[74,78],80,81,84,[86,89],91,92,94,96,97,100,104,105,[107,109],111,[113,118],122,[124,126],128,130,131,133,134,136,138,139,141,144,[147,150],[153,155],[157,164],[166,171],173],
"inc":[[1,4],6,9,16,19,[28,31],34,35,[38,40],42,44,46,47,52,55,60,67,70,76,81,[83,85],[87,91],94,96,100,101,105,112,113,[115,122],[124,126],[128,131],[133,137],140,142,143,145,[147,150],152,[157,162],164,166,170,173],
"ind":[[1,4],10,12,13,15,16,19,26,28,30,31,34,35,37,40,42,51,54,58,60,62,66,73,74,77,[79,81],85,[88,92],94,96,[99,101],[103,105],109,110,113,115,[117,119],[122,124],126,128,131,133,135,137,138,140,[142,145],[147,150],[153,162],164,166,167,170,171,173],
"ine":[2,3,6,10,12,14,16,21,22,26,28,30,31,34,35,37,38,[40,42],46,49,51,54,[57,60],62,70,[74,77],[80,82],[84,92],[94,96],100,101,105,[108,111],[113,115],[117,122],124,[126,130],[132,137],139,142,143,[145,150],152,[154,166],168,[170,173]],
"inf":[26,28,34,46,48,73,74,91,94,100,104,105,109,112,113,122,123,128,130,132,139,143,145,147,150,173],
"ing":[[0,6],8,10,12,14,[16,19],[21,24],26,[28,62],[64,106],[108,122],[124,173]],
"ini":[[1,4],14,21,24,26,28,30,31,34,35,37,40,45,46,48,54,56,62,[65,67],77,[80,82],84,85,[87,89],91,94,[99,101],103,108,[111,115],117,[119,122],124,126,128,130,135,137,139,[141,144],[147,150],152,153,156,[158,162],164,166,170,171,173],
"inj":[128],
"ink":[1,3,4,6,20,26,30,35,66,70,76,81,88,91,94,96,104,111,113,122,130,139,143,147,159,172],
"inl":[80,91,122,135,143,159,162],
"inn":[1,4,37,84,89,91,99,100,113,119,121,124,128,139,144,150,164,166,170],
"ino":[30,40,84,88,89,128,136,161],
"inp":[1,13,21,23,26,30,35,56,58,64,66,67,69,71,74,77,84,85,[87,91],94,95,[100,102],104,106,109,111,113,115,118,119,124,126,128,130,131,[133,137],[142,145],147,149,150,155,[157,162],164,170,172,173],
"ins":[[0,7],[10,14],16,17,[19,23],26,[29,31],34,35,37,39,40,42,[45,47],[49,51],54,55,[58,61],[64,68],[70,74],76,77,80,81,85,86,[88,97],[99,108],111,[113,126],[128,140],[142,145],[148,167],[169,173]],
"int":[[0,7],[10,12],19,[21,24],26,28,[30,48],52,54,55,[59,62],[65,81],[83,97],[99,102],104,105,[107,145],[147,173]],
"inu":[[0,3],5,6,14,18,26,30,40,47,57,73,75,81,82,88,91,94,100,109,113,122,[126,128],133,139,144,145,158,160,163,164,166,171],
"inv":[1,12,17,26,30,32,35,40,48,73,75,79,[88,92],94,101,104,109,112,113,115,[117,120],122,124,128,129,131,[133,136],144,149,152,155,162,164,166,170,173],
"iny":[85,99,118],
"iod":[31,37,105],
"iog":[40],
"iol":[81,100,111],
"iom":[109,143,150],
"ion":[[0,6],[10,24],[26,56],[58,173]],
"ior":[116,134],
"ios":[22,113,128,132,133,173],
"iot":[30,73,81,162],
"iou":[1,2,12,14,18,22,24,26,29,30,34,35,40,59,66,73,75,77,79,81,82,84,85,88,89,91,92,94,95,100,102,103,105,108,113,114,116,117,[119,124],126,128,130,136,139,143,145,147,149,150,152,156,[158,162],164,165,167,168,172,173],
"ipa":[122],
"ipe":[2,14,28,167,171,173],
"ipl":[6,9,12,22,28,30,34,40,48,55,59,60,66,69,70,81,82,84,86,88,89,91,94,113,119,121,122,124,132,[134,136],142,144,148,154,[157,159],[162,165]],
"ipm":[105,162],
"ipp":[0,20,43,91,100,113,126,128,144,151,158,159,164,166,167],
"ipr":[30,74,81,119,164,165],
"ips":[122,146,171],
"ipt":[1,2,10,31,32,37,47,51,75,81,88,94,105,115,122,123,128,130,146,148,159,162,167],
"ipu":[47,[59,61],67,68,85,88],
"ipv":[158],
"iqu":[28,30,40,77,80,[88,90],94,96,97,99,100,104,105,113,115,118,122,126,128,131,137,140,146,[157,160],162,164,170,173],
"ira":[122,128],
"irc":[108,123,159],
"ird":[1,19,23,46,75,76,81,82,89,104,105,113,115,129,135,136,139,142,160,162],
"ire":[1,2,4,12,14,16,[22,24],[26,28],[30,32],34,35,40,43,45,46,50,51,[53,55],[57,60],65,66,[68,70],72,74,77,78,81,[84,89],91,94,95,97,98,100,102,104,105,107,[113,115],[117,119],[121,136],138,142,143,145,[148,151],155,[158,160],162,165,166,168,173],
"iri":[122,135],
"irk":[33],
"irm":[120],
"iro":[30,81,128],
"irs":[1,2,4,[10,12],14,16,18,19,21,24,26,[29,32],34,35,37,39,40,47,48,[53,55],59,60,64,66,81,84,[87,89],91,92,94,[98,105],108,110,111,[113,115],117,119,122,124,126,128,130,131,[133,136],138,140,142,144,145,[147,150],152,[154,162],[166,171],173],
"irt":[37,49,57,76,81,82,116,120,122],
"is-":[100,166,170],
"is_":[24,54,65,80,87,111,120,131,137,140,170],
"isa":[2,24,39,42,47,55,59,60,81,88,94,100,102,105,108,109,114,117,120,122,123,128,131,136,146,158,161,162,164,166,171,173],
"isc":[1,10,22,31,34,37,40,43,66,69,71,88,89,100,111,113,122,126,128,135,137,139,157,159,[162,164],171,173],
"isd":[43,161],
"ise":[1,2,4,5,12,22,24,30,31,45,48,54,59,60,66,73,76,83,[87,91],94,95,97,100,102,104,105,107,111,113,115,118,121,122,124,[126,128],130,132,136,[138,140],[142,144],146,147,150,151,[158,164],166,167,170,172],
"isf":[138],
"ish":[1,10,12,16,26,28,31,35,47,59,73,81,[87,89],91,94,96,100,104,105,109,122,128,136,143,148,159,160,162,167,[171,173]],
"isi":[0,2,4,24,26,29,30,35,40,45,48,49,60,62,72,81,84,85,89,94,95,100,113,114,118,122,128,135,136,142,146,150,[159,162],164,165,167,171],
"isj":[34],
"isl":[81,161],
"ism":[35,88,128],
"isn":[10,14,24,26,28,36,40,47,66,70,73,74,81,87,94,96,99,100,119,161],
"iso":[1,2,4,12,30,31,35,40,44,45,52,54,55,[59,62],65,66,69,76,77,84,85,[87,92],94,[100,104],108,111,113,116,118,119,126,130,131,133,134,[136,140],142,144,[147,149],151,154,[156,158],162,164,166,[169,171],173],
"isp":[75,100,113,115,119,126,130,133,147,161,167],
"iss":[10,18,26,49,58,59,66,73,75,81,84,88,111,113,115,122,128,130,132,139,145,150,154,158,[160,162],173],
"ist":[[0,3],7,10,12,16,19,20,22,23,26,28,[30,32],34,35,38,40,44,47,48,52,54,55,59,61,62,66,[70,72],74,[79,85],[87,89],[91,95],[98,101],[103,105],[108,111],[113,116],118,119,[121,124],[126,128],[130,134],[136,141],[144,151],[158,164],166,167,[169,173]],
"isu":[81,105,128,132,161,173],
"isx":[127],
"it-":[1,12,40,45,54,55,59,60,66,68,69,71,74,78,80,[85,89],91,92,94,[97,102],106,113,115,[117,119],130,134,135,138,143,144,150,151,156,157,159,161,162,166,171],
"it0":[135],
"it1":[135],
"it7":[135],
"ita":[2,28,30,59,69,77,86,88,[90,92],95,100,102,104,108,111,113,115,122,150,152,161,164,166,170],
"itc":[12,29,68,75,112,122,133,141,147,148,158,159,161,162,166,173],
"ite":[0,1,2,4,6,7,10,12,15,19,22,[24,26],[28,31],[34,37],[39,41],[46,48],51,54,56,[60,64],71,73,75,76,[80,82],[84,92],[94,96],99,100,102,104,105,108,109,[111,115],[117,119],[122,124],[126,128],[130,132],135,136,139,[143,151],154,155,[157,164],166,167,[170,173]],
"itf":[40,126,149,172],
"ith":[[0,6],9,10,12,[14,16],[18,20],[22,24],26,[28,35],37,[39,45],[47,50],52,54,[57,64],[66,78],[80,105],[107,111],[113,122],[124,145],[147,173]],
"iti":[1,2,3,6,10,12,16,[19,24],26,[28,32],34,35,37,40,[44,47],[49,51],54,55,59,60,[62,66],68,69,71,72,[74,76],78,80,81,84,85,[87,89],[91,101],[103,105],109,111,[113,117],119,120,[122,124],126,128,[132,137],[139,144],[146,150],[152,154],[156,164],166,167,[169,173]],
"itl":[31,81,91,100,161,162,164,167],
"itm":[26,89,91,92,100,104,118,130,133,139,143,145,156,[158,160],169,170],
"ito":[1,2,16,30,39,57,88,[91,96],101,104,113,115,123,128,145,146],
"itp":[158,162],
"itr":[12,40,113,118,135,145,166,171],
"its":[1,2,4,10,12,16,23,24,29,30,32,34,[39,41],44,45,51,53,55,58,59,61,[66,71],74,76,78,80,81,84,85,[87,98],[100,102],105,108,111,[113,116],118,119,[122,124],[126,128],130,131,[133,135],[138,140],[142,150],[152,154],[156,164],[166,168],170,171,173],
"itt":[1,10,22,48,50,55,59,70,74,75,81,82,[87,89],91,93,94,96,100,104,109,113,[119,123],[126,128],131,140,141,143,[157,162],164,173],
"itu":[29,48,69,70,96,100,118,137,172,173],
"itv":[92],
"itw":[4,88,89,91,100,102,104,107],
"ity":[1,2,12,14,26,34,54,62,69,74,77,81,88,89,94,95,[100,102],105,108,113,118,119,122,126,128,129,131,135,137,138,143,145,147,150,152,154,155,[158,162],166,167,170,172,173],
"ium":[2,9,20,22,31,35,39,54,[59,62],66],
"iva":[5,12,22,59,69,84,88,94,105,107,133,139],
"ive":[[1,4],6,[10,12],[14,16],21,23,24,29,31,34,35,37,40,42,44,45,48,55,[59,62],64,66,[68,70],74,75,77,78,[80,82],[84,94],[98,101],104,105,[107,111],[113,115],[117,119],[121,124],[126,128],[130,136],139,143,145,147,[149,168],[170,173]],
"ivi":[6,12,30,32,34,48,59,81,84,87,88,91,94,105,111,113,115,120,126,128,131,136,138,140,142,[156,159],162,164,165,171,173],
"ivm":[30],
"ivo":[77],
"ivp":[165],
"iwa":[35],
"ix-":[88,89,142,159],
"ixe":[1,3,4,6,10,12,14,74,75,84,86,88,89,94,100,113,115,118,121,122,124,126,132,136,139,147,149,162,164,173],
"ixi":[128,142],
"ixt":[145,149,160,171],
"ixu":[150],
"iza":[12,26,30,40,48,77,81,82,85,87,88,91,94,105,111,113,116,120,121,130,131,133,134,136,137,140,142,143,145,148,159,160,162,164,170,172,173],
"ize":[[1,4],6,10,19,22,26,28,30,31,35,37,[40,45],47,48,53,54,57,59,62,70,75,77,78,80,81,[84,88],91,[93,95],100,101,[103,105],108,109,111,113,115,[117,122],124,[126,128],[130,134],136,137,139,140,142,144,145,[147,150],154,[158,166],[170,173]],
"izi":[85,100,102,105,113,121,124,131,140,154],
"izo":[16,113,124,158,162,168,171],
"id":[122],
"is":[81,122],
"j-t":[161,171],
"jac":[12,70,74,88,89,100,113,126,142,144,158,161,162,172],
"jae":[47],
"jan":[146],
"jap":[173],
"jav":[32,105,122,159,167],
"jb2":[159],
"jbe":[47],
"jci":[[0,173]],
"jda":[105],
"jdu":[47,154],
"jec":[[25,27],31,34,35,40,75,[79,81],104,110,113,117,122,[127,129],132,[157,159],[162,164],167,[171,173]],
"jge":[47],
"jia":[171],
"jie":[171],
"jkl":[70],
"jle":[47],
"jmp":[47],
"jne":[47],
"jns":[47],
"jnz":[46],
"job":[10,15,47,73,81,88,112,118,127,131,146,149,158,161,163,173],
"joh":[84,100,164],
"joi":[14,30,34,37,[69,71],73,84,88,100,105,111,144,161],
"jok":[122],
"jor":[72,81,88,94,100,113,128,136,144,147,154,159,162,173],
"joy":[105,122,167],
"jpe":[115],
"jqu":[167],
"jsc":[159],
"jso":[105],
"jum":[47,58,63,65,73,100,104,133,141,143,148,157],
"jun":[164],
"jus":[[1,4],6,10,16,17,20,21,23,29,30,32,37,39,40,42,47,55,57,59,61,64,66,69,73,75,77,79,81,85,88,91,92,94,[98,102],105,110,111,113,115,[117,122],124,126,128,130,133,134,[136,139],142,144,[147,149],154,155,[158,162],164,169,171,173],
"jr":[30],
"k-1":[23,111],
"k-b":[26,40,76],
"k-c":[113],
"k-h":[113],
"k-j":[105],
"k-m":[121],
"k-r":[151,169],
"k-t":[23,135,166],
"k7b":[94],
"k8b":[94],
"k_a":[115,128],
"k_b":[166],
"k_c":[126],
"k_e":[43,126],
"k_h":[73,82],
"k_i":[113],
"k_l":[73],
"k_s":[93,94,115],
"k_v":[113],
"kag":[128],
"kam":[105],
"kan":[1],
"kar":[2,54,100],
"kat":[111],
"kcd":[122],
"kdo":[167],
"ke-":[111,117,130,139,147,150,151,154,157,[164,166],170],
"ke_":[129],
"kea":[122],
"ked":[1,2,10,12,15,16,20,26,[29,31],35,36,40,42,47,48,54,60,66,[70,72],74,75,81,85,[87,89],91,94,96,105,109,111,113,115,118,120,122,123,126,128,131,136,137,139,140,142,145,147,151,[158,160],162,[164,166],169,170,173],
"kee":[4,15,26,35,37,62,69,72,101,105,108,111,[113,115],[117,119],122,126,128,130,132,136,139,144,145,149,157,159,162,167,170,173],
"kel":[79,84,92,113,119,123,128,132,133,139,159,170,173],
"ken":[40,86,96,105,113,119,122,159,161],
"kep":[104,111,118,134],
"ker":[1,29,30,40,74,75,81,88,89,91,105,111,122,126,138,146],
"kes":[26,31,35,66,74,88,89,91,94,100,104,105,122,128,139,158,159,[161,164],170,171,173],
"ket":[94,105,122,160,161],
"kew":[5,22,30,31,59,73,94,95,100,113,115,118,144,150,159,160,162,163],
"kex":[48,74,91,119,123,124],
"key":[13,19,23,37,62,77,87,92,105,122,123,133,139,145,147,[159,162],173],
"kfl":[167],
"kfo":[105],
"kgr":[6],
"khb":[6,72],
"khd":[72],
"khi":[72],
"khq":[72],
"khw":[72],
"kia":[81,105,122],
"kib":[73],
"kil":[2,4,22,47,49,58,100,113,122,131,138,165,173],
"kim":[1],
"kin":[1,4,12,15,26,31,34,37,40,47,[56,58],67,69,71,72,76,81,85,88,89,91,[94,96],100,105,108,110,113,115,122,123,128,143,147,148,[157,160],162,[166,168],170,172,173],
"kip":[2,14,20,28,108,113,126,160,167,[171,173]],
"kir":[122],
"kis":[148,173],
"kla":[118,134],
"klb":[6,16,72],
"kld":[72],
"kle":[128],
"kli":[128],
"klm":[70],
"klo":[72,88,89,94,104,113],
"klq":[72],
"klw":[16,72],
"kly":[86,109,113,126,142,145,150,158,159],
"kmo":[88,89,139],
"kne":[31],
"kni":[94,95,100,103],
"knl":[94,96,100],
"kno":[1,2,10,30,48,62,64,74,78,81,84,86,87,[89,91],94,100,105,113,[117,120],122,[124,126],128,129,135,136,143,147,148,150,154,158,159,[161,164],166,167,171,173],
"knu":[100],
"kor":[138,173],
"kov":[43],
"kow":[1,28],
"kpd":[55],
"kps":[55],
"kre":[151],
"krz":[81],
"ks_":[72],
"kso":[95],
"kss":[72,92],
"kte":[116],
"kto":[100,122],
"ktr":[128],
"kud":[140,162],
"kup":[0,1,3,4,16,26,28,30,35,57,59,66,68,73,77,85,[88,91],93,94,101,104,113,118,126,133,134,147,158,159,172,173],
"kur":[1,89,113],
"kus":[6,30,66,[70,72],113],
"kwa":[35,143],
"kxb":[6,12],
"kyl":[1,48,59,70,74,88,89,91,92,96,100,108,111,113,115,117,119,123,124,130,139,143,147,148,150,151,154,158,159,[164,166],170],
"kz_":[94],
"l-a":[164],
"l-b":[32],
"l-d":[162],
"l-f":[75],
"l-k":[105],
"l-l":[101,122,124],
"l-n":[163],
"l-o":[1],
"l-s":[49],
"l-t":[6,167],
"l-w":[30,74,105,113,122,126,158,173],
"l-z":[118],
"l<t":[82],
"l<u":[82],
"l_a":[101],
"l_b":[101],
"l_d":[113],
"l_e":[131,135,137,140],
"l_o":[131,137,140],
"l_s":[113,139],
"l_w":[64],
"la2":[159],
"la3":[159],
"laa":[118],
"lab":[[1,4],10,22,26,28,31,35,39,40,44,45,48,50,52,54,55,[59,62],[66,71],74,77,78,[85,89],94,97,98,[100,103],[105,108],111,113,[115,121],123,124,126,127,[129,140],[142,145],147,149,150,[152,162],[164,166],169,170,173],
"lac":[3,4,10,16,19,22,40,60,63,69,74,81,82,85,88,89,91,92,94,95,97,100,104,105,113,115,116,122,124,126,128,131,134,137,138,140,148,150,152,154,158,161,164,168,170,172,173],
"lad":[133,147,159],
"lag":[4,17,18,21,30,46,48,61,63,74,75,86,88,92,106,110,116,[119,121],124,128,131,137,140,143,148],
"lai":[1,7,16,17,19,30,31,40,58,60,74,75,77,81,87,94,100,105,113,119,120,122,124,128,129,133,143,147,152,158,159,162,164,165,167,170,172,173],
"lak":[1,48,59,70,74,88,89,91,92,96,100,108,111,113,115,117,119,123,124,126,130,135,139,143,145,147,148,150,151,154,[157,159],[164,166],170,173],
"lam":[83,122,129,171],
"lan":[2,26,28,[30,34],54,64,72,79,[81,83],88,91,[94,96],100,102,103,105,[109,111],[113,122],124,126,128,131,134,135,137,138,140,141,143,144,[148,150],152,156,159,[162,164],167,[171,173]],
"lap":[31,35],
"lar":[[1,4],7,10,12,22,23,26,28,30,31,33,37,40,45,46,49,55,[58,60],62,66,70,[73,75],[77,82],84,85,[87,89],91,92,94,96,[100,105],[108,111],[113,115],[117,122],124,[126,128],[130,134],[136,139],[142,146],150,152,[158,162],[164,167],[169,173]],
"las":[1,5,6,10,14,21,26,27,33,35,40,49,51,54,58,70,75,81,84,[87,89],91,94,100,[103,105],110,111,[113,116],118,120,122,126,[128,130],134,[142,146],150,156,[158,160],162,167,170,173],
"lat":[[1,6],9,12,16,17,22,23,26,28,30,31,34,37,40,42,44,45,47,48,52,53,55,[59,62],[64,70],[73,76],78,81,84,85,[87,92],94,96,97,[100,107],111,113,[115,119],[121,126],128,130,131,[133,145],[147,150],152,154,[156,162],[164,173]],
"lau":[28,37,138],
"lav":[111,138],
"law":[120,151],
"lax":[113],
"lay":[1,12,26,37,44,45,48,55,66,74,75,78,86,88,89,91,94,99,104,105,113,115,122,126,134,138,144,145,154,158,162,167,170],
"lba":[69,77,113,129],
"lbe":[100],
"lbw":[6,16,72],
"lc0":[120],
"lca":[155],
"lcm":[155],
"lco":[104,105,120],
"lcu":[1,2,16,17,22,23,30,31,34,37,40,42,44,45,48,52,60,62,66,69,70,73,74,76,78,84,88,91,94,97,100,101,103,106,107,113,115,118,119,121,124,126,130,[133,136],139,141,142,148,150,154,158,[160,162],164,[166,168],170,171,173],
"ld!":[12],
"ld-":[120,166],
"ld1":[47],
"ld_":[88,128],
"ldc":[47],
"lde":[119,148,165,166],
"ldi":[37,45,60,81,85,88,89,92,94,100,113,118,122,126,138,141,157,158,162,167,169,170],
"ldl":[47],
"ldn":[7,30,42,77,87,89,94,120,126,128,172],
"ldo":[88,89,100],
"ldq":[70,72],
"ldr":[26,35,168,170],
"lds":[12,40,44,47,66,77,78,88,89,91,92,94,95,97,100,101,104,106,111,[113,115],117,119,122,124,126,128,130,132,134,135,139,142,144,[149,151],[158,162],164,166,167,173],
"ldv":[128],
"ldw":[122,128],
"ldz":[47],
"le-":[22,26,75,81,88,91,97,99,105,113,115,128,135,150,155,158,159,162,164,173],
"le9":[40],
"le_":[60,72,91,113,115,118,121,126,128,131,138,140,142],
"lea":[1,2,10,12,14,16,22,24,26,[29,31],39,40,[43,45],47,48,58,[60,62],66,69,70,[72,76],78,[80,94],97,99,100,[103,106],108,[112,115],117,118,122,123,[125,129],[131,135],137,140,141,[143,146],[148,150],152,[156,160],162,164,167,[170,173]],
"lec":[1,2,3,15,18,23,30,37,40,42,45,67,74,77,81,[87,89],91,92,94,100,104,105,108,111,113,117,118,122,123,125,126,129,133,135,141,146,147,158,159,162,166,171,173],
"led":[1,3,4,6,10,12,22,26,35,37,40,[46,50],54,58,62,63,[73,75],[80,82],84,[87,89],91,[93,97],100,[103,105],[109,111],[113,120],[122,124],126,128,130,131,133,135,137,139,143,146,147,149,[157,162],[164,167],170,173],
"lee":[109],
"lef":[4,5,10,20,30,40,44,58,59,66,69,[82,84],88,91,94,115,124,142,143,148,150,154,163,164,168,170,171],
"leg":[122,132,139,162,166],
"leh":[72],
"lel":[0,1,16,23,30,35,54,59,60,[66,68],72,78,85,[88,91],94,[99,101],113,118,119,136,139,149,158,159,162,166,167,172],
"lem":[[1,4],6,[10,14],[16,18],22,24,26,[28,30],34,35,37,[39,41],48,51,54,55,[58,61],64,66,[68,71],[74,77],80,81,[83,105],[107,109],111,113,[115,122],124,[126,134],[136,143],145,[147,152],154,[156,162],[164,173]],
"len":[2,5,6,12,14,19,22,27,30,35,40,54,59,60,69,75,81,84,88,89,94,100,104,105,107,113,117,118,126,128,130,133,139,145,148,[157,159],162,167,173],
"leo":[40],
"lep":[122],
"ler":[2,10,26,38,40,42,46,56,58,60,[63,65],75,78,[80,82],84,[90,92],94,95,100,102,104,108,[111,113],[116,122],124,[128,133],136,137,[139,141],[143,145],[147,150],153,154,[158,166],170,172,173],
"les":[[1,5],[7,10],13,14,16,17,[20,23],26,29,[31,33],37,40,42,[45,48],56,[58,64],66,68,70,71,74,75,78,79,[81,83],[85,91],[93,95],[100,103],105,109,111,[113,115],[117,122],[124,128],130,131,133,134,136,139,[144,150],153,154,[157,160],162,[164,167],170,173],
"let":[2,10,12,19,26,31,34,35,37,42,44,[47,50],54,56,58,60,62,68,69,74,76,82,[87,89],91,93,94,96,98,100,104,[108,110],[113,115],[117,120],122,126,129,133,135,137,138,140,[142,150],152,154,155,[157,162],167,170,172,173],
"leu":[136],
"lev":[1,4,19,37,40,59,63,81,88,91,94,97,102,104,115,128,130,132,133,138,142,149,150,152,155,156,159,161,162,166,168,173],
"lew":[91,104,122],
"lex":[2,26,31,39,42,54,62,74,77,81,94,95,100,105,108,113,122,124,126,128,130,133,143,154,155,[158,160],162,163,166,167,[171,173]],
"ley":[1,32,74,101],
"lf-":[162,163],
"lfp":[34],
"lfr":[88,89,94,104],
"lfw":[122],
"lge":[122],
"lgo":[0,1,2,4,6,10,12,14,16,18,[22,24],28,30,34,35,40,42,45,52,54,[59,62],66,[68,71],74,77,78,[85,97],100,101,104,108,111,113,115,[117,119],121,122,124,126,128,130,131,[133,140],[142,145],147,149,150,[153,157],[159,161],164,165,167,168,170,173],
"lgr":[128],
"lhu":[6,30,66],
"li-":[173],
"li_":[72,94],
"lia":[19,22,28,38,105,111,114,115,118,125,126,138,145,157,159,173],
"lib":[2,14,26,42,43,47,49,74,75,88,89,[94,96],100,104,105,108,109,114,117,127,128,131,132,134,137,140,147,157,158,162,171],
"lic":[2,6,10,[12,14],[28,31],34,37,44,55,[58,61],66,69,70,74,75,79,[81,84],86,88,89,91,94,99,100,105,113,115,118,119,[122,124],128,129,132,136,138,[142,145],148,150,151,154,157,158,[160,162],[164,167],173],
"lid":[26,39,43,48,51,67,69,79,81,82,[89,91],94,102,104,112,113,118,119,122,129,136,144,147,[157,159],161,162,173],
"lie":[1,3,5,6,9,10,12,26,28,34,40,43,48,66,69,71,74,78,81,84,86,88,89,91,94,98,102,104,105,113,124,126,128,134,140,142,144,149,[158,160],162,164,167,173],
"lif":[31,69,81,85,87,88,91,105,113,115,122,135,145,152,159,173],
"lig":[1,22,26,30,31,35,72,73,81,88,89,94,97,100,101,111,113,118,122,127,129,138,145,147,158,162,164,[171,173]],
"lik":[2,5,17,22,27,[30,32],35,37,46,48,59,73,[79,81],[83,85],88,89,91,92,94,95,100,105,108,109,[112,119],122,123,126,128,[132,135],138,139,[142,150],[158,164],[167,170],172,173],
"lim":[10,14,24,26,30,31,37,39,40,64,70,81,84,85,[88,91],100,101,104,108,113,118,119,122,128,134,147,149,150,158,159,162,166,172,173],
"lin":[[0,4],6,10,12,14,16,[20,22],24,26,28,30,31,34,35,40,[47,49],51,52,54,57,58,62,[70,73],77,[80,82],85,[87,89],91,92,[94,96],100,104,108,110,111,113,115,117,[119,122],124,[126,128],130,132,134,135,137,139,142,143,145,147,148,152,[154,168],[170,173]],
"lio":[31,40],
"lip":[87,128],
"lis":[1,10,12,16,20,26,28,31,35,40,47,59,72,73,80,84,87,88,91,94,98,100,104,105,108,109,113,122,128,131,138,139,146,150,158,159,162,163,166,167,[170,173]],
"lit":[2,12,14,19,22,26,31,35,40,48,54,58,60,66,70,77,81,82,85,[88,91],[93,96],[100,102],104,105,108,109,113,118,122,126,128,131,135,137,138,142,144,145,147,158,159,161,162,167,170,173],
"liv":[37,105,122,128,167,168],
"liz":[2,6,10,26,37,40,44,45,48,59,70,81,84,88,91,94,100,101,105,108,113,115,[118,122],124,126,128,134,136,139,145,148,150,154,158,[160,162],164,165,[171,173]],
"lju":[161],
"lk!":[105],
"lke":[105],
"lks":[81,105,122,132],
"ll-":[6,32,49,75,105,124,162,167],
"ll_":[64,131,137,140],
"lla":[47,113,125,129,136,160,167],
"llb":[69,77,113,129],
"lld":[72,88,89,100],
"lle":[0,1,4,6,10,12,16,22,23,26,30,35,37,38,40,48,49,54,[58,60],62,[66,68],[73,75],78,[80,82],84,85,[87,91],[93,95],97,[99,101],104,105,108,111,[113,120],[122,124],128,[130,133],[135,137],139,140,143,144,146,147,149,[157,162],[164,167],170,172,173],
"lli":[19,31,34,35,40,72,73,81,88,89,91,94,100,104,105,126,128,130,132,139,159,161,162,165],
"llo":[[1,4],6,10,12,14,16,19,[21,24],26,28,[30,32],34,35,37,38,40,42,44,46,[48,51],53,54,59,[64,66],68,70,[73,75],77,[80,82],[84,86],[88,92],94,95,[97,101],105,106,109,111,113,115,[117,119],122,126,128,[130,137],139,[141,145],[148,152],154,[156,162],[164,167],170,171,173],
"llp":[105],
"lls":[2,22,29,54,94,100,113,122,127,128,131,132,137,140,143,157,158,162,165,166],
"llu":[66,119,144,158],
"llv":[91,124,163,173],
"llw":[30],
"lly":[1,4,10,12,14,26,27,[29,32],35,37,40,46,[57,59],61,64,66,75,78,[80,82],[84,86],88,89,[91,97],[100,102],104,105,107,109,111,[113,128],[130,134],[136,141],[144,153],[157,160],162,164,[166,173]],
"lma":[162],
"lme":[85,126],
"lmn":[70],
"lmo":[4,12,47,77,100,104,105,113,115,119,122,123,127,133,137,139,141,143,146,154,156,158,162,164,170,172,173],
"lmu":[162],
"lnu":[161],
"lo_":[72],
"loa":[2,3,6,[10,12],19,22,24,31,35,37,39,44,45,47,48,54,58,60,62,70,73,81,[85,88],91,94,95,100,104,105,108,109,111,113,115,118,119,[122,127],[129,131],133,137,139,142,[145,147],150,151,154,[158,160],[162,165],167,170,171],
"lob":[2,7,26,81,113,124,134,162],
"loc":[2,3,9,14,26,[35,37],47,50,[53,55],57,62,76,77,81,82,84,86,88,91,92,96,100,101,[103,105],110,113,115,119,122,124,126,128,132,133,139,141,147,150,[157,159],167,170,173],
"lod":[47,163],
"log":[1,26,30,42,52,74,75,78,84,86,88,89,94,100,104,105,115,119,122,128,134,146,149,150,161,162,164,166,167,171,173],
"loi":[68,80,96,135,150,166],
"lom":[88,89,94,104],
"lon":[2,3,18,30,31,40,57,59,66,78,81,82,94,97,100,102,113,118,120,127,128,139,147,151,158,161,164,167,173],
"loo":[[0,4],16,26,28,30,32,34,35,37,42,[45,48],54,58,59,61,66,68,73,74,76,77,[80,82],84,85,[88,91],[93,96],[98,101],104,105,108,109,[111,114],[117,124],126,128,130,133,134,137,139,140,142,143,146,147,[155,160],162,164,166,[171,173]],
"lop":[10,30,96,104,105,122,128,132,167],
"lor":[12,87,111,115,122,131,167],
"los":[40,60,82,113,128,137,145,160,164,167],
"lot":[12,31,37,40,81,105,120,122,128,147,158,167],
"lou":[122],
"lov":[105,122],
"low":[[1,4],6,10,12,14,16,19,[21,24],26,28,[30,32],34,35,[37,40],[42,44],[46,52],54,55,58,59,[62,78],[80,82],[84,102],[104,109],111,113,[115,119],121,122,124,[126,139],[141,152],[154,167],[170,173]],
"loy":[74,[88,90],96,116,122,164],
"lpe":[128,157,159,162],
"lpf":[128,167],
"lph":[3,6,12,26,105,161],
"lpr":[96,125,130],
"lps":[35,81,88],
"lqd":[72],
"lre":[26,34,40,42,47,48,60,88,89,91,96,100,105,108,109,113,122,140,143,[158,160],167,168,171,173],
"lsa":[171],
"lsb":[18],
"lse":[2,5,20,29,31,42,52,75,81,87,111,118,132,158,162],
"lsi":[126],
"lso":[1,2,6,14,[20,23],26,30,32,35,40,42,[48,51],[54,56],[59,62],64,69,70,[74,76],78,80,81,85,86,88,89,91,92,[94,96],98,100,102,[104,106],111,113,[115,119],121,122,124,126,128,[131,136],[138,141],143,144,148,154,155,[157,167],170,171,173],
"lsr":[106],
"lst":[161],
"lsx":[171],
"lt-":[2,69,110],
"lt_":[48,117],
"ltd":[47],
"lte":[29,31,37,45,109,116,118,125,132,133,143,144,148,152,[158,161],163,166,[171,173]],
"lth":[40,72,74,85,88,91,94,100,105,[113,115],119,122,[126,128],142,150,158,162,167,170,173],
"lti":[1,6,9,12,22,26,28,30,34,35,40,48,55,59,60,66,69,70,74,81,82,84,[86,89],91,94,101,105,113,119,121,122,124,128,132,[134,137],139,142,144,147,148,154,[157,159],[162,166],173],
"ltm":[105],
"lto":[28],
"lts":[[0,4],6,10,12,14,19,22,26,30,31,35,39,40,47,54,[59,62],66,70,71,[77,79],84,85,88,89,91,[93,95],100,101,103,104,107,113,115,118,119,121,123,124,128,130,131,134,136,137,139,140,144,147,151,154,[157,160],162,164,165,167,171,173],
"lty":[35,100,147,162],
"lua":[23,32,34,74,79,81,82,88,91,94,108,113,115,117,118,120,121,126,127,130,136,141,149,151,154,160,161,173],
"lub":[105],
"luc":[28,35,100,131,138,171],
"lud":[2,4,30,39,40,55,76,84,85,88,94,100,101,105,112,113,[117,119],128,133,135,140,158,159,161,162,173],
"lue":[[0,3],6,8,9,10,12,14,17,20,21,23,26,[28,30],37,[39,41],[44,46],48,52,55,59,60,62,64,[67,70],[72,74],76,78,80,81,83,84,[86,92],94,99,100,[103,105],[107,109],112,113,115,[117,120],[124,126],128,130,131,133,134,136,138,139,[141,144],[147,151],153,154,[156,164],166,[168,171],173],
"lug":[122],
"luh":[12,30,88],
"lui":[163],
"lum":[5,31,37,74,89,109,113,118,173],
"lun":[30,122],
"luo":[89],
"lur":[122,128],
"lus":[12,26,37,47,48,62,63,68,75,81,88,89,94,100,105,108,109,113,[119,121],124,126,130,132,136,139,144,148,158,159,162,164,167,168,173],
"lut":[1,2,8,11,12,17,23,24,26,30,31,37,40,46,52,66,73,76,77,80,81,84,85,[88,92],94,98,100,102,103,105,[107,109],[111,113],119,122,[124,128],130,134,143,[147,150],152,156,[158,162],164,166,167,[171,173]],
"lv_":[91,94],
"lva":[128],
"lve":[16,17,32,35,81,86,89,91,92,94,100,101,105,109,111,113,115,118,119,122,124,126,128,133,136,143,148,149,160,162,167,173],
"lvi":[133,147,160],
"lvm":[124,163,173],
"lvw":[91],
"lwa":[10,22,35,40,41,48,66,75,77,80,87,89,91,94,100,105,108,113,118,122,126,131,134,142,148,154,158,159,162,167,173],
"lwb":[16],
"lwd":[72],
"ly!":[122],
"ly-":[89,91,113,120,122,162,173],
"ly_":[131,140,166],
"lyg":[34],
"lyi":[26,84,105,113,162,164],
"lys":[35,94,113,126,128,150,155,157,158,173],
"lyz":[31,54,81,139],
"lzc":[99,150,152,156,160],
"m-b":[161],
"m-d":[122],
"m-p":[163],
"m-s":[126],
"m-t":[166],
"m04":[134],
"m12":[88,120,163],
"m15":[134],
"m16":[115],
"m20":[163],
"m25":[72,88,111,119,124,130,138,139],
"m26":[134],
"m2b":[113,134],
"m2i":[72,115],
"m37":[134],
"m51":[74,91,94,97,113,115,117,126,135,136,138,139],
"m54":[1,6,30,70,88,89,100,108],
"m_1":[42],
"m_2":[42],
"m_3":[42],
"m_a":[94,111,131,137,138,140],
"m_b":[89,117],
"m_c":[82,94,109,113,128,138],
"m_e":[115,131,137,140],
"m_h":[113],
"m_i":[114,115,131,137,140],
"m_m":[89,113,126],
"m_n":[131,137,140],
"m_p":[82,111,113,117],
"m_s":[88,113,115,118,120,126,138],
"mab":[105,162,173],
"mac":[6,12,26,35,41,46,49,57,81,84,85,89,91,92,94,100,119,124,[126,128],130,154,157,158,162,[164,166],170],
"mad":[12,31,70,83,88,89,100,105,113,122,124,139,144,158,161,162,167],
"mag":[3,4,6,12,23,59,69,76,81,84,96,105,118,120,122,142,159,162],
"mai":[3,24,[26,28],30,31,36,37,40,54,59,62,70,74,77,84,88,91,92,100,101,104,111,113,[117,119],124,130,[133,135],137,139,140,142,146,147,[154,156],[158,160],162,164,167,173],
"maj":[72,81,88,94,100,113,128,136,144,147,154,159,162,173],
"mak":[1,2,26,42,54,56,66,69,75,81,88,89,91,94,95,100,104,105,108,109,113,114,[118,120],128,129,131,135,136,139,[158,162],164,167,[170,173]],
"mal":[1,4,10,26,28,30,31,34,35,38,40,44,45,48,[58,63],66,[68,71],73,77,78,81,[84,86],88,89,92,94,100,105,108,113,118,119,122,126,128,130,132,133,136,[140,144],146,147,[150,152],154,[158,162],164,167,170,172,173],
"man":[1,2,4,6,10,14,22,26,29,31,37,38,40,43,47,49,[57,61],67,68,72,79,81,84,85,87,88,91,92,[94,96],100,101,[103,105],109,111,113,115,117,119,120,122,123,[125,130],133,137,139,147,[149,151],[158,162],164,165,167,169,170,172,173],
"map":[19,26,80,81,88,89,92,94,100,113,118,133,138,158,159,161,162,167],
"mar":[0,1,19,26,[29,31],36,37,40,47,48,54,62,66,74,77,84,85,87,89,91,94,100,101,104,105,113,115,118,119,122,124,126,128,130,134,137,140,142,143,145,147,148,154,[157,161],[164,167],170,173],
"mas":[2,16,18,23,28,40,45,48,51,55,[59,61],[66,69],71,73,[75,77],85,[87,89],[91,95],[99,101],104,111,113,[115,119],124,126,130,[133,135],[137,139],[143,145],[149,151],[156,160],162,164,166,[169,171],173],
"mat":[2,14,28,34,36,37,39,40,48,75,81,86,89,91,92,94,100,104,105,108,109,113,115,118,[120,122],124,126,128,130,131,133,135,138,145,147,150,154,[157,159],161,164,165,167,169,173],
"mav":[116,131,137],
"max":[1,2,5,6,12,19,22,29,31,35,40,44,46,52,66,78,84,90,107,113,119,126,132,134,136,139,142,150,154,155,158,159,162,166,168,170,173],
"may":[23,26,31,40,42,48,54,59,60,74,81,84,86,91,93,95,96,100,105,108,113,120,128,134,135,138,145,[147,152],155,[157,162],166,167,[171,173]],
"maz":[122,128,131,146],
"mb2":[99],
"mbd":[129],
"mbe":[[0,4],8,[10,12],21,23,24,[27,31],34,37,[39,42],44,45,47,48,52,53,55,[58,62],[65,71],77,78,81,[83,86],[88,95],97,98,100,102,103,[105,111],113,115,118,119,[121,126],[128,130],132,133,135,136,138,139,[141,148],[150,156],[158,167],[169,171],173],
"mbi":[3,22,40,60,85,88,94,113,122,128,[134,136],149,158,159,162,173],
"mbl":[2,46,47,55,58,74,91,92,96,104,106,109,115,116,[119,121],124,129,130,133,138,139,148,150,151,157,159,160,[162,164],169],
"mbo":[40],
"mbr":[128],
"mbu":[127],
"mch":[131,140],
"mcm":[2,100,159],
"md-":[2,54,76,77,88,100,133,136,142,144,158,164,170],
"md5":[74],
"mdi":[118,119,124,130,131,133,139],
"mdu":[[171,173]],
"me!":[105],
"me-":[75,133,159],
"mea":[0,1,2,4,30,31,37,48,54,62,64,81,88,89,94,95,97,99,100,105,107,108,111,113,114,[117,119],[121,123],126,128,130,131,[133,135],[142,145],158,160,162,164,167,172,173],
"meb":[84,105,146,162],
"mec":[128],
"med":[2,3,14,22,24,26,30,31,42,44,54,55,59,60,68,73,75,77,78,81,85,86,[88,91],94,100,104,105,108,111,113,115,[118,120],122,124,126,128,130,131,135,136,[143,147],149,150,157,160,162,163,171],
"mee":[100,155],
"meg":[81,113,128],
"meh":[76,105,122,142,159],
"mek":[31,117],
"mel":[100,122,167],
"mem":[2,3,4,19,22,24,[26,30],35,47,53,54,58,66,73,77,81,[84,90],94,95,100,104,105,[110,113],[120,123],126,128,129,131,132,137,140,145,148,150,154,155,159,160,162,163,[170,173]],
"men":[[0,4],6,[9,14],16,17,[22,24],26,[28,31],35,37,39,40,42,[46,48],50,[53,55],[58,62],[64,81],[83,92],[94,102],104,105,[107,109],111,113,[115,124],[126,143],145,[147,152],154,[157,167],[169,171],173],
"mep":[73],
"mer":[1,9,26,30,31,35,38,42,48,50,54,59,60,63,66,68,70,74,75,77,79,81,82,84,85,88,89,[93,97],100,101,104,105,[107,109],[112,115],118,119,122,126,130,136,137,139,144,153,[158,162],164,166,173],
"mes":[0,1,3,4,6,12,19,22,26,[29,31],[33,37],40,47,49,54,62,63,73,[79,81],85,86,88,89,91,94,100,101,104,108,109,111,113,115,117,119,121,122,[124,130],134,136,139,[145,147],149,152,155,[157,164],167,[171,173]],
"met":[0,1,4,10,16,18,19,21,23,26,27,[29,32],34,35,37,40,42,44,47,54,56,59,63,64,66,70,74,76,78,[80,92],[94,96],100,101,104,105,[107,110],113,114,118,119,122,124,125,[127,129],139,142,146,[148,150],[152,154],[156,159],161,162,164,[166,173]],
"mew":[28],
"mfe":[47],
"mho":[81],
"mi-":[126],
"mi1":[106],
"mi2":[[59,61],[66,68],85,88,89,91,126,131,137,145,166,173],
"mia":[66,136],
"mib":[85,[87,89],113],
"mic":[26,40,78,81,105,113,118,119,122,123,125,126,131,140,157,162],
"mid":[22,29,62,81],
"mig":[59,74,84,91,94,100,102,105,108,109,112,113,[117,119],121,122,126,[128,130],[132,136],142,[147,151],160,162,173],
"mil":[1,2,3,10,23,26,30,31,37,38,40,49,55,59,70,74,84,85,91,94,96,101,102,104,105,108,109,113,115,118,[120,122],126,128,138,143,144,150,158,159,161,162,166,167,171,173],
"min":[[1,5],13,14,19,21,28,30,31,34,35,37,40,45,48,51,54,59,60,62,63,65,66,75,81,82,84,85,[87,90],94,100,101,103,105,108,109,111,113,115,[117,119],121,122,124,[126,128],[130,133],135,136,139,141,143,144,[147,151],153,154,156,158,159,161,162,164,166,167,169,170,172,173],
"mio":[105],
"mip":[171],
"mir":[1,40,89,91,94,100,113,119,124,126,134,142],
"mis":[2,18,26,31,58,59,73,74,79,[81,84],94,100,105,109,110,113,118,122,126,128,[131,133],135,136,139,140,146,147,161,162,173],
"mit":[1,10,12,24,26,30,31,37,39,40,64,70,74,81,85,88,90,91,94,100,101,104,105,108,109,113,116,118,119,122,123,128,131,133,134,140,143,[147,150],154,158,[161,163],166,172,173],
"mix":[122,171],
"miz":[1,2,3,12,30,35,37,40,54,78,81,85,91,[102,105],113,116,121,131,133,140,143,148,159,160,172,173],
"mi":[81,122],
"mle":[83,113],
"mly":[75,104,172],
"mm0":[5,6],
"mm1":[2,42,163],
"mm2":[42,72,88,111,119,124,130,138,139,163],
"mm5":[74,91,94,97,113,115,117,126,135,136,138,139],
"mm8":[74,135],
"mm_":[42,88,89,94,111,113,115,117,118,120,126,138],
"mma":[0,19,26,31,37,40,[47,49],54,62,77,82,84,85,87,91,105,113,115,119,122,125,128,134,137,140,147,157,159,161,[164,166],173],
"mme":[9,14,42,48,50,63,73,74,78,79,81,82,84,89,90,94,100,104,105,109,113,115,118,122,126,130,137,150,158,159,[162,166],170,171,173],
"mmi":[40,94,100,101,109,122,124,128,136,159,161,162],
"mmo":[2,7,14,34,40,43,69,85,104,105,109,126,128,131,139,147,153,155,[158,160],162,164,172,173],
"mmp":[150],
"mmu":[36,104,128],
"mmx":[4,16],
"mmy":[7,14],
"mna":[102],
"mne":[47,171],
"mno":[70],
"mns":[118,173],
"mob":[105,126],
"mod":[2,3,14,22,26,30,42,47,48,54,59,62,66,75,77,78,81,82,85,87,88,91,94,100,103,104,108,118,122,125,126,128,132,139,142,145,147,[157,162],164,167,170,171,173],
"mol":[105],
"mom":[2,6,29,94,109,162,173],
"mon":[2,7,14,30,31,34,37,40,43,47,69,75,81,84,85,94,104,105,109,122,126,128,131,139,147,153,155,[158,160],164,172,173],
"moo":[31,100],
"moq":[88],
"mor":[1,3,4,7,19,[22,24],26,28,30,31,35,37,40,47,48,50,54,58,59,61,62,66,73,74,77,79,81,[84,91],94,95,98,100,102,104,105,[109,113],115,[119,124],126,128,[131,133],[139,141],143,145,147,[150,152],155,[157,160],[162,164],166,167,[170,173]],
"mos":[1,2,4,10,12,18,26,31,34,35,39,40,47,55,59,60,64,72,74,76,77,81,84,86,87,91,94,99,100,104,105,113,115,118,119,[121,125],127,128,[131,133],135,137,139,141,143,[145,147],[149,151],154,[156,159],162,164,166,[170,173]],
"mot":[38,57,122],
"mou":[10,16,26,30,32,37,40,44,54,55,78,81,84,88,91,97,113,122,139,159,172,173],
"mov":[3,6,12,16,20,22,26,30,35,39,40,47,55,59,69,71,[73,76],81,84,88,89,91,92,94,99,101,111,113,115,116,119,[122,124],126,128,131,137,139,140,142,144,148,150,155,157,[160,162],167,168,170,173],
"mp1":[55],
"mp_":[117],
"mpa":[0,1,2,4,5,12,26,30,31,35,39,40,44,45,48,52,54,[58,62],69,71,[76,78],81,84,85,[87,90],92,[94,96],[100,105],108,109,111,113,[116,119],122,124,126,127,130,131,133,[136,144],[147,149],151,154,[156,159],162,164,166,170,171,173],
"mpb":[47],
"mpd":[72,117],
"mpe":[2,3,16,35,59,100,[112,114],119,123,126,128,138,139,149,164,166,167],
"mpg":[60,94,113,117],
"mph":[28,147,159],
"mpi":[1,3,4,6,10,12,21,30,42,46,50,56,58,59,[63,65],75,[80,82],84,88,90,91,94,95,97,100,[102,105],110,111,113,[115,121],124,126,[128,131],133,135,137,[139,141],143,145,147,148,150,154,158,159,[161,166],170,171,173],
"mpl":[[1,7],[9,17],19,20,[22,24],[26,33],[35,52],[54,71],[74,102],[104,108],[111,124],[126,135],[137,147],149,150,[152,167],[169,173]],
"mpn":[116],
"mpo":[1,3,4,6,7,12,22,24,26,29,30,39,40,47,48,55,60,81,84,86,88,89,94,100,104,105,109,111,113,120,122,126,128,131,132,135,136,160,162,163,166,170,173],
"mpp":[47],
"mpr":[[0,4],6,14,26,31,40,58,62,66,69,81,[84,89],91,94,99,100,102,104,105,113,115,126,128,145,158,162,166,167,[171,173]],
"mps":[2,47,54,72,73,91,96,100,104,133,141,143,148,150],
"mpt":[34,40,91,94,100,108,113,117,128,150,155,158,161,167],
"mpu":[1,19,22,56,62,66,77,100,113,121,127,128,[134,136],150,[158,160],164,166,170,173],
"mpw":[47],
"mpx":[55,100],
"ms!":[167],
"ms_":[31],
"msb":[10,11,18,40,59,64,91,94,100,143,157,162],
"mse":[131,137,140],
"msg":[42],
"msi":[162],
"msk":[35,55,92,116,126],
"mso":[162],
"mss":[120],
"mst":[108],
"msv":[128,131,137,140,141],
"msy":[109],
"mtf":[35],
"mti":[125],
"muc":[1,4,22,26,30,31,40,58,61,64,68,81,85,89,91,94,100,105,115,119,122,127,128,130,139,158,160,162,163,173],
"mul":[2,6,9,12,22,26,28,30,34,35,37,40,47,48,55,[59,61],66,69,70,78,81,82,84,86,[88,91],94,101,105,113,115,119,121,122,124,[130,132],[134,137],[139,142],144,148,154,[157,160],[162,165],173],
"mum":[4,12,30,31,40,44,52,78,81,84,85,[88,90],94,100,108,113,115,117,119,124,127,130,134,136,139,141,142,144,148,153,155,158,159,162,166,168,170,173],
"mun":[104,128],
"mus":[2,12,27,44,58,59,66,76,86,89,93,94,96,100,104,108,113,115,118,124,126,130,131,135,136],
"mut":[16,36,42,72,91,94,105,110,111,113,115,126,156,159,160,162,171,173],
"mu":[[0,173]],
"mv7":[100,104],
"mv8":[100,104],
"mw2":[99],
"mxc":[48],
"my-":[14],
"myr":[163],
"mys":[94],
"n*3":[173],
"n*m":[54],
"n*s":[162],
"n-1":[159],
"n-a":[94,126,160,162,173],
"n-b":[59,89,104,159],
"n-c":[113,133,135,160],
"n-d":[37,113,137,144,162],
"n-e":[35,80,91,113,117,128,163,171],
"n-g":[31],
"n-h":[144],
"n-k":[2,54,100],
"n-l":[88,115,163,168],
"n-m":[169],
"n-n":[26,89,118,136],
"n-o":[31,120],
"n-p":[22,120,126],
"n-r":[162,165,170,171,173],
"n-s":[113,128,159,167,173],
"n-t":[81,93,97,105,113,142],
"n-u":[80,119],
"n-v":[144],
"n-z":[51,65,89,100,103,116,118,133,134,139,149,151,152,156,157,169,171],
"n00":[104],
"n36":[75],
"n64":[104],
"n_a":[1,119],
"n_b":[58],
"n_e":[37,117,139,173],
"n_f":[150],
"n_m":[113],
"n_p":[1,113,139],
"n_r":[113],
"n_t":[128],
"nab":[48,86,105,109,121,124,128,141,143,158,159],
"nac":[53,100,105,122,162,173],
"nae":[105],
"nag":[40,81,122],
"nai":[3,4,12,34,35,[59,61],64,66,[68,70],78,80,[84,86],88,89,91,92,94,104,108,113,118,119,121,124,126,128,130,134,139,143,151,158,173],
"nal":[[1,4],6,10,12,14,16,19,20,22,[26,28],[30,32],35,37,40,46,48,50,51,54,59,60,[62,64],66,69,70,[72,78],[80,82],84,[87,89],91,92,94,[96,98],100,104,105,107,[109,111],[113,118],120,[122,128],[130,134],[136,141],143,144,[147,150],[152,155],[157,162],164,166,167,[169,173]],
"nam":[1,26,33,38,40,47,60,81,100,104,110,115,122,126,128,139,[159,162],170,173],
"nan":[10,102,150,162],
"nap":[130],
"nar":[15,19,[22,24],26,28,31,32,35,37,40,42,44,47,59,61,62,67,72,74,76,77,84,86,88,89,94,100,104,108,113,115,117,124,126,128,[132,134],144,[148,150],153,154,158,160,162,164,166,[169,171],173],
"nas":[26,82,110,123],
"nat":[[1,4],10,12,14,22,29,34,37,40,44,51,60,65,66,68,70,73,[82,84],[87,89],94,97,98,100,104,106,109,111,113,115,116,118,120,122,[127,133],135,136,[138,140],143,[152,154],[158,166],168,170,171,173],
"nav":[85,100,147,159],
"naw":[105],
"nbe":[19,31,35,119],
"nbo":[173],
"nc_":[131,137,140],
"nca":[10,14,42,81,97,128,159,162,164,165],
"nce":[[1,6],14,16,22,23,[26,29],31,34,35,37,39,40,42,44,46,47,52,56,[58,60],64,67,69,70,74,81,82,84,85,[87,92],[94,96],[98,101],[103,105],107,108,110,111,[113,115],[117,122],[124,130],[132,136],139,140,[142,145],[147,151],[154,167],[169,173]],
"nch":[1,8,10,17,20,23,26,30,32,57,60,61,63,68,75,81,87,88,101,103,105,113,115,119,122,124,126,128,133,141,[143,147],154,157,158,160,161,164,165,170,171,173],
"nci":[4,89,100,104,122,128,139,148,150,154],
"ncl":[2,4,12,26,30,39,55,62,63,[74,76],81,84,85,88,89,94,100,101,105,108,109,112,113,117,[119,121],124,126,128,130,132,133,135,136,139,140,148,158,159,161,162,173],
"ncm":[2],
"nco":[14,38,40,42,47,61,67,80,84,85,[87,91],94,104,105,113,118,122,126,128,130,145,150,158,159,[161,164],167,[171,173]],
"ncr":[1,9,29,35,40,42,46,84,89,94,96,113,116,120,124,126,131,137,140,152,159,160,170],
"nct":[1,2,3,5,16,19,22,24,[26,28],30,31,35,38,41,43,47,[51,55],58,60,62,63,74,76,77,80,83,88,89,95,100,104,105,[108,111],113,[117,122],124,[126,129],132,133,135,138,140,141,143,147,154,[156,159],162,164,170,173],
"ncu":[105],
"ncy":[[1,4],9,28,35,38,40,47,60,61,74,85,88,89,94,100,105,113,118,119,122,130,139,150,154,[158,160],164,167],
"nd-":[40,94,113,117,121,128,141,143,158,159,162,164,171,173],
"nd2":[10],
"nd_":[6,66,128,131,137,140,143],
"nda":[0,2,26,27,43,48,53,57,74,77,81,86,88,89,91,94,100,104,108,109,113,114,117,118,120,122,128,134,160,162,169,170,173],
"ndb":[24,47,145],
"ndc":[113],
"nde":[[1,4],6,10,12,14,16,19,23,26,31,33,35,37,40,[47,51],58,[60,62],66,71,73,74,77,79,81,82,84,85,87,88,[90,92],94,95,100,101,104,105,110,113,115,[117,120],122,124,126,129,[131,133],135,143,148,154,157,[159,164],[166,168],170,171,173],
"ndi":[2,6,10,12,16,20,[22,24],26,31,32,34,37,40,42,47,48,54,59,60,[62,65],71,74,76,81,[84,86],88,89,91,94,95,97,100,101,[103,105],113,[115,119],122,124,126,128,133,134,138,[141,145],[148,150],152,[155,162],164,166,168,[170,173]],
"ndl":[2,22,43,47,54,58,66,74,88,89,91,96,97,100,106,109,[112,115],118,[126,128],130,132,140,145,147,[158,160],162,170,172,173],
"ndn":[88,89,118,143],
"ndo":[31,35,37,40,48,75,94,100,108,122,126,128,132,140,147,159,160,170,172],
"ndp":[164],
"ndr":[47,58,81,122],
"nds":[1,10,22,24,26,[30,32],38,[40,42],48,77,78,[85,87],90,94,96,100,113,119,122,124,125,127,128,131,133,136,139,142,[144,146],[157,162],164,166,167,170,171],
"ndt":[161],
"ndv":[89,117],
"ndy":[100,129,167,172,173],
"ne-":[81,88,89,91,100,113,122,123,143,159],
"ne_":[131,135,137,140],
"nea":[12,26,35,49,62,73,77,78,81,89,[94,96],105,108,115,126,[132,134],148,154,159],
"nec":[24,30,31,105,113,118,128,158],
"ned":[1,3,5,6,[10,12],14,22,27,[30,32],35,37,40,41,43,44,46,52,59,62,[68,70],73,75,76,[79,92],94,[100,102],105,107,109,111,[113,115],[117,122],124,125,128,130,[132,135],137,139,[142,148],150,152,156,[158,168],170,171,173],
"nee":[[0,4],6,10,12,14,16,20,23,24,26,30,31,39,40,45,46,52,54,57,59,60,67,69,73,74,77,80,85,86,88,89,91,94,97,[100,102],104,105,107,109,113,115,118,119,122,[124,129],[132,134],[137,139],[142,145],[147,150],[153,155],[158,160],[162,167],[170,173]],
"nef":[84,94,118,119,121,136,158,170],
"neg":[2,11,14,16,23,44,45,47,48,64,81,85,[87,89],98,107,113,118,124,[126,129],131,[135,137],140,143,149,150,152,154,[156,158],162,164,166,171,173],
"neh":[164],
"nei":[119,135],
"nel":[3,81,149,159,162,167,172,173],
"nem":[47,81,83,105,122],
"nen":[3,4,6,10,12,29,30,44,45,62,81,136,153,154],
"neo":[48,74,100,104,112,128,138,162,164],
"neq":[12,108,116,135,150,166],
"ner":[1,2,3,10,18,23,26,30,31,37,40,42,46,53,55,60,65,66,73,74,79,87,89,91,100,102,104,105,111,113,115,116,[118,122],124,126,127,129,133,135,[138,141],[147,150],158,159,162,164,166,170,171,173],
"nes":[1,12,23,26,30,31,34,35,41,46,51,56,58,59,67,[72,74],76,77,[80,82],[84,89],91,92,94,98,100,101,105,109,111,113,115,118,119,121,122,124,[126,128],130,[133,135],[138,140],142,143,147,149,150,152,[155,166],[170,173]],
"net":[2,30,31,105,158,167,171],
"nev":[6,11,12,26,31,41,42,46,47,55,60,81,83,84,89,91,94,100,107,108,110,113,114,120,125,128,134,142,144,146,149,158,162,166,167,172,173],
"new":[0,1,12,22,26,40,42,50,[59,61],[66,68],75,76,81,85,88,89,91,94,96,97,100,104,105,109,111,113,114,117,122,124,126,131,132,134,[137,140],142,143,146,159,160,162,165,167,170],
"nex":[2,24,26,34,35,80,88,91,94,97,101,108,111,113,114,122,126,128,134,142,145,149,150,152,154,156,[158,160],164,173],
"ney":[122],
"nfa":[100],
"nfe":[81,105,122],
"nfi":[34,46,75,81,112,120,150,162],
"nfl":[99,123,160],
"nfo":[1,2,10,26,28,48,51,62,65,66,73,74,88,91,94,98,100,104,105,109,111,113,116,122,123,130,132,135,136,[138,140],143,145,147,150,159,165,173],
"nfr":[109,128],
"nfu":[81,122],
"ng-":[10,48,86,97,109,124,128,146,159,162,164,165,171],
"ng<":[53],
"ng>":[19],
"ng_":[101,105,109,147],
"nga":[87,113,171],
"ngd":[118,135,144],
"nge":[1,2,[5,8],10,12,20,26,28,[30,32],34,37,39,40,45,47,53,57,59,60,62,70,[74,77],79,81,82,[86,91],[93,95],97,100,105,108,111,[113,115],118,119,122,[124,128],130,132,133,[135,137],139,142,144,146,147,150,[158,160],[162,164],[171,173]],
"ngi":[31,37,38,74,81,87,100,121,128,140,159,162,[171,173]],
"ngl":[[0,4],12,19,22,26,28,30,31,35,40,45,49,54,55,59,60,64,66,[68,70],[73,75],77,78,[80,82],84,[86,89],91,92,94,95,97,100,104,105,108,111,[113,115],[117,119],122,124,126,128,130,133,134,136,142,144,145,147,149,150,153,154,[157,167],[170,173]],
"ngo":[128],
"ngr":[31,111,118],
"ngs":[1,2,10,14,17,26,31,37,40,48,56,60,[69,71],75,81,84,[87,89],94,100,101,105,109,113,[118,120],122,128,131,133,135,147,148,151,154,159,161,162,167,168,[170,173]],
"ngt":[2,14,19,35,40,75,81,100,105,113,126,145,[157,159],162,173],
"ngu":[2,26,28,32,33,79,[81,83],88,89,100,105,109,114,120,122,128,159,162,167,173],
"nha":[1,2,100],
"nia":[164],
"nib":[1,40,60,66,68,71,89,[100,102],118,134,142,144,145,149,150],
"nic":[40,47,63,68,81,88,91,104,105,112,114,119,121,122,126,128,136,137,139,162,164,167,[169,173]],
"nid":[40],
"nie":[1,31,40,89,91,94,100,109,113,119,122,124,126,134,142],
"nif":[1,10,26,40,44,48,49,55,60,62,74,76,81,85,[87,89],91,94,108,113,118,124,[126,128],143,145,149,150,152,154,[157,160],164,173],
"nig":[37,81,94,95,100,103],
"nil":[24,128,167],
"nim":[[1,4],28,30,31,35,37,40,47,54,62,81,85,88,89,94,100,103,108,113,115,117,119,121,124,128,130,139,141,144,147,148,153,159,162,166,170,173],
"nin":[2,4,14,19,21,26,28,31,34,37,45,48,54,56,59,60,62,[65,67],[75,77],80,81,84,87,88,94,100,101,108,111,113,122,128,135,139,144,147,150,152,158,160,162,164,166,170,171],
"nio":[81,82,87,99,114,118],
"nip":[0,47,[59,61],67,68,85,88,91,100,113,144,151,158,159,166],
"niq":[28,30,40,77,80,[88,90],94,96,97,99,100,104,105,113,115,118,122,126,128,131,137,140,146,[157,160],162,164,170,173],
"nis":[81,100,128,143,146,160,162],
"nit":[24,28,30,31,34,37,46,56,69,74,75,77,81,88,89,91,94,96,100,104,105,112,113,115,117,119,120,122,[126,128],132,[137,139],[141,143],149,150,152,156,160,161,170,171],
"niv":[2,81,118,157],
"niz":[26,57,81,88,105,109,121,122],
"nje":[128],
"njo":[105,122,167],
"nk0":[111],
"nk1":[111],
"nk_":[93],
"nke":[20,26,70,91,94,159],
"nki":[12,76],
"nkn":[48,100,125,158,163],
"nko":[1],
"nks":[1,12,26,29,35,55,70,77,78,80,81,84,85,[87,89],91,93,94,100,[104,106],108,110,111,[113,115],118,119,122,124,128,133,134,145,147,150,158,164,172],
"nla":[124,130],
"nle":[62,136],
"nli":[28,80,81,84,85,91,92,94,100,113,115,132,135,139,143,145,158,159,[162,164],[171,173]],
"nlo":[2,19,24,31,37,54,74,110,146,147,149,150,166],
"nlu":[30],
"nly":[2,7,10,20,26,[29,31],40,[43,45],48,54,56,59,61,62,65,66,70,74,77,81,[84,89],[91,94],97,100,102,104,105,111,113,115,[118,120],122,124,128,130,131,[133,140],[142,144],[146,149],[151,154],[157,164],166,167,[170,173]],
"nma":[48,100,162],
"nme":[26,30,81,105,128,162,164],
"nnb":[173],
"nne":[1,3,23,31,69,81,89,91,100,105,119,121,124,128,162,164,166,168,170],
"nni":[2,4,19,31,37,60,62,81,100,109,113,128,139,144,150,164,166,170,171],
"nno":[30,42,84,91,96,99,124,126,130,131,142,147,148,150,154,158,162,164,165,168,170,173],
"nns":[105],
"nny":[33,81,105,114,122],
"no-":[113,119,120,133],
"nob":[75,128,131,132],
"noc":[84],
"nod":[24,26,28,29,35,128,132,155,168,170],
"nof":[171],
"noi":[56,122],
"nok":[81,105,122],
"nol":[122],
"nom":[136,153],
"non":[23,26,31,51,55,62,65,80,89,91,94,100,103,105,111,113,[116,120],122,124,126,128,130,131,[133,137],139,140,142,144,[149,152],154,156,157,160,162,164,[169,171],173],
"nop":[47,70],
"nor":[10,17,30,31,34,40,44,45,48,59,69,81,84,88,89,91,105,113,119,122,128,130,137,142,143,146,154,161,162,164,167,172,173],
"nos":[162,167],
"not":[[1,4],6,10,12,14,17,19,20,[22,24],26,28,[30,32],34,35,37,39,40,42,43,47,48,50,51,55,59,60,[62,66],[68,72],[74,77],[79,97],[99,101],[104,113],[115,120],[122,140],[142,145],[147,160],[162,173]],
"nou":[42,100,122,125,158,163,173],
"nov":[99,105,122,159,161],
"now":[1,2,10,12,14,26,30,31,37,38,48,54,55,58,60,62,64,68,69,74,76,78,[80,84],86,87,[89,92],94,100,104,105,108,111,113,[117,120],122,[124,126],128,129,131,[134,136],139,142,143,[147,150],152,154,[156,164],166,167,170,171,173],
"npa":[72,88,91,94],
"npc":[6,12,16,72],
"npi":[128],
"npo":[13,53],
"npr":[113,160,170],
"npu":[1,21,23,26,30,35,56,58,64,66,67,69,71,74,77,84,85,[87,91],94,95,[100,102],104,106,109,111,113,115,118,119,124,126,128,130,131,[133,137],[142,145],147,149,150,155,[157,162],164,170,172,173],
"nr_":[72,94,97,111,138],
"nre":[105,128,148,166],
"nrl":[1],
"nro":[1,4,6,22,35,88,91,94,95,100,111,113,115,117,119,124,126,130,139,158,164,165],
"ns!":[59],
"nsa":[2,3,32,100,105,119,126],
"nsb":[115],
"nsc":[158],
"nse":[13,19,26,35,40,43,58,65,73,81,88,95,108,113,115,122,128,129,140,148,158,159,161,162,170],
"nsf":[3,22,23,37,47,[88,90],94,104,108,113,115,126,131,133,135,137,140,144,150,158,159,164,166,173],
"nsh":[161],
"nsi":[1,2,4,5,10,12,22,24,27,[30,32],34,35,37,38,40,42,44,46,48,52,55,59,60,62,63,66,[68,70],[72,75],[80,82],84,85,88,89,91,94,95,97,100,102,[104,107],[113,116],[118,120],122,124,126,[128,133],135,[137,140],[142,144],[148,150],152,154,156,[158,160],[162,166],[170,173]],
"nsl":[12,26,28,68,85,[87,89],91,92,94,96,102,104,113,115,117,118,123,133,136,139,143,147,[158,161]],
"nso":[31,75,105,122,128],
"nsp":[16,96,105,117,128,135,139,159,162],
"nsr":[3,88],
"nst":[[0,7],[10,13],16,17,[20,23],26,[29,31],[33,35],37,39,40,42,[44,47],50,51,[54,56],[58,62],[64,68],[70,74],[76,78],[80,82],[85,97],[99,108],110,111,[113,128],[130,140],[142,145],[148,152],[154,173]],
"nsu":[26,75,105,113,121,122,126,128,145,150],
"nsw":[26,87,88,102,105,109,113,136,137,152],
"nt!":[58],
"nt-":[130,166,167,170],
"nt1":[37,55,101,119,124,158,162],
"nt2":[37,101],
"nt3":[11,46,54,101,108,113,119,124,131,142,156],
"nt5":[10],
"nt6":[46,59,149,154],
"nt8":[1,26,104,119,124,131,158,162,165],
"nt_":[113,120,131,137,140],
"nta":[[1,4],6,[10,14],16,17,22,24,26,30,31,34,35,37,39,40,46,47,49,50,54,55,[59,62],64,[66,71],74,77,80,81,[83,89],[91,98],100,101,104,105,107,108,[111,113],115,[117,122],124,[126,128],[130,134],[136,140],142,144,145,147,149,150,[152,154],[156,173]],
"ntd":[99,149,150,152,156],
"nte":[[0,6],9,10,12,16,21,22,26,[28,35],[37,48],52,54,55,[58,62],[65,67],[69,97],[99,101],104,105,[107,145],[147,155],[157,168],[170,173]],
"ntf":[30,36,86],
"ntg":[30],
"nth":[37,47,75,94,110,132,163],
"nti":[0,1,[9,11],14,18,20,22,23,26,28,30,31,35,39,40,54,[59,62],66,73,75,[77,79],81,[84,86],[88,91],94,95,99,100,105,113,119,122,[124,128],130,[133,136],139,141,144,147,149,152,[154,162],166,167,[169,171],173],
"ntl":[1,32,35,40,42,47,57,59,60,75,81,84,94,100,104,108,111,113,114,122,124,[126,128],131,136,139,143,148,152,154,[158,162],167,171,173],
"nto":[2,3,19,22,35,47,48,70,73,[88,92],94,96,97,[99,102],104,105,108,[111,115],[117,119],[122,124],[126,128],130,131,133,[136,139],[142,145],[147,152],154,[156,160],[162,164],[166,171],173],
"ntq":[99,149],
"ntr":[[1,6],12,14,15,24,26,28,30,31,[34,37],40,47,48,61,62,66,[68,78],81,[85,91],94,95,97,[99,101],104,105,108,109,111,[113,122],124,[126,140],[142,145],147,[149,162],[164,167],[170,173]],
"nts":[[0,4],6,7,11,12,15,26,30,31,34,35,37,38,40,42,48,[53,55],[58,62],[65,67],[69,78],81,[84,97],[99,102],104,105,108,111,113,[115,122],124,[126,141],[143,150],152,154,[157,168],[170,173]],
"ntu":[81,84,88,89,91,96,100,114,119,122,124,126,130,139,147,158,159],
"nty":[81,167],
"nu-":[163],
"nua":[1,18,43,57,85,113,126,128,137,146,147,160,164],
"nub":[5,139],
"nue":[88,91,100,113,126,144],
"nui":[128],
"nul":[26,97,128,129,167],
"num":[[0,4],8,[10,12],17,21,23,[28,31],34,[37,42],44,45,47,48,52,55,[58,62],[65,71],77,78,81,[83,86],[88,95],97,98,100,102,103,[105,108],[111,113],115,118,119,[121,128],130,132,133,135,136,138,139,[141,147],[150,156],[158,166],[169,171],173],
"nun":[122],
"nuo":[26,73,75,91,94,133,160,166],
"nup":[75],
"nus":[13,40,60,109,162,164,173],
"nut":[81,82,100,122,171],
"nuw":[5],
"nux":[[0,3],6,14,30,40,47,57,81,122,127,128,163],
"nv_":[135],
"nva":[26,30,48,79,[89,91],94,104,112,113,117,122,144,162,170,173],
"nve":[0,2,4,6,10,11,22,23,28,30,34,[39,41],44,48,[59,61],[66,72],75,79,[81,83],[85,87],91,92,99,102,109,113,118,119,124,126,130,133,135,138,[142,145],[149,151],153,154,[156,158],164,167,[169,173]],
"nvi":[30,81,105,122,128],
"nvo":[1,12,17,30,32,35,73,88,89,91,92,94,101,104,109,113,115,118,120,122,124,128,129,131,[133,136],149,152,155,166,170,173],
"nvq":[135],
"ny_":[58,131,137,140],
"nyi":[101],
"nyt":[34,43,110,127,128,133,158,162,164,167,172,173],
"nyw":[111,119,164],
"nze":[51],
"o-8":[87],
"o-b":[157,158],
"o-c":[128,159,162],
"o-d":[113],
"o-e":[1,3,143],
"o-f":[26,35,104],
"o-g":[115,173],
"o-i":[64,163],
"o-l":[88],
"o-m":[133],
"o-o":[88,91,119,123,143],
"o-r":[75,168],
"o-s":[113,124],
"o-t":[120,150,158],
"o-v":[121,131],
"o-w":[28],
"o_b":[54,157],
"o_e":[72],
"o_h":[60],
"o_l":[87],
"o_v":[147],
"oa3":[30],
"oa6":[30],
"oab":[115,128,171],
"oac":[4,10,12,16,23,26,31,32,34,36,59,60,69,73,76,80,81,[86,88],94,100,104,108,111,113,115,[117,119],122,124,128,131,133,139,143,144,147,151,152,155,[157,161],164,166,167,170,173],
"oad":[2,3,6,12,19,22,24,31,35,37,48,54,[58,60],70,73,77,81,85,87,88,91,94,95,99,100,104,105,108,111,113,115,118,119,[122,124],126,127,[129,131],133,135,[137,139],142,[145,147],[149,151],[158,160],[162,164],167,170,171],
"oal":[85,100,117,123,139,149,158,159,162],
"oas":[31],
"oat":[10,11,39,44,45,47,48,62,81,86,95,105,109,125,131,150,154,162,164,165,171],
"oba":[6,26,37,81,84,124,129,134,162,167],
"obb":[7,105,162],
"obe":[86,113,126,138,157,162],
"obi":[105,159],
"obj":[[25,27],31,47,[79,81],122,[127,129],132,154,159,167],
"obl":[3,14,17,18,26,29,31,34,37,41,48,51,59,69,[75,77],80,81,83,84,[86,89],[91,94],96,98,100,102,103,105,109,113,116,118,120,122,126,[128,130],132,136,138,139,141,143,[147,150],152,154,156,[158,160],162,168,169,172,173],
"obo":[75,128,131,132],
"obs":[1,2,3,26,47,49,54,60,68,81,84,87,88,94,118,123,127,134,135,144,152,154,157,159,160,170,173],
"obt":[6,14,26,30,31,48,62,81,86,101,113,119,124,126,128,129,133,142,144,145,150,159,173],
"obv":[12,24,30,35,73,75,77,81,82,84,85,88,89,94,100,103,108,113,116,117,121,122,126,128,130,139,143,145,147,149,150,152,156,158,161,162,165,167,172,173],
"oby":[2,113,126],
"oc_":[26],
"oca":[2,3,14,26,28,30,35,36,[53,55],57,74,76,77,81,84,86,88,89,91,96,100,101,[103,105],109,110,113,115,118,119,122,124,128,[131,135],139,149,150,152,155,[157,159],164,165,170,173],
"occ":[2,26,37,40,44,48,49,66,76,84,89,100,113,126,130,142,156,157,159,160],
"oce":[[1,4],6,12,18,22,24,26,[29,31],34,35,37,38,40,47,54,59,60,62,64,66,[69,71],74,76,78,81,[84,89],91,92,94,96,97,100,101,103,104,106,111,113,115,117,[119,121],124,126,128,130,131,[133,140],143,145,147,149,150,[156,160],162,[164,167],170,172,173],
"ocf":[81],
"och":[125],
"oci":[40,89,90,94,110,112,118,122,132,159],
"ock":[2,9,35,37,47,50,62,82,85,92,100,104,105,110,113,115,126,132,133,141,147,157,159,167,173],
"oco":[1,26,28,31,34,[59,61],73,76,[90,92],94,128,135,138,159,166],
"oct":[66,91,148,158],
"ocu":[39,40,50,54,74,87,94,119,128,149,150,157,160,162,167,171],
"ocz":[2],
"oc":[81,105,122],
"oda":[88,89,94,96,162],
"odb":[105,120,131,137,140],
"odd":[12,35,60,70,88,113,135,138,147,158,162,167,171,173],
"ode":[[0,3],5,6,8,10,12,14,16,[20,24],[26,32],34,35,40,42,43,[46,48],50,54,55,[58,71],73,74,[76,78],[80,82],[84,86],[88,92],[94,96],98,[100,108],[110,113],[115,122],124,[126,145],[147,173]],
"odi":[2,3,14,22,26,40,42,47,54,59,62,66,75,77,78,81,85,[87,91],94,100,104,105,108,118,125,126,130,139,142,145,147,[158,162],170,173],
"odr":[105],
"ods":[0,1,4,10,27,31,32,35,40,47,66,70,74,81,85,86,88,89,94,100,101,113,118,120,124,[127,129],150,158,159,161,169],
"odu":[[1,6],10,12,24,26,30,31,34,35,37,40,48,[59,62],64,66,[68,71],[73,78],81,82,[85,92],94,95,97,[99,101],104,105,[108,111],[113,122],[124,145],147,[149,167],[170,173]],
"ody":[31,75,84,105,122,128,131,132,146,162],
"oea":[100],
"oed":[89,113,118],
"oef":[136,148],
"oes":[0,1,10,15,30,[33,35],37,42,45,47,59,66,69,73,76,81,85,86,88,89,91,94,96,[99,101],104,105,108,[110,116],118,119,122,124,126,[128,131],133,135,136,138,139,142,144,148,149,154,155,159,162,[164,167],169,170,173],
"of-":[40,100,128,164],
"of_":[53,65,131,137,140,142,157],
"ofe":[167],
"off":[2,14,37,40,74,81,85,88,89,94,100,105,118,122,127,128,133,135,144,[162,164],167,171,173],
"ofi":[102,105,108,120,170],
"ofs":[5],
"oft":[1,31,61,70,75,84,87,97,105,113,121,122,126,127,131,140,150,159,162,166,167],
"oga":[26,78],
"ogd":[74,150,166],
"oge":[1,14,55,69,78,101,113,115,119,124,142,144,149],
"ogg":[86,171,173],
"ogi":[42,74,88,94,100,104,115,119,128,134,149,150,162,164,171,173],
"ogl":[40,145,167],
"ogn":[109],
"ogq":[74],
"ogr":[[0,4],6,9,10,12,19,22,26,30,32,35,39,40,[42,45],[48,50],52,54,[59,63],66,74,75,79,81,82,[84,89],[92,95],97,[99,106],109,113,[115,117],120,122,[126,128],130,[132,134],137,140,146,147,149,150,[158,162],[164,167],171],
"ogs":[75,146,167],
"ogy":[122,128],
"ohn":[84,100,164],
"oia":[56],
"oic":[31,58,66,88,111,162],
"oid":[1,37,81,85,94,100,105,121,124,139,143,148,159,160,162,164,166,173],
"oil":[122],
"oin":[1,3,10,12,14,24,26,30,31,34,37,39,[43,45],48,59,62,[69,71],73,77,81,[84,86],[88,91],94,95,[99,101],105,109,111,113,118,120,122,124,126,[128,134],140,[142,145],148,150,151,[154,158],[160,162],164,165,167,[170,173]],
"ois":[104,122,124,127,135,150,166],
"oit":[68,80,96],
"ojc":[[0,173]],
"oje":[31,34,35,110,117,122,128,157,[162,164],167,173],
"oke":[1,12,30,73,96,101,113,115,120,122,126,129,134,166,170],
"oki":[37,81,100,105,108,122,128,157,159],
"oks":[31,32,37,84,89,105,113,123,128,142,146,147,162],
"oku":[0,1,3,4,16,26,28,30,35,59,66,68,73,77,85,[88,91],93,94,101,104,113,118,126,133,134,147,158,159,172,173],
"ol-":[163],
"ola":[12,31,55,59,60,62,65,66,74,81,89,91,100,104,105,111,122,126,134,144,164,166,169],
"old":[12,16,22,31,35,39,40,50,58,59,61,62,66,70,77,78,89,96,108,109,[113,117],119,120,122,[126,128],130,131,134,140,142,146,[148,150],152,158,159,161,162,[164,167],170,173],
"ole":[2,3,16,29,31,34,40,47,48,54,62,72,74,75,[80,82],88,90,94,95,100,[103,105],111,113,115,118,119,122,[125,129],134,138,142,144,146,147,150,162,167,171,173],
"olf":[105],
"oli":[10,16,26,31,87,105,122,162],
"oll":[[1,4],6,10,12,14,19,[21,24],26,28,[30,32],35,37,38,40,42,44,46,48,49,51,54,59,[64,66],68,70,[73,75],77,[80,82],[84,86],[88,91],94,95,[97,101],105,106,108,111,[113,115],[117,119],[122,124],126,128,130,131,133,134,136,137,139,[141,146],[148,152],154,[156,162],[164,167],170,171,173],
"olm":[126],
"olo":[12,87,115,122,128],
"ols":[26,40,48,57,81,105,122,132,171],
"olt":[105,120,131,137,140],
"olu":[1,2,5,8,11,12,17,23,24,26,31,37,40,46,52,66,73,74,76,77,80,81,84,85,88,89,91,92,94,98,100,102,103,105,[107,109],[111,113],118,119,122,[124,128],130,134,143,[147,150],152,156,[158,162],164,166,167,[171,173]],
"olv":[17,32,35,81,86,89,91,92,94,100,105,109,122,126,128,133,136,143,[147,149],160,162,167],
"oly":[34],
"om-":[122,126],
"om_":[109,131,137,140],
"oma":[24,28,51,75,100,109,128,131,137,158,167],
"omb":[3,22,40,60,85,88,94,113,122,128,[134,136],149,158,159,162,173],
"ome":[1,2,3,6,[14,16],19,[22,24],26,[28,31],34,35,37,40,42,46,48,49,56,59,60,63,[72,76],81,[83,89],91,94,96,100,102,104,105,108,109,113,114,[117,122],[124,129],133,135,136,[139,144],146,148,150,152,[156,164],[166,168],[170,173]],
"omi":[2,35,37,60,74,91,94,100,104,105,111,122,123,131,132,135,136,140,148,153,161,162,173],
"oml":[75,172],
"omm":[2,7,14,34,37,40,43,49,69,81,82,84,85,89,90,104,105,109,113,115,118,122,125,126,128,131,139,147,153,155,[158,162],[164,166],170,172,173],
"omo":[38],
"omp":[[0,7],10,12,14,19,21,22,26,[29,31],35,37,39,40,42,[44,48],50,52,54,56,[58,66],69,71,[74,78],[80,82],84,85,[87,92],[94,97],[99,105],[108,111],113,[115,122],124,[126,131],[133,145],[147,151],[154,167],[170,173]],
"omy":[1],
"on!":[128],
"on-":[26,31,37,51,59,65,80,88,89,91,94,100,[103,105],113,[116,120],126,128,[133,136],139,142,144,149,151,152,156,157,160,162,165,[168,171],173],
"on2":[104,113],
"on6":[104],
"on_":[113],
"ona":[1,2,3,6,15,16,19,20,26,28,[30,32],35,37,40,46,50,51,54,[62,64],66,72,74,76,77,81,82,84,[86,89],91,94,98,100,105,109,113,[116,118],120,122,128,134,137,140,141,143,148,152,154,[157,162],164,166,167,[171,173]],
"onc":[2,12,14,23,26,29,35,37,40,47,56,60,62,63,69,75,81,82,84,85,89,91,94,97,100,105,108,109,113,[118,122],124,126,128,130,132,135,136,139,142,144,147,148,[157,160],162,164,173],
"ond":[1,2,5,10,14,18,20,24,31,32,40,47,48,60,61,[63,66],69,71,76,77,81,82,84,88,89,92,94,96,97,[100,102],104,105,111,[113,117],119,122,[124,126],128,130,131,[133,135],141,[143,146],148,150,[157,162],164,166,168,[170,173]],
"one":[[1,4],6,[10,12],16,18,19,[21,23],26,[28,35],37,40,44,45,[47,49],51,54,55,57,[59,62],64,66,67,[69,71],[73,77],[81,85],[87,92],94,95,[97,102],[104,109],[111,119],[121,124],126,[128,131],[133,145],[147,150],[152,167],[169,173]],
"onf":[75,81,99,105,120,122,123,160,162],
"ong":[2,3,14,30,31,40,74,75,78,81,82,84,[86,89],91,94,96,97,100,102,105,113,116,[118,120],127,128,139,147,151,157,158,161,164,167,171,173],
"oni":[40,47,57,59,81,146],
"onl":[2,7,10,20,26,[28,31],40,[43,45],48,54,56,59,61,62,65,66,70,74,77,81,[84,89],[91,94],97,100,102,104,105,111,113,115,[118,120],122,124,128,130,131,[133,140],[142,144],[146,149],[151,154],[157,164],166,167,[170,173]],
"onm":[30,81,128],
"onn":[23,31,105,128,164],
"ons":[[0,7],10,12,16,17,[20,24],[26,28],[30,35],37,38,[40,42],[44,48],[50,56],[58,64],[66,97],[99,102],104,105,[107,111],[113,124],[126,140],[142,145],[147,173]],
"ont":[[0,4],6,10,12,14,16,18,22,23,26,30,31,34,35,37,40,[47,49],54,[59,62],66,67,[69,71],[73,78],80,81,[85,96],100,101,104,105,108,111,113,[115,119],121,122,124,[126,128],[130,140],[143,145],147,149,150,[152,155],[157,168],[170,173]],
"onu":[122],
"onv":[0,2,4,6,10,11,22,23,28,30,34,39,41,44,48,[59,61],[66,72],79,[81,83],[85,87],91,92,99,102,105,109,113,118,119,122,124,126,130,133,138,[142,145],[149,151],153,154,[156,158],164,167,[169,173]],
"onz":[51],
"ood":[4,12,23,30,40,47,56,63,66,77,80,81,84,86,89,96,100,109,122,125,127,142,147,[158,160],162,167,173],
"oof":[5,55,69,119,128,142],
"oog":[40,145,167],
"ook":[0,1,3,4,16,24,26,28,[30,32],35,37,47,58,59,61,66,68,73,76,77,81,82,84,85,[88,91],93,94,96,98,100,101,104,105,108,109,112,113,[118,120],122,123,126,128,133,134,142,143,146,147,[156,160],162,172,173],
"ool":[26,29,31,57,74,80,81,105,113,122,125,132,151,160,[162,164],167,171],
"oom":[2,40,81,145],
"oon":[31,68,122,171],
"oop":[1,2,3,35,42,46,48,54,58,74,80,84,89,91,94,95,99,100,111,113,114,117,119,121,124,126,130,134,137,139,140,143,155,158,160,162,164,166,173],
"oor":[1,45,59,100,109,148,159,168],
"oos":[23,31,34,77,81,82,85,[87,89],100,105,113,118,119,122,127,144,147,158,162,173],
"oot":[2,24,48,81,105,120,128,131,132,140,150,152,154,155,168,170],
"op-":[101,119,122],
"op_":[53,101,170],
"opa":[23,76,94,122,142],
"opc":[1,3,47,99,101,105,130,134,135,139,149,150,152,158,[161,163]],
"ope":[1,2,3,5,6,10,12,16,19,23,24,26,27,30,31,34,37,40,[42,45],47,48,55,59,60,62,64,66,[68,70],[72,74],77,78,[80,82],[84,86],[88,91],[94,96],100,101,[104,108],[111,119],121,123,124,126,[128,132],135,136,[138,140],142,144,147,150,151,153,[158,160],162,[164,167],[169,171],173],
"opf":[147],
"oph":[26,159,173],
"opi":[14,81,82,84,87,99,111,[113,115],122,126,128,132,143,159,160,162,172],
"opl":[1,81,105,114,122,126,128,167],
"opm":[122,128],
"opo":[75,77,81,104,108,109,111,113,115,122,124,126,139,160,166,173],
"opp":[29,[87,89],115,122,137,147,166],
"opr":[103,113,117,128,133,142],
"ops":[1,42,74,80,91,94,99,100,113,119,123,124,128,134,150,155,162,171],
"opt":[1,2,3,6,10,12,30,31,35,40,78,81,82,85,91,92,94,100,102,104,105,109,113,116,118,120,121,126,128,130,131,133,136,140,143,148,[158,161],[164,166],172,173],
"opu":[1,6,16,30,37,52,59,64,74,78,100,101,113,115,128,130,134,135,137,138,145,146,149,150,152,156,162,169,171],
"opy":[14,18,64,91,100,[113,115],122,125,126,128,131,135,137,140,147,158,164,166,171,173],
"oqs":[88],
"or!":[162],
"or-":[81,138,151,164,166,170,171],
"or<":[108],
"or>":[53],
"or_":[139],
"ora":[7,26,32,50,75,88,104,111,128,132,160,173],
"orb":[30,47],
"orc":[26,48,62,88,89,94,97,100,105,114,116,122,125,128,140,142,150,162,173],
"ord":[[1,6],10,12,15,16,18,19,[22,24],26,28,30,31,35,37,40,42,44,47,49,51,52,54,55,[58,60],64,[66,72],74,75,77,78,81,84,85,[87,91],93,94,96,97,100,101,[103,105],108,111,113,115,116,119,122,124,126,128,130,[132,135],139,[141,145],147,[149,152],[157,162],164,[166,173]],
"ore":[[0,4],6,7,9,10,12,14,15,19,[22,24],[26,31],34,[37,40],44,47,48,50,54,55,[58,62],66,69,70,72,[74,81],[84,91],94,95,[98,102],104,105,[108,111],113,[115,122],124,126,[128,134],[136,145],147,151,152,154,[157,167],[170,173]],
"orf":[122],
"org":[19,26,81,83,88,105,[120,122],128,131,137,151,162,173],
"ori":[0,1,2,4,6,10,12,14,16,18,[22,24],26,28,30,31,34,35,37,40,42,45,52,54,[59,62],66,[68,71],74,75,77,78,[84,97],100,101,104,105,108,111,113,115,[117,119],121,122,124,126,128,130,131,[133,140],[142,145],[147,150],[153,162],[164,168],[170,173]],
"ork":[2,3,6,7,10,16,26,29,31,33,37,45,[57,60],67,70,75,81,88,89,91,94,95,97,99,100,104,105,110,111,113,115,[117,120],122,124,126,128,129,132,138,142,144,146,147,149,150,152,[158,160],162,164,166,167,170,171,173],
"orl":[23,31,47,74,75,90,105,112,122,126,128,136,140,158,162,173],
"orm":[[1,4],6,10,12,14,16,[22,24],28,30,31,[34,37],39,40,44,45,48,50,54,55,58,59,62,[65,70],73,75,77,78,81,86,[88,92],[94,98],[100,105],108,109,111,[113,120],[122,124],[126,131],133,[135,140],[142,152],154,[157,162],[164,167],[169,173]],
"orn":[79],
"orp":[161],
"orr":[6,10,23,29,30,56,60,66,71,84,86,88,89,91,[94,97],100,104,105,110,112,[117,119],122,124,126,128,134,140,144,145,[159,162],168,170],
"ors":[1,2,4,6,14,18,22,26,[30,32],34,35,39,40,42,44,48,54,62,73,75,81,82,[84,86],[88,91],94,96,97,[99,101],104,108,109,[111,122],124,[126,128],130,132,[134,136],144,146,153,155,159,160,162,164,167,170,171,173],
"ort":[1,2,3,10,[12,14],16,18,22,23,[26,28],30,31,34,35,[37,40],44,[46,48],50,51,55,60,63,65,66,[68,70],[72,75],77,81,82,84,86,88,89,91,92,[94,96],98,100,102,[104,109],111,113,115,116,[118,120],122,123,[125,132],[135,140],143,147,148,[150,152],[157,167],[170,173]],
"oru":[10],
"orw":[1,4,28,35,40,60,94,101,115,119,122,128,139,143,144,150,152,157,159,162,164,170,172,173],
"ory":[[1,4],19,22,26,28,30,31,35,38,43,47,54,57,58,66,73,77,81,[84,96],100,101,104,105,[110,115],[120,123],125,126,128,132,145,150,155,157,160,162,163,167,[170,173]],
"os!":[84],
"os-":[146],
"osa":[75,122],
"osd":[140],
"ose":[15,16,20,23,31,34,40,60,67,69,75,77,81,82,88,89,94,96,100,104,105,109,111,[113,115],118,[124,129],133,134,136,137,139,144,145,147,149,152,153,[158,160],162,170,171,173],
"osg":[31],
"osi":[1,2,3,10,12,16,[21,23],31,34,35,37,40,44,45,47,49,54,55,57,59,60,64,66,69,77,84,85,[87,89],[91,101],103,104,111,113,115,119,124,[126,128],[133,136],142,145,150,153,154,[156,164],166,167,169,170],
"oso":[131,140],
"osp":[134],
"oss":[2,3,6,12,14,16,20,23,24,26,[29,31],34,37,40,48,51,[54,56],60,66,70,78,81,82,[84,89],91,92,94,97,100,102,104,105,109,[111,113],115,[118,120],125,126,128,129,131,132,135,137,[139,142],144,[146,149],154,[158,164],166,170,171,173],
"ost":[1,2,4,6,10,12,15,18,26,30,31,[34,41],47,55,[57,60],64,[72,74],76,77,81,82,[84,89],91,94,99,100,104,105,[111,113],115,118,119,[121,125],[127,133],135,137,139,[141,143],[145,147],[149,151],154,[156,160],162,164,166,167,[170,173]],
"osu":[13],
"osz":[81,122],
"ot-":[81,92,119,158,159,171],
"ot_":[45],
"ota":[12,16,26,40,47,69,76,81,88,89,94,96,105,113,115,122,132,134,135,138,[144,147],150,155,158,162,172,173],
"otb":[16],
"otc":[122],
"ote":[1,2,6,10,12,14,22,23,26,30,31,38,40,46,55,57,59,60,66,68,70,74,76,79,83,[87,89],91,92,94,97,99,100,104,106,108,110,113,115,[117,119],123,124,[126,128],130,131,[133,139],[143,149],153,[156,160],162,164,166,168,173],
"oth":[[0,5],10,12,16,19,23,24,26,[30,32],34,37,40,42,47,60,62,66,[68,71],[74,77],[81,92],94,95,97,98,100,101,104,105,[107,113],115,116,118,119,[122,128],130,[132,136],138,139,[141,145],[147,151],[155,160],[162,164],167,168,[170,173]],
"oti":[1,6,12,14,48,75,82,94,99,108,122,125,126,131,140,155,164,171],
"oto":[2,12,40,50,84,159],
"otp":[81,128,132],
"otr":[30,73,81],
"ots":[55,118,120,122,158],
"ott":[26,30,70,74,84,94,120,122],
"oty":[122],
"ou!":[94,100,111,113],
"oub":[3,10,37,39,45,83,91,93,95,104,113,119,128,131,134,159,162,164,167,170,171],
"ouc":[94,108,113,145,159],
"oud":[122],
"oug":[2,3,23,34,40,46,54,[59,61],72,74,76,79,81,85,88,89,91,94,100,104,105,108,[113,115],119,122,[125,130],142,147,150,[157,159],162,163,167,170,173],
"oul":[1,2,6,7,[10,12],16,23,26,[28,32],37,[40,44],47,50,51,[54,56],[58,61],64,66,[68,70],[73,75],77,[80,82],[84,94],96,99,100,102,105,107,[109,114],117,119,120,122,126,128,[130,134],136,[141,143],145,147,152,[156,162],[164,167],170,172,173],
"oun":[1,3,4,6,9,10,12,14,16,19,26,[29,31],[35,38],[40,42],44,[46,49],54,55,60,74,77,78,80,81,84,86,88,89,91,94,95,97,[99,101],105,108,110,111,113,114,118,119,122,124,[126,128],[130,132],134,[136,140],142,[144,150],[152,154],[156,162],164,[166,168],[170,173]],
"oup":[19,30,40,47,59,72,88,89,94,109,[145,147],158,162,168,172,173],
"our":[1,3,6,12,22,29,30,34,35,37,39,40,42,43,46,48,51,55,57,62,66,67,74,75,77,78,[81,86],[88,91],[93,95],97,98,[100,105],107,108,110,111,[113,122],124,[126,128],[130,134],[136,162],[164,167],[169,171],173],
"ous":[1,2,4,12,14,18,24,26,29,30,32,34,35,40,48,54,59,66,73,75,77,79,81,82,84,85,88,89,91,92,94,95,100,102,103,105,108,112,113,116,117,[119,124],126,128,130,133,136,139,143,[145,147],149,150,152,156,[158,162],[164,168],172,173],
"out":[1,2,3,6,9,10,12,14,16,22,24,26,28,[30,33],[35,40],[43,45],47,48,50,51,[53,56],59,63,66,69,71,74,75,77,78,81,[83,86],[88,91],94,100,104,105,[108,111],113,[115,122],[124,126],128,130,131,134,135,[138,140],[142,145],[147,149],154,[157,160],[162,164],166,167,169,170,172,173],
"ova":[22,99],
"ovb":[47,113],
"ovc":[20],
"ovd":[3,73,89,99,123,139],
"ove":[[0,4],6,12,16,20,23,26,30,32,[35,40],43,44,47,48,50,51,55,[58,63],66,69,71,[74,76],78,81,[83,89],[91,95],[99,102],104,105,108,109,111,[113,119],122,124,[126,134],136,137,139,140,[142,146],[148,152],155,[157,164],[166,168],170,171,173],
"ovh":[88],
"ovi":[26,30,35,48,59,84,88,91,100,104,105,115,117,119,122,124,126,128,132,134,139,144,150,155,[160,162],164,170,171],
"ovl":[47],
"ovm":[35,55,92,113,116,126],
"ovo":[81,126],
"ovq":[47,88,139],
"ovr":[128],
"ovs":[47,59,113,124],
"ovu":[22],
"ovw":[47],
"ovz":[6,12,47,119],
"ow!":[105],
"ow-":[49,63,159,165],
"ow_":[118],
"owa":[26,28,118,126],
"owd":[48,49,96,170],
"owe":[[1,4],6,10,12,14,16,21,22,26,[30,32],34,35,37,40,[49,52],54,55,[58,62],[64,68],70,71,[73,77],[81,91],[94,96],98,[100,102],[104,106],108,110,113,[115,119],122,124,126,[128,134],[136,139],[141,144],[147,155],[157,159],[161,165],167,[170,173]],
"owf":[154],
"owi":[[0,4],6,10,12,14,19,[21,24],26,28,30,32,35,37,38,40,42,44,46,48,49,54,59,[64,66],68,70,[72,75],77,81,82,[84,86],88,89,91,94,[97,101],105,106,111,113,115,[117,119],122,126,128,130,131,133,134,[136,139],[141,145],[148,152],154,[157,162],164,166,167,170,171,173],
"owl":[1,87,89,94,100,113,[117,119],124,126],
"own":[2,3,10,19,24,26,30,31,35,37,40,48,49,54,59,62,66,70,73,74,81,87,88,91,94,96,97,100,105,113,115,[117,119],122,[124,128],130,131,138,139,142,143,[145,147],149,150,152,154,[158,160],[162,164],166,167,170,173],
"owo":[75],
"ows":[1,12,15,16,22,26,28,30,31,35,37,40,44,47,48,53,56,59,60,66,70,74,77,78,80,84,[87,92],94,95,100,101,105,110,111,[113,115],[117,119],121,126,128,[132,135],139,140,144,145,148,150,154,[156,160],162,164,166,167,[170,173]],
"oxe":[122],
"oxi":[105,113,164,165],
"oyd":[74],
"oye":[88,89,100,105,122],
"oys":[89,90,96,116,144,159,160],
"oyt":[40],
"oze":[88,89,94,100,120,128],
"p-6":[1],
"p-8":[1],
"p-a":[46,94,119,167],
"p-b":[0,16,26,91,94,119],
"p-i":[101,159,173],
"p-n":[122],
"p-r":[2,54,100],
"p-t":[30,66],
"p01":[119],
"p05":[119],
"p16":[4],
"p8a":[135,150,166],
"p8m":[135],
"p<s":[19],
"p_0":[118],
"p_8":[118],
"p_a":[27],
"p_b":[53,101,104],
"p_e":[117],
"p_h":[101,170],
"p_n":[104],
"p_p":[104],
"p_t":[22],
"p_u":[22],
"p_v":[104],
"pab":[8,100,113,131,140,154],
"pac":[6,12,16,26,30,31,40,42,47,48,54,66,[70,72],74,77,81,85,88,89,91,92,94,101,104,113,119,122,126,128,132,145,146,151,158,161,162,167,168,172,173],
"pad":[1,6,66,83,94,119,120,147],
"pag":[23,43,53,76,94,100,122,142,146],
"pai":[14,31,40,100,101,111,115,116,122,124,126,134,136,142,144,145,147,149,[162,164],170],
"pal":[73,97,100,111,133,158],
"pan":[16,37,40,45,60,62,66,68,80,85,[88,90],94,100,101,104,105,113,119,122,128,133,145,149,150,154,[158,161],163,167,172,173],
"pap":[1,28,40,86,101],
"par":[0,1,2,4,5,10,12,13,16,[22,24],26,28,30,31,34,35,37,39,40,44,45,52,54,[56,62],[65,71],[74,78],[81,96],[99,105],[108,111],113,[115,119],122,[124,131],[133,145],[147,149],151,[154,167],[169,173]],
"pas":[28,29,31,74,91,100,109,114,122,126,129,158,159,162],
"pat":[26,28,35,49,59,[73,76],81,87,88,98,100,104,105,113,115,119,126,130,133,135,[145,147],150,157,158,160,165,170,172,173],
"pay":[84,105,173],
"pbe":[100,104],
"pbl":[89,117],
"pbr":[94,99,138],
"pca":[161,162],
"pck":[6,12,16,72],
"pcm":[16,35,59,60,73,74,94,100,113,116,117,123,139,149,166],
"pcn":[1,101,130,134,139,149,150,152,158],
"pco":[1,3,47,99,101,105,111,122,123,126,130,135,139,152,[161,163]],
"pda":[0,1,[3,6],12,26,28,30,31,34,35,40,47,48,54,55,59,60,64,66,70,74,77,81,85,88,89,91,92,94,96,100,102,104,108,109,111,113,[115,120],[124,127],130,131,134,[137,140],142,144,145,150,152,[158,160],162,164,166],
"pde":[[59,61],66,88,166],
"pdf":[86],
"pdo":[41],
"pea":[1,2,6,26,31,35,37,40,42,47,55,59,68,81,84,85,94,95,100,101,104,105,109,112,113,118,122,124,126,128,130,132,139,141,149,150,[158,160],164,167,170,172,173],
"pec":[2,17,18,21,22,26,30,33,37,39,42,54,59,64,66,70,73,81,82,85,86,88,89,91,92,94,100,105,111,[113,115],[118,122],124,[128,131],133,135,138,139,152,157,158,[162,164],166,[170,173]],
"ped":[2,10,14,20,22,[28,30],38,43,47,81,88,89,94,96,100,104,[112,115],122,126,128,133,138,145,162,164,167,170,171,173],
"pee":[[0,4],6,12,19,22,26,30,31,35,37,39,48,[58,61],66,70,78,81,[85,89],91,[94,96],100,[103,105],111,113,115,117,119,121,124,126,127,130,139,[157,161],[164,166],170,172,173],
"pef":[100],
"peg":[115],
"pel":[31,34,88,89,91,94,100,104,105,128,161,164],
"pen":[1,2,3,9,10,12,14,16,20,22,23,26,[29,31],[33,35],[39,41],43,47,48,54,[59,62],66,74,75,77,82,[84,88],94,100,104,105,113,118,119,122,[126,128],133,136,138,143,[146,148],152,154,[158,160],162,164,166,167,170,173],
"peo":[1,27,81,105,114,122,126,128,167],
"peq":[16,35,59,73,138,139,149,166],
"per":[[0,6],10,12,14,16,19,[22,24],[26,28],30,31,34,35,37,40,42,44,45,47,48,54,55,[58,60],62,[64,70],[72,75],77,78,[80,82],[84,92],[94,97],[100,108],[110,140],[142,144],[146,151],153,[156,173]],
"pes":[31,38,46,76,81,84,100,113,115,120,122,123,128,162,168,171],
"pet":[0,1,12,30,91,95,100,113,144,151,[158,160],166],
"pex":[3,67,68,89,115,126,145,159,166],
"pfi":[147],
"pfr":[158],
"pfu":[128,167],
"pga":[105,123,173],
"pge":[94],
"pgr":[75],
"pgs":[31,36],
"pgt":[60,94,113,117],
"pha":[3,6,12,26,69,113,144,161,168],
"phe":[26],
"phi":[128,159,[164,166],168,170,173],
"phm":[13],
"pho":[84,105,122],
"php":[33,41,122],
"phr":[31],
"phs":[128,160,165],
"phv":[128],
"phy":[31,37,40,162],
"pi1":[72,91,113,115,124],
"pi3":[72,74,91,94,97,111,113,115,117,119,120,126,131,137,140],
"pi6":[72,88,91,94,135],
"pi8":[72,89,91,94,111,113,115,117,118,126,131,[135,140]],
"pic":[2,15,31,40,88,89,94,100,105,109,113,115,118,120,123,126,128,131,133,134,136,137,140,146,158,159,162,163,167,173],
"pid":[79,122,128],
"pie":[14,82,84,111,[113,115],126,142,159,162,172],
"pik":[35,162],
"pil":[1,3,4,6,10,12,21,30,42,46,50,56,58,59,[63,65],75,[80,82],84,88,90,91,94,95,97,100,[102,105],110,111,113,[115,121],124,126,[128,131],133,135,137,[139,141],143,145,147,148,150,154,158,159,[161,166],170,173],
"pim":[150],
"pin":[3,19,29,81,82,87,88,94,99,109,[113,115],118,122,128,129,132,133,143,144,158,[160,162],171],
"pio":[30,73,81],
"pir":[117,122,128,135,159],
"pis":[100,105],
"pit":[84,88,100,147,161,171],
"piv":[77],
"pix":[3,4,6,12,115],
"pla":[1,3,4,7,10,16,17,19,22,30,31,34,37,40,48,54,58,60,63,69,74,75,77,81,82,85,[87,89],91,92,[94,96],99,100,104,105,113,115,116,119,120,122,124,126,128,129,131,133,134,137,140,143,145,147,148,150,152,154,158,159,161,162,[164,168],170,172,173],
"ple":[[1,6],[9,17],19,20,[22,24],[26,33],[35,52],[54,71],74,75,[77,95],[97,102],[104,108],111,[113,115],[117,124],[126,135],[137,140],[142,147],149,150,[152,167],[169,173]],
"pli":[1,2,6,9,10,[12,14],19,26,[28,31],34,35,37,40,43,44,48,54,55,[58,61],66,[69,71],74,75,77,79,[81,91],94,[98,102],104,105,113,115,118,122,124,126,128,129,132,[134,136],138,[142,145],[148,152],154,[157,162],[164,167],173],
"plo":[40,68,80,[87,90],96,111,116,122,131,163,164],
"plt":[117],
"plu":[47,68,88,94,109,122,144,158,159,162,164,167,168,173],
"ply":[6,12,14,22,30,47,48,59,60,69,75,76,81,84,86,88,89,91,94,100,101,[111,113],124,126,128,135,141,142,152,153,[156,159],162,164,172,173],
"plz":[99,150,152,156],
"pm_":[82],
"pma":[5,12,70,89,113,124,144,158,162],
"pme":[105,122,128],
"pmi":[5,139,162],
"pmo":[6,12,35,55,92,113,116,119,124,126],
"pmu":[6,12,30,66,70,88,91],
"pne":[116],
"poc":[2,125],
"pod":[120],
"poi":[1,3,10,12,26,31,34,39,[43,45],48,59,62,77,81,[84,86],88,91,94,95,[99,101],105,109,111,113,118,120,122,124,[126,134],140,[142,145],150,151,154,155,157,158,160,162,164,165,167,[170,173]],
"pol":[10,12,16,26,31,34,62,66,81,87,105,122,162],
"pon":[3,4,6,10,12,29,30,44,45,48,62,81,89,97,100,104,105,114,117,119,120,122,124,128,134,136,145,148,153,154,[159,162],170],
"poo":[26,59,109,122,132,148,159],
"pop":[1,6,16,30,37,39,47,52,53,59,64,74,78,[99,101],113,115,122,126,128,130,134,135,[137,139],145,146,149,150,152,156,158,161,162,[169,171]],
"por":[1,7,16,18,22,23,[26,28],30,[37,40],[46,48],55,60,70,72,74,75,81,82,84,86,88,89,91,92,94,96,100,102,104,105,[107,109],111,113,115,116,[118,120],122,123,[125,132],[135,140],143,151,152,[157,160],162,164,166,167,[170,173]],
"pos":[1,2,3,6,10,[12,16],18,[20,24],26,[29,31],[34,38],40,41,44,45,[47,49],51,[53,57],59,60,64,66,67,69,70,75,77,78,81,82,[84,89],[91,105],109,[111,115],[118,120],122,[124,137],[139,142],144,145,[147,154],[156,164],166,[169,171],173],
"pot":[26,74,84,94,100,120,136],
"pow":[1,6,16,21,52,[64,66],81,88,91,104,106,113,116,136,148,150,153,154,162,171],
"ppa":[131,140,147],
"ppd":[47],
"ppe":[0,2,14,20,22,26,29,33,37,38,42,43,47,55,59,60,68,75,81,82,84,[86,91],94,100,104,105,109,112,113,115,119,122,126,128,132,133,138,139,142,144,146,149,151,156,[158,162],164,166,167,170,172,173],
"ppi":[29,94,109,118,122,133,158,161,162],
"ppl":[1,2,12,13,26,28,31,43,69,71,74,75,81,84,86,91,98,105,113,122,124,126,132,134,138,144,149,156,158,159,161,162,164,173],
"ppo":[15,16,18,20,23,27,28,37,38,67,69,70,72,74,75,[87,89],91,96,100,102,104,105,[107,109],[114,116],118,122,123,126,128,134,[136,138],140,143,147,152,153,162,164,166,170,171],
"ppr":[4,10,12,16,23,26,31,32,34,36,59,60,69,73,76,80,81,[86,88],91,94,100,[103,105],108,111,113,115,[117,119],122,124,128,[131,133],139,[142,144],147,151,152,154,155,[157,161],[164,167],170,173],
"pps":[123,164,165],
"ppv":[128],
"ppy":[109],
"pra":[13,34,74,86,88,100,105,108,113,122,126,128,133,[157,159],162,164,170],
"pre":[[0,3],5,6,10,12,14,16,18,23,24,26,[28,34],37,40,42,45,48,54,[58,61],[65,69],71,[73,76],[79,84],[86,95],[99,101],104,105,108,109,[113,115],[117,119],121,122,124,126,[128,131],133,[136,142],144,[147,154],[156,162],164,[166,168],[170,173]],
"pri":[0,4,12,23,28,30,35,36,40,60,66,72,75,81,83,85,86,88,89,94,96,[103,105],[111,113],116,117,121,122,124,125,127,128,130,[132,134],136,142,143,146,159,161,165,167,169],
"pro":[[0,6],9,10,12,14,[16,20],[22,24],26,27,[29,32],[34,45],[47,52],54,55,[58,64],66,[69,71],[73,106],[108,111],113,[115,122],124,[126,145],[147,173]],
"ps2":[164,165],
"psa":[1,2,16,54,72,96,100,119,124,130,134,149],
"psc":[123],
"pse":[1,26,28,31,34,[59,61],76,77,90,92,94,104,135,163,166],
"psh":[0,1,3,6,16,22,23,42,60,71,72,[88,91],101,104,113,115,118,126,130,144,145,150,152,158,173],
"psl":[30,72,91],
"psr":[72,91,119],
"psu":[42,73,81,91,107,113,135,138,139,162],
"pt_":[126],
"pta":[86,100,132,158],
"pte":[74,100,101,105,113,116,122,149,150,160,166,171],
"pth":[24,26,29,137,155,168],
"pti":[1,2,3,6,10,12,[30,32],34,35,40,48,51,53,78,79,81,82,85,88,89,[91,94],97,100,102,104,105,109,112,113,116,118,[120,122],126,128,130,131,133,136,139,140,143,148,150,155,[158,162],[164,167],172,173],
"pto":[31,35,108,155,158],
"ptr":[105,114,128,131,140,150,152],
"pts":[2,31,37,42,75,81,88,113,122,123,128,162],
"ptu":[81,162],
"pty":[40,91,113,117,128],
"pu-":[22],
"pu8":[72,113,119,124,130,139],
"pub":[1,47,73,83,128,167,171],
"puc":[113],
"pul":[1,6,16,30,37,47,52,57,[59,61],64,67,68,74,78,85,88,100,101,113,115,128,130,134,135,137,138,145,146,149,150,152,156,[160,162],169,171],
"pun":[6,12,16,72,126],
"pur":[81,104,133,137,139,147,162,171,173],
"pus":[0,26,47,60,66,74,81,84,89,100,105,117,122,123,139,154,157,161,163,164,170],
"put":[1,2,3,14,19,[21,23],26,30,35,39,43,50,56,58,[60,64],66,67,69,71,74,75,77,84,85,[87,91],[94,96],[100,102],104,106,108,109,111,[113,116],118,119,121,122,124,[126,128],130,131,[133,138],[142,145],[147,150],155,[157,164],166,169,170,172,173],
"pv4":[158],
"pve":[10,128],
"pvo":[146],
"pwa":[155],
"pxo":[73,116,139,150],
"pxs":[100],
"py-":[122],
"py_":[128,131,137,140],
"pya":[26,128,132],
"pyb":[128],
"pyd":[28,128],
"pyi":[64,115,166],
"pyp":[128],
"pys":[27],
"pyt":[2,14,24,25,27,32,55,88,100,115,122,125,128,161,167],
"p":[122],
"q2p":[11,150],
"q_e":[138,139],
"qa3":[99],
"qa6":[139],
"qbn":[164],
"qdq":[72],
"qed":[5],
"qem":[171],
"qna":[150],
"qpd":[123],
"qps":[123],
"qrt":[154],
"qsu":[88],
"qu8":[123],
"qua":[1,2,5,12,21,34,40,48,54,61,65,68,77,84,88,89,91,92,94,95,[98,100],102,104,108,113,118,119,121,126,128,130,133,136,138,139,142,144,[147,151],[153,157],159,160,164,166,170,173],
"que":[2,14,15,27,28,30,31,35,37,38,40,[46,48],52,60,64,74,77,80,81,85,[88,90],94,[96,100],104,105,113,115,117,118,122,126,128,[131,133],136,137,139,140,142,143,[145,147],150,[157,160],[162,164],167,170,172,173],
"qui":[4,5,12,14,16,19,[22,24],[26,28],[30,37],39,40,[45,47],50,51,[53,55],[57,62],65,66,[68,75],77,78,81,[84,89],91,94,95,97,98,100,102,104,105,107,109,113,115,118,121,122,[126,133],135,136,139,[142,145],[148,151],154,155,[157,164],167,170,173],
"quo":[164],
"qvi":[134],
"qwo":[3,16,135],
"r-b":[94,100,131,145,166],
"r-c":[87,104],
"r-d":[113],
"r-e":[117,151,170,171],
"r-f":[66,96,105],
"r-g":[173],
"r-i":[114,122,162,164],
"r-m":[35],
"r-n":[171],
"r-o":[59],
"r-p":[81],
"r-r":[151],
"r-s":[88,167],
"r-u":[35],
"r-w":[2,100,138],
"r32":[147],
"r64":[100,147],
"r8x":[111],
"r<i":[108],
"r>&":[53],
"r_a":[2,87],
"r_b":[108,143],
"r_e":[72,91,94,97,111,113,115,126,138],
"r_l":[2],
"r_m":[2],
"r_n":[118],
"r_o":[65],
"r_s":[126,139],
"ra_":[87],
"rab":[1,2,25,30,40,54,95,100,105,124,159,162,164,173],
"rac":[3,4,10,13,18,26,30,31,34,44,45,49,53,60,[67,69],71,74,75,81,83,[85,91],94,96,100,102,104,105,[107,109],112,113,115,118,119,122,124,126,128,133,136,139,142,144,147,148,[152,154],[156,162],164,166,167,[170,173]],
"rad":[48,75,88,100,105,113,130,[164,166],170,173],
"raf":[105,113,122,167],
"rag":[2,4,6,26,31,32,40,50,62,75,77,81,105,113,115,122,126,128,130,132,133,139,[158,161],[164,166],170,173],
"rai":[1,4,7,26,28,35,37,40,48,53,60,73,81,83,94,101,104,105,[113,115],119,122,128,136,139,143,144,150,152,154,[156,159],162,164,168,172,173],
"ral":[0,1,2,4,10,16,18,22,23,26,30,31,35,37,40,42,53,54,59,60,[66,68],74,78,85,86,[88,91],94,[99,101],104,105,109,113,118,119,122,126,128,133,136,139,141,147,[149,151],155,[157,159],162,166,172],
"ram":[[0,4],6,9,10,12,19,22,26,[30,32],35,37,39,40,[42,45],[48,50],52,54,56,[59,63],66,74,75,79,[81,89],[91,95],97,[99,106],109,110,113,[115,120],122,[126,128],130,[132,134],137,146,147,149,150,[158,162],[164,167],170,171],
"ran":[2,3,5,6,8,10,12,16,17,20,22,23,26,28,[30,32],34,35,37,39,40,45,47,48,53,56,[59,63],68,70,75,77,[79,81],[85,97],100,[102,105],108,111,[113,115],117,118,[121,124],126,128,[130,133],[135,137],[139,144],[146,148],150,[157,164],166,[170,173]],
"rap":[2,29,38,40,46,59,60,81,82,94,105,119,122,128,129,132,143,158,160,162,[164,166],168,170,173],
"rar":[2,3,7,14,26,37,40,42,43,74,88,89,95,104,105,108,109,111,113,114,117,118,128,131,134,135,137,140,145,147,157,166,171,173],
"ras":[26,31,53,75,79,100,104,105,128,132],
"rat":[[0,6],9,10,12,16,[22,24],26,27,30,31,[34,37],40,42,[44,48],51,54,55,[59,61],[64,66],[68,70],[72,75],77,78,[80,82],[84,92],94,95,[100,102],104,105,[107,124],[126,136],[138,145],147,150,151,[153,156],[158,160],162,[164,167],[169,173]],
"rav":[24,29,122,124,126,128,131,138,139,155],
"raw":[6,12,19,30,36,54,85,86,88,126,139,145,147,154,168,173],
"ray":[0,26,31,35,40,58,62,75,77,80,91,92,94,[103,105],108,111,113,115,[117,119],121,124,130,131,142,145,150,151,158,159,164,170,173],
"raz":[31,128],
"rba":[66,71,87,89,122,158,160],
"rbe":[162],
"rbi":[40,113,118,135,145,166,171],
"rbj":[30],
"rbo":[104,124,129,147],
"rbs":[147,159],
"rbu":[159],
"rc3":[1],
"rca":[60,87,144,167,172,173],
"rce":[1,10,12,26,30,35,39,40,42,48,55,62,67,77,78,88,89,94,95,97,98,[100,105],107,108,110,111,[113,119],121,122,[124,128],[130,134],[136,140],142,143,147,149,150,[152,162],[164,167],[169,171],173],
"rch":[1,2,19,24,26,[29,32],34,35,40,41,48,54,62,77,81,84,88,89,94,96,98,100,[103,105],108,119,123,124,130,131,133,140,143,147,148,[157,162],[164,167],170,171,173],
"rci":[24,62,122],
"rco":[6,83,88,104,105,109,113,119,150],
"rcp":[164,165],
"rcu":[108,118,123,134],
"rd-":[2,105,115],
"rd_":[30,64,151],
"rdb":[127,132],
"rdc":[3,42,147],
"rdd":[123,173],
"rde":[15,24,26,37,40,47,49,60,66,[70,72],74,75,77,[88,91],94,96,100,108,111,113,115,116,122,126,134,135,143,152,[158,160],162,164,166,168,173],
"rdi":[1,10,37,42,71,74,81,85,88,89,91,94,97,104,105,119,122,126,130,133,145,150,[158,160],166,168,170,171],
"rdl":[4,31,48,122,131,162],
"rdn":[82],
"rdp":[123],
"rdq":[123],
"rds":[[1,6],10,12,19,22,23,26,28,30,31,35,37,40,52,54,59,60,66,[68,71],78,85,[87,89],91,94,97,100,101,103,104,113,115,122,124,126,128,130,[133,135],141,144,145,147,[149,152],155,[158,161],166,167,169,172,173],
"rdt":[9,113],
"rdw":[1,17,22,32,42,48,61,77,81,94,105,122,123,154,160,162],
"re!":[122],
"re-":[1,9,24,37,74,116,121,128,136,140,142,150,158,159,162],
"re2":[0,6,9,12,30,31,48],
"re_":[22],
"rea":[[1,7],9,10,12,14,19,23,24,26,[28,31],34,35,37,40,[42,44],[46,49],51,53,[57,62],66,70,74,75,77,[80,82],[84,94],96,[99,102],104,105,[107,109],[111,115],[117,120],122,[124,128],[130,135],[139,146],148,151,152,154,155,[158,162],164,[166,168],170,171,173],
"reb":[26,126,161],
"rec":[2,6,10,22,23,26,[29,31],34,35,37,39,42,43,45,49,[55,57],60,65,66,71,[74,76],81,84,86,88,89,91,[94,96],100,104,105,107,[109,115],118,119,[121,126],128,130,133,134,136,138,140,[142,144],148,152,[158,162],[164,166],168,[170,173]],
"red":[[0,4],7,10,12,16,19,[22,24],26,[29,31],33,34,37,38,40,44,45,47,48,54,55,[58,60],62,65,66,69,73,[75,77],81,82,84,85,[87,91],93,94,[96,98],100,104,105,[108,111],[113,120],122,[124,130],[132,139],[142,151],153,[158,160],162,[164,168],[170,173]],
"ree":[0,2,3,5,14,16,19,24,26,28,31,34,35,37,40,47,48,52,59,66,[72,74],77,81,84,85,88,89,91,[100,102],104,105,113,115,[117,119],122,124,[126,128],130,132,133,135,136,139,141,144,145,147,149,150,155,[158,160],162,163,167,168,170,172,173],
"ref":[1,2,3,6,14,22,29,31,40,54,89,94,100,104,105,[113,115],122,126,128,136,140,147,[157,161],[164,167],170,171,173],
"reg":[[0,4],6,7,12,16,18,20,22,23,31,32,37,48,52,54,59,61,[70,74],81,84,[87,89],[91,95],100,101,[103,105],111,113,115,116,118,119,123,124,126,128,130,131,133,134,[136,139],[141,146],[148,151],158,160,[162,164],166,169,[171,173]],
"rei":[37,81,170],
"rej":[31,75,113,158],
"rel":[5,26,28,30,31,37,40,48,54,60,75,81,84,85,[87,89],91,92,94,95,105,109,[111,114],117,119,120,122,125,128,135,139,142,143,151,[157,159],162,164,166,[170,173]],
"rem":[1,4,6,9,12,24,26,29,30,34,35,39,40,46,48,53,57,75,77,81,84,88,89,94,[100,102],105,113,117,119,120,122,126,130,131,137,140,142,148,154,156,[158,162],164,167,170,173],
"ren":[[1,4],6,10,14,16,20,22,24,26,[29,31],34,35,37,39,40,47,57,59,66,70,73,80,81,85,86,88,89,91,94,97,100,101,104,105,[107,110],[113,115],[117,119],[121,128],[130,136],139,140,143,146,150,[155,160],162,164,[166,173]],
"reo":[1,23,26,30,37,40,81,86,88,95,100,102,104,105,109,113,115,119,121,158],
"rep":[0,1,2,6,10,12,23,26,28,30,31,34,35,37,40,47,48,54,[57,61],66,69,74,[81,83],85,86,88,89,[91,96],100,101,104,105,108,113,115,116,118,122,[124,133],136,137,[140,142],145,148,150,151,154,[157,162],164,167,168,170,173],
"req":[4,12,14,16,[22,24],[26,28],[30,32],34,35,40,[45,47],50,51,[53,55],[58,60],65,66,[68,70],72,74,77,78,81,[84,89],91,94,97,98,100,102,104,113,115,118,121,122,126,127,[129,132],135,136,142,145,[149,151],155,[158,160],162,173],
"rer":[111,131,160],
"res":[[0,6],10,12,[14,16],19,[21,24],[26,32],[34,42],[44,48],[50,52],54,55,[58,64],[66,71],73,74,[77,89],[91,95],97,[99,126],[128,145],[147,168],[170,173]],
"ret":[1,12,26,31,[33,35],37,41,43,47,58,67,73,74,78,81,84,[88,91],94,100,[103,105],109,111,[113,115],117,121,125,126,128,129,132,133,135,137,139,147,150,154,[157,160],162,164,166,171,173],
"rev":[2,14,18,22,24,26,29,34,40,48,59,60,62,66,71,75,84,88,89,91,92,94,96,100,104,105,109,113,119,122,124,126,128,131,135,137,140,144,152,[156,162],164,168,171,173],
"rew":[63,80,82,84,87,89,94,104,131,141,148,151,157,162,164,173],
"rex":[123],
"rfa":[92,122,132,172],
"rfc":[133],
"rfe":[3,4,28,30,58,67,75,81,84,85,91,105,122,124,142,143,147,148,159,162,167,173],
"rfi":[161],
"rfl":[1,12,32,35,43,44,48,69,76,78,84,89,113,119,124,136,139,142,149,158,162],
"rfo":[[1,4],6,10,12,14,16,22,24,28,30,31,35,37,44,54,55,58,59,65,66,68,70,77,78,81,86,88,89,91,92,[94,97],[100,105],108,111,[113,120],124,126,127,[129,131],133,135,136,138,139,[142,144],[146,149],151,[158,160],162,[164,167],[169,171],173],
"rfu":[1,16,81,91,104,113,116,122,171],
"rga":[26,81,88,105,121,122,151],
"rgb":[3,6,162],
"rge":[1,4,22,26,28,30,31,37,40,45,46,49,58,62,66,73,75,[77,83],85,86,88,89,[93,95],97,100,101,103,105,107,108,113,115,118,119,122,128,[130,134],136,137,140,143,144,[147,149],[158,162],166],
"rgi":[88,89,100,113,115,160,164,173],
"rgo":[81],
"rgu":[1,23,42,47,[65,67],[71,74],84,88,94,100,113,115,116,119,120,123,126,[128,131],[133,136],141,150,159,[161,164],170,171],
"rha":[110,128],
"rhe":[122,[127,129],132,166],
"rho":[122],
"ria":[1,6,7,27,29,30,33,35,38,40,43,44,56,58,61,66,70,[73,75],81,84,85,88,89,91,94,95,97,100,102,103,105,[109,111],113,[115,119],122,124,126,128,[132,136],138,139,142,145,147,148,[158,160],[162,164],[169,173]],
"rib":[1,3,4,6,14,24,28,30,37,40,59,62,70,71,74,76,[80,82],85,86,[88,91],94,100,104,105,108,113,118,122,124,126,128,130,134,136,142,147,[158,160],162,167,170,172,173],
"ric":[1,2,10,23,30,31,35,38,42,60,[68,70],73,76,77,79,81,94,100,102,[104,106],108,[111,113],115,122,124,126,[133,136],139,144,[148,150],156,158,159,161,162,164,166,170,171,173],
"rid":[38,89,100,105,113,115,118,119,133,148,151,159,160],
"rie":[1,2,[14,16],19,22,23,26,28,31,35,37,40,42,47,54,62,66,73,74,77,81,[87,89],94,96,98,100,104,105,108,109,113,114,117,118,122,126,128,132,133,142,143,147,154,[158,162],164,166,167,170,172,173],
"rif":[30,32,88,89,113,162,164],
"rig":[1,2,5,6,10,18,[30,32],40,44,59,61,64,66,68,69,75,78,82,[84,86],88,91,94,101,111,115,118,122,124,126,128,131,134,139,[147,150],154,[156,158],[160,162],164,167,168,170,173],
"rik":[162],
"ril":[105,113,122,125],
"rim":[1,14,26,31,35,37,40,47,54,59,60,62,66,70,78,[86,89],94,96,102,104,105,108,113,115,117,119,124,[130,132],136,139,143,147,159,160,[163,166],170,173],
"rin":[0,1,2,6,14,19,23,26,28,30,36,37,[39,41],45,[47,49],53,54,60,61,67,[69,72],74,75,78,79,81,[83,86],[88,91],94,96,98,100,102,104,105,108,109,112,113,115,116,119,120,122,[125,128],[131,135],138,140,144,145,147,148,150,154,[157,162],164,167,[169,173]],
"rio":[1,22,31,37,40,79,88,94,95,100,102,113,116,[119,121],123,126,128,[132,134],136,160,161,166,173],
"rip":[1,2,10,31,32,37,47,51,75,81,88,91,94,100,105,115,122,123,128,130,146,148,159,161,162,164,167],
"ris":[1,2,4,12,31,35,40,44,45,52,54,[59,62],66,69,72,76,77,81,[83,85],[87,90],92,94,[100,105],108,111,113,115,116,118,119,121,122,124,[126,128],130,131,133,[136,140],[142,144],[146,149],151,154,[156,160],[162,167],170,171,173],
"rit":[0,1,2,4,6,7,10,12,14,16,18,[22,24],26,28,30,31,34,35,40,42,44,45,47,50,52,[54,56],[59,64],66,[68,71],74,75,77,78,[80,82],[84,97],[100,102],104,105,[107,109],111,113,115,[117,122],[124,126],128,130,131,[133,145],[147,151],[153,162],164,165,167,168,170,171,173],
"riv":[12,42,55,59,87,89,105,111,120,122,127,128,131,140,142,152,158],
"rix":[135],
"riz":[16,19,30,40,42,48,87,88,94,95,108,111,113,115,[117,119],121,122,124,126,130,131,133,136,137,140,144,145,158,160,162,164,166,168,[170,173]],
"rju":[161],
"rk-":[105,113],
"rk_":[115],
"rkd":[167],
"rke":[29,36,40,66,74,75,81,87,89,91,94,105,115,118,122,142,146,170,173],
"rkf":[167],
"rki":[1,47,57,67,94,122,159,160,173],
"rkl":[113],
"rks":[3,6,26,30,33,45,57,59,60,70,81,88,89,91,94,95,97,99,100,105,111,113,115,118,119,124,126,128,129,138,144,145,149,150,154,157,158,160,164,166,170,171,173],
"rla":[31,122,165],
"rld":[23,31,72,74,75,90,105,112,119,122,126,128,136,140,158,162,173],
"rle":[1,12,54,60,72,74,101,104,133,135,145],
"rli":[3,10,40,71,72,78,81,91,94,104,113,119,128,158,160,162],
"rlo":[81,122,126,129],
"rls":[167],
"rlv":[91,94],
"rly":[1,22,26,37,45,49,59,70,74,78,84,85,89,91,94,100,105,106,112,113,115,116,118,[126,128],135,136,138,144,158,159,162,165,166,171,173],
"rm1":[115],
"rm2":[72,113,115,134],
"rm_":[114,131,137,140],
"rma":[1,2,4,10,14,22,26,28,34,36,37,39,44,45,48,58,59,73,81,86,88,91,92,[94,96],100,101,[103,105],108,109,111,113,115,117,119,120,122,[126,130],133,135,139,[145,147],[150,152],154,158,159,161,162,164,165,167,169,170,172,173],
"rmb":[88,91,115,126],
"rmd":[91,94,115,126],
"rme":[2,3,22,24,31,44,54,55,59,68,75,77,81,86,[88,91],94,100,104,108,113,115,[118,120],124,131,135,136,143,144,146,149,157],
"rmi":[21,28,31,34,35,45,51,54,59,65,73,81,[88,91],94,100,101,113,118,119,124,126,133,149,158,159,162,169,172,173],
"rml":[104],
"rmo":[122],
"rmp":[72],
"rmq":[72],
"rms":[1,2,23,24,31,34,35,37,59,66,67,70,77,88,94,98,100,108,113,[122,124],126,135,138,148,151,158,160,162,170,171],
"rmu":[6,16,30,42,72,91,94,111,113,115,126,156,160,162,171],
"rmv":[100,104],
"rmw":[115],
"rna":[26,29,74,77,88,91,94,100,104,109,110,[113,115],118,123,127,128,[132,134],143,149,150,152,[159,164],171,173],
"rnb":[101],
"rnc":[2],
"rnd":[10,170],
"rne":[1,41,75,76,79,83,90,105,109,125,128,132,148,158,167,173],
"rni":[40,54,56,75,128,152],
"rnl":[74,149,150,166],
"rnm":[105],
"rno":[43],
"rns":[26,31,35,43,49,88,98,100,103,110,113,126,132,135,145,157,158,162,164],
"rnt":[105,122,137,140],
"ro-":[1,3,119,123,150,157],
"ro_":[54,157],
"roa":[4,10,12,16,23,26,31,32,34,36,59,60,69,73,76,77,80,81,[86,88],94,95,99,100,104,105,108,111,113,115,[117,119],[122,124],128,131,133,135,138,139,143,144,147,[149,152],155,[157,162],164,166,167,170,171,173],
"rob":[3,6,14,17,18,26,29,34,35,37,41,48,51,59,69,[75,77],80,81,83,84,[86,89],[91,94],96,98,100,102,103,105,109,113,116,118,120,122,126,[128,130],132,136,138,139,141,143,[147,150],152,154,[156,160],162,[167,169],172,173],
"roc":[[1,4],6,12,18,22,24,26,[29,31],34,35,37,38,40,47,54,59,60,62,64,66,[69,71],74,76,78,81,[84,89],91,92,94,96,97,100,101,[103,106],111,113,115,117,[119,122],124,126,128,130,131,[133,140],143,145,147,149,150,[156,160],162,[164,167],170,172,173],
"rod":[[1,6],10,12,24,26,30,31,34,35,37,40,48,[59,62],64,66,[68,71],[73,78],81,[85,92],94,95,97,[99,101],104,105,[108,111],[113,122],124,[126,145],147,[149,167],[170,173]],
"roe":[113,115,118,170],
"rof":[102,105,108,120,167,170],
"rog":[[0,4],6,9,10,12,19,22,26,30,32,35,39,40,[42,45],[48,50],52,54,[59,63],66,74,75,79,81,82,[84,89],[92,95],97,[99,106],109,113,[115,117],120,122,[126,128],130,132,133,137,140,147,150,158,159,161,162,[164,167],171],
"roi":[90,111,121,150,160,162],
"roj":[31,34,35,110,117,122,128,157,[162,164],167,173],
"rok":[113,122],
"rol":[[1,4],6,12,22,35,47,48,81,88,91,94,95,100,105,111,113,[115,117],119,124,126,130,131,139,140,145,150,152,158,162,164,165,171],
"rom":[[0,6],9,10,12,14,16,[18,22],24,26,28,[30,32],35,[37,40],43,[47,51],54,55,[58,62],[66,71],[73,75],77,78,80,81,[84,94],[96,98],[100,102],[104,106],[108,111],[113,115],[117,124],126,[128,140],[142,145],[147,150],[152,171],173],
"ron":[14,26,30,35,37,48,57,74,75,81,82,[86,89],91,94,96,100,105,112,115,116,122,128,146,157,158,161,164],
"roo":[2,5,24,40,48,55,69,81,105,119,120,128,131,140,142,145,150,152,154,155,168,170],
"rop":[2,10,12,19,23,24,26,27,31,40,45,59,62,69,[75,77],81,[84,86],88,90,91,94,100,[103,106],108,109,111,113,[115,118],122,124,126,128,129,133,[135,137],139,142,144,147,[158,160],162,[164,167],170,173],
"roq":[100],
"ror":[32,38,39,43,48,56,75,81,82,84,88,89,91,94,104,109,113,115,128,129,144,158,164],
"ros":[1,12,16,26,30,34,39,48,51,54,64,67,73,81,88,91,94,[98,100],111,113,115,118,119,125,126,128,[130,132],140,142,[146,148],150,152,[156,158],160,162,163,166,171],
"rot":[14,16,26,40,46,79,83,99,110,128,135,138,143,150,157,159],
"rou":[[1,4],6,9,10,12,16,19,23,26,30,[34,36],40,[46,49],54,[59,61],72,74,76,77,81,[84,86],88,89,94,100,101,105,109,113,119,122,[128,130],132,[145,147],150,[157,159],162,164,167,168,172,173],
"rov":[[0,4],12,26,30,35,40,48,58,62,66,69,81,[85,89],91,94,100,102,104,105,115,117,119,122,124,126,128,132,134,144,145,150,158,161,162,164,171,173],
"row":[15,31,37,47,53,72,77,80,84,88,89,108,113,115,118,122,126,157,162,171,173],
"rox":[91,105,113,122,132,154,158,159,164,165,173],
"roy":[59,91],
"rp-":[2,54,100],
"rpa":[94,113,124,[126,128],138,160,161,173],
"rpo":[12,36,62,81,133,137,139,162,171,173],
"rpr":[4,12,33,35,40,60,66,67,72,81,83,89,94,104,105,111,113,121,122,124,127,128,136,139,143,146,150,154,159,162,164,167],
"rpt":[94],
"rpu":[161],
"rqd":[123],
"rqp":[123],
"rqq":[123],
"rqv":[134],
"rra":[0,26,31,35,40,58,62,75,77,80,91,92,94,100,[103,105],108,111,113,115,[117,119],121,124,130,131,142,145,150,151,158,159,164,170,173],
"rre":[2,6,10,14,23,29,30,34,40,48,56,60,66,71,[80,82],84,86,88,89,94,95,97,100,104,105,109,110,[112,114],[117,119],123,124,126,128,130,134,139,140,144,145,[156,162],167,168,170],
"rri":[38,74,82,96,100,105,113,170],
"rrn":[43],
"rro":[32,38,39,43,48,49,56,72,75,77,81,82,84,88,89,91,94,104,108,109,112,113,115,122,128,129,144,158,162,164],
"rru":[112],
"rry":[18,23,32,46,55,59,74,76,79,91,94,100,104,119,122,126,142,143,149,162,166],
"rs!":[128],
"rs1":[163],
"rsa":[2,24,118,157,173],
"rsc":[118],
"rse":[1,3,12,29,30,34,37,40,46,51,57,60,66,67,69,71,77,81,83,86,88,90,93,94,100,103,105,[108,110],113,[118,120],124,127,128,[130,133],135,137,140,144,152,155,[157,159],162,166,167,170,171,173],
"rsh":[105],
"rsi":[0,1,4,6,[10,12],[22,24],26,29,30,33,36,39,52,55,[59,61],[66,72],[74,79],[81,92],94,96,100,[102,104],106,109,[111,113],[116,119],121,124,128,130,131,133,136,137,139,140,[142,145],147,148,151,152,158,159,163,164,167,172,173],
"rsk":[30,73],
"rso":[109,122,137,167,171],
"rsp":[81,113,135,161,162],
"rst":[1,2,4,[10,12],14,16,18,19,21,23,24,26,[29,32],34,35,37,39,40,44,[47,49],[53,55],59,60,62,64,66,81,82,84,[87,89],91,92,94,96,[98,105],108,110,111,[113,115],117,119,120,122,124,126,128,130,131,133,135,138,140,142,144,[147,150],152,[154,162],[164,171],173],
"rsu":[139],
"rt-":[113,115],
"rt_":[10,115],
"rta":[1,10,19,22,23,26,30,37,39,40,[46,48],55,60,70,81,84,[86,88],94,100,104,105,109,113,120,122,126,128,131,132,135,136,160,162,166,173],
"rte":[2,3,16,18,19,26,30,31,34,37,39,40,44,48,50,55,65,66,69,75,81,82,84,86,92,94,96,100,102,104,108,111,113,115,118,122,123,[126,128],[130,132],137,138,140,143,144,147,157,158,160,[162,164],167,170,173],
"rtf":[88],
"rth":[1,3,12,16,37,63,66,81,85,88,94,100,105,113,118,119,122,128,137,143,148,158,159,164],
"rti":[1,2,10,13,19,23,24,26,30,31,34,35,37,40,44,50,54,59,60,64,66,[68,71],74,77,78,81,[86,95],[99,101],104,105,108,111,113,115,117,118,122,124,126,128,[134,136],139,140,[142,144],146,147,149,150,153,154,156,[158,162],164,[166,170],172,173],
"rto":[81,109,113,122],
"rts":[4,11,16,[37,39],60,70,73,77,83,85,88,91,94,100,102,104,105,108,113,115,118,119,122,[125,128],138,139,144,147,[150,152],154,156,[158,162],164,171,173],
"rtt":[81,110],
"rtu":[1,2,10,34,37,51,65,66,68,70,73,76,81,88,89,94,98,100,104,106,109,111,113,116,118,120,122,128,130,[135,140],165,173],
"rtw":[115],
"rty":[10,49,57,62,82,88,100,135,142,159,164,166],
"rub":[162],
"ruc":[[0,6],[10,13],16,17,[19,24],26,27,30,31,33,35,39,42,[45,47],50,51,54,55,[58,61],[64,68],[70,74],76,77,80,81,[85,92],94,96,97,[99,111],113,[115,124],[126,128],[130,140],[142,145],[148,150],152,154,[156,160],[162,171],173],
"rue":[5,12,14,20,28,29,43,51,52,58,74,81,87,91,100,108,120,122,125,128,138,139,148,157,159,172,173],
"rui":[126,145],
"rul":[98,144,159,170,172,173],
"rum":[10],
"run":[[1,4],6,10,19,30,31,35,37,54,57,60,62,75,78,81,84,87,88,94,97,100,103,105,110,[113,115],117,119,122,[124,128],130,131,133,139,146,154,157,159,162,[164,166],168,172],
"rup":[112],
"rus":[40,105,122,128,160,162,173],
"rut":[74,88,113],
"rv6":[163],
"rva":[1,3,47,60,68,[86,88],94,123,134,135,144,152,154,157,159,160,170],
"rve":[26,31,39,41,49,57,58,73,81,84,122,128,137,154,157,159,162,167,170,173],
"rvi":[40,56,113,122,134,146,160,162,173],
"rvv":[162],
"rwa":[1,4,28,35,40,60,94,101,115,119,122,128,139,143,144,150,152,157,159,162,164,170,172,173],
"rwh":[85],
"rwi":[2,60,87,94,97,105,111,113,142,144,147,151,158,159,170,172],
"rwr":[89,94,131],
"ry!":[162],
"ry-":[14,74,81,94,128],
"ry_":[114],
"ryb":[122],
"rye":[128],
"ryi":[37,43,142,167],
"ryl":[74,94],
"ryt":[33,38,42,72,75,81,84,89,90,104,105,122,129,136,167],
"ryw":[125,172,173],
"ryz":[[164,166],170,173],
"rze":[81],
"rs":[135],
"s-1":[128],
"s-2":[128],
"s-3":[128],
"s-4":[128],
"s-b":[1],
"s-c":[9],
"s-e":[146],
"s-f":[166],
"s-i":[126],
"s-l":[115],
"s-o":[170],
"s-p":[100],
"s-s":[170],
"s2d":[164,165],
"s_a":[87],
"s_c":[24,37],
"s_e":[72,113,126,131,137,140],
"s_h":[170],
"s_m":[113],
"s_p":[65,120],
"s_q":[31],
"s_s":[27,80,111,131,137,140],
"s_v":[31],
"s_z":[54,157],
"sa-":[162],
"saa":[105],
"sab":[114,120,158,164],
"sac":[162],
"sad":[1,2,16,24,39,54,72,81,96,100,105,108,112,119,124,130,134,136,137,149,158],
"saf":[12,22,26,30,32,44,84,89,100,105,107,120,126,142,145,173],
"sag":[13,26,54,60,70,79,94,99,105,113,128,132,135,139],
"sah":[47],
"sai":[35,94,104,105,122,162,173],
"saj":[105],
"sak":[81,109,118,140,143,160,162,170],
"sal":[2,24,75,94,118,122,157,161,162],
"sam":[[1,6],[10,12],19,20,24,26,27,[30,32],34,35,37,[39,41],44,45,[47,50],52,54,55,[59,62],[64,66],[68,71],74,78,81,[85,89],[91,95],97,98,100,101,[103,106],108,111,113,[115,119],121,[124,126],128,[132,135],137,138,[142,147],149,150,[152,166],[169,171],173],
"san":[4,89,100,128,132,146,161,162,167,173],
"sap":[122],
"sar":[24,47,113,118,158],
"sas":[47,55,88,117,130,161,162,164,171,173],
"sat":[2,3,6,12,34,88,92,94,100,107,113,119,126,128,131,138,144,146,158],
"sav":[6,12,14,26,28,37,39,40,42,44,47,48,52,60,64,66,69,74,80,85,[87,89],91,94,99,100,104,108,113,122,126,128,135,145,[162,164],173],
"saw":[40,84,105,109,113,119,122,126,128],
"sax":[171],
"say":[14,26,39,43,51,58,71,76,77,81,83,113,122,126,133,135,147,163,164,173],
"sbb":[18,47],
"sbf":[162],
"sbl":[47],
"sbs":[100,157],
"sbw":[89],
"sc-":[[162,164],171],
"sca":[12,23,26,30,31,37,40,47,54,55,59,60,62,66,70,71,[87,89],91,92,94,100,[102,104],111,113,115,[117,119],[121,124],126,130,131,136,137,139,[142,144],152,154,[157,160],162,[164,166],168,[170,173]],
"sce":[22,37,40,62,94,100,126,128,132,133,166,173],
"sch":[1,3,14,19,24,26,30,40,85,88,94,111,113,117,154,158,159,164],
"sci":[23,30,31,39,59,60,[66,71],81,85,[87,89],91,94,102,104,113,122,142,144,148,157,158,161,169,172,173],
"scl":[122],
"sco":[100,128,137,158],
"scr":[[1,4],6,10,14,24,28,[30,32],37,40,47,51,59,70,71,[74,76],80,81,85,86,[88,91],94,100,104,105,108,113,115,118,[122,124],126,128,130,134,136,142,[146,148],[158,160],162,167,172,173],
"scu":[1,10,22,34,40,43,66,69,80,81,88,89,111,113,126,135,139,162,173],
"scv":[163,171],
"sd-":[113],
"sdb":[159],
"sde":[161],
"sdi":[43,161],
"sdw":[70,72,92,113],
"se!":[83],
"se-":[1,2,3,10,31,48,100,111,122,144,158],
"se2":[1,3,4,8,22,30,66,71,96,100,130],
"se3":[0,1,6,12,16,22,23,60,70,71,78,113],
"se4":[1,2,3,5,6,12,13,30,54,70,96,100,113,117,120],
"se5":[16],
"se6":[84,85,[88,91],94,104],
"se_":[22,30,67,101,131,137,140],
"sea":[1,2,19,24,26,29,31,32,34,35,40,54,62,74,77,83,84,94,96,98,100,101,103,105,108,113,130,133,147,158,161,164,167,170],
"sec":[1,2,5,14,18,26,30,31,34,37,40,48,55,66,69,77,81,88,89,91,92,94,96,100,102,104,105,108,111,[113,115],118,119,122,[124,126],128,130,135,138,139,[143,146],149,150,152,154,[158,162],164,167,168,173],
"sed":[[0,6],[10,12],14,16,19,24,26,[28,32],34,35,37,38,40,42,44,47,48,55,[58,62],66,[69,71],[73,77],81,[84,95],97,100,101,[104,106],109,111,[113,124],[126,131],[133,136],138,139,[143,147],150,152,154,[157,167],[170,173]],
"see":[[1,4],10,11,14,20,23,24,26,30,31,35,37,40,42,43,47,50,[54,56],[58,60],[67,70],[73,75],[77,79],81,82,85,88,89,94,96,100,101,104,105,110,111,113,115,118,119,122,123,126,128,[131,134],[136,140],142,[144,148],152,154,[157,162],164,166,167,[170,173]],
"sef":[28,42,47,81,104,109,116,122,128,129,161,162],
"seg":[128],
"sel":[1,2,3,15,18,23,30,37,40,42,45,47,67,74,77,81,[87,89],91,92,94,100,104,105,111,113,115,117,118,121,122,124,125,128,129,133,135,137,140,141,147,[158,160],162,163,166,167,171,173],
"sem":[2,46,47,55,58,74,91,92,96,104,106,109,115,116,[119,121],124,129,130,133,138,139,148,150,151,157,159,160,[162,164],169],
"sen":[0,1,3,5,10,16,26,28,30,31,34,37,40,42,43,45,54,[58,62],66,68,75,80,81,83,84,86,88,89,95,100,101,104,105,108,113,115,118,122,124,126,128,130,133,136,137,140,142,144,149,150,153,154,156,[158,162],164,167,168,[171,173]],
"sep":[1,16,26,34,40,60,69,85,88,89,91,94,[100,102],105,113,118,119,126,[134,136],[142,145],147,156,158,159,162,164,165,169,173],
"seq":[2,14,27,31,35,40,46,48,52,64,74,85,88,89,94,98,100,104,113,117,118,126,133,142,143,145,147,150,158,162,163,167,170],
"ser":[0,1,3,10,13,15,16,19,23,26,31,35,[39,41],47,49,[56,58],60,65,68,73,81,82,84,[87,89],[94,96],98,100,105,109,113,115,122,123,128,129,[133,137],140,[142,144],146,152,154,[157,162],166,167,170,173],
"ses":[[2,6],10,14,24,26,27,31,34,35,37,40,42,44,54,58,59,72,74,76,81,84,85,[87,92],94,100,102,[104,106],108,[110,113],115,[118,122],124,[126,128],132,133,138,139,[142,145],[148,150],152,153,[156,164],166,168,170,172,173],
"set":[1,2,10,12,14,16,21,23,26,29,31,35,37,40,43,[46,48],51,55,58,60,61,64,65,68,73,74,76,78,80,81,[87,89],[91,94],[98,101],103,104,[106,108],[113,116],118,120,122,[124,126],128,[130,133],[135,137],[139,141],143,144,[147,152],154,[157,164],166,167,171,173],
"seu":[1,26,28,31,34,[59,61],76,77,90,92,94,104,135,163,166],
"sev":[1,22,26,31,74,76,86,88,90,91,94,100,101,105,109,111,113,118,122,126,128,133,136,139,145,147,150,155,157,159,162],
"sew":[162],
"sey":[31,35],
"sfa":[12],
"sfe":[22,47,89,94,104,159,164,166],
"sfi":[105,138],
"sfo":[3,23,37,[88,90],94,108,113,115,126,131,133,135,137,140,144,150,158,173],
"sfu":[122,128],
"sg1":[42],
"sgr":[31],
"sh1":[159],
"sh2":[159],
"sh3":[159],
"sh_":[159,170],
"sha":[14,19,31,35,42,53,74,85,94,105,110,111,113,114,126,128,146,147,158,159,162,173],
"she":[1,12,42,47,59,81,89,94,100,104,105,109,122,126,128,135,159,160,171,173],
"shi":[3,4,6,10,12,17,18,23,28,30,32,40,[42,45],55,[58,61],64,66,68,69,74,78,[84,86],[88,92],94,97,100,101,104,105,111,115,118,119,124,126,134,[142,144],[147,150],154,[156,159],[162,164],166,167,171,173],
"shl":[47,89,148],
"sho":[[0,3],7,10,12,14,16,22,26,30,31,35,37,38,40,[42,44],47,50,52,55,56,[59,61],66,69,70,74,77,78,81,82,[84,92],[94,96],[99,102],105,108,110,[113,115],[117,122],[126,128],130,132,134,[136,139],[142,145],[147,150],152,155,156,[158,164],166,167,170,172,173],
"shr":[47,143],
"sht":[161],
"shu":[0,1,3,6,16,22,23,40,42,60,71,72,[88,91],94,101,104,113,115,118,120,126,134,135,138,144,145,150,152,158,162,164,166,170,171,173],
"si1":[89,138],
"si2":[72,138],
"si5":[139],
"sia":[113,173],
"sib":[0,2,3,6,12,14,16,20,23,24,26,[29,31],34,35,37,40,48,49,51,[54,56],60,66,70,78,81,82,[84,89],92,94,97,100,102,104,105,109,[111,115],[118,120],125,126,128,129,131,132,135,137,[139,142],144,[148,150],154,156,[158,166],168,170,171,173],
"sic":[1,4,6,26,31,37,44,47,53,62,65,66,72,74,81,85,[87,91],94,96,100,101,104,105,113,115,116,[118,120],122,126,128,[130,135],137,138,140,141,147,149,152,157,161,162,164,166,171,173],
"sid":[1,2,4,5,12,22,24,26,30,31,34,35,37,40,44,59,60,63,66,73,75,[81,84],88,89,94,96,97,100,105,113,114,117,118,120,122,126,[128,132],137,140,142,145,150,154,158,[160,162],167,170,172,173],
"sie":[34,50,75,81,88,91,102,104,113,118,122,125,127,128,145,158,159,164,166,170,173],
"sif":[87,113,118,144,150,158,159,162],
"sig":[1,5,[10,12],17,[26,28],[30,32],34,[39,41],44,46,48,49,52,55,59,60,[68,70],74,76,79,[81,83],85,[87,92],94,100,102,105,[107,109],111,113,[117,119],121,122,124,[126,129],139,[143,145],[147,150],152,154,[156,160],[162,165],167,168,170,171,173],
"sil":[28,29,34,55,60,68,71,77,84,85,88,91,94,95,100,104,105,128,134,142,[144,146],164,167,171],
"sim":[[0,4],6,10,[14,16],19,23,24,26,[28,31],33,[35,40],43,46,47,49,51,52,[54,61],[63,66],[68,70],[74,77],80,81,[84,94],96,97,[100,102],104,105,[107,109],[111,113],115,[117,124],126,[128,131],[133,146],149,150,[152,154],[156,162],[164,167],[170,173]],
"sin":[[0,6],8,10,12,16,18,19,[22,24],26,[29,32],34,35,37,40,[42,45],47,49,50,52,54,55,[59,62],64,[66,75],77,78,[80,82],[84,92],94,95,97,[99,105],108,109,111,[113,115],[117,119],121,122,[124,136],138,139,[142,145],[147,154],[156,167],[169,173]],
"sio":[0,1,4,6,[10,12],14,22,23,26,27,30,32,33,36,39,40,42,43,45,48,52,55,[59,63],[66,92],[94,96],100,[102,106],108,109,[111,113],[115,122],124,126,128,[130,133],[135,145],[147,152],158,159,[162,167],[171,173]],
"sir":[2,4,16,59,66,91,115,142,150,159,168,173],
"sis":[2,3,10,30,31,34,35,38,44,66,85,88,91,94,95,113,115,118,122,123,128,139,144,155,157,158,164,170,173],
"sit":[1,2,3,10,12,16,[21,24],29,31,34,35,37,40,44,45,[47,49],54,55,57,59,60,62,64,66,69,80,81,84,85,[87,89],[91,101],103,104,111,113,115,118,119,122,124,126,128,[133,136],142,145,146,150,153,154,[156,164],166,167,169,170,172,173],
"siv":[6,29,31,40,62,68,75,80,81,[85,87],89,94,100,104,105,110,113,159,162,164,171,173],
"six":[31,89,101,113,127,133,142,145,149,159,160],
"siz":[1,3,4,22,26,28,31,40,41,43,47,53,59,62,75,77,80,81,[84,87],91,93,94,[103,105],108,109,111,113,[117,119],121,124,[126,128],132,134,142,145,147,149,[158,160],162,163,170,172,173],
"sjo":[34],
"sk7":[94],
"sk8":[94],
"sk_":[73,94,113,115,126,166],
"skb":[35,55,92,113,116,126],
"ske":[10,48,60,75,115,122,123,126,139,151,[158,160],162,164,166,169],
"ski":[1,14,20,28,30,73,81,85,91,94,108,113,115,122,126,158,160,162,172,173],
"skm":[89],
"skp":[55],
"sks":[40,88,89,92,94,99,100,105,113,115,130,135,143,150,156,[158,160],162,166,167,[171,173]],
"skt":[100],
"sky":[1,48,59,70,74,88,89,91,92,96,100,108,111,113,115,117,119,123,124,130,139,143,147,148,150,151,154,158,159,[164,166],170],
"skz":[94],
"sla":[12,26,28,68,85,[87,89],91,92,94,96,102,104,113,115,117,118,123,133,136,139,143,147,[158,161]],
"sle":[122],
"sli":[1,26,81,88,89,94,101,119,122,124,145,147,158,162],
"sll":[30,72,91,94],
"slo":[1,3,4,10,12,22,26,30,31,35,37,39,40,48,49,58,59,62,66,81,[87,89],[94,96],100,104,108,113,115,117,122,127,142,147,158,161,162,170,172,173],
"sly":[12,14,32,83,84,89,94,100,105,113,116,117,122,126,128,139,147,149,150],
"sma":[4,10,26,31,35,38,40,48,58,63,66,68,73,77,78,81,84,85,88,89,94,100,104,108,113,118,122,128,132,133,136,140,141,143,144,147,154,158,159,161,170,172,173],
"sml":[122],
"sms":[105],
"sna":[105,122,130,150],
"sne":[149,159,172,173],
"sni":[0,91,100,113,144,151,158,159,166],
"snt":[113],
"snu":[161],
"so-":[87],
"soc":[40,89,90,94,110,112,118,122,132,159],
"sof":[1,61,75,97,105,113,122,131,140,162,166,167],
"sol":[1,2,8,11,12,17,23,24,26,31,37,40,46,52,54,55,59,60,65,66,[73,77],80,81,[84,86],88,89,91,92,94,98,100,[102,105],[107,109],[111,113],119,122,[124,128],130,133,134,143,144,[147,150],152,156,[158,162],164,166,167,169,[171,173]],
"som":[1,2,3,6,[14,16],19,[22,24],28,30,31,34,35,37,40,42,46,48,49,56,59,60,63,72,[74,76],81,[83,89],94,96,102,104,105,108,109,113,114,[118,120],122,124,125,[127,129],133,135,136,[139,144],146,148,150,156,158,159,[161,163],[166,168],[170,173]],
"son":[1,2,4,12,14,31,35,37,40,44,45,48,52,54,[59,62],69,[75,77],81,[83,90],92,94,[100,105],108,109,111,113,115,116,118,119,122,[124,126],128,130,131,133,[136,142],144,145,[147,149],151,154,[156,158],162,[164,166],170,171,173],
"soo":[68,122],
"sop":[159,173],
"sor":[1,13,18,22,26,30,40,59,91,94,95,100,101,[103,105],108,111,113,115,122,128,130,131,137,140,159,160,164,168,170],
"sou":[1,12,30,35,[38,40],42,48,55,62,67,77,78,94,95,97,98,[100,105],107,108,110,111,113,115,[117,119],121,122,124,[126,128],[130,134],[136,140],142,143,147,149,150,[152,162],[164,167],[169,171],173],
"sov":[40],
"spa":[26,31,37,40,45,75,77,85,90,103,105,113,115,119,122,126,130,132,133,150,154,158,[161,163],167,168,172,173],
"spb":[100,104],
"spe":[[0,4],6,12,[17,19],21,22,26,30,31,34,35,37,39,42,48,54,[58,61],64,66,70,73,78,81,[85,89],91,92,[94,96],100,[103,105],111,113,115,[117,122],124,[126,128],130,131,133,135,138,139,152,[157,166],[170,173]],
"spi":[84,100,105,117,128,135,159,161,162,171],
"spl":[19,31,35,40,54,58,60,66,70,75,77,85,[88,91],94,96,100,101,122,128,142,144,145,158,159,161,162,167,173],
"spn":[113],
"spo":[16,26,48,74,84,89,94,97,100,104,105,114,117,119,120,122,124,128,134,135,145,148,[159,162],170],
"spr":[30,36,86,100,113,126,133,147,161,162,167,173],
"sql":[15,31,[36,38],41,159],
"sqr":[154],
"squ":[31,48,105,121,154],
"src":[101,126,157],
"srl":[72,91,94,119],
"srq":[88],
"srx":[3],
"ss-":[115,170],
"ss7":[105],
"ss_":[126],
"ssa":[10,12,24,79,81,113,118,128,130,158,162],
"ssb":[126],
"ssd":[72,92],
"sse":[[0,6],8,[10,13],16,[22,24],26,27,[30,32],34,35,42,[44,48],54,55,58,[60,62],66,[69,71],73,74,[76,78],81,[85,89],91,92,94,96,[100,102],104,[106,108],111,[113,122],124,126,[128,130],133,134,138,139,[143,145],148,150,151,154,[157,164],166,[169,173]],
"ssf":[12,122,128],
"ssi":[1,2,3,6,10,12,14,16,18,20,[22,24],[26,32],34,37,40,43,44,47,48,51,[54,56],59,60,66,[68,70],73,74,[78,82],[84,90],92,94,97,100,102,104,105,[109,113],115,[117,121],123,125,126,128,129,131,132,[135,137],[139,142],144,[147,152],154,[158,164],[166,168],170,171,173],
"ssl":[32,83,113],
"sso":[1,18,22,40,59,75,83,89,90,94,100,101,103,104,[110,112],118,122,128,132,159,160,164,168],
"ssp":[161],
"sss":[0,1,6,12,16,22,23,60,70,71,78,113],
"sst":[163],
"ssu":[10,12,26,30,33,34,49,59,60,66,75,81,84,88,89,91,94,100,108,111,113,115,126,128,132,135,142,145,148,150,154,155,158,[160,162],164,168,170,172,173],
"ssw":[72,92],
"st-":[24,29,35,56,87,94,121,131,143,159,172,173],
"st_":[24,31,39,54,113,115,143,157],
"sta":[0,2,4,10,12,14,23,24,26,27,[29,31],[33,35],37,40,43,44,47,48,50,53,55,[57,59],62,66,70,[73,91],[93,97],99,100,104,105,[108,111],[113,115],117,118,[120,122],[124,126],128,129,[131,138],140,143,144,[146,152],154,155,[157,164],[166,173]],
"stb":[47,138],
"stc":[47,138],
"std":[0,19,54,58,75,79,81,[94,96],100,105,[108,110],113,114,117,119,120,124,129,131,140,170],
"ste":[[0,4],6,7,10,12,14,16,19,20,[22,24],26,[29,32],34,[36,40],43,48,52,54,[57,61],66,[70,72],[74,78],80,81,[85,89],[91,97],[99,105],108,111,[113,119],121,122,[124,128],[130,134],[136,142],[144,151],154,[156,167],[169,173]],
"stg":[15,31,[36,38],41],
"sti":[1,3,12,16,19,26,28,30,31,35,40,44,47,48,51,57,59,60,64,66,74,75,80,81,83,84,[86,89],93,94,99,100,105,109,[111,116],[118,120],122,124,[126,132],134,[136,139],143,146,148,150,[158,167],[170,173]],
"stl":[2,19,47,81,86,100,115,122,126,128,133,139,150,152,159,162],
"stm":[1,30,59,77,88,89,99,100,108,113,116,119,124,166],
"stn":[100,123],
"sto":[0,1,2,10,14,15,19,22,[26,32],[37,40],44,47,50,54,55,60,66,69,[75,77],80,81,[84,86],[88,91],94,100,104,105,110,113,115,[117,122],124,126,128,129,131,133,134,[136,140],142,[144,146],149,151,155,[158,163],167,170,171,173],
"stp":[31,39,47,130],
"str":[[0,7],[10,14],16,17,[19,24],[26,28],30,31,[33,37],[39,42],[45,47],[49,51],[53,55],[58,62],[64,74],76,77,[79,81],[83,92],94,[96,113],[115,124],[126,128],[130,140],[142,150],152,154,[156,173]],
"sts":[[0,3],19,22,26,30,31,34,35,[39,41],47,66,73,75,80,81,84,85,[87,89],91,93,94,98,100,108,111,113,115,124,[126,129],138,139,144,147,150,151,154,158,159,161,162,164,166,167,170,171,173],
"stu":[24,35,47,55,79,81,84,85,88,89,94,96,122,128,131,143,146,162,171],
"stw":[116],
"sty":[82,110,147,167],
"sua":[13,29,35,37,40,60,80,81,94,102,122,123,126,128,133,159,162,172,173],
"sub":[2,10,18,30,31,34,40,44,45,47,48,54,60,66,69,70,73,75,77,81,86,[88,91],[94,97],99,100,102,104,107,108,111,113,[118,120],124,126,130,134,136,139,142,144,145,[147,149],152,153,156,[158,160],162,168,[171,173]],
"suc":[[10,12],26,28,29,31,32,35,37,[40,42],44,46,55,74,75,83,84,86,89,94,[99,101],104,105,109,[111,113],115,[117,122],[126,128],131,133,134,136,137,139,142,145,148,150,154,158,159,162,166,168,172,173],
"sud":[91],
"sue":[26,40,49,66,73,75,81,84,88,111,113,115,128,132,135,138,145,154,158,160,162,173],
"suf":[2,91,97,100,113,115,118,124,128,134,136,144,147,149,150,158,159,161],
"sug":[87,126,139,161,170,173],
"sui":[2,28,30,59,69,77,86,88,92,95,100,111,113,115,150,164,166,170],
"sul":[[0,4],6,10,12,14,16,19,22,23,26,30,31,35,39,40,42,47,48,51,52,54,55,[59,64],66,67,[69,71],74,[77,82],[84,89],[91,95],[99,101],[103,109],112,113,115,116,118,119,121,123,124,126,128,130,131,[133,137],139,140,142,144,145,[147,152],154,[156,160],[162,167],171,173],
"sum":[0,1,12,16,19,26,[31,34],37,38,40,41,47,48,52,54,59,60,62,74,75,77,78,84,85,[87,89],91,94,100,102,104,105,108,111,113,115,118,119,121,122,124,126,128,130,131,134,136,137,139,140,142,144,145,[147,150],[153,155],[157,162],[164,166],168,[170,173]],
"sun":[81],
"sup":[15,16,18,20,23,27,28,37,38,67,69,70,72,74,75,88,89,91,96,100,102,104,105,[107,109],[114,116],118,123,126,128,134,[136,138],140,143,147,152,153,161,162,[164,166],170,171],
"sur":[0,1,2,4,10,12,30,35,40,48,49,54,60,62,[65,67],72,75,81,83,84,[87,89],94,100,104,105,111,113,117,[119,122],124,[126,128],130,131,135,136,143,145,146,159,167],
"sus":[81,105,120,126,128,130,132,139],
"sut":[87],
"suw":[13,88],
"svc":[128,131,137,140,141],
"sve":[31,162,164],
"swa":[1,2,12,20,22,59,60,66,[68,71],85,[87,89],94,96,100,102,113,131,140,142,147,152,157,158,161,170],
"swb":[6,30,66,71,72,92],
"swe":[1,26,[87,89],96,100,102,105,109,113,124,136,137,152],
"swi":[12,29,68,75,112,122,133,141,147,148,158,159,161,162,166,173],
"swl":[47],
"sxb":[124],
"sxw":[124],
"sy-":[75,159],
"sym":[40,94,108,155,173],
"syn":[35,47,57,81,88,89,111,122,132,146,162,163],
"sys":[31,37,43,75,81,86,87,92,104,113,114,122,125,132,136,138,162,167,173],
"sze":[51],
"szu":[81],
"t&t":[47],
"t-a":[12,45,55,59,60,66,68,69,71,78,[85,89],94,98,102,115,118,119,130,134,135,143,144,156,159,164,166],
"t-b":[1,69,89,124,126,130,135,158,159,162],
"t-c":[56,101,170],
"t-d":[14,113,160],
"t-e":[92,111,119,124,159],
"t-f":[81,88,91,101,159],
"t-h":[142],
"t-i":[2,86,110,162],
"t-l":[1,40,88,89,115,130,159,166,173],
"t-m":[45,89,92,94,[99,101],113,117,118,121,131,138,150,162],
"t-o":[12,54,55,59,60,66,68,69,80,85,86,88,89,92,94,100,113,115,118,134,144,157,162,164,166,171],
"t-p":[1,35,78,87,94,113,150,158,172],
"t-r":[172,173],
"t-s":[6,24,29,59,74,80,85,88,89,92,126,130,135,161,166,167,171],
"t-t":[32,106,143,168],
"t-v":[138],
"t-w":[40,88,97,162,166],
"t-x":[54,87,88,94,118,135,151,157,159],
"t12":[55],
"t16":[119,124,158,162],
"t1_":[94],
"t2i":[10],
"t32":[11,46,54,108,113,119,124,131,142,150,156],
"t3_":[71],
"t52":[10],
"t5_":[70],
"t64":[46,59,101,149,154],
"t8-":[165],
"t8_":[1,26,119,124,131],
"t8x":[104],
"t_0":[118],
"t_8":[118,126],
"t_a":[143],
"t_b":[157],
"t_c":[24,113],
"t_d":[31],
"t_e":[88,91,94,113,115,117,120,128,131,137,140],
"t_f":[31,125],
"t_i":[10,108,115,131,137,140],
"t_m":[48,88,125,161],
"t_o":[53],
"t_p":[45,158],
"t_s":[24,39,113,120,157],
"t_t":[31,39,58,100,125],
"t_u":[126],
"t_z":[54],
"ta!":[22],
"ta6":[30],
"tab":[[1,4],[13,16],19,22,23,26,28,30,31,36,37,46,47,59,66,[68,70],73,74,77,80,81,85,86,[88,96],98,100,102,108,109,111,113,115,118,119,121,122,126,128,[132,134],143,145,150,[158,162],164,166,167,170,172,173],
"tac":[24,26,29,43,47,105,129,142,144,149,156,159,162],
"tad":[76,173],
"tag":[2,24,39,61,62,81,84,85,91,92,94,100,105,108,113,128,134,136,157,158,161,163,167],
"tai":[1,2,6,10,12,14,16,19,22,26,30,31,34,37,40,[47,49],62,66,67,70,71,74,77,[79,81],83,84,[86,89],[91,96],100,101,104,105,108,109,111,113,115,[118,122],124,126,128,129,133,134,142,[144,146],149,150,153,154,[157,160],162,164,167,170,172,173],
"tak":[26,31,35,47,66,74,79,[82,84],94,96,100,105,110,113,118,119,122,128,131,140,[146,148],[157,159],[161,163],168,170],
"tal":[12,16,26,35,40,46,47,66,69,76,81,88,89,94,104,105,112,113,115,122,124,125,128,131,132,134,[144,148],152,155,158,[161,163],168,[171,173]],
"tam":[122],
"tan":[0,1,2,4,10,12,22,23,26,27,30,34,39,40,43,44,47,48,53,55,57,59,60,62,74,77,78,81,82,84,[86,91],[93,95],97,99,100,104,105,108,109,[113,115],117,118,[120,122],126,128,[131,133],135,136,143,144,[148,152],154,155,[157,164],166,167,[169,173]],
"tar":[30,37,40,50,57,62,70,73,75,77,78,81,84,88,94,108,110,113,115,119,122,124,126,128,[130,133],137,140,143,144,[147,150],154,[158,162],164,[166,168],170],
"tas":[2,12,14,50,67,75,86,87,90,118,121,126,143,158,159,167,172,173],
"tat":[[1,4],6,[10,14],16,17,22,24,26,30,31,33,35,37,39,40,42,50,[54,56],[58,62],64,66,[68,72],74,76,77,80,81,[83,91],[94,98],100,101,104,105,[107,109],111,[113,115],[117,122],[124,128],[130,140],142,145,[147,150],152,154,[156,162],[164,171],173],
"tax":[35,47,88,89,122,162],
"tay":[59,96],
"tb_":[138],
"tbh":[46,167],
"tbl":[104],
"tbo":[122],
"tcc":[92,96],
"tch":[2,3,4,12,29,37,40,54,58,66,68,75,77,81,89,90,94,100,112,113,115,118,119,121,122,126,128,130,[133,136],141,142,[144,148],150,[157,159],161,162,166,167,173],
"tco":[128,143,159,162,163,173],
"tcw":[47],
"td2":[0],
"td3":[0],
"td_":[131,140],
"tda":[1,12,59],
"tdc":[75],
"tde":[160],
"tdl":[96],
"tdq":[11,149,150],
"te-":[1,40,54,56,59,60,[88,91],94,97,99,100,102,115,[117,119],122,126,130,134,138,139,142,149,156,159,171],
"te0":[14],
"te2":[72],
"te4":[72],
"te_":[104,121,131,137,140],
"tea":[2,6,10,26,29,40,59,60,66,76,88,89,92,100,113,115,118,119,122,126,136,138,140,148,150,158,159,162,173],
"tec":[1,30,[32,34],[39,41],46,48,54,76,81,84,[88,91],94,[96,100],104,105,110,113,115,118,119,[122,124],126,128,132,138,140,144,154,[157,160],162,164,[171,173]],
"ted":[[0,6],9,10,12,[14,16],18,19,[22,24],26,[28,35],[37,40],[42,48],54,55,[57,62],[64,70],[74,77],[80,92],[94,97],[99,102],104,105,[107,141],[143,147],[149,154],[156,168],[170,173]],
"tee":[109,122,145,148,149,159,160],
"tef":[105,135],
"teg":[10,21,26,30,32,35,[37,41],44,46,47,52,61,62,65,72,75,[79,81],83,84,86,92,95,[99,101],105,107,109,111,113,116,117,120,122,125,131,132,135,136,141,142,145,148,150,153,154,157,159,162,164,165,170,171],
"tei":[159,161],
"tel":[1,2,10,12,16,29,34,40,42,43,51,54,56,59,60,65,66,68,70,73,74,81,[86,89],91,94,97,98,100,101,[104,107],109,111,113,[116,119],[121,124],126,128,130,131,135,136,[138,140],144,145,147,[158,160],162,[164,166],170,173],
"tem":[7,15,26,31,35,37,43,50,58,75,76,81,84,[86,88],91,92,[94,96],99,100,104,105,108,111,[113,115],[117,119],122,124,125,128,132,133,136,138,139,147,148,[158,160],162,166,167,170,173],
"ten":[[0,4],6,9,10,12,14,19,22,[26,28],30,31,34,35,37,38,40,42,48,50,54,55,[59,62],66,[68,71],[73,78],81,[84,92],94,95,97,99,100,[104,106],108,111,113,[115,122],124,[126,128],[130,141],[143,145],[147,150],152,154,155,[157,167],[170,173]],
"tep":[1,4,6,10,16,20,22,24,30,40,[57,59],66,70,71,76,78,[85,89],91,94,95,97,100,101,104,113,115,118,119,121,124,126,130,134,138,142,144,149,150,[156,160],[164,166],170,173],
"ter":[[0,7],9,10,12,14,16,[19,26],[28,37],39,40,[44,56],[58,62],[65,78],[80,105],[108,111],[113,119],[122,124],[126,139],[141,152],154,155,[157,173]],
"tes":[[0,6],12,14,16,19,22,23,25,26,30,31,34,35,37,39,40,42,43,[47,49],51,54,55,[58,60],62,65,66,[69,75],[77,82],[84,89],[91,95],[97,104],106,108,111,[113,122],124,[126,136],[138,147],[149,152],[156,167],169,[171,173]],
"tet":[91,158],
"teu":[105,122],
"tev":[18,31,57,80,111,161,162],
"tew":[16],
"tex":[1,2,16,19,24,26,30,31,34,35,48,52,54,55,67,69,71,[84,91],94,100,104,105,110,111,[113,115],118,119,121,122,126,128,132,135,137,144,[158,160],162,[164,167],170,172,173],
"tf-":[35,40,128,157,172,173],
"tf1":[88],
"tfi":[40,149],
"tfo":[1,4,28,35,40,60,88,89,94,100,101,115,119,128,139,143,144,150,157,159,164,167,172,173],
"tfu":[126],
"tge":[31,37],
"tgo":[30],
"tgr":[15,31,[36,38],41],
"th-":[24,26,29,100],
"tha":[[0,6],10,12,15,16,22,[26,31],[33,37],40,[42,45],47,49,54,55,[58,60],62,[64,67],70,[74,92],[94,97],[99,102],[104,140],[142,167],[170,173]],
"the":[[0,7],[9,12],[14,16],[18,24],[26,52],[54,173]],
"thi":[[0,4],6,7,10,12,[14,19],[21,24],[26,35],[37,40],[42,52],54,56,[58,92],[94,101],[103,105],[108,122],[124,148],[150,154],[156,160],[162,167],[169,173]],
"thm":[0,1,2,4,6,10,12,14,16,18,[22,24],26,28,30,34,35,40,42,44,45,47,52,54,[59,62],64,66,[68,71],74,77,78,[84,97],100,101,104,107,108,111,113,115,[117,119],121,122,124,126,128,130,131,[133,140],[142,145],147,149,150,[153,157],[159,162],164,165,167,168,170,171,173],
"tho":[[0,4],10,12,14,16,21,[24,27],[29,35],40,44,45,54,55,59,66,69,70,72,[74,76],[78,92],[94,96],100,101,104,105,108,[112,115],[118,122],[124,129],142,146,147,150,152,154,[156,162],164,166,167,169,170,172,173],
"thr":[0,2,3,5,14,16,23,34,40,[46,48],[52,54],[59,61],66,[72,74],76,77,81,84,85,88,89,91,[100,102],104,105,108,113,115,[117,120],122,124,[126,130],135,136,139,141,144,145,150,[157,160],162,167,172,173],
"ths":[14,28,37,47,49,75,100,145,150,155,158,159,162,166,168],
"thu":[[0,4],10,21,26,30,35,39,40,44,45,[59,62],[66,68],71,77,78,81,[84,89],[91,105],110,111,[113,115],[117,119],121,122,[124,128],[130,140],[142,145],[147,150],[152,167],169,170,173],
"ti-":[26,132,157,162,173],
"ti1":[119,124],
"ti3":[115],
"tia":[1,14,24,26,30,35,66,70,78,81,85,88,89,91,[93,95],100,115,[118,120],126,134,136,137,139,[141,143],149,150,152,156,158,160,167,170,171],
"tib":[105],
"tic":[1,2,6,[12,14],18,23,26,31,34,35,37,40,44,47,48,54,60,64,66,70,74,75,78,81,82,84,[86,92],94,100,101,104,105,[107,109],113,[117,120],122,[124,127],[131,136],[139,141],146,147,149,150,[153,160],162,164,166,167,[169,171],173],
"tid":[37,96],
"tie":[19,24,31,40,48,81,88,100,105,109,113,118,122,134,135,137,144,147,158,164,170],
"tif":[31,74,88,89,91,113,158,161,162,170,173],
"tig":[75,77,81],
"tih":[30],
"til":[6,14,26,37,40,51,64,80,84,86,91,94,100,101,105,108,109,113,115,116,[120,122],124,[126,128],134,136,143,145,146,150,154,155,[158,160],162,164,165,[170,173]],
"tim":[[0,4],6,12,14,19,22,26,[29,31],[34,37],40,[47,49],54,59,60,62,63,66,70,73,75,77,78,[80,82],[85,89],91,92,[94,97],[100,102],104,105,108,109,111,113,[115,117],119,121,122,[124,128],130,131,[133,137],139,140,143,[145,151],154,155,[158,162],[164,167],170,172,173],
"tin":[0,1,3,10,12,16,18,19,23,24,26,[28,31],[34,37],39,40,42,44,45,47,48,50,54,57,59,60,62,66,[68,71],[73,78],80,81,[83,102],104,105,109,[111,116],118,119,121,122,[124,126],[128,136],138,139,[141,150],[152,154],[156,173]],
"tio":[[0,6],[9,24],[26,32],34,35,[37,56],[58,173]],
"tip":[6,9,12,22,28,30,34,40,48,55,59,60,66,69,70,81,82,84,86,88,89,91,94,113,119,121,122,124,132,[134,136],142,144,148,154,[157,159],[162,165]],
"tir":[26,95],
"tis":[10,26,31,35,40,66,81,91,105,113,126,128,132,138,158,159],
"tit":[31,37,81,89,91,95,105,122,126,128,134,137,152,[158,161],167],
"tiu":[9,20,22,31,35,39,54,[59,62],66],
"tiv":[2,[10,12],14,21,23,24,31,34,37,40,44,48,62,66,74,81,84,85,[87,89],94,[98,100],105,107,109,113,114,117,118,122,124,126,128,130,132,133,135,136,143,150,[152,154],[158,167],[170,173]],
"tiw":[35],
"tiz":[35,100,132],
"tla":[115,139,150,152],
"tle":[22,[30,32],48,70,81,82,88,91,93,96,100,161,162,167,173],
"tli":[2,6,10,12,16,22,30,88,89,91,111,113,117,124,126,161,164,173],
"tll":[139],
"tly":[[0,4],12,23,26,29,30,35,40,42,47,55,57,59,60,64,67,74,75,81,[84,86],88,89,91,94,100,101,[104,108],111,[113,115],118,119,[122,124],[126,128],130,131,133,135,136,138,140,142,143,145,147,148,150,152,154,[157,162],[164,168],170,171,173],
"tma":[26,89,91,92,100,104,105,118,130,133,139,143,145,156,[158,160],169,170],
"tmb":[99,113],
"tmd":[116,166],
"tme":[1,30,59,77,81,88,89,100,108,119,124],
"tmp":[55],
"tmw":[99],
"tna":[173],
"tne":[30,47,56,105],
"tni":[100,123],
"to-":[26,35,75,88,91,115,121,123,131,143,159,168,173],
"to_":[60,87,147],
"toa":[30,31,39],
"toc":[159],
"tod":[88,89,94,96],
"toe":[89],
"tof":[40],
"tog":[1,14,55,69,78,101,113,115,119,124,134,142,144,146,149,160,161,171,173],
"toi":[113],
"tol":[87,109,113],
"tom":[1,28,54,70,75,86,100,121,122,126,128,131,137,140,167,171],
"ton":[16,100,105,128,158,159,165],
"too":[35,40,42,57,68,73,77,[80,82],89,94,96,99,105,113,119,122,123,139,140,142,144,151,158,160,163,167,171,173],
"top":[29,31,35,47,76,100,113,122,123,126,146,159,170],
"tor":[0,1,2,6,10,12,[14,16],19,22,[26,28],[30,33],[37,40],[42,44],50,53,55,57,60,66,69,70,[73,75],77,[80,82],84,85,[87,97],[99,101],104,105,[108,122],[124,140],142,[144,146],151,[153,156],[158,164],166,167,[170,173]],
"tos":[47,81,84,122,140],
"tot":[12,26,40,47,69,76,81,88,89,94,105,108,113,115,122,132,134,[144,147],155,158,162,172,173],
"tou":[94,108,113,145,159],
"tov":[111,117,137,140,164],
"tow":[28],
"toy":[144,159,160],
"tp_":[27],
"tpa":[158],
"tpe":[1,94,100,124],
"tpl":[47,162],
"tpr":[31,81,128,130,132],
"tps":[47,144,159,160,[163,165]],
"tpu":[14,39,43,50,63,66,71,74,75,84,85,88,89,91,94,108,113,115,116,126,128,130,135,138,143,145,148,[157,159],[162,164],169,173],
"tqb":[91],
"tr_":[2],
"tra":[1,3,4,7,10,12,16,18,[22,24],26,[28,31],34,35,37,40,44,45,47,53,59,60,[67,69],73,75,[80,82],[84,92],[94,96],[100,102],104,105,107,108,[112,119],[122,124],126,128,129,[131,133],[135,140],[142,148],[150,162],164,[166,168],[171,173]],
"trb":[3],
"trc":[30],
"trd":[3],
"tre":[4,7,10,19,24,26,31,35,37,40,44,70,86,91,93,94,100,101,104,112,118,120,122,127,130,[132,135],139,144,146,147,155,[158,160],167,168,170],
"tri":[1,2,10,14,15,19,23,26,28,[30,32],[35,37],[39,41],49,53,54,59,60,62,66,67,[69,74],76,77,79,81,83,84,[86,89],91,94,96,98,100,102,[104,106],108,109,111,113,116,119,120,[122,124],[126,128],[131,135],138,140,[142,144],147,148,150,[156,159],161,162,164,166,167,[170,173]],
"trl":[54],
"trm":[100,113,123],
"trn":[2],
"tro":[[1,6],12,24,26,30,31,34,35,37,40,47,48,59,61,62,66,[68,71],[73,78],81,[85,91],94,95,97,[99,101],104,105,108,109,111,[113,122],124,[126,140],[142,145],147,[149,162],[164,167],[170,173]],
"trp":[36],
"trq":[3],
"trs":[2,49,96,100,113],
"trt":[109,113],
"tru":[[0,6],[10,14],16,17,[19,24],[26,31],33,35,39,42,43,[45,47],[50,52],54,55,[58,61],[64,68],[70,74],76,77,80,81,[85,92],94,96,97,[99,111],113,[115,128],[130,140],[142,145],[148,150],152,154,[156,160],[162,173]],
"trx":[3,100],
"try":[2,12,14,24,28,31,36,43,48,66,68,76,77,80,84,105,113,122,126,159,164,167,168,[171,173]],
"ts_":[37,113],
"tsc":[9],
"tsd":[154],
"tse":[40,58,74,101,118,124,128,160,163,167],
"tsi":[26,81,118,138,145,172,173],
"tso":[40],
"tsp":[126],
"tsq":[31],
"tsv":[31],
"tsw":[47,161],
"tta":[2,100,105],
"tte":[1,10,12,19,26,31,34,35,37,40,49,55,[58,60],66,68,69,[73,76],81,84,[87,89],91,92,94,[96,98],100,104,105,108,109,113,[115,124],[126,128],130,131,133,135,136,[138,141],[143,152],[157,167],170,172,173],
"tth":[104,124],
"tti":[1,10,39,48,50,54,81,88,91,95,101,104,105,110,118,119,122,125,128,133,135,136,[142,144],150,158,159,161,162,166,172,173],
"ttl":[22,30,48,70,81,82,88,93,96,162],
"tto":[70,122],
"ttp":[19,57,144,146,147,159,160,[163,165]],
"ttr":[40],
"tty":[12,73,74,81,84,89,91,94,100,104,105,109,[113,115],121,128,129,137,158,160,171],
"tu1":[91,119,124,130,139,147],
"tu2":[158,159],
"tua":[29,35,37,48,76,81,84,91,100,102,113,116,[118,121],123,124,126,139,143,158,159,162,164,172,173],
"tub":[69,70,81,113],
"tuc":[131],
"tud":[24,35,81,84,85,88,89,94,96,137],
"tue":[122,167],
"tuf":[47,96,143,146,171],
"tug":[173],
"tui":[114,122],
"tun":[1,2,6,10,34,51,65,66,68,70,73,88,89,94,98,100,104,106,109,111,113,116,118,122,128,130,[135,140],145,159,165,173],
"tup":[35,37,79,91,113,122,128,135,136,147,162],
"tur":[1,4,6,10,12,24,26,27,31,34,35,41,43,48,[54,56],58,73,75,[80,84],[88,90],92,96,100,[103,105],107,[109,111],113,114,116,117,119,120,[122,129],[132,136],144,147,152,[157,162],164,167,168,[170,173]],
"tus":[131,137,140,161],
"tve":[92],
"tvl":[162],
"twa":[1,61,97,105,113,122,166,167],
"twe":[2,14,22,26,40,82,83,88,89,94,100,104,108,113,121,128,130,137,139,140,142,148,154,162,164,168,173],
"twg":[157],
"twi":[1,4,21,29,47,51,52,54,88,89,91,[100,102],104,107,[113,115],124,126,155,160,165,170,173],
"two":[2,3,4,6,8,12,16,20,22,26,28,[30,32],34,35,37,40,54,[58,60],62,[64,66],69,70,73,74,76,77,80,81,[83,85],[87,89],91,92,94,95,97,[99,102],[104,108],111,[113,115],118,119,[122,135],137,[139,145],[148,153],155,[157,159],[161,164],166,[168,173]],
"tx6":[115,139,150,152],
"txt":[47,54,87,126],
"ty!":[122],
"ty-":[162],
"tyc":[122],
"tyl":[147,167],
"typ":[26,27,31,37,38,41,42,46,53,55,59,75,76,79,81,82,84,104,105,110,112,113,115,119,120,122,124,[127,130],133,138,148,159,162,164,170,171],
"tzc":[103,158],
"u-g":[163],
"u-s":[22],
"u1~":[91,119,124,130,139,147],
"u2~":[158,159],
"u64":[126,169],
"u8_":[113,119],
"u_s":[89,139],
"uab":[81,113],
"uad":[1,91,100,104,113,159],
"uag":[2,26,28,32,33,79,[81,83],100,105,109,114,120,122,128,159,162,167,173],
"uai":[40],
"ual":[1,2,5,12,13,21,29,35,37,40,43,54,57,60,61,65,68,76,77,80,81,84,85,88,89,91,92,94,95,[98,100],102,108,113,115,116,[118,124],126,128,130,133,[136,139],[142,144],[147,151],[153,160],162,164,166,[170,173]],
"uan":[89,126],
"uar":[48,121,146,148,154,159,160],
"uat":[18,23,29,32,34,35,48,74,79,82,88,91,94,100,108,113,115,117,118,120,121,126,127,130,136,141,149,151,154,160,161,172,173],
"ub!":[105],
"ub-":[86,100,104,[118,120],124,130,145,160,162],
"ub_":[136],
"uba":[77,94,111,113,130],
"ubb":[139,160],
"ubd":[2],
"ube":[81,94,162],
"ubf":[158],
"ubj":[40,104,[171,173]],
"ubl":[1,3,10,37,39,45,47,73,83,91,93,95,104,113,119,128,131,134,159,162,164,167,170,171],
"ubp":[18,100],
"ubr":[77,90,95,97],
"ubs":[2,12,30,31,40,48,54,70,75,77,81,89,95,96,99,100,108,113,118,124,142,144,[147,149],[158,160],162],
"ubt":[10,18,30,34,40,44,45,60,69,81,83,88,90,94,102,107,113,126,136,142,144,147,148,152,153,156,158,162,168,171],
"ubu":[88,89,91,96,100,107,113,119,124,130,139,147,158,159],
"ubv":[73,99,119,124,126,162],
"ubw":[31,66,88,91,113,134,158,159,171],
"ucc":[28,31,111,122,128,159],
"uce":[1,2,3,5,10,12,26,31,59,60,64,66,68,70,73,75,81,85,88,89,91,92,94,100,105,109,111,[113,117],122,126,128,129,134,136,139,141,143,150,151,153,157,159,160,[162,164],166,167,171,173],
"uch":[1,4,[10,12],22,26,[28,32],35,37,[40,42],44,46,55,58,61,64,68,74,75,81,[83,86],89,91,94,[99,101],104,105,108,109,[111,113],115,[117,122],[126,128],130,131,133,134,136,137,139,142,145,148,150,154,[158,160],162,163,166,168,172,173],
"uci":[[70,72],74,81,85,[87,89],99,105,113,122,128,135,138,156,157,160,162,170],
"uck":[100,131,138,160,171],
"ucl":[113],
"uco":[47],
"ucs":[128],
"uct":[[0,6],[10,13],16,17,[19,24],26,27,30,31,[33,35],37,39,40,42,[45,48],50,51,54,55,[58,62],[64,74],[76,78],80,81,[85,92],[94,97],[99,111],113,[115,124],[126,140],[142,145],[147,173]],
"uda":[137],
"udd":[87],
"ude":[2,4,76,81,84,88,94,96,100,101,105,113,118,119,128,133,135,137,140,158,161],
"udi":[28,30,35,39,40,55,84,85,88,112,117,159,162,173],
"udo":[1,26,28,31,34,[59,61],76,77,[90,92],94,104,135,140,162,163,166],
"udq":[30],
"udy":[24,85,88,89,94],
"ue!":[28],
"ue-":[154],
"ue_":[105,131,137,140],
"ued":[49,73,88,100,113,115,135,138,145,160,162,167],
"uee":[105],
"uel":[40,170],
"uen":[2,14,27,28,31,35,40,[46,48],52,64,74,85,88,89,94,98,100,104,113,117,118,126,133,142,143,145,147,150,158,159,162,163,167,170],
"uer":[15,31,37,38,40,77,132,162,167,172],
"ues":[0,1,2,12,13,23,26,[28,31],37,39,40,46,48,55,60,62,64,66,69,70,[72,74],76,81,85,86,88,89,91,94,96,97,99,100,[103,105],108,112,113,115,[117,120],122,124,126,128,[130,133],136,137,139,142,144,[149,151],[156,162],164,166,170,171,173],
"ueu":[105,122],
"uf2":[22],
"uf_":[127],
"ufb":[0,1,6,16,22,23,60,71,72,[88,91],101,104,113,115,118,126,144,145,150,152,158,173],
"ufd":[3,22,42,72],
"uff":[2,39,47,71,72,84,88,89,91,94,96,97,100,104,113,115,118,120,124,126,128,[134,136],138,[143,147],149,150,158,159,161,162,164,166,170,171,173],
"ufh":[22,72],
"ufl":[22,72],
"ufp":[16],
"uge":[26,84,94,105,108,113,122,[126,128],132,158,162,172,173],
"ugg":[86,87,126,128,139,161,170,173],
"ugh":[2,3,23,34,40,46,54,[59,61],72,74,76,79,81,85,88,89,91,94,100,104,105,108,[113,115],119,122,[125,131],142,147,150,[157,159],162,163,167,170,173],
"ugl":[81,105,109],
"ugm":[122],
"ugs":[84,128],
"ugt":[96],
"ugu":[173],
"uhw":[12,30],
"uic":[22,34,57,86,95,109,113,126,142,145,150,151,[157,159],167],
"uid":[104,122,171],
"uil":[1,2,26,31,35,37,40,45,59,70,75,81,85,88,89,91,92,94,97,[99,101],104,105,110,111,113,115,119,122,126,128,[130,132],134,135,138,139,141,147,150,[157,160],162,167,169,170,173],
"uin":[1,11,26,46,54,59,104,119,124,142,145,149,150,154,156,158,162,164,165],
"uip":[105],
"uir":[4,12,14,16,[22,24],[26,28],[30,35],40,45,46,50,51,[53,55],[58,60],65,66,[68,70],72,74,77,78,81,[84,89],91,94,97,98,100,102,104,113,115,118,121,122,126,127,[129,132],135,136,142,145,[149,151],155,[158,160],162,173],
"uis":[81,88,89,128,159,160,162,173],
"uit":[2,12,19,22,24,26,28,30,[34,37],39,40,47,[59,62],69,71,73,75,77,[84,86],88,92,94,95,100,111,[113,115],118,122,123,[126,128],132,135,139,[143,145],148,150,154,[157,159],[161,164],166,167,170],
"uiv":[5,22,59,69,84,88,94,107,133,139],
"ul_":[135],
"ula":[1,2,6,16,17,22,23,28,30,31,34,37,40,42,44,45,47,48,52,[59,62],64,[66,70],73,74,76,78,81,84,85,88,90,91,94,97,100,101,103,106,107,113,115,118,119,121,122,124,126,128,130,131,[133,142],[144,146],[148,150],152,154,156,[158,162],164,[166,171],173],
"ulb":[135],
"uld":[1,2,6,7,[10,12],16,23,26,[28,32],37,[40,44],47,50,51,[54,56],[58,61],64,66,[68,70],[73,75],77,[80,82],[84,94],96,99,100,102,105,107,[109,114],117,119,120,122,126,128,[130,134],136,[141,143],145,147,152,[156,162],[164,167],170,172,173],
"ule":[26,75,81,82,98,122,125,128,132,144,158,159,170,172,173],
"ulh":[6,30,66],
"uli":[114,118,162],
"ull":[1,6,16,26,30,31,47,55,57,59,64,66,69,72,73,77,81,82,[86,89],94,95,100,101,105,107,108,113,115,119,120,126,[128,130],133,138,149,150,[157,162],167,172,173],
"ulo":[30,88,94,159,171],
"ulp":[47,96,125,130],
"uls":[47,59],
"ult":[[0,4],6,9,10,12,14,16,19,22,23,26,28,30,31,34,35,39,40,47,48,51,52,54,55,[59,64],66,67,[69,71],74,[77,89],[91,95],[99,101],[103,109],112,113,115,116,118,119,[121,126],128,[130,137],139,140,142,144,145,[147,152],154,[156,160],[162,167],[170,173]],
"ulu":[12,30,88],
"um0":[134,159],
"um1":[134],
"um2":[134],
"um3":[134],
"um4":[9],
"uma":[122,128,162,173],
"umb":[[0,4],8,[10,12],21,23,[28,31],34,37,[39,42],44,45,47,48,52,55,[58,62],[65,71],77,78,81,[83,86],[88,95],97,98,100,102,103,[105,109],111,113,115,118,119,[121,126],128,130,132,133,135,136,138,139,[141,147],[150,156],[158,167],[169,171],173],
"ume":[1,12,23,26,33,[38,40],42,47,50,54,60,[65,68],[70,74],81,84,[87,89],91,94,100,108,[111,113],115,116,[118,120],122,123,126,[128,130],[133,136],141,142,145,148,150,[153,155],[158,164],167,168,[170,173]],
"umi":[59,75,105,113,121,128,173],
"umm":[0,7,14,19,26,31,37,40,47,48,54,62,77,78,84,85,87,91,94,113,115,119,124,130,134,136,137,140,147,157,159,162,[164,166],173],
"umn":[5,31,37,74,89,113,118,159,173],
"ump":[34,47,58,63,65,73,91,94,96,100,104,112,114,128,133,141,143,148,150,154,155,157,158,161,167],
"ums":[1,16,104,108,109,112,113,119,134,139,171],
"umu":[78,90,101,113,119,124,127,130,131,137,[139,141]],
"un-":[81,97,113],
"un_":[1,37],
"una":[1,2,10,22,34,51,65,66,68,70,73,85,88,89,94,98,100,[104,106],109,111,113,116,118,122,128,130,135,136,[138,140],159,165,173],
"unb":[119],
"unc":[1,2,3,5,10,20,22,24,26,27,30,31,35,38,[41,43],[51,55],58,60,62,63,74,76,77,80,88,95,100,104,105,[108,111],113,117,[119,122],124,[126,129],132,133,135,138,140,141,143,147,154,[156,159],162,164,165,167,170,173],
"und":[[1,4],6,9,10,12,14,16,19,23,26,30,33,35,36,38,40,[46,49],54,58,60,77,81,82,[84,86],88,91,94,100,101,105,108,110,113,[118,120],122,128,132,134,136,142,144,148,[157,160],162,164,[166,168],170,171,173],
"une":[6,128,145,159],
"unf":[1,2,10,51,65,66,73,88,94,98,100,104,109,111,113,116,122,130,135,136,138,140,165,173],
"ung":[75,122],
"uni":[2,28,47,62,69,74,75,77,80,81,88,94,99,100,104,105,113,117,118,127,128,131,137,138,140,146,[157,160],162,170,172,173],
"unk":[1,48,85,87,93,100,104,108,110,111,113,125,131,137,147,150,158,160,163,164,172],
"unl":[62,84,85,91,92,94,100,110,113,115,132,139,145,158,[162,164],172,173],
"unm":[48,100,162],
"unn":[2,19,31,33,37,60,62,69,81,100,105,109,113,114,122,166],
"uno":[171],
"unp":[6,12,16,72,88,91,94,113,128,160,170],
"unr":[1,4,6,22,35,88,91,94,95,100,105,111,113,115,117,119,124,126,128,130,139,148,158,[164,166]],
"uns":[1,5,10,12,32,37,40,44,46,52,59,69,70,82,88,94,100,102,105,107,[113,115],118,119,124,126,139,143,144,146,148,156,158,159,[162,165],168,[170,172]],
"unt":[1,3,9,10,14,16,26,[29,31],37,40,41,44,47,55,74,75,78,80,81,88,89,91,[94,97],[99,101],105,111,113,114,119,122,[124,128],[130,134],[137,140],[145,150],[152,162],166,168,[170,173]],
"unu":[13,40,60,162,173],
"uop":[123,150],
"uor":[132],
"uot":[164],
"uou":[26,73,75,77,89,91,94,133,160,166],
"up-":[0,1,16,30,66,91,94,159,173],
"up1":[4],
"up8":[4,85],
"up_":[104],
"upc":[105,111,122,162],
"upd":[0,1,[3,6],12,26,28,30,31,34,35,40,47,48,54,55,59,60,64,66,70,74,77,81,85,88,89,91,92,94,96,100,102,104,108,109,111,113,[115,120],[124,127],130,131,134,[137,140],142,144,145,150,152,[158,160],162,164,166],
"upe":[47,88,89,145],
"upf":[158],
"upg":[75],
"upi":[19,79,113,122,126,128,142,150,162],
"upl":[37,99,122,128,162],
"upo":[120,151],
"upp":[15,16,18,20,23,27,28,37,38,60,67,69,70,72,74,75,87,88,90,91,96,100,102,104,105,[107,109],[114,116],118,123,126,128,134,[136,138],140,[142,144],147,152,153,156,158,159,161,162,164,166,[170,173]],
"upr":[165],
"ups":[0,22,26,28,72,73,85,88,89,91,94,104,113,118,121,146,159,162,173],
"upt":[112],
"upv":[146],
"upw":[155],
"upy":[26,40,66,126],
"ur-":[104,113,117,145,151],
"ura":[4,6,10,12,53,75,81,[86,88],92,107,113,119,122,136,144,158,162],
"urb":[55,162],
"urc":[1,12,30,35,39,40,42,48,55,62,67,77,78,94,95,97,98,[100,105],107,108,110,111,113,115,[117,119],121,122,124,[126,128],[130,134],[136,140],142,143,147,149,150,[152,162],[164,167],[169,171],173],
"urd":[122],
"ure":[[0,4],6,10,12,22,24,26,27,[29,31],35,37,38,41,48,54,59,60,62,[64,67],[69,71],[74,76],[80,89],91,92,94,96,97,100,101,[104,106],[109,111],[113,117],[119,140],143,145,[147,150],[156,162],[164,168],[170,173]],
"urf":[165],
"urg":[81,86,147],
"uri":[26,54,79,81,84,90,94,100,102,105,113,119,[121,123],126,128,134,135,158,159,161,162,167,173],
"urk":[173],
"url":[81,146,157,167],
"urn":[1,26,31,34,35,41,43,56,58,73,88,90,100,103,109,111,117,125,126,128,132,133,135,147,152,157,159,162,164,173],
"uro":[31,122,173],
"urp":[4,12,35,40,60,66,72,81,83,89,94,104,105,111,113,121,122,124,127,128,133,136,137,139,143,146,159,162,167,171,173],
"urr":[2,10,14,34,40,48,49,66,80,81,97,100,105,109,111,113,114,117,123,126,128,130,139,[156,160],162,167,168],
"urs":[1,3,12,29,37,40,46,48,49,51,57,66,67,77,81,83,84,86,[88,90],93,100,[110,112],119,122,127,128,130,133,159,167,173],
"urt":[1,3,85,94,105,118,128,158,159],
"urz":[1,89,113],
"us-":[9,126],
"us_":[72,113],
"usa":[4,13,26,54,60,70,94,99,105,113,132,135,139,146,159],
"usb":[6,89,113],
"usd":[70,72,113],
"use":[[0,4],6,[10,12],[14,16],19,[21,23],26,[28,32],[34,38],[40,44],[46,50],54,55,[58,61],66,69,70,[73,77],[80,97],[100,102],[104,109],111,113,115,116,[118,124],[126,136],[138,145],[147,154],[156,167],169,170,172,173],
"ush":[47,48,161,170],
"usi":[1,2,4,5,12,16,22,23,26,[29,31],37,40,43,50,54,55,59,[61,64],[66,68],70,71,74,75,80,81,85,86,[88,92],94,97,[99,101],[103,105],108,109,111,113,115,[117,122],124,[126,128],[130,136],138,139,144,148,150,151,153,156,[158,164],167,169,170,172,173],
"usl":[12,14,84,89,94,100,105,113,116,117,122,126,128,139,147,149,150],
"usp":[105,120,130,159],
"usr":[35,47,128],
"uss":[1,10,22,34,40,43,66,69,88,89,111,113,126,135,139,162,173],
"ust":[[1,4],6,10,12,16,17,20,21,23,27,29,30,32,37,39,40,42,44,47,54,55,[57,59],61,64,66,69,73,[75,77],79,81,85,86,88,89,[91,94],96,[98,102],104,105,108,110,111,113,115,[117,122],124,126,128,130,131,[133,140],142,144,[147,149],154,155,[158,162],164,167,169,171,173],
"usu":[13,29,35,37,40,60,80,81,94,102,122,123,126,128,133,159,162,172,173],
"usw":[6,30,66,71,72],
"usx":[107],
"usz":[105,122],
"ut-":[1,32,100,126,164],
"ut_":[53],
"uta":[16,30,36,42,56,62,72,77,81,113,115,121,[134,136],156,159,160,162,166,171],
"utc":[128,143,159,162,163,173],
"utd":[1,12,59],
"ute":[1,8,19,22,31,35,37,40,42,49,57,60,61,66,69,72,77,78,[80,82],85,88,91,94,100,105,107,110,111,[113,115],119,120,122,124,[126,128],130,133,134,139,150,[158,161],164,167,170,171,173],
"utf":[40,128,157,[171,173]],
"uth":[1,14,59,74,75,84,100,104,112,162],
"uti":[2,6,11,12,14,17,23,24,26,29,31,35,37,40,46,48,52,59,62,66,73,74,76,77,80,81,[84,86],88,[90,92],94,98,[100,103],105,108,109,[111,113],119,121,122,[124,128],130,134,136,139,143,145,[147,150],152,154,156,[158,162],[164,167],[170,173]],
"utl":[2,6,10,12,16,22,30,88,89,91,111,113,117,124,126,164,173],
"uto":[28,30,40,75,100,111,115,117,121,128,131,137,140,162,164,167,173],
"utp":[1,14,39,43,50,63,66,71,74,75,84,85,88,89,91,94,100,108,113,115,116,124,126,128,130,135,138,143,145,148,[157,159],[162,164],169,173],
"utr":[87],
"uts":[26,66,71,74,81,84,89,94,102,113,115,118,136,142,144,145,[157,162],172,173],
"utt":[84,95,105,116,122],
"utu":[75,81,110],
"uwy":[88],
"ux-":[81,163],
"uxi":[28,115,120,127,145,159,173],
"uyi":[162],
"uys":[38,81],
"ua":[[0,173]],
"v-i":[162],
"v-v":[171],
"v16":[162],
"v24":[162],
"v31":[162],
"v3b":[26],
"v4a":[26],
"v51":[91],
"v64":[163],
"v7l":[104],
"v_e":[89,91,94,117,135],
"vab":[3,128],
"vad":[162],
"vae":[122,123],
"vai":[[1,4],10,22,28,31,35,39,40,44,45,48,50,52,54,55,[59,62],[66,71],74,77,78,[85,89],94,97,98,[100,103],[105,108],111,113,[115,119],121,123,124,126,127,[130,140],[142,145],147,149,150,[152,162],[164,166],169,170,173],
"val":[0,1,2,5,6,8,9,10,12,14,17,[20,23],26,[28,30],32,34,37,[39,41],[43,46],48,51,52,55,59,60,62,64,[67,70],[72,74],76,[78,84],[86,92],94,99,100,[102,105],[107,109],112,113,115,[117,121],[124,131],133,134,136,138,139,[141,144],[147,151],153,154,[156,164],166,[168,171],173],
"van":[2,24,39,61,62,81,92,94,100,105,108,111,113,136,145,157,158,162,163,167],
"vap":[22],
"var":[1,6,7,26,27,29,30,33,35,38,40,43,44,56,58,61,66,70,[73,75],81,84,85,88,89,91,[94,97],100,102,105,[108,111],113,115,116,[118,120],124,126,128,132,134,135,138,139,145,147,148,154,[158,160],162,164,[169,173]],
"vas":[105,122,161,167],
"vat":[1,12,47,60,68,87,88,94,99,105,123,134,135,144,152,154,157,159,160,170],
"vb2":[113],
"vbm":[91,113,115,126,131,137,140,145,164],
"vbr":[115],
"vbs":[74],
"vcc":[20],
"vcm":[101,113],
"vco":[104],
"vcv":[150],
"vdp":[123],
"vdq":[73,89,99,123,139],
"ve-":[26,35,105,159],
"ve_":[131,137,140],
"vea":[96,113,114,128,135,162,164],
"vec":[1,2,6,12,16,19,30,31,40,42,69,70,73,74,77,[87,92],[94,97],[99,101],104,108,111,113,[115,121],124,126,130,131,[133,140],144,145,151,156,158,160,162,164,166,[170,173]],
"ved":[1,4,14,26,28,30,35,37,39,40,42,44,47,49,55,60,62,64,66,69,75,80,81,[87,89],91,94,100,104,105,109,113,122,126,128,133,135,142,143,145,148,156,159,160,162,163,167,168,170,173],
"vel":[1,4,10,19,21,29,30,37,40,63,66,75,88,91,94,96,97,100,102,104,105,113,115,119,122,128,130,132,133,138,142,149,150,152,155,156,158,159,162,163,[166,168],173],
"vem":[[0,3],26,40,62,69,76,[85,87],89,100,102,105,122,126,145,158,162,173],
"ven":[2,4,6,12,[14,16],22,24,26,29,31,32,35,37,41,45,46,48,49,54,60,66,70,[74,76],[79,81],84,[86,91],93,94,99,100,105,109,111,[113,115],118,119,122,123,126,128,[130,134],139,142,145,147,149,150,[154,156],[158,163],167,168,[170,173]],
"vep":[113,161],
"ver":[[0,4],6,[10,12],14,18,[22,24],26,[28,44],[46,48],[50,52],54,55,[57,63],[66,72],[74,92],[94,96],[99,111],[113,140],[142,167],[169,173]],
"ves":[1,3,16,20,31,32,35,39,40,58,69,75,81,86,88,89,91,92,94,[99,101],105,111,113,115,118,119,124,131,136,143,145,148,150,152,158,[161,163],167,173],
"veu":[89],
"vex":[34,119,124,167],
"vey":[128],
"vfi":[150],
"vga":[123],
"vgb":[150],
"vge":[104],
"vgf":[135],
"vgw":[150],
"vhl":[88],
"via":[1,59,84,87,97,100,111,120,122,128,131,140,142,152,158,162],
"vic":[40,81,105,122,146],
"vid":[6,12,26,30,32,34,48,81,84,88,91,94,100,104,105,113,115,117,119,122,124,126,132,134,136,138,142,144,150,[156,159],161,162,164,165,171,173],
"vie":[1,9,84,105,109,111,113,122,128,134,157,160,162,167,173],
"vig":[86,147],
"vik":[122],
"vil":[1,104,162],
"vim":[122],
"vin":[26,30,35,56,59,81,85,[87,89],91,94,95,97,98,100,104,105,113,122,125,126,128,133,134,139,144,145,147,149,150,155,156,[158,160],162,163,166,167,170,171,173],
"vio":[2,12,14,18,22,24,26,29,30,34,35,40,59,66,73,75,77,81,82,84,85,88,89,91,92,94,100,103,105,108,111,113,114,116,117,[119,122],124,126,128,130,139,143,145,147,149,150,152,156,[158,162],164,165,167,168,172,173],
"vir":[30,37,76,81,116,120,128],
"vis":[0,24,26,29,30,35,48,49,62,81,84,85,113,114,118,122,124,126,128,131,[134,136],138,139,142,146,150,159,160,162,164,165,171,173],
"vit":[104],
"viz":[128],
"vi":[105],
"vla":[75],
"vle":[162],
"vli":[162],
"vlm":[162],
"vm-":[163],
"vma":[113],
"vmo":[30,99,123,139],
"vmp":[72],
"vms":[35,55,92,116,126,162],
"voc":[28,88,89,91,104,109,113,115,118,124,128,131,[133,135],149,152,155,173],
"voi":[1,37,81,85,100,105,124,139,143,148,159,160,162,164,166,173],
"vok":[1,12,30,73,81,101,113,115,120,126,129,134,166,170],
"vol":[17,32,35,92,94,122,133,136,167],
"vor":[84],
"vot":[77,146],
"vou":[90,105,111,122,138,162],
"vpa":[72,97,100,119],
"vpb":[94,99,138],
"vpc":[74,99,116,117,123,126,139,149,166],
"vpe":[72,88,91,94,113,115,126,134,145,173],
"vpg":[123,173],
"vpl":[99,150,152,156],
"vpm":[91,113,119,124,139],
"vpo":[149,150,152,166],
"vps":[72,91,115,119,123,124,134,139,149,165,173],
"vpt":[74,101,113,116,149,150,166],
"vpu":[72],
"vpx":[116,139,150],
"vqb":[135],
"vs1":[162],
"vs2":[162],
"vsa":[124],
"vsb":[47],
"vsc":[123],
"vse":[74,162],
"vsh":[89],
"vst":[162],
"vsw":[47],
"vsx":[59,113,124],
"vtb":[104],
"vtd":[11,150],
"vte":[113,119],
"vtt":[164,165],
"vty":[162],
"vup":[22],
"vv!":[162],
"vv-":[162],
"vwa":[162],
"vx-":[94,116,149,160,162,[164,166],[169,173]],
"vx2":[1,[72,74],76,77,88,89,91,94,96,[100,102],108,111,113,115,[117,120],124,126,130,131,133,134,[137,140],[164,166],170,173],
"vx5":[74,88,91,[94,97],99,100,[102,104],111,113,[115,118],120,123,126,130,131,[134,140],145,[149,152],156,160,162,[164,166],169],
"vzb":[47],
"vze":[123],
"vzw":[47],
"vzx":[6,12,119],
"w-2":[91,111,117,119,124,130,139,147,160,[164,166],170],
"w-l":[63,100,159],
"w-p":[49],
"w-u":[165],
"w2d":[99],
"w_0":[118],
"w_8":[118],
"w_e":[72],
"wad":[26,162],
"wai":[75,147],
"wal":[1,28,81,113],
"wan":[15,18,23,38,42,51,67,69,72,86,93,94,98,100,102,103,[112,114],116,118,122,126,[128,130],135,136,138,139,[141,143],[148,151],153,155,156,158,161,162,167,168,173],
"wap":[20,22,59,60,66,68,69,71,[87,89],94,131,140,152,161,170],
"war":[1,2,4,12,17,22,28,31,32,35,40,42,47,48,54,56,[59,61],[68,70],75,77,81,85,87,88,90,94,96,97,[100,102],104,105,110,[113,115],118,119,122,123,126,128,132,139,[142,144],147,150,152,154,155,[157,160],162,164,166,167,170,172,173],
"was":[1,3,4,6,10,12,26,[30,32],34,35,37,40,47,58,61,62,75,81,84,86,88,91,[94,96],99,100,[102,105],109,111,[113,117],[119,123],[125,128],[130,132],135,[138,140],142,143,[145,149],[157,159],161,162,167,170,172,173],
"wat":[81,105,122],
"way":[1,10,22,26,28,35,40,41,48,60,62,64,66,68,70,[74,77],80,[85,87],89,91,94,100,[103,106],[108,111],113,118,119,122,[124,128],[130,132],134,139,[142,145],147,148,150,154,[158,162],164,166,167,169,172,173],
"wa":[122],
"wba":[6,12,19,30,36,54,85,86,88,126,139,145,147,173],
"wbi":[81],
"wdo":[48,49,96,170],
"we!":[105],
"wea":[31,54,81,96,100,126],
"web":[122,146,167],
"wed":[3,50,51,60,61,77,81,84,85,89,90,94,98,101,105,108,110,113,118,122,131,137,141,144,150,155,162,164,165,167,170,173],
"wee":[2,14,22,26,40,75,82,83,88,89,100,104,108,113,121,128,130,137,139,140,142,148,154,162,164,168,173],
"weg":[126,135],
"wei":[23,46,75,81,82,101,113,122,126,129,136,142,154,162,167],
"wel":[1,2,6,30,40,58,59,62,76,78,81,84,88,89,92,94,96,99,100,104,105,[112,114],122,124,128,143,150,154,162,166,171,173],
"wen":[113,122,128,173],
"wer":[[0,4],6,10,12,16,21,22,26,30,31,34,35,37,40,47,49,51,52,[58,60],62,[64,66],68,71,73,75,76,81,[85,89],91,92,[94,96],[100,102],[104,106],108,109,113,[115,120],122,124,[126,128],130,131,134,[136,138],140,[144,150],[152,154],[157,162],[164,167],[171,173]],
"wes":[1,3,30,32,40,52,55,59,[65,67],70,77,85,88,89,91,96,100,105,108,113,119,126,131,134,149,155,158,[162,164],173],
"wev":[[1,4],10,12,14,31,34,35,37,40,50,54,58,60,62,70,74,75,[81,89],94,95,[100,102],[104,106],110,113,117,118,124,[128,134],136,138,139,[142,144],147,151,152,154,[157,159],[162,164],170,172,173],
"wfr":[154],
"wfu":[105,109,122],
"wg-":[157],
"wha":[0,3,12,18,29,31,42,45,48,57,60,67,80,82,84,85,99,105,109,110,114,119,120,122,126,128,131,[135,138],144,145,148,150,[157,159],161,162,167,170,173],
"whe":[2,6,10,12,14,17,20,23,24,26,[28,31],33,35,37,40,[43,45],[47,49],51,[56,58],[60,66],68,71,[73,79],81,[84,90],[92,96],100,101,[103,111],[113,126],[128,135],138,139,[141,145],147,148,[150,152],[154,160],162,163,[165,170],172,173],
"whi":[1,2,6,21,26,29,30,32,34,40,45,48,55,58,59,68,[74,77],[80,82],84,[86,91],[93,96],[99,101],[103,105],108,109,[111,116],[118,136],138,139,[143,148],150,152,[154,167],[170,173]],
"who":[2,3,16,34,40,47,62,72,81,82,[87,90],94,95,100,[103,105],111,113,115,[117,119],122,124,126,127,129,134,138,142,144,146,147,149,150,162,171,173],
"why":[14,42,46,62,79,81,84,109,115,119,120,122,124,131,135,136,145,147,154,173],
"wic":[1,29,47,91,101,[113,115],124,155,160,165,170,173],
"wid":[1,16,21,29,30,34,40,48,51,52,54,76,78,86,88,93,94,97,100,101,104,113,126,128,130,138,139,150,152,158,162,[166,168],[171,173]],
"wik":[2,14,28,36,167,171,173],
"wil":[14,26,29,33,42,44,46,60,[74,76],79,81,82,84,88,89,94,100,102,104,105,108,110,113,114,118,119,122,123,126,128,130,132,133,139,142,144,149,150,153,154,[157,162],166,173],
"win":[[0,4],6,10,12,14,19,[21,24],26,28,30,32,35,37,38,40,42,44,46,48,49,54,57,59,[63,66],68,70,[72,75],77,81,82,[84,86],88,89,91,94,[97,101],105,106,111,113,115,[117,119],122,126,128,130,131,133,134,[136,145],[148,152],154,[157,162],164,[166,168],170,171,173],
"wir":[122],
"wis":[1,2,4,5,22,30,31,54,59,60,73,[87,91],[94,97],100,102,104,105,107,111,113,115,118,122,128,130,136,139,142,144,147,150,151,[158,160],162,163,166,167,170,172],
"wit":[[0,6],9,10,12,[14,16],[18,20],23,24,26,[29,33],35,37,[39,45],[47,50],52,54,[57,60],62,63,66,[68,78],[80,96],[98,105],[107,122],[124,145],[147,152],154,[156,173]],
"wle":[1,87,89,94,100,113,[117,119],124,126],
"wn-":[163],
"wnc":[162],
"wne":[105,128],
"wnl":[2,19,24,31,37,54,146,147],
"wns":[31,35,40,59,66,73,97,105,122,124,126,131,138,139,150,160,170],
"wo-":[28,64,88,113,124,143,158],
"woj":[[0,173]],
"wol":[105],
"won":[7,13,23,31,61,69,105,122,131,132,149,166],
"wor":[[1,7],10,12,16,18,19,22,23,26,[28,31],[33,35],37,40,42,44,45,51,52,54,55,[57,60],[62,64],[66,71],74,75,78,81,82,84,85,[87,91],[93,97],[99,101],[103,105],[110,113],115,[117,120],122,124,126,[128,130],[132,152],155,[157,162],164,166,167,[169,171],173],
"wou":[16,23,28,30,32,37,[40,43],47,55,58,59,61,66,74,75,77,81,82,86,87,89,94,100,102,105,107,109,[111,113],117,119,122,126,128,[130,134],136,141,142,147,152,[156,162],164,166,167,170,173],
"wow":[105],
"wp-":[167],
"wpa":[110],
"wra":[2,29,38,46,59,60,81,94,105,119,128,129,132,143,158,162,173],
"wri":[7,10,26,31,35,40,50,55,56,59,63,75,[80,82],84,85,87,89,94,102,104,109,115,[120,122],126,128,131,136,141,145,148,150,151,[157,160],162,164,167,173],
"wro":[14,26,40,46,74,75,79,[81,83],86,88,89,91,94,96,99,105,116,122,128,143,157,158,161,164],
"wsh":[110],
"wsi":[157,171],
"wsk":[1,28,122],
"wtf":[148],
"wtl":[47],
"wto":[165],
"wun":[150],
"wva":[160],
"wy0":[88],
"wya":[88],
"wyd":[30,73],
"wye":[120,126],
"x-1":[21],
"x-5":[94,116,149,160,162,[164,166],[169,173]],
"x-8":[88,89,100],
"x-a":[104],
"x-d":[142],
"x-g":[163],
"x-l":[159],
"x-r":[81],
"x-u":[88,89],
"x00":[51,60,89,142,149,150,157,159,164,173],
"x01":[113,118,135,142,149,150,173],
"x02":[162,173],
"x03":[173],
"x04":[173],
"x05":[173],
"x0a":[173],
"x0f":[89,144,173],
"x10":[118,149,150,172,173],
"x11":[113,149,159,173],
"x12":[72,118,173],
"x13":[142,173],
"x14":[118,173],
"x15":[118,173],
"x16":[74,104,173],
"x17":[118,173],
"x18":[118,173],
"x19":[173],
"x1_":[173],
"x1a":[89,118,173],
"x1b":[173],
"x1c":[173],
"x1d":[173],
"x1e":[173],
"x1f":[118,172,173],
"x2-":[1,111,119,124],
"x20":[2,4,59,118,135,173],
"x21":[173],
"x22":[173],
"x23":[173],
"x24":[173],
"x25":[173],
"x26":[173],
"x27":[173],
"x28":[173],
"x29":[89,173],
"x2_":[126],
"x2b":[89],
"x2c":[173],
"x2d":[173],
"x2e":[158],
"x2f":[89],
"x2v":[91,113,115],
"x30":[[66,68],89,102,142,144,158,169],
"x31":[67,68,102,118,144,169],
"x32":[68,102,111],
"x33":[68,102,113],
"x34":[68,89,102,142,173],
"x35":[68,102,118],
"x36":[2,68,102],
"x37":[68,102,173],
"x38":[68,173],
"x39":[68,74,89,102,158,173],
"x3_":[104],
"x3a":[173],
"x3c":[173],
"x3d":[173],
"x3e":[89,118,173],
"x3f":[89,143,173],
"x40":[68,113,144,157],
"x41":[68,89,144,173],
"x42":[68,118,173],
"x43":[68],
"x44":[68,113],
"x45":[68],
"x46":[68,144,173],
"x47":[173],
"x48":[4,173],
"x49":[173],
"x4a":[173],
"x4b":[173],
"x4c":[173],
"x4d":[173],
"x4e":[173],
"x4f":[89,173],
"x50":[89,173],
"x51":[74,88,91,[94,97],99,100,[102,104],111,113,[115,118],120,123,126,130,131,[134,140],145,[149,152],156,160,162,[164,166],169,173],
"x52":[173],
"x53":[118],
"x55":[113],
"x56":[113],
"x5a":[89,173],
"x60":[4,144],
"x61":[68,89,144,173],
"x62":[68],
"x63":[68],
"x64":[68,72,100,115,118,135,139,150,152],
"x65":[68,118,142],
"x66":[68,144],
"x68":[74],
"x6b":[113],
"x6f":[89],
"x70":[89],
"x75":[118],
"x76":[4],
"x77":[113,118],
"x7a":[89,173],
"x7f":[23,60,76,94,128,157],
"x80":[16,60,74,91,94,113,128,135,150,157,164,173],
"x86":[3,6,8,12,20,22,23,39,42,47,58,60,61,69,86,92,118,131,140,141,143,154],
"x88":[134,149],
"x8b":[118],
"x96":[74],
"x97":[118],
"x_f":[150],
"x_m":[166],
"x_o":[157],
"x_s":[168],
"xa5":[118],
"xa6":[173],
"xa7":[173],
"xa8":[118],
"xaa":[113,156,158],
"xab":[173],
"xac":[0,2,3,12,26,51,60,64,67,74,84,85,88,91,94,100,106,108,113,115,119,123,124,126,128,132,133,135,138,143,145,147,149,150,154,155,[157,159],161,162,170,173],
"xad":[60,61,68,71,144],
"xam":[1,9,10,14,15,23,26,30,31,37,[40,42],[45,48],52,[54,56],59,60,66,67,74,[78,81],[83,85],87,88,90,93,95,[98,100],105,108,111,113,118,120,122,126,128,133,134,138,142,143,[147,150],152,154,156,[158,164],166,167,170,172,173],
"xan":[81,113],
"xav":[131],
"xb1":[142],
"xb5":[173],
"xb9":[118],
"xbb":[113],
"xbd":[119,124],
"xbw":[6,12,119,124],
"xc0":[157,173],
"xc1":[118],
"xca":[74,118],
"xce":[32,40,46,48,49,53,54,79,81,88,89,91,93,94,100,101,109,118,119,122,128,134,139,142,158,161,162,164,173],
"xch":[20,47,59],
"xci":[75],
"xcl":[40,118,122],
"xco":[116],
"xcs":[48],
"xcu":[96],
"xd6":[173],
"xd8":[173],
"xdd":[113,150],
"xde":[173],
"xe4":[67,74],
"xe5":[158],
"xe8":[74],
"xec":[1,29,31,35,37,42,48,49,57,60,61,69,74,77,78,80,81,85,90,100,105,[113,115],119,120,126,128,133,134,139,170],
"xed":[4,10,19,40,66,74,75,84,86,94,113,121,122,124,126,132,136,139,149,162,164,167],
"xee":[113],
"xel":[3,4,6,12,115],
"xem":[31],
"xeo":[91,111,117,119,124,130,139,145,147,158,160,[164,166],170,173],
"xer":[24,122],
"xes":[1,14,31,74,79,88,89,94,100,105,118,122,147,173],
"xf0":[144],
"xf6":[144],
"xf8":[173],
"xf9":[144],
"xfb":[173],
"xfe":[74,94],
"xff":[2,46,51,89,94,113,118,128,130,142,144,150,164,171,173],
"xib":[81],
"xil":[28,115,120,127,145,159,173],
"xim":[12,40,44,52,78,84,90,105,113,119,134,136,139,142,155,158,159,162,[164,166],168,170,173],
"xin":[77,128,142,167],
"xis":[26,31,34,80,81,84,88,99,100,105,109,114,122,128,147,162,167,170,171],
"xit":[40,54,62,74,77,94,95,100,108,143,154,155,166,167],
"xkc":[122],
"xml":[167],
"xmm":[[0,3],5,6,22,42,48,52,88,89,138],
"xno":[162],
"xop":[1,74,88,89,101,104,171],
"xor":[20,42,47,51,54,73,74,80,87,88,94,100,113,116,118,135,139,[149,151],156,157,159,161,162,164,[171,173]],
"xpa":[40,60,62,66,68,80,85,88,89,94,100,104,105,128,145,149,[159,161],163,167,173],
"xpe":[1,26,31,33,35,37,39,40,47,54,59,60,62,66,70,78,82,[86,89],91,94,96,102,104,105,108,113,115,117,[119,122],124,[128,132],139,143,147,157,159,160,[162,167],170,173],
"xpl":[31,68,80,82,87,88,96,100,105,111,113,115,120,122,124,129,131,143,[150,152],158,[162,164],166],
"xpo":[10,44,45,62,81,127,136,153,154,162,167],
"xpr":[0,5,23,32,42,60,61,69,71,73,74,79,80,82,84,[87,89],94,100,105,113,[117,119],121,126,131,133,136,138,139,141,142,144,[148,154],[157,159],164,170,173],
"xst":[100],
"xt-":[126,159,172,173],
"xt_":[24,126],
"xtb":[115,122],
"xte":[1,3,4,6,12,14,22,26,27,42,50,55,59,60,66,68,71,75,81,87,88,91,94,95,100,105,106,113,119,124,[126,128],131,133,135,[137,140],143,145,148,149,152,159,160,[162,164],166,167,171,173],
"xtr":[3,4,23,31,45,[67,69],75,[84,86],89,95,100,101,105,112,113,115,116,118,119,122,124,126,129,132,133,135,151,154,155,158,159,162,164,166,167],
"xts":[30,31,87,126,167,173],
"xtu":[158,159,171],
"xub":[5],
"xup":[150],
"xuw":[5],
"xva":[91,94,115,126],
"xwd":[119,124],
"xxx":[84],
"y-1":[69],
"y-a":[89,91,113,162],
"y-b":[26],
"y-c":[100],
"y-d":[126],
"y-e":[14],
"y-f":[120,162,170],
"y-h":[173],
"y-l":[162],
"y-m":[14,81],
"y-p":[122],
"y-r":[128],
"y-s":[1,74,89,94,101],
"y-t":[75,122,159],
"y02":[88],
"y_b":[128],
"y_e":[131,137,140,166],
"y_i":[58,114,131,137,140],
"y_o":[131,137,140],
"y_s":[101,131,140],
"yac":[88],
"yah":[26,128,132],
"yan":[40],
"ybe":[23,40,42,60,81,84,93,96,128,148,161,167],
"ybo":[122],
"ybr":[113],
"ybu":[128],
"ybv":[86],
"ych":[122],
"ycl":[[1,4],9,31,60,61,74,89,91,94,100,101,103,113,115,117,119,121,122,124,126,130,133,139,145,147,150,154,[157,159],[164,166],170,173],
"yda":[28,128],
"yde":[30,73],
"ydr":[109],
"yea":[10,47,84,104,122,128,137,140,146,167],
"yed":[88,89,105,122],
"yee":[122],
"yel":[136],
"yer":[100,120,122,126,128,162],
"yes":[28,35,37,56,59,75,99,105,109,110,131,136,137,139,140,145,162,173],
"yet":[104,128,143,150,158,167],
"yge":[123],
"ygo":[34],
"ygw":[14,19,57],
"yie":[12,60,77,88,89,92,95,100,106,107,111,113,[117,119],124,126,130,[134,136],138,139,144,150,151,[159,164],166,167,170,171,173],
"yin":[1,26,37,43,64,84,96,101,105,113,115,122,126,142,158,159,162,164,166,167],
"yip":[30],
"yla":[1,48,59,70,74,88,89,91,92,96,100,108,111,113,115,117,119,123,124,130,139,143,147,148,150,151,154,158,159,[164,166],170],
"yle":[147,167],
"ylo":[74,94],
"ymb":[40],
"ymi":[122],
"ymm":[88,94,138,173],
"ymp":[108,155],
"yna":[26,40,81,122,162],
"ync":[57,81,111,146],
"ynt":[35,47,88,89,122,132,162,163],
"ynv":[122],
"yon":[100,105],
"yor":[128],
"you":[1,12,24,26,28,44,45,55,57,62,66,74,75,79,[81,84],86,88,89,91,94,96,99,100,104,105,109,111,113,115,120,122,126,128,134,138,144,145,154,158,167,170],
"ype":[26,27,31,37,38,41,42,46,53,55,59,75,76,79,81,82,84,104,110,112,113,115,[118,120],122,124,[127,130],138,148,162,170,171],
"ypi":[105,113,120,128,129,133,159],
"ypo":[31,113,164],
"yri":[163],
"yse":[27,35,94,113,150,158],
"ysi":[31,35,37,94,113,126,128,155,157,162,173],
"yss":[31],
"yst":[31,37,43,75,81,86,87,92,104,113,114,122,125,132,136,138,162,167,173],
"yte":[[0,6],12,16,18,22,23,26,30,35,39,40,42,51,54,55,[58,60],[66,71],73,77,78,85,[87,92],94,97,[99,102],104,111,113,115,[117,119],124,126,128,[130,132],[134,136],138,139,142,144,145,147,149,150,152,[156,162],[164,166],[169,173]],
"yth":[2,14,24,25,27,[32,34],38,42,43,55,72,75,81,84,[88,90],100,104,105,110,115,122,125,[127,129],133,136,158,161,162,164,167,172,173],
"yts":[40],
"ytu":[128],
"yty":[27],
"ywa":[111,119,164],
"ywh":[125,172,173],
"ywo":[105,159,162],
"yze":[31,54,81,139,[164,166],170,173],
"z_s":[94],
"zab":[142,145,170],
"zac":[126,135],
"zag":[115],
"zar":[81,82],
"zat":[12,26,30,40,48,77,81,85,87,88,91,94,105,111,113,116,120,121,130,131,133,134,136,137,140,143,148,159,160,162,164,170,172,173],
"zbl":[47],
"zcn":[99,103,150,152,156,158,160],
"ze3":[54],
"ze6":[54],
"ze_":[53,84],
"zec":[173],
"zed":[1,2,6,10,26,30,35,40,44,45,48,70,75,77,78,81,84,88,91,94,95,104,105,108,111,113,115,[118,120],122,124,126,128,130,131,133,136,137,139,140,144,148,154,[158,160],164,166,[170,173]],
"zej":[81],
"zem":[81],
"zen":[94,120,128,[164,166],170,173],
"zeo":[26,75],
"zer":[1,2,3,11,16,21,29,30,39,47,48,51,54,55,[64,67],70,73,[88,90],94,[98,100],103,[106,108],111,113,115,116,118,119,122,123,126,128,130,[132,134],[139,142],144,147,[149,152],154,[156,160],162,164,166,167,[169,171]],
"zes":[19,59,103,108,109,113,119,127,131,132,159,170,172,173],
"zfh":[162],
"zfi":[161],
"zig":[115],
"zin":[85,100,102,105,113,121,122,124,128,131,140,154],
"zip":[167],
"zmm":[91,113,138],
"zon":[16,113,124,146,158,162,168,171],
"zor":[31],
"zta":[2],
"zur":[81],
"zwl":[47],
"zxb":[6,12,119],
"zxw":[119],
"zzz":[23],
"zo":[122],
"|aa":[104],
"|bb":[104],
"~10":[100],
"~13":[173],
"~16":[91,119,124,130,139,147,158,159],
"~18":[39],
"~19":[19],
"~25":[128],
"~26":[173],
"~27":[173],
"~28":[19],
"~30":[146,158,173],
"~43":[31],
"~45":[54],
"~50":[173],
"~81":[173],
"~hi":[144],
"~ma":[117],
"rn":[30],
"nt":[94],
"a":[122],
"d":[122],
"aw":[81,105,122],
"ko":[122],
"ot":[122],
"sk":[81,122],
"an":[122],
};
DOCUMENTS = [
["notesen/2008-04-29-sse-hexprint.html", 'SSSE3: printing hex values', 'SSSE3: printing hex values Wojciech Mua Added on 2008-04-29 Updated 2016-03-07 (github repo, results from Core i5), 2008-05-24 Contents SIMD algorithm Tests Core2 Core i5 SIMD algorithm Instruction PSHUFB does parallel lookup from 16-byte array stored in an XMM register --- this is exactly what bin to hex conversion needs. Code snippet showing the idea: Tests hexprint.c is a test program that compares speed of presented method with three other lookup-based methods: std --- standard 16-byte lookup (2 lookups per byte) std2 --- 256-byte lookup (1 lookup per byte) std3 --- 2 x 256-byte lookups (2 lookups per 2 bytes) In a single iteration 100 x 16 bytes are decoded, and the number of iterations is 100000. Core2 Here are times measured on my Linux box, with Core 2 Duo E8200. method user time speedup std 780 100% ========== std2 640 122% ============ std3 640 122% ============ ssse3 580 133% ============= Core i5 CPU: i5 CPU M 540 @ 2.53GHz method user time speedup std 9.74 1.00 ========== std2 8.99 1.08 ========== std3 9.07 1.07 ========== ssse3 8.35 1.16 ============ Summary: There is no visible improvement on newer CPUs.'],
["notesen/2008-05-24-sse-popcount.html", 'SSSE3: fast popcount', 'SSSE3: fast popcount Wojciech Mua Added on 2008-05-24 Last update 2017-01-28 (link to the XOP variant), 2016-11-27 (link to the paper) Contents Introduction Vector algorithm Further improvements Source code Experiments (64-bit code) Core i5 (Westmere) Core i7 (Haswell) Core i7 (Skylake) Experiments (32-bit code) --- outdated Acknowledgments See also Changelog Introduction Population count is a procedure of counting number of ones in a bit string. Intel introduced instruction popcnt with SSE4.2 instruction set. The instruction operates on 32 or 64-bit words. However SSSE3 has powerful instruction PSHUFB . This instruction can be used to perform a parallel 16-way lookup; LUT has 16 entries and is stored in an XMM register, indexes are 4 lower bits of each byte stored in another XMM register. Vector algorithm With help of PSHUFB we can get a vector that contains population count for 16 nibbles. To get a vector of population count for each 16 byte, instruction PSHUFB have to be called twice on vectors of lower and higher nibbles, and finally added together. Following code shows the idea: The last step is adding all bytes from vector. Instruction PSADBW calculate sum of absolute differences of unsigned bytes --- if the first arguments is full of zeros, then result is a sum of bytes from second argument. Unfortunately PSADBW invoked with 128-bits arguments calculate separate sums for bytes 0..7 and 8..15, and finally stores them in the lower and the higher quad words. Because of that few additional instructions are needed: Further improvements PSADBW has 3 or 4 cycles latency, also additional instructions need some time to execute (I guess around 2 cycles). PSADBW doesn\'t need to be called in every iteration --- since max values of popcount for single byte is 8, we can perform up to floor(255/8)=31 parallel additions ( PADDB ) without overflow. Moreover, partial sums returned by PSADBW could be added together in the end. Pseudocode: Source code Github repository contains the original code from 2008 and also the new C++11 (2015, 2016), intrinsics-based implementation. Experiments (64-bit code) Program from the repository were run with default settings ( make run and make run_avx2 ) and repeated several times. Minimal measurements were considered. Below is the list of procedures listed in here. The repository has more variants. procedure implementation lookup-8 LUT-based procedure ( uint8_t[266] ) lookup-64 LUT-based procedure ( uint8_t[266] ), avoid zero-extend bit-parallel well know method, described for example in Bit Twiddling Hacks bit-parallel-optimized above + the trick from section \"Further improvements\" harley-seal Harley-Seal variant sse-bit-parallel SSE variant of bit-parallel sse-lookup the method described in this text using SSE instructions sse-lookup the method described in this text using AVX2 instructions cpu popcnt instruction emitted via intrinsic Core i5 (Westmere) The CPU architecture: Core i5 M540 @ 2.53GHz (Westmere) More details in a separate file . procedure 32 B 64 B 128 B 256 B 512 B 1024 B 2048 B 4094 B lookup-8 2.29884 2.20039 2.15086 2.12830 3.40985 3.38632 3.37334 3.36643 lookup-64 2.29837 2.19979 2.15067 2.12608 3.40112 3.38135 3.37165 3.36490 bit-parallel 2.13645 2.00652 1.93406 1.90567 3.01241 2.99661 2.99112 2.99828 bit-parallel-optimized 1.37812 1.23970 1.16183 1.13877 1.79016 1.77086 1.75989 1.78260 harley-seal 1.47658 1.29922 0.79424 0.63432 0.90197 0.86194 0.83491 0.85399 sse-bit-parallel 2.69418 2.40001 1.40793 0.95652 1.17003 1.00129 0.92382 0.86693 sse-lookup 0.75528 0.54195 0.34942 0.31078 0.47211 0.45694 0.44650 0.46007 cpu 0.49283 0.37799 0.32058 0.29185 0.44360 0.43213 0.42637 0.36332 CPU popcnt outperforms the code described here. Core i7 (Haswell) The CPU architecture: Haswell i7-4770 CPU @ 3.40GHz. More details in a separate file . procedure 32 B 64 B 128 B 256 B 512 B 1024 B 2048 B 4094 B lookup-8 1.20408 1.10938 1.06312 1.10722 1.69922 1.66315 1.64113 1.63397 lookup-64 1.17775 1.09994 1.06374 1.09102 1.67579 1.64548 1.62390 1.61094 bit-parallel 1.26768 1.10553 1.05222 1.02626 1.62086 1.61024 1.60495 1.61435 bit-parallel-optimized 1.00233 0.82545 0.72246 0.67454 1.04113 1.02366 1.01708 1.03801 harley-seal 1.00260 0.79597 0.50116 0.39440 0.54553 0.50277 0.48139 0.48978 sse-bit-parallel 2.15206 2.02008 1.09393 0.66777 0.75717 0.61179 0.53791 0.49923 sse-lookup 0.53520 0.33902 0.21379 0.18061 0.26688 0.25605 0.25054 0.25780 avx2-lookup 0.53068 0.33920 0.21373 0.13579 0.17133 0.15500 0.14293 0.17005 cpu 0.29480 0.24051 0.15478 0.13270 0.20052 0.19462 0.20843 0.21684 AVX2 code is faster than the dedicated instruction for input size 512 bytes and larger. Core i7 (Skylake) The CPU architecture: Skylake i7-6700 CPU @ 3.40GHz More details in a separate file . procedure 32 B 64 B 128 B 256 B 512 B 1024 B 2048 B 4094 B lookup-8 1.02956 0.94836 1.04671 0.95623 1.46018 1.42373 1.40633 1.39675 lookup-64 1.00704 0.94387 1.03233 0.94744 1.45629 1.42371 1.40747 1.39947 bit-parallel 1.05662 0.95297 0.90992 0.88908 1.40587 1.39753 1.39337 1.41585 bit-parallel-optimized 0.81278 0.69091 0.63329 0.60453 0.94443 0.93320 0.92760 0.95122 harley-seal 0.81283 0.66397 0.43348 0.34035 0.46871 0.43077 0.41181 0.41767 sse-bit-parallel 2.25432 1.70980 0.92443 0.57618 0.68189 0.58220 0.50169 0.45568 sse-lookup 0.40749 0.29802 0.18290 0.15742 0.23956 0.23057 0.22657 0.23177 avx2-lookup 0.43350 0.26368 0.17950 0.11587 0.14881 0.13729 0.12798 0.14222 cpu 0.21676 0.16256 0.13546 0.12192 0.18423 0.22065 0.19643 0.20293 Again AVX2 code is faster than the dedicated instruction for input size 256 bytes and larger. Experiments (32-bit code) --- outdated Note 2016-03-13 : this section refers to results from 2008. ssse3_popcount.c is a test program that contains implementations of following procedures: lookup --- popcount based on LUT with 256 entries; I tested GCC __builtin_popcount , however it was much slower than my implementation ssse3-1 --- straightforward SSSE3 implementation ssse3-2 --- improved SSSE3 implementation ssse3-unrl --- ssse3-2 with inner loop unrolled 4 times sse2-1 --- SSE2 bit-level parallel implementation sse2-2 --- improved SSE2 implementation (using the same tricks as SSSE3 version) see2-unrl --- ssee2-2 with inner loop unrolled 4 times The first argument of the program is a function name, the second is the number of 16-byte chunks processed by the selected procedure in one iteration and the third is the iterations number. The table shows results for different chunk count; test script I\'ve used is available. Program was compiled with following options: Tests were run on my Linux box, with Core 2 Duo E8200; Results clearly show, that the method presented above brings significant speedup, which depends on the data size. The straightforward SSSE3 implementation is 2-2.8 times faster, the improved around 3 times, and the unrolled 4-5 times. procedure number of 16-byte chunks iterations time [s] speedup lookup 1 20,000,000 0.22 100% sse2-1 0.19 115% sse2-2 0.20 110% ssse3-1 0.14 157% ssse3-2 0.16 137% lookup 8 20,000,000 1.42 100% sse2-1 0.92 154% sse2-2 0.79 179% ssse3-1 0.61 232% ssse3-2 0.52 273% lookup 32 2,000,000 0.55 100% sse2-1 0.34 161% sse2-2 0.30 183% sse2-unrl 0.22 250% ssse3-1 0.22 250% ssse3-2 0.19 289% ssse3-unrl 0.12 458% lookup 128 200,000 0.21 100% sse2-1 0.13 161% sse2-2 0.11 190% sse2-unrl 0.08 262% ssse3-1 0.08 262% ssse3-2 0.07 299% ssse3-unrl 0.04 525% lookup 512 200,000 0.86 100% sse2-1 0.53 162% sse2-2 0.45 191% sse2-unrl 0.34 252% ssse3-1 0.34 252% ssse3-2 0.26 330% ssse3-unrl 0.18 477% lookup 1024 200,000 1.73 100% sse2-1 1.07 161% sse2-2 0.90 192% sse2-unrl 0.68 254% ssse3-1 0.69 250% ssse3-2 0.52 332% ssse3-unrl 0.38 455% lookup 2048 200,000 3.47 100% sse2-1 2.14 162% sse2-2 1.80 192% sse2-unrl 1.37 253% ssse3-1 1.38 251% ssse3-2 1.06 327% ssse3-unrl 0.76 456% Acknowledgments Daniel Lemire has gave me access to computers with Haswell and Skylake processors, thanks to that I could play with AVX2 code and run tests. Kim Walisch contributed the Harley-Seal implementation. There were some fixes and enhancements to sample code by various people . Thank you. See also Population count using XOP instructions Paper by Daniel Lemire, Nathan Kurz and me: Faster Population Counts using AVX2 Instructions . Hacker news discussion . Speeding up bit-parallel population count --- delaying byte-wise sum (the trick with PSADBW ) applied for bit parallel method gives 50% speedup over plain, SWAR 64-bit procedure. Anatomy of High-Performance 2D Similarity Calculations --- paper contains interesting comparison of similarity calculations which heavily use popcount operation. The authors compared 4 basic methods: 1) hardware-based, i.e. popcnt instruction, 2) simple LUT, 3) bit-level parallel method (SSE2 procedure), and 4) the method described here. The most important observation, from my point of view of course, is that the speed of SSSE3 code is comparable to hardware popcnt , it is just a bit slower. The authors published also the full source code and I noticed they manually unrolled inner loop. I did the same in my code and speedup increased from 3 to 4-5 --- sources and article has been updated. Benchmarking CRC32 and PopCnt instructions --- Peter Kankowski compared speed of SSE4.2 instructions crc32 and popcnt against software implementations. Hardware CRC32 is significantly faster, but population count is slightly slower than the algorithm presented here Changelog 2016-03-16 --- detailed results from Westmere, Haswell & Skylake 2016-03-13 --- AVX2 implementation, results from Westmere and Skylake, wording 2015-03-04 --- link to github repo 2011-10-22 --- link to paper, unrolled loops 2010-06-28 --- link to Peter\'s site 2010-03-27 --- SSE2 procedures'],
["notesen/2008-05-27-sse4-substring-locate.html", 'SSE4 string search --- modification of Karp-Rabin algorithm', 'SSE4 string search --- modification of Karp-Rabin algorithm Wojciech Mua, wojciech_mula@poczta.onet.pl Added on 2008-05-27 This article is obsolete, refer to SIMD-friendly algorithms for substring searching . Contents Introduction Algorithm outline Implementation Performance tests Results Short offsets Medium offsets Long offsets Downloads See also Introduction String search is a common task in text processing. There are many algorithms that try to minimize number of exact comparing substrings. One of them is Karp-Rabin algorithm --- char-wise comparison is performed only when values of hash function calculated for a part of text and a substring are equal. SSE4 introduced complex instruction MPSADBW which calculate eight Manhattan distances (L1) between given 4-byte vector and 8 subsequent vectors; if the distance is zero, then vectors are equal. The idea of modification is to use equality of 4-byte substring\'s prefix instead of hash values equality. MPSADBW is fast, it has latency 4 cycles and throughput 2 cycles. Even if latency is not compensated, overall performance is very promising --- 0.5 cycle per one 4-byte vectors comparison. Unfortunately there are three disadvantages: Searching a substring shorter than 4 chars need some additional work. A hash is calculated for whole substring, MPSADBW consider just 4-byte prefix, thus the number of false-negative alarms could be greater. At least the length of a substring must be known. In the sample application text length is also given --- this make program shorter and faster. Algorithm outline Load 4-byte prefix of substring (done once): Load next 16 bytes of text ( MPSADBW needs first 11 bytes): Locate prefix --- result is vector of 8 words: MPSADBW result is converted to word-mask: If xmm1 is equal zero, goto 2. Otherwise perform exact comparison of a substring and a text: words of value 0xffff indicate positions where the prefix is located. Comparison could be done with built-in functions like strncmp or memcmp . However since the length of substring is known we can use few SSE instructions to compare short strings, up to 36 chars. Implementation sse4_strstr.c include five functions: sse4_strstr_any --- is the most generic procedure, it uses MPSADBW to locate possible positions of substring, but comparison is done by a standard library function strncmp . sse4_strstr_len4 --- is the most specialized, it accepts only strings of length 4 chars, and no additional comparisons are needed. sse4_strstr_len3 --- this function accepts only strings of length 3 chars, and no additional comparisons are needed. sse4_strstr_max20 --- this function accept strings of length in range 4..20 chars. Substring\'s suffix of length 0..16 chars is loaded just once into a single XMM register, and comparison is done with few assembler instructions. sse4_strstr_max36 --- this function is similar to previous one: it stores suffix in two XMM register, comparison is also done with few assembler instructions. There is a wrapper sse4_strstr that calls proper function depending on length of s1 . All functions fits following declaration: Note : these functions were not well optimized, I guess there are room for some improvements, but at the moment don\'t have any ideas. Performance tests The application ( sse4_strstr.c ) loads some text file, and in a loop perform repeat substring searching using built-in function strstr or sse4_strstr wrapper. With assistance of Python script following tests were done. Script loads desired text and picks 3*59 substring to locate. Substrings have length from 4 to 63 chars, their positions are selected from 3 different ranges: first 64 bytes (short offsets, 0..63) first 1kB (medium offsets, 64..1023) rest of text (long offsets, 1024..) Then results of built-in strstr and sse4_strstr are compared and if matched, performance tests were done. First strstr is measured --- the number of iterations is adjusted to make running time longer than one second. Then sse4_strstr is timed using the same number of iterations. Tests have been done on Core 2 Duo E8200 clocked at 2.6GHz, under Linux control. Article Assembly language from Wikipedia has been used, it has 38 kilobytes. Results Speedup mostly depend on the offset, i.e. position of s1 the first occurrence in a text. offsets speedup min avg max short 0.97 2.20 4.75 medium 2.45 4.67 8.04 long 3.79 6.21 10.47 Short offsets s1 offset s1 length strstr time SSE4_strstr time speedup 0 4 1.350s 1.390s 0.97 12 5 3.460s 2.030s 1.70 30 6 4.540s 2.680s 1.69 39 7 5.740s 2.640s 2.17 29 8 4.820s 2.630s 1.83 0 9 2.770s 1.860s 1.49 40 10 8.800s 2.840s 3.10 63 11 9.560s 3.970s 2.41 29 12 5.760s 3.370s 1.71 61 13 1.080s 0.320s 3.38 24 14 5.720s 2.430s 2.35 27 15 6.350s 2.960s 2.15 39 16 7.910s 3.050s 2.59 34 17 7.520s 3.020s 2.49 42 18 8.950s 3.320s 2.70 60 19 1.490s 0.390s 3.82 18 20 7.500s 2.840s 2.64 61 21 1.290s 0.430s 3.00 8 22 7.500s 2.620s 2.86 40 23 1.240s 0.430s 2.88 21 24 9.530s 3.170s 3.01 53 25 1.150s 0.430s 2.67 34 26 1.010s 0.350s 2.89 27 27 1.050s 0.380s 2.76 44 28 1.500s 0.380s 3.95 45 29 1.530s 0.460s 3.33 26 30 1.230s 0.350s 3.51 35 31 1.160s 0.350s 3.31 57 32 1.490s 0.480s 3.10 64 33 1.560s 0.400s 3.90 15 34 1.070s 0.240s 4.46 13 35 1.090s 0.320s 3.41 49 36 1.460s 0.400s 3.65 36 37 1.370s 0.590s 2.32 31 38 1.320s 0.620s 2.13 43 39 1.440s 0.630s 2.29 18 40 1.340s 0.590s 2.27 11 41 1.220s 0.580s 2.10 40 42 1.760s 0.720s 2.44 41 43 1.760s 0.720s 2.44 59 44 1.960s 0.720s 2.72 30 45 1.520s 0.650s 2.34 45 46 2.000s 0.730s 2.74 60 47 2.280s 0.760s 3.00 4 48 1.370s 0.640s 2.14 13 49 1.530s 0.660s 2.32 25 50 1.700s 0.730s 2.33 29 51 1.660s 0.720s 2.31 42 52 1.840s 0.760s 2.42 6 53 1.540s 0.680s 2.26 19 54 1.720s 0.740s 2.32 42 55 1.920s 0.780s 2.46 43 56 3.780s 0.790s 4.78 30 57 1.860s 0.760s 2.45 8 58 1.730s 0.770s 2.25 8 59 1.730s 0.760s 2.28 59 60 2.410s 0.890s 2.71 60 61 2.680s 0.880s 3.05 23 62 1.900s 0.830s 2.29 61 63 2.480s 0.900s 2.76 Min: 0.97, max: 4.78, average: 2.20 Medium offsets s1 offset s1 length strstr time SSE4_strstr time speedup 699 4 9.860s 1.940s 5.08 556 5 2.900s 0.950s 3.05 120 6 1.870s 0.480s 3.90 691 7 1.040s 0.190s 5.47 202 8 3.380s 0.670s 5.04 464 9 3.850s 1.020s 3.77 73 10 1.450s 0.360s 4.03 362 11 5.170s 1.720s 3.01 790 12 1.680s 0.220s 7.64 207 13 3.050s 0.670s 4.55 664 14 1.020s 0.220s 4.64 321 15 6.750s 1.010s 6.68 189 16 2.970s 0.700s 4.24 539 17 7.970s 1.620s 4.92 634 18 9.330s 1.870s 4.99 214 19 2.890s 1.180s 2.45 643 20 6.850s 1.900s 3.61 416 21 6.270s 1.330s 4.71 714 22 1.020s 0.200s 5.10 278 23 5.430s 0.960s 5.66 638 24 9.230s 1.960s 4.71 549 25 6.540s 1.060s 6.17 403 26 6.420s 1.230s 5.22 736 27 7.570s 0.960s 7.89 576 28 6.990s 1.780s 3.93 273 29 4.120s 0.960s 4.29 767 30 8.000s 2.440s 3.28 184 31 3.760s 0.740s 5.08 468 32 8.680s 1.740s 4.99 747 33 1.060s 0.210s 5.05 753 34 9.390s 2.510s 3.74 847 35 1.240s 0.230s 5.39 359 36 5.990s 1.470s 4.07 927 37 1.660s 0.280s 5.93 931 38 9.110s 2.900s 3.14 643 39 7.380s 2.180s 3.39 871 40 1.580s 0.310s 5.10 121 41 2.750s 0.840s 3.27 630 42 1.010s 0.220s 4.59 419 43 6.500s 1.980s 3.28 565 44 5.670s 0.970s 5.85 764 45 5.700s 1.020s 5.59 681 46 1.260s 0.240s 5.25 331 47 5.790s 1.780s 3.25 561 48 7.720s 0.960s 8.04 879 49 1.380s 0.280s 4.93 929 50 1.050s 0.330s 3.18 845 51 1.860s 0.270s 6.89 397 52 9.450s 1.640s 5.76 128 53 4.180s 0.980s 4.27 155 54 3.040s 1.070s 2.84 777 55 4.640s 1.280s 3.62 254 56 4.980s 2.020s 2.47 293 57 5.590s 1.420s 3.94 387 58 9.520s 2.180s 4.37 710 59 6.060s 0.950s 6.38 1023 60 1.950s 0.330s 5.91 447 61 7.370s 1.810s 4.07 562 62 4.800s 0.950s 5.05 181 63 4.180s 1.190s 3.51 Min: 2.45, max: 8.04, average: 4.67 Long offsets s1 offset s1 length strstr time SSE4_strstr time speedup 9655 4 1.100s 0.220s 5.00 25113 5 3.800s 0.610s 6.23 33958 6 4.940s 0.840s 5.88 4696 7 8.720s 1.840s 4.74 3890 8 6.010s 1.200s 5.01 23649 9 6.100s 1.000s 6.10 9118 10 1.300s 0.220s 5.91 12530 11 2.530s 0.300s 8.43 15698 12 1.830s 0.380s 4.82 24124 13 4.190s 0.590s 7.10 9425 14 1.860s 0.230s 8.09 24289 15 3.020s 0.590s 5.12 8296 16 1.350s 0.200s 6.75 29318 17 6.880s 0.720s 9.56 3785 18 4.280s 0.950s 4.51 19056 19 4.970s 0.680s 7.31 29172 20 4.720s 0.720s 6.56 30185 21 8.220s 0.960s 8.56 35429 22 3.300s 0.860s 3.84 30084 23 4.030s 0.850s 4.74 21020 24 2.470s 0.510s 4.84 1940 25 3.030s 0.580s 5.22 32933 26 3.840s 0.960s 4.00 28921 27 2.820s 0.740s 3.81 24984 28 2.830s 0.620s 4.56 12179 29 1.780s 0.300s 5.93 8794 30 8.940s 2.190s 4.08 26064 31 6.700s 0.640s 10.47 26132 32 5.140s 0.640s 8.03 37875 33 4.230s 0.950s 4.45 36593 34 4.430s 1.110s 3.99 31745 35 3.400s 0.780s 4.36 10705 36 1.420s 0.260s 5.46 30480 37 5.150s 0.760s 6.78 15060 38 3.290s 0.430s 7.65 28798 39 3.080s 0.710s 4.34 30460 40 7.170s 0.750s 9.56 3355 41 4.890s 0.870s 5.62 20004 42 5.130s 0.660s 7.77 31452 43 7.580s 0.780s 9.72 30040 44 3.660s 0.750s 4.88 8599 45 2.020s 0.210s 9.62 37178 46 1.020s 0.140s 7.29 35331 47 3.480s 0.860s 4.05 24538 48 9.340s 0.960s 9.73 31491 49 6.310s 0.790s 7.99 9371 50 1.230s 0.240s 5.12 11476 51 1.100s 0.290s 3.79 2153 52 4.740s 0.960s 4.94 36412 53 5.780s 0.900s 6.42 15820 54 3.230s 0.420s 7.69 18578 55 3.340s 0.730s 4.58 17378 56 6.930s 1.500s 4.62 22165 57 3.180s 0.550s 5.78 21275 58 2.060s 0.520s 3.96 14870 59 3.460s 0.360s 9.61 26933 60 3.800s 0.890s 4.27 16482 61 3.990s 0.450s 8.87 5921 62 7.380s 1.620s 4.56 13398 63 3.370s 0.330s 10.21 Min: 3.79, max: 10.47, average: 6.21 Downloads All files are available at github repository . Subdirectory original contains a 32-bit code from 2008, the root directory contains fresh C++11 programs. See also SIMD-friendly Rabin-Karp modification --- universal modification, suitable also for SWAR solutions'],
["notesen/2008-06-01-sse-lookup32bpp.html", 'SSE: modify 32bpp images with lookup tables', 'SSE: modify 32bpp images with lookup tables Wojciech Mua Added on 2008-06-01 Updated on 2016-03-04 (+link to github) 32bpp pixels have four components: red, green, blue and alpha channel. The same number of lookup tables is needed; elements of tables has size 4 bytes, and can be combined with simple or: Or without alpha channel: I did some tests with SSE2 and SSE4 instructions used to minimize memory references --- with a single XMM instruction 16 bytes are read. Main problem is how to extract bytes or double words from the selected position of an XMM register. x86 code The x86 code is a base for further improvements. If pixel is loaded into an x86 register, following code can be used to extract all RGBA components: Code that works with RGB pixels is of course shorter: SSE2 code SSE2 code uses the same scheme as the x86 code, however it fetches 4 pixels at the same time, and load eax from XMM register with a MOVD instruction. Since MOVD moves lowest dword, additional shifts are needed to place all dwords at that position --- PSHUFD instruction is used to do this. SSE4 code SSE4 (SSE4.1) introduced instructions PEXTRB , PEXTRD and PEXTRQ --- element\'s index is hardcoded in opcode, destination is register or memory location, extracted byte/dword/qword is zero-extended. Contrary operation is performed by PINSRx instructions. These instructions seem perfect, do exactly what SSE-assist lookup needs. PEXTRx / PINSRx have throughput one cycle, however latency is very long --- five cycles. I think it is possible to compensate latency, but not in 32-bit code --- we can use just 5 registers, because 3 are used for two pointers and one is a loop counter; the 64-bit mode gives 8 extra registers. Tests results Tests was done on Core 2 Duo @ 2.6GHz, under Linux control. Image 1024 x 768 was transformed 1000 times, test were run 10 times. Sample program is available at github , and was compiled with following options: Function naive is a C implementation. GCC generated code very similar to x86 presented above, however added some extra instructions that slowed down whole procedure. Other function refers to these described earlier. RGBA pixels Gain 1.3 times. function time [s] speedup naive 2.26 100% x86 1.90 119% SSE2 1.76 128% SSE4 1.89 120% RGB pixels No observable gain. function time [s] speedup naive 1.55 100% x86 1.57 98% SSE2 1.53 101% SSE4 1.54 100%'],
["notesen/2008-06-01-sse-pix16to32bpp.html", '16bpp/15bpp to 32bpp pixel conversions --- different methods', '16bpp/15bpp to 32bpp pixel conversions --- different methods Wojciech Mua Added on 2008-06-01 Updates 2016-03-06 (link to github, results from Core i5) Contents Introduction Sample program Test results Core 2 Image 320x200 Image 640x480 Image 800x600 Image 1024x768 Comparison Core i5 Image 320x200 Image 640x480 Image 800x600 Image 1024x768 Comparison Introduction Basically this kind of conversion needs following steps: extract components R, G and B (using bitwise and) extend words from 6 or 5 bits to 8 bits (shift left) place components at desired places in a 32-bit word (shift, bitwise or) Since there aren\'t many pixels (32 or 64 thousand) lookup tables can be used. First approach is to use one big table indexed by pixels treated as natural numbers: this table has size 65536 * 4 bytes = 262144 bytes. Just one memory access is needed to get 32bpp pixel, however the table size is big, and even if it fits in a L2 cache, then the memory latency kill performance. Another approach needs two tables indexed by the lower and the higher byte of a pixel, the final pixel is result of bitwise or. These tables has size 2 * 256 * 4 bytes = 2048 bytes --- perfectly fit in a L1 cache. Sample program Sample program is available at github , and includes following procedures: naive --- is a straightforward implementation of the algorithm described in the beginning; lookup16 --- uses single, large lookup table; lookup8 --- use two, small lookup tables; it converts one pixel per iteration; lookup8(2) --- improved lookup8 --- converts two pixels per iteration, requires single fetch of 4 bytes; MMX --- naive algorithm using MMX instructions; SSE2 --- naive algorithm using SSE2 instructions; converts 8 pixels per iteration; SSE2(2) --- unrolled SSE2 version that converts 16 pixels per iteration; Test results Core 2 Program was compiled with following flags: Here are timing from my Core 2 Duo E8200 @ 2.6GHz. Each procedure was called 10 times, results are average. Image 320x200 procedure time [us] speedup naive 16625 100% ========== lookup8 13584 120% ============ lookup16 24438 65% ====== lookup8(2) 6175 270% =========================== MMX 7862 210% ===================== SSE2 4103 405% ======================================== SSE2(2) 4604 360% ==================================== Image 640x480 procedure time [us] speedup naive 49371 100% ========== lookup8 40177 120% ============ lookup16 73051 65% ====== lookup8(2) 18574 265% ========================== MMX 23483 210% ========================== SSE2 12703 390% ======================================= SSE2(2) 13716 360% ==================================== Image 800x600 procedure time [us] speedup naive 77634 100% ========== lookup8 62893 120% ============ lookup16 115156 65% ====== lookup8(2) 28830 270% =========================== MMX 36452 210% ===================== SSE2 19217 400% ======================================== SSE2(2) 21696 360% ==================================== Image 1024x768 procedure time [us] speedup naive 130867 100% ========== lookup8 106543 120% ============ lookup16 205421 60% ====== lookup8(2) 48503 270% =========================== MMX 62737 210% ===================== SSE2 37881 345% ================================== SSE2(2) 44162 295% ============================= Comparison speedup procedure 320x200 640x480 800x600 1024x768 naive 100% 100% 100% 100% lookup8 120% 120% 120% 120% lookup16 65% 65% 65% 60% lookup8(2) 270% 265% 270% 270% MMX 210% 210% 210% 210% SSE2 405% 390% 400% 345% SSE2(2) 360% 360% 360% 295% As we see the worst results have lookup16 . Single lookup8 is a bit faster than naive implementation, lookup8(2) that reads 2 pixels in one iteration is almost 2 times faster. I think memory latencies can help to understand these results: L1 latency is small, 3 cycles or less, L2 cache --- around 10-15 cycles. SIMD versions are naturally much faster, however SSE2(2) is a bit slower than basic SSE2 . Core i5 CPU: Core i5 CPU M 540 @ 2.53GHz The test program was run 100 times, the minimum measurement were considered. Image 320x200 procedure time [us] speedup naive 11,136 1.00 ========== lookup8 8,584 1.30 ============= lookup16 10,433 1.06 ========== lookup8(2) 3,360 3.31 ================================= MMX 3,750 2.97 ================================ SSE2 2,262 4.92 ================================================= SSE2(2) 2,192 5.08 ================================================== Image 640x480 procedure time [us] speedup naive 53,748 1.00 ========== lookup8 41,333 1.30 ============= lookup16 52,948 1.02 ========== lookup8(2) 15,853 3.39 ================================= MMX 18,114 2.97 ============================== SSE2 11,813 4.55 ============================================= SSE2(2) 11,411 4.71 =============================================== Image 800x600 procedure time [us] speedup naive 82,974 1.00 ========== lookup8 66,451 1.25 ============ lookup16 98,951 0.83 ======== lookup8(2) 24,834 3.34 ================================= MMX 31,525 2.63 ========================== SSE2 25,625 3.24 ================================ SSE2(2) 23,893 3.47 =================================== Image 1024x768 procedure time [us] speedup naive 141,784 1.00 ========== lookup8 112,439 1.26 ============= lookup16 191,798 0.73 ======= lookup8(2) 45,362 3.13 =============================== MMX 78,091 1.82 ================== SSE2 75,230 1.88 =================== SSE2(2) 75,403 1.88 =================== Comparison speedup procedure 320x200 640x480 800x600 1024x768 naive 1.00 1.00 1.00 1.00 lookup8 1.30 1.30 1.25 1.26 lookup16 1.06 1.02 0.83 0.73 lookup8(2) 3.31 3.39 3.34 3.13 MMX 2.97 2.97 2.63 1.82 SSE2 4.92 4.55 3.24 1.88 SSE2(2) 5.08 4.71 3.47 1.88 The unrolled SSE implementation beats others in most cases. The improved lookup8(2) is surprisingly good. It keeps the speedup at the same level regardless of the image size.'],
["notesen/2008-06-02-sse4-unsigned-gtlt.html", 'SSE4: grater/less or equal relations for unsigned bytes/words', 'SSE4: grater/less or equal relations for unsigned bytes/words Wojciech Mua Added on 2008-06-02 Updated on 2015-04-03 --- added proofs Relation greater or equal can be expressed with min function: Likewise relation less or equal can be expressed with max function: SSE4.1 introduced instructions PMAXUB , PMAXUW , PMINUB and PMINUW that operate on unsigned bytes and words. With help of these instructions we can compare unsigned words using presented equivalences. Here is a sample code that test if all bytes from xmm0 lie in range [lo .. hi] : Proof In the proof we consider three cases: x < y, x = y and x > y. The second and the last column (i.e. left and right side of equivalence) are the same in both cases. QED Greater or equal case x <= y min(x, y) min(x, y) = x x < y true x true x = y true x true x > y false y false Less or equal case x >= y max(x, y) max(x, y) = x x < y false y false x = y true x true x > y true x true'],
["notesen/2008-06-03-sse4-alphaover.html", 'SSSE3/SSE4: alpha blending --- operator over', 'SSSE3/SSE4: alpha blending --- operator over Wojciech Mua Added on 2008-06-03 Updates 2016-03-03 (results from Core i5) Contents Introduction SSSE3 and SSE4 algorithm outline Possible drawback SSSE3 and SSE4 implementation Test results Core2 Core i5 Introduction Alpha blending refers to many different operations. This note describes results for the over operator that works on RGBA pixels with premultiplied alpha. Basic formula: where alpha in range [0 .. 255] , and + denotes add with saturation . The reference implementation coded in C: Note : dividing by 256 never bring component value 255 --- to obtain correct range some additional operations are needed. Probably no one notice differences. SSSE3 and SSE4 algorithm outline Load 4 foreground pixels: Extend components range from bytes to words. SSSE3 implementation uses UNPCKLBW and UNPCKHBW , SSE4 --- PMOVZXBW ( PSHUFB could be also used, but need two additional vectors): Populate alpha and multiply by 256 ( PSHUFB ): Multiply alpha with components: x * (alpha << 8) --- result of PMULHUW is the higher word of result, no additional right-shift is needed to back to range [0..255] : Since the max value of multiplication result is not greater than 255, word to byte conversion is done ( PACKUSWB ): Last step is to load background pixels, add with saturation ( PADDUSB ) to xmm0 and save back results. Possible drawback While SSE can perform 8 multiplies, the sample program uses just 6 results, i.e. 75% of full power is utilized. At the moment I have no idea how to overcome this at low cost. SSSE3 and SSE4 implementation Sample program blend_32bpp contains four procedures: x86 --- C implementation (1 pixel/iteration) SSSE3 --- SIMD reference implementation (4 pixels/iteration) SSE4 --- instruction pmovzx used instead of punpckxbw (4 pixels/iteration) SSE4-2 --- unrolled SSE4 variant (8 pixels/iteration) Test results Program was compiled with following options: Core2 Two images 640 x 480 pixels (1.2MB) were blended 1\'000 times, each test was repeated 5 times, and results averaged. Test machine was Core 2 Duo @ 2.6GHz, run under Linux control. procedure time [s] speedup x86 1.727 100% ===== SSSE3 0.238 725% ==================================== SSE4 0.256 675% ================================== SSE4-2 0.173 995% ================================================== Results are impressive, I think well-tuned procedure could bring even bigger speedup. Core i5 Two images 640 x 480 pixels (1.2MB) were blended 10\'000 times. Machine: Core i5 M540 @ 2.53GHz procedure time [s] speedup x86 14.69 1.00 ===== SSSE3 2.38 6.17 ============================== SSE4 2.41 6.09 ============================== SSE4-2 1.96 7.49 ====================================='],
["notesen/2008-06-07-gcc-asm-constraints.html", 'GCC asm constraints', 'GCC asm constraints Wojciech Mua Added on 2008-06-07 Read-write variables Read-only variables, registers are clobbered This won\'t work, GCC complains: We can declare a temporary variable, and treat it as read-write: If there are more registers, or var shouldn\'t be changed, then we can declare a common dummy variable:'],
["notesen/2008-06-08-pabsq.html", 'PABSQ --- absolute value of two singed 64-bit numbers', 'PABSQ --- absolute value of two singed 64-bit numbers Wojciech Mua Added on 2008-06-08 Branch-less x86 code: SSE2:'],
["notesen/2008-06-08-rdtsc-on-core2.html", 'RDTSC on Core2', 'RDTSC on Core2 Wojciech Mua Added on 2008-06-08 RDTSC is incremented with bus-clock cycles, and then multiplied by core-clock/bus-clock ratio. From programmer view, RDTSC counter is incremented by value greater then 1, for example on C2D E8200 it is 8. Latency of RDTSC in Pentium4 is about 60-120 cycles, on AMD CPU around 6 cycles.'],
["notesen/2008-06-15-fptricks.html", 'Floating point tricks', 'Floating point tricks Wojciech Mua Added on 2008-06-15 Floating point numbers store at most 23 (32-bit float ) or 52 (64-bit double ) bits of mantissa; the most significant bit is always set (if number is normalized), thus 24 or 53 bits are known, but MSB bit isn\'t stored. Note : methods presented here produce correct results only if certain conditions are met --- they are not general, don\'t work for NaNs, denormalized numbers, etc. Converting float to int Few years ago I\'ve developed a method that do not need any floating-point operations --- description is written in Polish, but sample code should be easy to understand. In short words mantissa is completed with the implicit bit 23 (or 52) and treated as a natural number. Then this number is shifted left or right to place the dot position at 0 --- the shift amount depends on the exponent value. Another method uses floating point operations and is limited to positive number less than [...] [...] When value [...] Let see an example, number 7.25 (111.01) has following floating point representation: After adding [...] Mantissa field treated as natural number contains an integer part of number. Because addition is used, then the result is rounded or truncated, depending on the current FPU\'s rounding settings. When bare bit shift is used instead of addition (as in the method mentioned earlier), then the number is always truncated. Note : this method could be used to get fixed point, just smaller value is needed: [...] Implementation from sample program float2int.c : However this method is slower than ordinal FPU instructions, i.e.: Float rounding Very similar method could be used to perform float rounding. First value [...] There is FPU instruction FRNDINT that does the job, but is very slow: Faster is another FPU code: But the trick beats both FPU methods. Sample program round2.c has been compiled with following options: Then program was run on C2D E8200 @ 2.6GHz: SSE: converting 64-bit to double [21.06.2008] On Intel forum user pvercello asked about SSE-assisted conversion of signed int 64-bit (less than [...] pvercello shown better approach, that need fewer operations. Finally I found a simple, branch-less way to do a singed conversion, unfortunately slower than FPU conversion. Below is unsigned int to float algorithm outline. Please follow the discussion to find details about signed conversion. The idea is based on the same property of floats that is use in float -> int conversion. Assure, that the number is less than [...] [...] Set the exponent of floating point number to 52 --- value of such double is [...] Last step is to subtract floating point value [...] Sample program convert_int52_double.c is available.'],
["notesen/2008-06-18-sse-uint32-to-float.html", 'SSE: conversion uint32 to float', 'SSE: conversion uint32 to float Wojciech Mua Added on 2008-06-18 There is no such instruction --- CVTDQ2PS converts signed 32-bit ints. Solution: first zero the MSB, such number is never negative in U2, so mentioned instruction could be used. Then add [...] See a sample implementation .'],
["notesen/2008-06-21-sse4-crossfading.html", 'SSSE3: PMADDUBSW and image crossfading', 'SSSE3: PMADDUBSW and image crossfading Wojciech Mua Added on 2008-06-21 Updated on 2016-05-03 ( Dmitry Petrov noticed that alpha can have better resolution; new SWAR code; updated results for Core i5) 2016-03-02 (results from Core i5), 2015-12-26 (instruction pmaddubsw was introduced by SSSE3, not SSE4; thanks a lot Harold!) Contents Introduction Algorithm outline SWAR Algorithm outline Sample program Test results Core2 (outdated) Core i5 Core i7 Conclusions Introduction Image crossfading is a kind of alpha blending where a final pixel is the result of linear interpolation of pixels from two images: where alpha lie in range [0, 1]. Of course when operating on \"pixels\" color components are considered; components are unsigned bytes. SSSE3 introduced instruction PMADDUBSW . This instruction multiply a destination vector of unsigned bytes by a source vector of signed bytes --- the result is a vector of signed words. Then adjacent words are added with signed saturation (the same operation as PHADDSW ). This is exactly what crossafading needs. The obvious drawback is that instruction operates on signed values. Because alpha must be positive, this reduces resolution of alpha from 8 to 7 bits. (was: Because multiplication results are signed and then added, the sum must not be greater than 32767 --- this requirement reduces resolution by another bit. Finally alpha must lie in range [0..63]. ) Dmitry Petrov pointed out that alpha can be a 7-bit value, as such value never cause an overflow. Let\'s assume that both pixel1 and pixel2 have maximum value, and check if following inequality is true: Obviously the inequality is true. Algorithm outline Prepare constant vector of 127*alpha / 127*(1-alpha) : Load 16 components from images X and Y: Interleave components: Interpolate components with PMADDUBSW : Divide by 64 --- now all words lie in range [0..255] : Pack words to bytes and save result: goto 2 SWAR Crossfading using SWAR approach is possible and on 64-bit machines is pretty fast. The core SWAR idea is to perform 4 multiplications using single multiplication instruction. When a register has following byte layout: then multiplication by value in range [0..255] yields a vector of four 16-bit values. Algorithm outline Load four pixels: Isolate odd and even components (_ denotes 0): Multiply by alpha and 255 - alpha (values in range [0..255]): Add components, no overflow is possible. Now each components is premultiplied by 256: Divide by 256 and set proper byte position: Save the result: Number of operations per two pixels: bit-and: 6, bit-or: 1, add: 2, mul: 4, shift: 3. Sample program Sample program contains following procedures: x86 --- C implementation ( blend ); SSE4 --- SSE approach: first components are extended from byte to word, then multiply with PMULUHW and finally packed back ( SSE4_blend ); I called it SSE4 because for extending instruction PMOVZXBW is used, however this task could be accomplished with an old good PUNPCKxBW ; SSE4-2 --- implementation of above algorithm ( SSE42_blend ); swar --- implementation of SWAR; SSE(1) --- SSE translation of the SWAR algorithm; SSE(2) --- SSE translation of the SWAR algorithm, with reduced numbers of shifts. Test results Program was compiled with following options: Image 1024 x 768 pixels were crossfaded 100 times, total time is given Core2 (outdated) Results from Core2 Duo E8200 @ 2.6GHz. procedure time [us] speedup x86 745,702 1.00 SSE4 309,393 2.41 SSE4-2 309,167 2.41 Speedup over the x86 code is around 2.4 times. However comparison shows that speed of both SSE procedures is equal. Core i5 Results from Core i5 M 540 @ 2.53GHz procedure time [us] speedup SSE(2) 64,221 1.00 SSE(1) 69,228 0.93 SSE4 55,530 1.16 SSE4-2 44,315 1.45 swar 143,059 0.45 x86 206,044 0.31 The SSE4-2 algorithm is almost 1.5 faster than good implementation of the naive algorithm (SSE(2)). The SWAR algorithm is almost 40% faster than the scalar version. Core i7 Results from Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz procedure time [us] speedup SSE(2) 31,727 1.00 SSE(1) 33,684 0.94 SSE4 47,566 0.67 SSE4-2 20,939 1.52 swar 71,826 0.44 x86 70,728 0.45 As for Core i5, the SSE4-2 algorithm is almost 1.5 faster than SSE(2). But the SWAR algorithm is not faster than the scalar. Conclusions And what is worth to note that gcc invoked with the -O3 switch produced quite fast x86 code. Without any optimization x86 code was almost 10 times slower! I am surprised, and in my private ranking of the best open source application GCC has gone up.'],
["notesen/2008-08-03-sse4-insertionsort.html", 'SSE4.1: PHMINPOSUW --- insertion sort', 'SSE4.1: PHMINPOSUW --- insertion sort Wojciech Mua Added on 2008-08-03 Unusual application of PHMINPOSUW instruction as key part of insertion sort for 8 element tables. I guess it won\'t find any practical usage. Implementation :'],
["notesen/2008-12-03-join-locate.html", 'Join locate databases', 'Join locate databases Wojciech Mua Added on 2008-12-03 man locatedb says: \"Databases can not be concatenated together, even if the first (dummy) entry is trimmed from all but the first database. This is because the offset-differential count in the first entry of the second and following databases will be wrong\". It\'s true if we follow man authors --- but concatenation is possible without reencoding any database. For details about the compression scheme algorithm please refer to Wikipedia , the file format is described in man locatedb . In short: compression is based on common prefix elimination in a sequence of strings --- when a string share prefix with the previous string, we store pair (length of prefix, rest of string). For example if previous string is \"aaabbb\" and current is \"aaabcd\", then output is (4, \"cd\"), where 4 is length of common prefix: \"aaab\". Locate files also store differences between prefixes lengths; for example (4, \"...\"), (5, \"...\"), (2, \"...\") is encoded as (4, \"...\"), (5-4=1, \"...\"), (2-5=-3, \"...\") --- this is the reason why we can\'t simply join database files. However joining locate files isn\'t very complicated and, as I previously stated, do not require reencoding databases. We have to set diff value for the first entry of an appended file to negative value of the length of common prefix for the last entry of first file. For example when the first file contains three entries (0, \"...\"), (10, \"...\"), (-2, \"...\"), then last length is 0+10-2 = 8. The second file contains (0, \"...\"), (5, \"...\"). After join: (0, \"...\"), (10, \"...\"), (-2, \"...\"), ( -8 , \"...\"), (5, \"...\"). Some time ago I wrote python utility/library , and now extended it to perform this task. Implementation details: To obtain the length L of common prefix of the last entry, the first database is decoded in a dry-mode (no results are saved). Then the first file is simply copied to an output file. Before copy the second database skip first dummy-entry (diff=0, string=\"LOCATE02\") and skip diff=0 of second entry --- this need simple file seek. Then save diff=-L, and finally copy rest of the second database file. I\'ve tested joined database with native Linux locate (under Cygwin) and didn\'t notice any problems.'],
["notesen/2010-03-30-postgresq-get-rows-in-order.html", 'PostgreSQL: get selected rows with given order', 'PostgreSQL: get selected rows with given order Wojciech Mua Added on 2010-03-30 Suppose that a database stores some kind of a dictionary and an user picks some items, but wants to keep the order. For example the dictionary has entries with id=0..10, and the user picked 9, 2, 4 and 0. This simple query does the job:'],
["notesen/2010-03-31-simd-transpose-bits.html", 'Transpose bits in byte using SIMD instructions', 'Transpose bits in byte using SIMD instructions Wojciech Mua Added on 2010-03-31 Method presented here allows to get any bit permutation, transposition is just one of possible operations. Lookup-based approach would be faster, but algorithm is worth to (re)show. Algorithm outline for 8-byte vector (with SSE instruction it is possible to get 2 operations in parallel): fill vector with given byte: leave one bit per byte: perform desired transposition (\"move\" bits around): perform horizontal OR of all bytes: Here is my old MMX code (polish text); below SSE/SSE5 implementation details. Ad 1. Series of punpcklbw/punpcklwb/shufps or pshufb if CPU supports SSSE3. Ad 2. Simple pand with mask packed_qword(0x8040201008040201). Ad 3. If plain SSE instructions are supported this step requires some work. First, each bit is populated to fill the whole byte (using pcmpeq --- we get negated result), then mask bits on desired positons. SSE5 has powerful instruction protb that can do perform rotation of each byte with independent amount --- so in this case just one instruction is needed. Ad 4. Since bits are placed on distinct positions, we can use instruction psadbw , that calculate horizontal sums of bytewide differences from two registers (separately for low and high registers halves). If one register is full of zeros, we get sum of bytes from other register. Depending on instruction set, three (SSE) or two (SSE5) additional tables are needed.'],
["notesen/2010-04-01-branchless-signum.html", 'Branchless signum', 'Branchless signum Wojciech Mua Added on 2010-04-01 Problem: calculate value of sign(x) : -1 when x < 0 0 when x = 0, +1 when x > 0. My solution do not involve any hardware specific things like ALU flags nor special instructions --- just plain AND, OR, shifts. C99 implementation:'],
["notesen/2010-04-01-clone-bit.html", 'Fill word with selected bit', 'Fill word with selected bit Wojciech Mua Added on 2010-04-01 This is continuation of the subproblem from the previous post: we have a word (byte, dword, whatever) and want to fill it with the selected bit. The most general algorithm mask bit: clone word: shift bit in first word to MSB, and to LSB in second word: subtract c = a - b: add missing MSB c = c OR a : If arithmetic shifts are supported shift bit to MSB: arithmetic shift right: 386 processor specific On processors 386+ we can clone the carry flag (CF) with sbb reg, reg and with bt reg, reg copy the selected bit from a reg to CF.'],
["notesen/2010-04-03-stl-map-of-strings.html", 'STL: map with string as key --- access speedup', 'STL: map with string as key --- access speedup Wojciech Mua Added on 2010-04-03 The idea is quite simple: we do not have a single stl::map<string, something> , but a vector of maps, indexed with O(1) time --- each map stores keys sharing certain properties. Drawback: additional memory. I\'ve tested following grouping schemes: the length of string, the first letter of string (one level trie), both length and the first letter. Third is the fastest --- around 60% faster then plain std::map from GCC (red-black tree). Tests: my program read plain text (I\'ve used The Illiad from http://gutenberg.org ), text is split into words (~190000) and then each words is inserted into a dictionary (~28000 distinct words); then the same words are searched in dictionaries. Table below summarizes results on my computer (gcc 4.3.4 from Cygwin). data struct running time [ms] speedup [%] min avg max min avg max inserting std::map 269 287 355 100 100 100 first char 218 241 395 81 84 111 length 218 240 345 81 84 97 len./char 165 172 207 61 60 58 searching std::map 295 322 483 100 100 100 first char 243 263 460 82 82 95 length 238 248 292 80 77 60 len./char 184 190 241 62 60 50 Download test program .'],
["notesen/2010-04-08-branchless-xchg.html", 'Brenchless conditional exchange', 'Brenchless conditional exchange Wojciech Mua Added on 2010-04-08 Suppose we have to exchange (or just move) two registers A and B: C := A xor B C := 0 if condition is not true A := A xor C B := B xor C If C is 0, then A and B left unchanged, else A and B are swapped. If only a conditional move from B to A is needed, then step 4th have to be skipped. Here is a sample x86 code, where condition is value of CF: Branchless moves are possible in Pentium Pro and higher with instructions cmovcc. See also XOR linked list .'],
["notesen/2010-04-11-is-pow2.html", 'Determining if an integer is a power of 2', 'Determining if an integer is a power of 2 Wojciech Mua Added on 2010-04-11 Method from Bit Twiddling Hacks : (x != 0) && (x & (x-1) == 0) . GCC compiles this to following code: We can use also BSF and BSR instructions, which determine position of first and last bit=1, respectively. If a number is power of 2, then just one bit is set, and thus these positions are equal. BSx sets also ZF flag if input value is zero.'],
["notesen/2010-05-01-reverse-array-of-bytes.html", 'Speedup reversing table of bytes', 'Speedup reversing table of bytes Wojciech Mua Added on 2010-05-01 In-place reversing is performed by following algorithm: We can use some CPU-specific instruction to speedup the algorithm. 486 processors have BSWAP instruction that swaps four bytes (quick conversion between big-/little-endian); SSE2 extension has PSHUFD that calculate any combination of dwords in an xmm register, likewise PSHUFLW and PSHUFHW calculate combinations of words; SSSE3 extension has PSHUFB that calculates any combination of 16 bytes from an xmm register. Program can load a part of table into registers, then swap bytes in register using one or more instructions and then store register\'s content at new position. If the size of a table is not multiply of register size, then few bytes in the middle of a table have to be swapped using default algorithm. Modified algorithm outline: Function hardware_swap(x) is equivalent to single instruction: BSWAP reg or PSHUFB xmm, const ; SSE2 code requires more instructions: Test program contains several procedures that implement the modified algorithm: swap_tab_asm (alias x86) --- asm implementation of default algorithm (reference); swap_tab_bswap (bswap) --- modified algorithm: one bswap (8 bytes per iteration) swap_tab_bswap_unrolled (bswap2) --- modified algorithm: two bswap (16 bytes per iteration) swap_tab_sse (sse) --- modified algorithm: one SSE swap (32 bytes per iteration) swap_tab_sse_unrolled (sse2) --- modified algorithm: two SSE swaps (64 bytes per iteration) swap_tab_pshufb (pshuf) --- modified algorithm: one PSHUFB (32 bytes per iteration) swap_tab_pshufb_unrolled (pshuf2) --- modified algorithm: two PSHUFB (64 bytes per iteration) Important note : SSE implementations use safe MOVUPS instruction for transfers data from/to memory. This instruction is much slower than MOVAPS even if accessing aligned data! Tests Two scenarios of test were considered: The table size is hardware friendly, i.e. is multiply of implementation base step; also address of table is aligned: all procedures use MOVUPS , all procedures use MOVAPS . The size is not hardware friendly and address is not aligned. Procedures were tested on following computers: recent Core 2 Due E8200, quite old Pentium M (instruction PSHUFB not available). Quick results discussion: As always speedup depends on the table size --- for larger tables speedup is also larger. Max speedup: Core 2: 15.5 times --- PSHUFB unrolled & MOVAPS 3.5 times --- PSHUFB & MOVUPS Pentium M: 4 times --- BSWAP unrolled Unaligned memory access kills performance --- results clearly shows this behaviour. Results for Core 2 Results Results Results Results for Pentium M Results Results Results'],
["notesen/2010-06-09-brancheless-hex-print.html", 'Branchless set mask if value greater or how to print hex values', 'Branchless set mask if value greater or how to print hex values Wojciech Mua Added on 2010-06-09 Suppose we need to get a mask when a nonnegative argument is greater then some constant value; in other words, we want to evaluate following expression: Portable branchless solution: choose a magic number M := (1 << (k-1)) - 1 - n , where k is a bit position, for example 31 if we operate on 32-bit words calculate R := x + M k-th bit of R is set if x > n fill mask with this bit - see note Fill word with selected bit The key to understand this trick is binary form of M: 0111..1111zzzz , where z is 0 or 1 depending on n value. When x is greater then n , then x + M has form 1000..000zzzz , because the carry bit propagates through series of ones to the k-th position of the result. Real world example --- branchless converting hex digit to ASCII ( M=0x7ffffff6 for k=31 and n=9 ). It is also possible to convert 4 hex digits in parallel using similar algorithm, but the input data have to be correctly prepared. Moreover generating mask requires 3 instructions and one extra register (in a scalar version just one arithmetic shift). I guess it wont be fast on x86, maybe this approach would be good for a SIMD code, where similar code transforms more bytes at once. See also: SSSE3: printing hex values (weird use of PSHUFB instruction)'],
["notesen/2011-02-17-traversing-trees.html", 'Traversing tree without stack', 'Traversing tree without stack Wojciech Mua Added on 2011-02-17 This is a solution of some exercise from Cormen handbook (AFAIR exercise limited domain to binary trees). If you study algorithms and data structures, please DO NOT READ this text. Introduction Obvious traversal algorithms require [...] An iterative algorithm described here performs depth-first-search and requires [...] p , is a node processed in the previous step of the algorithm. Following properties of a tree node x are needed: it is possible to check if a node y is a child ( x.is_child(y) ); it is possible to check if a node y is a parent ( y = x.parent() ); it is possible to get the first child node ( x.first_child() ); it is possible to get the next sibling child node if another child y is given ( x.next_sibling(y) ); For binary trees all of these functions are quite simple. The main disadvantage is necessary to remember the parent of each node. Algorithm Initial conditions: p = nil x = root In each iteration following cases are considered: If x is a leaf, then go to the parent. If p = nil , then go the first child of x , If p is a parent of x , then go to the first child of x . If p is a child of x , then go to next sibling node of p , but if there is no more sibling nodes, go to the parent of x . The processing ends in 4th case, when x is root and we try to reach its parent (impossible, isn\'t it). To get pre-order scheme, visiting of node have to be performed after going deeper, i.e. in cases 2, 3 and 4 (see sample code). Download Sample python implementation .'],
["notesen/2011-02-26-python-is-iterable.html", 'Python: test if object is iterable', 'Python: test if object is iterable Wojciech Mua Added on 2011-02-26'],
["notesen/2011-03-26-trie-representation.html", 'Efficient trie representation', 'Efficient trie representation Wojciech Mua Last update 2011-03-31 Added on 2011-03-26 Trie is a multi-way tree, where each edge is labelled with a single letter. In this text several trie representations are shown. The article is the side effect of work on the pyahocorasic module . Contents Introduction Simple layouts Array of all possible edges [version 1] Pointer to array of all possible edges [version 1a] Pointer to array of limited set of edges [version 1b] Pointer to array of limited set of edges --- lookup tables Dynamic table of pointers [version 2] Linked list of pointers [version 2b] Dynamic table modifications Table of letters and pointers [version 3] Table of letters, children count and pointers [version 3b] Array of children nodes [version 4] Table of letter and array of children nodes [version 4a] Experiments results summary Speed Memory allocators Experiments Updates Introduction Each node of a tree store two kinds of data: user data and trie-related data. Let say an alphabet has at most 256 letters, thus a letter could be saved on a byte. During maintaining tree structure following issues appear: Amount of memory required to store nodes and edges. Internal memory fragmentation in underlying dynamic memory allocation routines ( malloc / free ), that makes real size of tree larger. If small object are allocated/reallocated fragmentation could be significant. Dynamic allocation/reallocation scatters data on a heap, making cache misses visible. Using arrays may improve memory locality . Data alignment in nowadays CPUs is important, making reading and writing memory faster. Structure of node could be packed to fill the smallest possible memory at cost of speed. Time required to retrieve a child node depending on a letter (edge label): const (arrays), logarithmic (arrays) or, linear (arrays, lists). In experiments Polish, English, French and German words lists were used. User data has got two pointers, i.e. additional 8 bytes per node. list words trie nodes english 138 622 312 855 german 162 032 610 470 french 629 420 1 297 080 polish 3 588 729 5 933 658 The sample program were linked against GNU libc, and procedure malloc_stats from malloc.h was used to obtain statistics about the real memory usage. Simple layouts Array of all possible edges [version 1] The simplest solution is to store all possible pointers to children nodes in array of constant size. C-structure: Procedure that returns child node or NULL depending on a letter works in constant time: Cons Huge memory requirements --- size of node 256 * size of pointer + size of user data . Pros Very simple implementation and use. Theoretically constant time addressing, but because of large data cache misses may be visible. Experiment results language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 1,032 322,866,360 1032.00 325,369,216 2,502,856 0.77 german 1,032 630,005,040 1032.00 634,888,816 4,883,776 0.77 french 1,032 1,338,586,560 1032.00 1,348,963,216 10,376,656 0.77 polish n/a n/a n/a n/a n/a n/a Pointer to array of all possible edges [version 1a] Instead of a static array of pointers allocate such array only when needed, i.e. leaf nodes don\'t occupy much memory. This cost additional test when accessing children. Node structure: Next function: Pros smaller memory, but still large Experiments results language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 12 232,249,620 742.36 235,286,176 3,036,556 1.29 german 12 495,588,296 811.81 501,844,744 6,256,448 1.25 french 12 894,746,784 689.82 906,803,728 12,056,944 1.33 polish n/a n/a n/a n/a n/a n/a Pointer to array of limited set of edges [version 1b] Do not store the array of all possible pointers, but only a continuous range between first and last non-null pointer. Node structure: The array has size hi - lo + 1 . Next function: Pros much smaller memory (but still quite large and in degenerated cases allocated memory could be as large as in version 1a) Cons more tests in order to retrieve a child node inserting/deleting nodes require more operations Experiments results language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 16 12,688,512 40.56 17,552,000 4,863,488 27.71 german 16 18,303,588 29.98 28,461,208 10,157,620 35.69 french 16 44,657,336 34.43 63,965,320 19,307,984 30.19 polish 16 312,236,524 52.62 393,812,632 81,576,108 20.71 Pointer to array of limited set of edges --- lookup tables This method extends 1b approach. The size of chars set stored in entire trie may be smaller than 256, for example words in english dictionary contains small and big letters and apostrophe, i.e. about 53 chars. Thus the size of array in each node could be much smaller, with cost of additional translation table(s). Such translation tables can be applied for all nodes or be specific for nodes at the same depth. Sample functions retrieving a child node: Pros even less memory (but still large) Cons 3 or 4 memory accesses, additional tests translation tables can be constructed when a trie already exists adding new words containing invalid characters forces to rebuild lookup tables Experiments results Global translation table has 54 elements, while size of translation tables created for each depth vary from 1 to 53: Results for tries with additional lookups. method node struct size total size bytes/node All possible edges 1036 324,117,780 1036.00 Global translation table 16 72,582,360 232.00 Depth-local translation table 16 41,797,316 133.60 Dynamic table of pointers [version 2] Dynamic table of pointers --- store only non-null pointers. This require store also size of a table and a edge label. Procedure returns next node: Pros Simple to use, less memory usage than the linked list version. Cons Linear time to obtain a child node. Many indirect memory operations. Adding/removing require reallocating memory, this brings internal fragmentation. Improvements Keep a table sorted and thus allow logarithmic time to obtain a child ( binary search ). Or use move-to-front strategy. For n = 1 do not allocate 1-element table, but save pointer directly in a node structure ( version 2a ). Experiments results Version 2: language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 16 6,257,096 20.00 11,193,376 4,936,280 44.10 german 16 12,209,396 20.00 22,448,216 10,238,820 45.61 french 16 25,941,596 20.00 45,420,392 19,478,796 42.89 polish 16 118,673,156 20.00 201,448,152 82,774,996 41.09 Version 2a: language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 16 5,563,904 17.78 8,419,680 2,855,776 33.92 german 16 10,607,980 17.38 16,040,816 5,432,836 33.87 french 16 23,480,024 18.10 35,573,008 12,092,984 33.99 polish 16 109,473,048 18.45 164,644,264 55,171,216 33.51 Linked list of pointers [version 2b] Use single-linked list instead of dynamic table. This requires also store a letter (label\'s edge) on a list. Procedure returns next node: Pros Store only required links. Cons Linear time to obtain a child node. Many indirect memory operations. Each node of linked list has small size (2 pointers = 8 bytes on 32-bit machine), thus large internal memory fragmentation when a standard C library routines are used ( malloc / free ). Improvements Use move-to-front strategy, i.e. move last found item to the front of a list --- next search will find this item faster. Use memory pools to reduce memory wasting. See section Memory allocators Experiments results language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 12 7,508,508 24.00 10,011,360 2,502,852 25.00 german 12 14,651,268 24.00 19,535,040 4,883,772 25.00 french 12 31,129,908 24.00 41,506,560 10,376,652 25.00 polish 12 142,407,780 24.00 189,877,056 47,469,276 25.00 Dynamic table modifications Table of letters and pointers [version 3] The dynamic table require two memory reads: the first gets a pointer to child, then get a letter from a child. In this representation letters are separated from the node structure and saved in front of the table of pointers. Sample memory layout for node with 3 children: Letters area has size rounded to alignment, in this case 4 bytes. Structure of node is simple: Procedure returns next node: Pros Letters are stored in a single memory area, thus specialized routines to locating chars could be used, for example functions that use SSE instructions. Cons Linear time to obtain a child node. Adding/removing words require reallocating memory. Internal memory fragmentation in letters area. Because of structure packing size of node don\'t become smaller. Improvements Keep a table sorted and thus allow logarithmic time to obtain child nodes. Or use move-to-front strategy. After all structure packing could be ally. If alignment is 4 bytes, then there are two free bytes after n element. If n == 1 or n == 2 we don\'t need to allocate letters part of dynamic table, but use these spare bytes. ( version 3a ) Procedure returns next node: Experiments results Version 3: language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 16 7,588,476 24.26 11,349,160 3,760,684 33.14 german 16 18,070,716 24.17 28,197,544 10,126,828 35.91 french 16 62,388,760 24.20 97,167,832 34,779,072 35.79 polish 16 310,656,956 24.24 480,136,984 169,480,028 35.30 Version 3a: language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 16 6,406,060 20.48 11,349,160 4,943,100 43.55 german 16 15,098,296 20.19 28,122,600 13,024,304 46.31 french 16 52,107,676 20.21 96,885,336 44,777,660 46.22 polish 16 259,933,364 20.28 478,677,552 218,744,188 45.70 Table of letters, children count and pointers [version 3b] A modification of the previous scheme --- move counter n to a dynamic array. Also type of n could be change to uint8_t . If node has no children, then pointer is NULL, and n never get value 0, so we have values outside range 1..256. Structure of node is simple: Procedure returns next node: Sample memory layout for node with 3 children: Pros smaller size of a node Cons see previous section Experiments results language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 12 6,297,676 20.13 8,841,424 2,543,748 28.77 german 12 12,267,360 20.09 17,782,664 5,515,304 31.02 french 12 26,152,132 20.16 35,824,896 9,672,764 27.00 polish 12 120,114,864 20.24 158,666,648 38,551,784 24.30 Array of children nodes [version 4] Instead of storing pointers to children it\'s possible to store all children nodes in a single array and save only one pointer to that array. Structure of node: Pros much smaller memory requirements memory locality (spatial locality) Cons adding/removing nodes require reallocation, this bring internal memory fragmentation Size improvements If a trie is not modified, then memory could be even more compacted, but following constraints are set: all nodes are stored in a continuous area of memory (array) there are up to [...] Structure of node: Procedure that returns child node: Such trie takes exactly nodes count * sizeof(TrieNode) . Experiments results language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 16 5,005,680 16.00 6,814,952 1,809,272 26.55 german 16 9,767,520 16.00 13,623,080 3,855,560 28.30 french 16 20,753,280 16.00 27,680,536 6,927,256 25.03 polish 16 94,938,528 16.00 122,940,568 28,002,040 22.78 Table of letter and array of children nodes [version 4a] This is merge of version 4 and version 3b --- children nodes are saved in an array (v4), a children counter and edge lables are also stored in the table (v3b). Structure of node: (Pseudo)structure od array: Procedure returns next node: Pros & cons same as for version 4 Experiments results language node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] english 12 4\'687\'400 14.98 6\'340\'624 1\'653\'224 26.07 german 12 9\'290\'880 15.22 12\'901\'616 3\'610\'736 28.00 french 12 19\'209\'800 14.81 25\'460\'408 6\'250\'608 25.55 polish 12 86\'460\'392 14.57 111\'249\'824 24\'789\'432 22.28 Experiments results summary English words: layout node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] version 1 1,032 322,866,360 1032.00 325,369,216 2,502,856 0.77 version 1a 12 232,249,620 742.36 235,286,176 3,036,556 1.29 version 1b 16 12,688,512 40.56 17,552,000 4,863,488 27.71 version 2 16 6,257,096 20.00 11,193,376 4,936,280 44.10 version 2a 16 5,563,904 17.78 8,419,680 2,855,776 33.92 version 2b 12 7,508,508 24.00 10,011,360 2,502,852 25.00 version 3 16 7,588,476 24.26 11,349,160 3,760,684 33.14 version 3a 16 6,406,060 20.48 11,349,160 4,943,100 43.55 version 3b 12 6,297,676 20.13 8,841,424 2,543,748 28.77 version 4 16 5,005,680 16.00 6,814,952 1,809,272 26.55 version 4a 12 4\'687\'400 14.98 6\'340\'624 1\'653\'224 26.07 German words: layout node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] version 1 1,032 630,005,040 1032.00 634,888,816 4,883,776 0.77 version 1a 12 495,588,296 811.81 501,844,744 6,256,448 1.25 version 1b 16 18,303,588 29.98 28,461,208 10,157,620 35.69 version 2 16 12,209,396 20.00 22,448,216 10,238,820 45.61 version 2a 16 10,607,980 17.38 16,040,816 5,432,836 33.87 version 2b 12 14,651,268 24.00 19,535,040 4,883,772 25.00 version 3 16 18,070,716 24.17 28,197,544 10,126,828 35.91 version 3a 16 15,098,296 20.19 28,122,600 13,024,304 46.31 version 3b 12 12,267,360 20.09 17,782,664 5,515,304 31.02 version 4 16 9,767,520 16.00 13,623,080 3,855,560 28.30 version 4a 12 9\'290\'880 15.22 12\'901\'616 3\'610\'736 28.00 French words: layout node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] version 1 1,032 1,338,586,560 1032.00 1,348,963,216 10,376,656 0.77 version 1a 12 894,746,784 689.82 906,803,728 12,056,944 1.33 version 1b 16 44,657,336 34.43 63,965,320 19,307,984 30.19 version 2 16 25,941,596 20.00 45,420,392 19,478,796 42.89 version 2a 16 23,480,024 18.10 35,573,008 12,092,984 33.99 version 2b 12 31,129,908 24.00 41,506,560 10,376,652 25.00 version 3 16 62,388,760 24.20 97,167,832 34,779,072 35.79 version 3a 16 52,107,676 20.21 96,885,336 44,777,660 46.22 version 3b 12 26,152,132 20.16 35,824,896 9,672,764 27.00 version 4 16 20,753,280 16.00 27,680,536 6,927,256 25.03 version 4a 12 19\'209\'800 14.81 25\'460\'408 6\'250\'608 25.55 Polish words: layout node size [bytes] trie size [bytes] bytes/node allocated [bytes] wasted [bytes] wasted [%] version 1 n/a n/a n/a n/a n/a n/a version 1a n/a n/a n/a n/a n/a n/a version 1b 16 312,236,524 52.62 393,812,632 81,576,108 20.71 version 2 16 118,673,156 20.00 201,448,152 82,774,996 41.09 version 2a 16 109,473,048 18.45 164,644,264 55,171,216 33.51 version 2b 12 142,407,780 24.00 189,877,056 47,469,276 25.00 version 3 16 310,656,956 24.24 480,136,984 169,480,028 35.30 version 3a 16 259,933,364 20.28 478,677,552 218,744,188 45.70 version 3b 12 120,114,864 20.24 158,666,648 38,551,784 24.30 version 4 16 94,938,528 16.00 122,940,568 28,002,040 22.78 version 4a 12 86\'460\'392 14.57 111\'249\'824 24\'789\'432 22.28 Speed Procedure tests if word is present in trie: All representations has been tested using similar procedure, and there are two conclusion: Any array-based approach is fast, no differences spotted, even if large input data and large tries were used. Linked list is 80 (eighty) times slower then array-based representation. Memory allocators Experiments clearly shows that internal memory fragmentation is significant, at least when GNU libc is used. The answer to this problem are specialized allocators. All representations require allocate (or free) single nodes, thus memory pools could be used. For example GNU libc provides obstacks , but such stack-based memory pool is quite simple to write. Representations using dynamic arrays require more complex memory pool, thus I wrote simple bitmap-based allocator. There is a linked list of arenas: The size of allocated array isn\'t stored in arena structure, because it\'s already saved in nodes. Thanks to that memory required by allocator is much smaller, but API is slightly different and isn\'t safe: Experiments Two representations were tested with the English dictionary: linked list --- separate stack-based memory pools for nodes and for list elements (both served 1024 elements per arena); dynamic array --- stack-based memory pool for nodes (1024 elements per arena) and bitmap-based allocator for arrays elements (256 elements per arena). Linked list memory pool for nodes: arenas : 306 memory allocated for user : 3\'760\'128 bytes (306 * 1024 * 12) memory used : 3\'754\'260 bytes memory consumed by allocator structures : 4\'896 bytes (306 * 16) memory pool for list elements: arenas : 306 memory allocated for user : 3\'760\'128 bytes (306 * 1024 * 12) memory used : 3\'754\'248 bytes memory consumed by allocator structures : 4\'896 bytes (306 * 16) theoretical size of tree : 7\'508\'508 bytes malloc used bytes : 7\'534\'960 bytes wasted : 36\'244 bytes, 0.48% (26\'452 - malloc, 2 * 4\'896 - pools) Dynamic array memory pool for nodes: arenas : 306 memory allocated for user : 5\'013\'504 bytes (305 * 1024 * 16) memory used by user : 5\'005\'680 bytes memory consumed by allocator structures : 4\'896 bytes (306 * 16) memory pool for arrays: arenas : 1224 memory allocated for user : 1\'253\'376 bytes (1224 * 256 * 4) memory used by user : 1\'251\'416 bytes (312854 * 4) memory consumed by allocator structures : 48\'960 bytes (1224 * 40) theoretical size of tree : 6\'257\'096 bytes malloc used bytes : 6\'332\'992 bytes wasted : 129\'752 bytes, 2.05% (75\'896 - malloc, 4\'896 and 48\'960 - pools) Updates 2011-03-31 new representation [v4a], info about speed 2011-03-30 added 2 new representations [1a, 1b], reorganization of text 2011-03-28 added experiments results for memory pools'],
["notesen/2011-04-08-sequence-like-object.html", 'Python: C extensions --- sequence-like object', 'Python: C extensions --- sequence-like object Wojciech Mua Added on 2011-04-08 If a class has to support standard len() function or operator in , then must be a sequence-like. This requires a variable of type PySequenceMethods , that store addresses of proper functions. Finally the address of this structure have to be assigned to tp_as_sequence member of the main PyTypeObject variable. Here is a sample code:'],
["notesen/2011-04-09-dawg-as-dictionary.html", 'DAWG as dictionary? Yes!', 'DAWG as dictionary? Yes! Wojciech Mua Added on 2011-04-09 If you read the Wikipedia entry about DAWG , then you find following sentence: Because the terminal nodes of a DAWG can be reached by multiple paths, a DAWG is not suitable for storing auxiliary information relating to each path, e.g. a word\'s frequency in the English language. A trie would be more useful in such a case. This isn\'t true! There is a quite simple algorithm, that allow to perform two-way minimal perfect hashing (MPH), i.e. convert any path representing a word to a unique number, or back --- a number to a path (word). Values lie in the range 1 .. n , where n is the number of distinct words saved in a DAWG. The algorithm is described in Applications of Finite Automata Representing Large Vocabularies , by Claudio Lucchiesi and Tomasz Kowaltowski (preprint is freely available somewhere online). The main part of the algorithm is assigning to each node the number of reachable words from a node; this can be easily done in one pass. Then these numbers are used to perform perfect hashing. Hashing algorithm is fast and simple, translation from pseudocode presented in the paper is straightforward. Algorithm requires additional memory for numbers in each node and a table of size n to implement dictionary lookups. I\'ve updated pyDAWG to support MPH.'],
["notesen/2011-04-11-traversing-dags.html", 'Traversing DAGs', 'Traversing DAGs Wojciech Mua Added on 2011-04-11 If a DAG has got one component, then the simplest traversing method is depth-first-search, which could be easily implemented recursively (using an implicit stack). On every call of DFS() the variable val is switched, and visited member is marked alternately with true or false . There is just one problem --- what if a traversing method stop execution before visiting all nodes? Of course in such situation we have to visit the DAG twice: on first pass reset (possibly many times) visited member to false , and then visit once each node. But usually bool have at least 8 bits, so numbers could be used instead of boolean values 0 or 1. On each call of DFS() a reference number is incremented, thanks to that even if previous call stopped in the middle, the procedure will work correctly. The only moment when visited markers have to be cleared is wrapping a reference numbers to zero. This happen every 256 calls if 8-bit values used; for wider counters (16, 32 bits) max value is greater.'],
["notesen/2011-10-21-sse-itoa.html", 'SSE: conversion integers to decimal representation', 'SSE: conversion integers to decimal representation Wojciech Mua Added on 2011-10-21 Updated on 2018-03-25 (updated test results, link to Milo\'s benchmarks) Contents Introduction SSE details Division Variable shifts Counting leading zeros Algorithm 1 Algorithm 2 Real-word requirements & limitations Implementation Tests results Core2 Duo E8200 (2Gz) Algorithm 1 --- utoa32_sse Algorithm 2 --- utoa32_sse_2 Westmere i5 M540 @ 2.53GHz Algorithm 1 --- utoa32_sse Algorithm 2 --- utoa32_sse_2 Core i7-6700 CPU @ 3.40GHz Algorithm 1 --- utoa32_sse Algorithm 2 --- utoa32_sse_2 See also Changelog Introduction With SSE2 instructions it\'s possible to convert up to four numbers in range 0..9999_9999 and get 32 decimal digits results. This texts describe code for two numbers (suitable for 64-bit conversions) and for one number (suitable for 32-bit conversions). The outline of algorithm 1 has been posted by Piotr Wyderski on the usenet group pl.comp.lang.c , I merely implemented it. The main idea is to perform in parallel divisions & modulo by [...] [...] [...] [...] I\'ve developed the algorithm 2, converting just a single 8-digit number. First division & modulo by [...] [...] [...] [...] SSE details Division SSE doesn\'t provide an integer division, but division by a constant can be achieved using multiplication. This is well known and widespread technique, see for example Division by Invariant Integers using Multiplication by Torbjrn Granlund & Peter L. Montgomery, it\'s also described in Hackers Delight and Reciprocal Multiplication . The division algorithm follows scheme: There are two multiplication, one subtract and (sometimes optional) one right shift. The constant MC is calculated with following formula: Where d >= word bits and word bits = {8, 16, 32, 64, ...} . The value of correction depends on divisor and number of bits, please check one of the notes source for details. Variable shifts Instruction pmulhuw does in parallel (word_x[i] * word_y[i]) >> 16 . If one component has form 1 << n[i] ( n[i] = 0 .. 15 ), then the result of the instruction is word_x[i] >> (16 - n[i]) , i.e. a word shifted right by specified amount from 1 to 16. This is used in algorithm 2. (Likewise pmullw can be used to perform shifts left.) Counting leading zeros Both algorithms require this. Removing leading zeros is similar procedure to strchr : On a CPU with SSE4.2 this could be done with single instruction . Algorithm 1 Division by [...] Division by [...] pmuludq that does 2 multiplications and store full a 64-bit result. Division by [...] pmulhuw that does 8 multiplications and store the high 16-bit of result; likewise pmullw stores the low 16-bit of result. This perfectly fits our needs. Division by [...] Code for conversion 64-bit numbers consist following steps: Start with two 8-digit numbers (32-bit values): Then divmod 32-bit numbers by [...] pmuludq ), results are 32-bit numbers: Then divmod 32-bit numbers by [...] pmulhuw and pmullw ), results are 16-bit numbers: Then divmod 32-bit numbers by [...] pmulhuw and pmullw ), results are 16-bit numbers: Finally join decimal digits, convert to ASCII and remove leading zeros. Algorithm 2 This algorithm can convert only a single number from range 0..9999_9999. The main idea is to divide 4-digits numbers by [...] [...] [...] Divide & modulo by [...] pmuludq ): Populate words: Multiply v1 by 4 with psllw (safe, because [...] Divide by [...] [...] [...] [...] pmulhuw ): Shift right by 9, 5, 3 and 1 bits each 4-words group (single pmulhuw , see subsection below): Calculate modulo: Pack words to bytes ( packuswb ), convert to ASCII and remove leading zeros. Ad 3. With pmuluhw we cannot divide by 1, the minimum is 2. Because pmulhuw is invoked two times (for divide and shift), we have to multiply input by 4, to finally get the abcd & efgh after step 5. Real-word requirements & limitations Signed numbers conversion requires to put a sign char in the front of string. This have to be done with CPU (scalar) instructions. Vectorized code generate 8 or 16 digits at single run. The longest 32-bit number has 10 decimal digits, and 64-bit --- 20 digits, thus 2 or 4 digits are not converted in SSE code. Using SSE code to obtain them wouldn\'t be wise decision. Implementation Sample program provides following functions: utoa64_sse --- algortihm 1: described here; utoa32_sse --- algorithm 1: implementation for 32-bit numbers; utoa32_sse_2 --- algorithm 2 utoa32 & uta64 --- plain C implementations; faster than sprintf(\"%d\", &x) . Please read the source header to find how to compile. Program can be used to measure speed of the selected procedure and to print results, thus allow to verify correctness. Tests results The best times are considered. For larger number speedup is around 3 times, while for short numbers time is comparable to the plain C code, and for very short numbers is much worse. Core2 Duo E8200 (2Gz) Tests were run on my Linux box with Core2 Duo E8200 (2GHz); gcc 4.6.1 ( -O3 flag) was used to compile the program. Algorithm 1 --- utoa32_sse number range iterations C [s] SSE [s] speedup 0 .. 99 1_000_000 0.492 0.880 56% 0 .. 9999 10_000 1.076 0.884 122% 0 .. 9999_9999 1 2.480 0.872 284% 1000_0000 .. 9999_9999 1 2.276 0.784 290% Algorithm 2 --- utoa32_sse_2 number range iterations C [s] SSE [s] speedup 0 .. 99 1_000_000 0.492 0.808 61% 0 .. 9999 10_000 1.076 0.812 132% 0 .. 9999_9999 1 2.480 0.728 340% 1000_0000 .. 9999_9999 1 2.276 0.812 280% Westmere i5 M540 @ 2.53GHz Compilation with GCC 7.3.0. Algorithm 1 --- utoa32_sse number range iterations C [ms] SSE [ms] speedup 0 .. 99 100_000 62 98 0.62 0 .. 9999 1_000 106 98 1.08 0 .. 9999_9999 1 2393 881 2.71 1000_0000 .. 9999_9999 1 2197 881 2.49 Algorithm 2 --- utoa32_sse_2 number range iterations C [ms] SSE [ms] speedup 0 .. 99 100_000 62 78 0.79 0 .. 9999 1_000 106 76 1.34 0 .. 9999_9999 1 2393 783 3.05 1000_0000 .. 9999_9999 1 2197 704 3.12 Core i7-6700 CPU @ 3.40GHz Compilation with GCC 7.3.0. Algorithm 1 --- utoa32_sse number range iterations C [ms] SSE [ms] speedup 0 .. 99 100_000 31 154 0.20 0 .. 9999 1_000 51 155 0.33 0 .. 9999_9999 1 1077 1389 0.78 1000_0000 .. 9999_9999 1 986 1533 0.64 Algorithm 2 --- utoa32_sse_2 number range iterations C [ms] SSE [ms] speedup 0 .. 99 100_000 31 123 0.25 0 .. 9999 1_000 51 122 0.42 0 .. 9999_9999 1 1077 1221 0.88 1000_0000 .. 9999_9999 1 986 1099 0.90 See also Milo Yip compared different itoa and dtoa implementations on Core i7, including the algorithm 2 which use SSE2 instructions. Results for itoa are interesting: SSE2 version is not as good as it seemed to be. Tricky branchlut algorithm is only 10% slower, moreover is perfectly portable. One obvious drawback of this method is using lookup-table - in real environment where is a big pressure on cache, memory access could be a bottleneck. Changelog 2011-11-06 2013-11-24 - minor updates 2011-11-06 - utoa32_sse_2 2011-10-15 - utoa64_sse 2011-10-09 - initial results 2011-10-08 - optimization 2011-10-07 - first utoa32_sse version'],
["notesen/2012-05-25-sql-ngram-index.html", 'Speeding up LIKE \'%text%\' queries (at least in PostgeSQL)', 'Speeding up LIKE \'%text%\' queries (at least in PostgeSQL) Wojciech Mua Added on 2012-05-25 Update 2017-03-12 (spelling), 2013-10-20, 2013-11-03 (FST results from PC, better scripts) Contents Introduction Index as a table PostgreSQL experiments Data definition N-grams indexes Demonstration Summary Download Full Search Text indexes PostgreSQL experiments GIN index GIST index Results Summary Download Introduction PostgreSQL executing queries with construct like \'%text%\' can\'t use any system index (I guess none of existing SQL servers have such feature). But it\'s possible to speed up such queries with an own index using n-grams. N-gram is a subword consists N successive characters. For example all 3-grams (trigrams) for word \"bicycle\" are: \"bic\", \"icy\", \"cyc\", \"cle\". Likewise all 4-grams for this word are: \"bicy\", \"icyc\", \"ycle\". This article shows two approaches: An n-gram index as a regular table --- may be applicable for engines other than PostgreSQL; Full Search Text indexes GIN and GIST existing in PostgreSQL since 8.4. Note that both types of indexes has different properties in terms of update and read timings. Index as a table Each row of an index contains a pair: an n-gram and a list of ids; an id points to the row in a data table where text contains given n-gram. When search is performed then the searched text is split to n-grams, and we choose the n-gram with the least number of assigned phrases. The chosen n-gram is used to limit the number of phrases, and finally a regular search is performed on such subset to filter out false-positives. Pseudocode: PostgreSQL experiments Data definition Polish aspell dictionary containing about 3.6 million words was used in experiments: The definition of table data is: Default B-tree index on id has been created. The size of relation is about 166MB, the size of index 63MB. N-grams indexes Two n-grams indexes were created for 3-letter and 4-letter grams: A B-tree index on column ngram exists on both tables. Some statistics: count min(count) avg(count) max(count) 3-grams 18107 1 2038.57 1054928 4-grams 99424 1 334.36 202237 The physical size of tables: main table [MB] TOAST table [MB] sum [MB] 3-grams 9 110 119 4-grams 28 143 171 Demonstration Check this simple query: Regardless of a searched term time is similar, about 1.6 seconds. Now we try to repeat the sample search using these 3-grams index; 3-grams for word \"domek\" are: \"dom\", \"ome\", \"mek\": The best candidate is \"mek\": 3.6 milliseconds . It\'s not mistake, typo nor random data pasted from a console. Now examine 4-grams index; 4-grams for \"domek\" are: \"dome\", \"omek\": The choice is simple: 1.1 millisecond . Summary The speedup is impressive, but the method has some weakness: The speedup highly depends on n-grams. If a searched text contains n-grams connected with large number of records it may be slow. For example in Polish the n-gram \'nie\' (means \'no\', but often is a prefix in many words) exist in 1 million words. Searching texts shorter than the shortest n-gram index requires sequence scan. Maintaining indexes needs additional work (for example in triggers). Creating indexes for many n-grams, for example five, six or more characters, could help a lot, because longer n-grams are connected with relative small number of phrases (see the first table in this text for comparison). Download functions.sql --- data definition and sample PL/pgSQL procedures; some SQL or PL/pgSQL constructs may seem non-optimal, but were carefully chosen after many experiments with explain analyze Full Search Text indexes Let define a simple function that returns an array of all trigrams: Now we are able to create a lexemes list ( tsvector ): A full text search query is represented by an object of type tsquery . The query is a set of lexemes and boolean operators ( & , | and ! ). In n-grams searches it\'s required that all grams are present, so query has form \'bic\' & \'icy\' & \'cyc\' & \'cle\' . The function that creates a query: An index can be create as a functional one using function trigrams_vector , or can be set on the dedicated table\'s column. The functional index requires the same function that is used in a condition. An extra column takes additional disc space, but when different full search queries are performed on the same table this may be the only solution. PostgreSQL experiments Sample data is a set of ~43000 titles of books from The Gutenberg Project , the postprocessed list is available for download. The table has size 3.4MB, here are some statistics: Simple query, i.e. performing sequence scan, takes 230 ms : GIN index Functional index using function trigrams_vector is defined as follows: The index size is 18MB. A SQL query have to use trigrams_vector and trigrams_query : The query plan: The downside of GIN index is obligatory rechecking a query, because this index may produce false-positive results. GIST index GIST index: The index size is 9.4MB. The plan for the same SQL query as used in the GIN example: Results There are 25 different search phrases (picked from the titles). Searching has been performed 5 times, minimum running times were considered. The script fst_test contains all data; functions and queries is available for download. Experiments were made on my old laptop (Pentium M @ 1.5GHz with 1.2GB RAM) using PosgreSQL 9.1 from Debian. phrase GIN [ms] GIST [ms] alice in wonderland 50.30 9.12 begin 0.83 280.83 build 0.79 90.42 cats 0.60 49.41 dog 0.44 327.40 eagle 0.46 44.51 europe 1.35 754.64 meaning of life 38.82 8.57 moon 0.51 94.09 old man 6.67 46.55 other stories 44.84 156.64 poland 7.85 51.66 razor 0.26 0.80 scientific 7.98 146.38 scientific american 29.89 80.84 seven 1.71 213.18 seven periods of english 69.81 3.12 Shakespear 4.02 61.99 sonnets 2.42 23.19 the odyssey 32.15 3.78 trees 1.23 81.14 whatever 4.61 14.36 wonder 3.17 145.17 world war 5.33 41.88 writer 4.20 91.95 Experiments made on my PC (Core2 @ 2.6GHz with 2GB RAM) using PosgreSQL 9.1 from Debian. phrase GIN [ms] GIST [ms] alice in wonderland 23.90 4.23 begin 0.36 111.20 build 0.35 37.87 cats 0.27 19.65 dog 0.19 128.52 eagle 0.20 18.94 europe 0.61 293.58 meaning of life 17.20 4.40 moon 0.22 37.34 old man 3.13 19.83 other stories 19.50 67.57 poland 3.42 20.94 razor 0.11 0.54 scientific 3.71 59.76 scientific american 13.22 34.19 seven 0.76 86.62 seven periods of english 31.58 2.23 Shakespear 1.88 25.70 sonnets 1.12 9.69 the odyssey 13.96 1.90 trees 0.57 31.89 whatever 2.11 5.80 wonder 1.45 60.38 world war 2.52 16.59 writer 1.93 36.96 Summary (Times are given from the first results table.) GIN search is much faster than GIST in most cases. GIST is generally slow, average time is 40 ms (times larger than 100 ms rejected). GIN average time is 13 ms (calculated for all data samples). However GIST search is faster than GIN when number of trigrams is larger. In few cases GIST search is slower than sequence scan time (280/325/750 vs 230 ms). GIN index search never reached sequence scan time, the worst time is 70 ms. Size of GIN index is two times larger than GIST (18MB vs 9.4MB). Download fst_functions.sql --- data definition and sample PL/pgSQL procedures fst_test.sql --- data & procedures used to obtain results fst_data.sql.bz2 --- list of book titles (560kB)'],
["notesen/2012-07-02-average-unsigned-ints.html", 'Average of two unsigned integers', 'Average of two unsigned integers Wojciech Mua Added on 2012-07-02 The famous error in Bentley\'s binary search code was caused by an integer overflow in following code: First the sum is evaluated, then divided (or shifted), but the sum could exceed the integer range. In unsafe languages, like Java, C or C++, such errors are not detected, while Ada would trigger an exception. The safest expression, even in unsafe languages, looks like this: We sum up all-but-the-lowest bits, then adjust this sum with carry from lowest bit ( a & b & 1 ). This expression involves two shifts, 2 additions, and two ands, require also additional storage for carry. Another approach detects an overflow without accessing to hardware registers: This require on sum, one shift and conditionally or. The condition could be expressed branchlessly: Sample program Following python script verifies both methods (for 8-bit integers)'],
["notesen/2013-09-01-php-quirk.html", 'PHP quirk', 'PHP quirk Wojciech Mua Added on 2013-09-01 PHP is very funny language. Here we are a simple class, without a constructor: One can assume that interpreter will detect undeclared variables, but as their names state this doesn\'t happen (PHP versions 5.3..5.5): When the class Foo have the constructor: everything works as expected:'],
["notesen/2013-09-15-convex-polygon-intersection.html", 'Detecting intersection of convex polygons in 2D', 'Detecting intersection of convex polygons in 2D Wojciech Mua Added on 2013-09-15 Updated on 2017-01-28 (spelling) Contents Introduction SAT recall Number of operations in the worst case Another approach Algorithm Number of operations in the worst case Demo Introduction Detecting intersection of convex polygons is a common problem in a wide range of problems. The method of separated axis theorem (SAT) is widely used, and considered as the easiest and the fastest. This article presents a quite naive algorithm, that in terms of processing polygon vertices is better than SAT --- in the worst case it requires fewer additions & multiplications. However, in practice SAT is faster. I believe that the approach was already discussed, but quick search didn\'t return anything. SAT recall SAT algorithm: for each face of both polygons find its normal, project both polygons on the normal. If projections are disjoint then the polygons do not intersect. Projection of polygon requires calculation a cross product of each vertex and the normal. If the first polygon consist [...] [...] [...] [...] Number of operations in the worst case In the worst case [...] There are [...] The number of additions/subtractions is [...] [...] Another approach If convex polygons have no intersection then exists a line, that divides the plane in two halfplanes containing each polygon. A line is represented as [...] [...] [...] There are infinity number of separating lines, but fortunately we can easily find one if we allow that a separating line goes through a vertex (or an edge) of both polygons. This assumption looses mathematical definition (i.e. sometimes sign of [...] Algorithm We check all possible lines going through all vertices of both polygons, and check which one separates them: Determining position of polygon against the line can be done in constant time . Let p is the current vertex ( vertice1 or vertice2 , depending on a polygon), and then p0 is the previous & p1 is the next vertex. If both p0 and p1 lie on the same side of the line, then whole polygon lies on that side. Since the polygon is convex, it\'s not possible that any other edge cross the line. Pseudocode: Number of operations in the worst case In the worst case most [...] Finding the line equation costs three subtracts and two multiplications. Checking a line side requires evaluation of the line equation (two multiplications and two additions), this is done four times (two points per polygon). The number of additions/subtractions is [...] [...] Demo Check interactive demonstration .'],
["notesen/2013-09-30-sse-trie.html", 'SSE: trie lookup speedup', 'SSE: trie lookup speedup Wojciech Mua Added on 2013-09-30 Last update 2017-02-14 (link to github, syntax highlighting) Introduction Trie is a multiway tree where each edge is labelled by a letter; such trees are used as dictionaries. Lookup takes [...] [...] Trie node is defined in C: Lookup procedure is simple. Function trie_next returns a child node labelled with given letter. The implementation of this procedure determines overall searching and inserting time. Analysis Following algorithms used by trie_next has been studied: linear search linear search with move-to-front strategy linear search with incremental move-to-front strategy linear search with minimized memory reads linear search optimized in SSE binary search Linear search Implementation of linear : This procedure performs at most n reads from letters array, and one from children if letters has been found. Since reading letters is done sequentially CPU caching helps. Linear search with move-to-front strategy Implementation of linear-mtf : Thanks to MTF item located at index 0 is at the fast path of procedure, hit rate was about 50% in my tests. This procedure does 3 additional reads 4 additional writes on hit item with index greater than 0. These writes gives some penalty, but are amortized by fast-path execution. Linear search with incremental move-to-front strategy Implementation of linear-mtf-incr : First variant of MTF allows to random fluctuating element located at the fast-path, this variant --- by moving item one position backward --- keep at index 0 most frequently used items. Linear search with minimized memory reads Implementation of linear-unrolled : This procedure reads 4 bytes in one iteration (when run on 32-bit machine), and also some parallelism is involved --- comparison is done for 4 bytes at once. However, this procedure require array of length rounded up to 4 bytes, that costs additional memory. Linear search optimized in SSE Implementation of sse : This is quite naive implementation, that uses obvious SSE instruction like pcmpeq and pmovmskb . In one iteration 16 bytes are processed in parallel. The downside of this method is high setup time, that is really visible when arrays are short. Binary search Implementation of binary : Procedure use straightforward binary search implementation (yes, it has integer overflow bug). Experiments Test programs use two lists: dictionary --- list of 99171 English words, /usr/share/dict/american-english from Debian; input words --- list of 133861 English words, the split text of \"The Oddysey\" from Project Gutenberg. Each test program reads dictionary and build trie, then loads input words into simple array. Finally for each input word call trie_lookup , and this is repeated 100 times. Tests were run on my old laptop with Pentium M. Tests on recent CPU are coming. Statistics There are 227979 nodes in trie. Word length Node degree Results [Pentium M, clocked at 1,5GHz] procedure min [ms] avg [ms] max [ms] linear 4501 4517 4543 linear-mtf 4386 4408 4445 linear-mtf-incr 3923 3941 3963 linear-unrolled 4111 4127 4151 sse 3951 3970 4005 binary 4400 4424 4441 As we see linear search is the worst, and binary search is not better. Unrolling loop as always helps, SSE instructions helps too. But the most surprising is that simple linear search with \"incremental\" move-to-front strategy beats all methods. As Rob Pike said \"Fancy algorithms are slow when n is small, and n is usually small.\" Proved! Sources Sample programs are available at github .'],
["notesen/2013-10-06-plpgsql-printf.html", 'PostgreSQL: printf in PL/pgSQL', 'PostgreSQL: printf in PL/pgSQL Wojciech Mua Added on 2013-10-06 PostgreSQL wiki has entry about sprintf --- is is quite simple approach (and isn\'t marked as immutable ). The main drawback is iterating over all chars of a format string. Here is a version that use strpos to locate % in the format string, and it\'s faster around 2 times:'],
["notesen/2013-11-02-postgres-reorder-tuples.html", 'PostgreSQL --- faster reads from static tables', 'PostgreSQL --- faster reads from static tables Wojciech Mua Added on 2013-11-02 Contents Introduction Problem and solution Experiments Simple reads Aggregation Summary Downloads Introduction \"Static table\" means that data is changed rarely, in my case it\'s a cache for some reporting system. Table has no any foreign keys, constraints etc. This cache is feed by night cron by a query looking like this: reports_cache_data is a stored procedure that performs all boring transformations, contains many joins, filters out certain rows, etc. The cache table contains a lot of records. The main column used by all report is a \"creation date\", range filtering on this column appear in virtually all queries. For example aggregating query looks like this: Of course there is an index on date field. Problem and solution If a range spans short period of time, then a query runs fast, but if span a few months, then could be quite slow. The reason of low speed is amount of data retrieved from a disc. The presence of index doesn\'t count, because a database engine have to read all data to feed a sum aggregator --- is not possible to avoid reading data (Of course, such big table can be partitioned and some aggregations could be precalculated). On lower level we have many disc reads, and if rows are scattered over a disc, then reads cost an additional seek time. In PostgreSQL each row has an implicit column called ctid (the type is tid ) containing a physical position of row: the block number and the row index within block. Lets examine ctid values from sample table: As we see these rows live on different blocks. In case of querying range of dates index scan is usually used. A B+-tree index in fact keeps values ordered, so in terms of block reads the index scan acts similarly to ORDER BY clause used in the example. If rows were physically ordered by date, we would expect shorter read time due to minimize seek time, utilize on-disc cache and probably operating system cache at I/O level. PostgeSQL supports command CLUSTER that reorders tuples according to given index, for example: But this doubles work, i.e first we have to fill a table, then cluster data. When the table is built from scratch, we can achieve same effect using ORDER BY on query building data: Let\'s examine ctid for this table: Now rows are saved on disc in date order. Experiments There are two tables: reports_cache --- contains 100000 rows of random data: 7 integers (simulating indices and counters) and one date field reports_cache_ordered --- same as reports_cache but data was populated as in example above. This table is called \"ordered\". Simple reads Following query was examined: Each query was executed 5 times and best running time was considered. parameters cache table time [ms] ordered table time [ms] ordered table speedup [%] LIMIT OFFSET 100 0 0.194 0.154 25.97 1000 0 0.696 0.394 76.65 10000 0 66.027 3.691 1688.86 20000 0 126.459 7.578 1568.76 50000 0 290.584 21.259 1266.88 100 100000 539.982 28.405 1801.01 1000 100000 546.095 22.566 2319.99 10000 100000 598.351 27.031 2113.57 20000 100000 654.423 30.171 2069.05 50000 100000 824.982 43.018 1817.76 100 200000 1069.146 45.186 2266.10 1000 200000 1074.740 45.423 2266.07 10000 200000 1129.873 48.953 2208.08 20000 200000 1183.656 52.939 2135.89 50000 200000 1350.786 64.667 1988.83 Aggregation In this experiment more complicated query was examined: Each query was executed 5 times and best running time was considered. parameters cache table time [ms] ordered table time [ms] ordered table speedup [%] start date end date days 2011-01-01 2011-02-01 31 105.981 24.267 336.73 2011-01-01 2011-03-01 59 127.806 46.871 172.68 2011-01-01 2011-06-01 151 188.580 113.715 65.84 2011-01-01 2011-09-01 243 252.568 180.529 39.90 2011-01-01 2012-01-01 365 340.549 275.296 23.70 2011-01-01 2013-01-01 731 629.485 624.822 0.75 Summary In an ordered table read is generally faster. The biggest speedup occurs for simple queries with OFFSET part. However, when amount of data is large, then speedup decreases. Reading time dominates over seeking, caching and other things. So, is it worth of play? Definitively yes in scenario described in the beginning, it cost just one ORDER BY clause in a query executed once per day. Downloads prepare-data.sql --- scripts to prepare tables and fill them with random data. Run SELECT init() experiment1.sql --- scripts executes test for \"Simple reads\" section. Run SELECT run_experiment1() experiment2.sql --- scripts executes test for \"Aggregation\" section. Run SELECT run_experiment2()'],
["notesen/2013-11-04-postresql-sum.html", 'Short story about PostgreSQL SUM function', 'Short story about PostgreSQL SUM function Wojciech Mua Added on 2013-11-04 Here is a simple PostgreSQL type: and a simple query wrapped in a stored procedure: Now, we want to sum everything: And we have an error about types inconsistency! This is caused by SUM function --- in PostgreSQL there are many variants of this function, as the db engine supports function name overriding (sounds familiar for C++ guys). There are following variants in PostgreSQL 9.1: Smaller types are promoted: from integer we get bigint, from bigint we get numeric, and so on.'],
["notesen/2013-11-07-fbstp.html", 'FBSTP --- the most complex instruction in x86 ISA', 'FBSTP --- the most complex instruction in x86 ISA Wojciech Mua Added on 2013-11-07 As documentation says FBSTP \"Store BCD Integer and Pop\". FBSTP saves integer part of floating point value as BCD number. Instruction expects an 11-bytes buffer, the first byte is reserved for a sign, rest are BCD digits. Disadvantages of this instruction: BCD output --- conversion to ASCII is needed. All digits are saved, including leading zeros. Limited range of numbers, not all valid double values are converted. There is limit to ~18 digits. Most important: FBST is very, very slow . Sample sources Sources are available at github. Program fbst_tests.c converts a number to a string, remove leading zeros, and detects errors: Program fbst_speed.c compares instruction FBSTP with simple implementation of itoa . There are no formatting, BCD to ASCII conversion, etc. Numbers from 1 to 10,000,000 are converted. Results from quite old Pentium M: and recent Core i7: There is no difference! FBSTP is just 5% faster on Core i7.'],
["notesen/2013-11-23-integer-sequence-encoding.html", 'Encoding array of unsigned integers', 'Encoding array of unsigned integers Wojciech Mua Added on 2013-11-23 Update 2013-11-24 (minor updates), 2013-12-01 (pair encoding) Contents Introduction Better compression Encoding subsets of close values Subset selection algorithm Varnibble Varbits Pair encoding Experiments Sample data Method 1 --- Variable length bitfields Method 2 --- Varnibble Method 3 --- Subsets of close values Method 4 --- Pick better: subsets of close values or varint/varnibble Method 5 --- Varbits Method 6 --- Pair encoding Summary and discussion Source code Bibliography Introduction Russ Cox wrote very interesting article about algorithms behind service Google Code Search. In short: files are indexed with trigrams, the query string is split to trigrams and then an index is used to limit number of searched files. Code search manages a reverse index --- there is a file list, and for each trigram there is a list of file\'s id. I\'ve interested how the list of file\'s id is stored on a disc. In the Russ implementation such list is built as follows: ids are sorted in ascending order; differences between current and previous id are encoded using variable length integers ( varint ). The variable length integer is a byte-oriented encoding, similar to UTF-8, where each byte holds 7 bit of data and 1 bit (MSB) is used as the end-of-word marker. Thus smaller values require less bytes: integers less than 128 occupy 1 byte, less than 16384 occupy 2 bytes, and so on. Important: lists of file\'s id are encoded independently , because of that it is not possible to use any common attributes to increase compression. Better compression Encoding subsets of close values Downside of byte-oriented encoding is wasting bits if values are small. For example list of id: after calculating differences becomes: The first and the last value could be saved on 2 bytes, rest on 1 byte --- total 12 bytes. Small values are stored on one byte, but in fact require 1, 2 or 3 bits, so 5-7 bits in a byte are unused. It\'s possible to efficient encode such subset of small values on a bitset of constant size. Difference between each value and the first value (\"head\") are encoded as bit positions. For subset: we have: head: 10000 (encoded separately), differences set: [1, 3, 4, 6, 7, 9, 10, 17] , and differences encoded as 32-bit bitset 00000000000000010000001101101101 . Instead of 12 bytes we got 2 + 4 + 2 = 8. Of course for longer subsets results are better, in the best case we can encode one value using just one bit; however, for subsets smaller than 6 elements this operation has no sense. Note: There is an encoding scheme called Simple9 (see the first position in bibliography) that can achieve similar compression ratio, but Simple9 requires a 4-bit header per 28-bit data word, thus compression ratio in the same scenario would be smaller. Subset selection algorithm I\'ve checked two methods: greedy --- find longest subset in the values, then remove it, repeat until no more subsets could be found; first match --- sequence scan on sequence elements, get the longest subset starting from the current value. Although first match seems to be \"too easy\", this method gives better compression ratio than greedy . Moreover is very fast and simple to implement. Greedy is very, very slow --- well maybe some kind of dynamic programming would help, but this wasn\'t the main subject of research, so I left it \"as is\". All results presented here use first match searching. Varnibble Varnibble encoding is similar to varint , in this case we operate on 4-bit words instead of 8 bits --- each word contains 3 bits of data and 1 bit of end-value marker. This encoding require some bit operations (shift, and, or) but with constant shifts amounts/masks, so this isn\'t as expansive as other bit-level encoding schemes. Varnibble decreases mentioned earlier \"bit-wasting\" for small values. Varbits This is generalization of varint and varnibble --- the number of data bits can be arbitrary. Selecting the number of bits is done once for the whole sequence, this number is saved on one byte, then all elements are encoded. Pair encoding There is compression method called \"byte pair encoding\", in pair encoding \'values\' are used instead of bytes. Algorithm: Find the pair of symbols occur most frequently in a sequence If there is no such pair --- exit Assign new value to that pair Replace all occurrences of the pair with the new value Goto 1 Experiments Sample data A set of trigrams and associated file\'s id were collected from subtree of Linux source. Each list was saved in a separate file, then I picked some of them. Here are some statistics about lists: lists count: 853 min length: 5 max length: 13002 avg length: 711 The plot shows size of lists encoded as differences with varint . Most of them are quite short, only few are long. The total size of all lists: values encoded using varint : 1,208,400 B differences encoded using varint : 621,208 B It\'s clear that using differences can save up to 50% of space, so other methods always use differences instead of plain values. Results for differences encoded with varint (called for short varint diff ) are set as reference. Comparisons with other methods are done for following properties: total size of all encoded lists; how many encoded lists have size greater/less/equal; relative space save, calculated as: (encoded size - varint diff size) / varint diff size . Method 1 --- Variable length bitfields This algorithm finds the minimum number of bits required to save the largest value from single list. Then each value is saved on a bitfield of the calculated width. Algorithm: get the maximum value of differences (except first one) calculate number of bits ( [...] [...] save the first value as a 4-byte word; save [...] save differences on k-bits fields. count count [%] size [B] size [%] greater 369 43.26 121,264 21.61 25.04 equal 49 5.74 19,240 3.43 less 435 51.00 420,537 74.96 total size 561,041 improvement 90.31% Method 2 --- Varnibble count count [%] size [B] size [%] greater 48 5.63 766 0.20 0.52 equal 82 9.61 1,234 0.32 less 723 84.76 385,867 99.48 total size 387,867 improvement 62.44% Method 3 --- Subsets of close values Encoding is done in two steps: Split values to list of pairs (head, differences subset); a difference subset could be empty if a subset contains less elements then cutoff value; in experiments it was 6 elements. Size of such subset would be greater than encoded values. Head values are treated as a separated sequence (again: differences of values are considered) and encoded using varint or varnibble . Encoded values are multiplied by 2 and the lowest bit is set when subset is not empty. count count [%] size [B] size [%] greater 461 54.04 66,427 17.78 18.68 equal 101 11.84 3,329 0.89 less 291 34.11 303,752 81.32 total size 373,508 improvement 60.13% count count [%] size [B] size [%] greater 372 43.61 34,494 9.43 10.34 equal 62 7.27 3,322 0.91 less 419 49.12 327,922 89.66 total size 365,738 improvement 58.88% Varnibble is a bit better than varint backend, however the number of samples greater/equal is significant in both cases. Method 4 --- Pick better: subsets of close values or varint/varnibble As we saw subsets methods are not always better, so there is a room for some improvement. This method is combination of two encodings: method 3 with varint or varnibble encoding. List of integers is encoded using subsets method and also with varint / varnibble , then shorter form is saved. We need to save which method is used, this require just one bit --- the first element of list is multiplied by 2 and the lowest bit is set/unset depending of the selected method. This solution is cheap, because in the worst case costs an additional byte/nibble, while in average case increase compression ratio. count count [%] size [B] size [%] greater 0 0.00 0 0.00 17.63 equal 562 65.89 65,026 17.63 less 291 34.11 303,752 82.37 total size 368,778 improvement 59.36% count count [%] size [B] size [%] greater 48 5.63 766 0.23 0.59 equal 82 9.61 1,234 0.37 less 723 84.76 335,743 99.41 total size 337,743 improvement 54.37% Method 5 --- Varbits Selecting number of data bits is done in straightforward way: encode data on bits 1..16, then the best one is picked: For sample set of data, optimal number of bits is usually smaller than 7 bits used by varint . count count [%] size [B] size [%] greater 57 6.68 780 0.23 0.53 equal 71 8.32 1,032 0.30 less 725 84.99 339,788 99.47 total size 341,600 compression 54.99% Method 6 --- Pair encoding New values for pair numbers are selected starting from 1, excluding already used values that present in a sequence. Each pair is saved as three values: (pair number, value 1, value 2). The end of a pair list is marked with value 0, then values from sequence are stored. Finally to save values varint and varnibble encoders were used. Results for varint : count count [%] size [B] size [%] greater 652 76.44 131,606 29.65 29.83 equal 4 0.47 806 0.18 less 197 23.09 311,480 70.17 total size 443,892 compression 71.46% Results for varnibble : count count [%] size [B] size [%] greater 167 19.58 30,823 7.36 8.43 equal 61 7.15 4,471 1.07 less 625 73.27 383,365 91.57 total size 418,659 compression 67.39% Summary and discussion # method size improvement a 0 varint - reference 621,208 100.00% =================================== b 1 bitfields 561,041 90.31% =============================== c 2 varnibble 387,867 62.44% ===================== d 3 subsets [varnibble] 365,738 58.88% ==================== e 3 subsets [varint] 373,508 60.13% ===================== f 4 subsets or varnibble 337,743 54.37% =================== g 4 subsets or varint 368,778 59.36% ==================== h 5 varbits 341,600 54.99% =================== i 6 pair [varint] 443,892 71.46% ========================= j 6 pair [varnibble] 387,867 67.39% ======================= The bitfields method is not much better then varint , moreover operating on variable length bitfields is not easy to implement. Varnibble is surprisingly good. With a bit harder writing and reading offers nice results. Subsets method is as good as varnibble encoding (c). Additionally, it can be used with varint backend reaching similar compression ratio. The best results brought combined subsets and varnibble or varint methods. Varbits is comparable to subsets (f), however this method requires reading/writing at bit level. Pair encoding is the worst in group of \"better\" methods: save only 30% space at cost of very expansive encoding/decoding algorithms. Random thought: Again fancy algorithms (\"greedy\" search of subsets) gave worse results and is slower then straightforward implementation (\"first match\"). Source code All data and sources are available at github . Bibliography Some encoding techniques are described in paper Inverted Index Compression and Query Processing with Optimized Document Ordering by Hao Yan, Shuai Ding and Torsten Suel. Decoding billions of integers per second through vectorization by Daniel Lemire , Leonid Boytsov'],
["notesen/2013-12-07-postgresql-pdo.html", 'Problems with PDO for PostgreSQL on 32-bit machines', 'Problems with PDO for PostgreSQL on 32-bit machines Wojciech Mua Added on 2013-12-07 The size of an integer in PHP depends on machine , it has 32 bits on 32-bit architectures, and 64 on 64-bit architectures. On 32-bit machines PDO for PostgreSQL always convert bigint numbers returned by a server to string. Never casts to integer even if value of bigint would fit in 32-bit signed integer. Type bigint is returned for example by COUNT and SUM functions. On 64-bit machines there is no such problem because PHP integer is the same as bigint.'],
["notesen/2013-12-12-instructions-usage.html", 'x86 extensions are useless', 'x86 extensions are useless Wojciech Mua Added on 2013-12-12 Intel announced new extension to SSE : instructions accelerating calculating hashes SHA-1 and SHA256. As everything else added recently to the x86 ISA, these new instructions address special cases of \"something\". The number of instructions, encoding modes, etc. is increasing, but do not help in general. Let see what sha1msg1 xmm1, xmm2 does (type of arguments is packed dword): The logical operation \"xor\" is hardcoded. Why can\'t we use \"or\", \"and\", \"not and\"? These operations are already present in ISA. Indices to xmm1 and xmm2 are hardcoded too. The instruction pshufd accepts an immediate argument (1 byte) to select permutation, why sha1msg1 couldn\'t be feed with 2 bytes allowing a programmer to select any permutations of arguments? Sources of operators are also hardcoded. Why not use another immediate (1 byte) to select sources, for example 00b = xmm1/xmm1 , 01b = xmm1/xmm2 , 10b = xmm2/xmm1 , 11b = xmm2/xmm2 . Such generic instruction would be saved as generic_op xmm1, xmm2, imm_1, imm_2, imm_3 and execute following algorithm: Then sha1msg1 is just a special case: Maybe this example is \"too generic\", too complex, and would be hard to express in hardware. I just wanted to show that we will get shine new instructions useful in few cases. Compilers can vectorize loops and make use of SSE, but SHA is used in drivers, OS and is encapsulated in libraries --- sha1msg1 and friends will never appear in ordinary programs.'],
["notesen/2013-12-25-fopen-directory.html", 'fopen a directory', 'fopen a directory Wojciech Mua Added on 2013-12-25 It\'s not clear how function fopen applied to a directory should behave, manual pages don\'t say anything about this. So, our common sense fail --- at least when use a standard library shipped with GCC, because fopen returns a valid handle. Discussion on stackoverflow pointed that fseek or ftell would fail. But on my system it\'s not true, ftell(f, 0, SEEK_END) returns the size of an opened directory. Only when we trying to read data using fread or fgetc the errno variable is set to EISDIR error code. Here is output from simple test program :'],
["notesen/2013-12-27-convert-float-to-integer.html", 'Convert float to int without FPU/SSE', 'Convert float to int without FPU/SSE Wojciech Mua Added on 2013-12-27 This short article shows how a normalized floating point value could be safely converted to an integer value without assistance of FPU/SSE. Only basic bit and arithmetic operations are used. In the worst case following operations are performed: 6 comparisons, 2 subtracts, 1 and, 1 or, 2 shifts (one with variable, one with constant amount). The floating point value is calculated as: [...] sign has 1 bit, exponent has 8 bits, fraction has 23 bits, and bias has value 127; exponent + bias is saved as an unsigned number. The layout of binary word: Let clear fields exponent + bias and sign and restore the implicit integer 1 at 24-th bit: The value of such 32-bit word treated as an unsigned integer is [...] shift := exponent - 23 ; only few cases have to be considered: If shift is negative, then the word must be shifted right. The number of significant bits is 24, so if [...] If shift is positive, then the word must be shifted left. Since destination is a 32-bit signed value, thus maximum shift is 31 - 24 = 7 bits --- when shift is greater than 7, then overflow will occur. If [...] [...] [...] [...] Sample program is available .'],
["notesen/2013-12-29-calculate-floor-without-fpu.html", 'Calculate floor value without FPU/SSE instruction', 'Calculate floor value without FPU/SSE instruction Wojciech Mua Added on 2013-12-29 Presented algorithm works properly for any normalized floating point value, examples are given for double precision numbers (64-bit). The layout of value 8192.625: The exponent value is 13, thus fraction bits spans range 0 .. 52 - 13: To calculate the floor of value, the bits after decimal dot have to be clear. This operation doesn\'t alter the exponent, so only single bit-and is required, and no extra calculations are needed. To be precise, value of dot_position := 52 - exponent decides what have to be done: If dot_position > 52 then the value is less than 1.0, i.e. floor(x) = 0 . If dot_position <= 0 then the value have no fraction part (it is larger than [...] floor(x) = x . If 0 < dot_position <= 52 then the value have fraction part and bits after dot_position bits have to be cleared. The number of operations: Extracting exponent value requires: 1 shift, 1 bit-and, 1 subtract. Determining which case have to be selected requires up to 4 comparisons. When clearing bits is needed, then building bit-mask require: 1 shift, 1 subtract, 1 bit negation, 1 bit-and. Sample program is available :'],
["notesen/2013-12-30-infinite-loop.html", 'I accidentally created an infinite loop', 'I accidentally created an infinite loop Wojciech Mua Added on 2013-12-30 I needed to iterate through all values of 32-bit unsigned integer, so I wrote: Is it ok? No, because the value of uint32_t will never exceed UINT32_MAX = 0xffffffff . Of course we can use larger types, like uint64_t , but on 32-bit machines this requires some additional instructions. For example gcc 4.7 compiled following code: to: TBH, I have no idea why such a weird sequence has been generated ( add , adc , or , jnz ). The simplest and portable solution is to detect a wrap-around of 32-bit value after increment: In an assembly code it\'s even simpler, because a CPU sets the carry flag:'],
["notesen/2014-01-01-instruction-utilization.html", 'x86 - ISA where 80% of instructions are unimportant', 'x86 - ISA where 80% of instructions are unimportant Wojciech Mua Added on 2014-01-01 Few years ago I counted instructions from many Linux binaries --- 2014 is a good year to repeated this experiment and see that nothing has changed. I use 32-bit Debian, my installation has been updated few months ago. All files from /usr/bin and all *.so files from /usr/lib was disassembled with objdump (5050 files were processed). Instructions were grouped simply by mnemonic name. Taking into account all addressing and encoding modes would be overkill. I\'ve published script that does the job. Short summary: The number of distinct decoded instructions is around 650. Since objdump use AT&T syntax, same opcodes are seen under different mnemonics, for example mov is saved as movw , movb , movl depending on argument size. Total number of x86 instructions is around 750. Read: one hundred instructions never appeared in the binaries. There are 81 instructions used just once. For example quite useful CMPPD . There are 22 instructions used twice. For example MFENCE --- no one aware of memory ordering? There are 15 instructions used three times. For example BTC , but bit manipulating operations are useless. 81 plus 22 plus 15 is 118. Another hundred of useless stuff. Lets look at top 15 rows from detailed results, i.e. instruction with frequency grater than 1%: The total count of these instructions is 87.84% of all instructions (almost all, isn\'t it?). The most frequently used instruction is data transfer ( mov / movl ) --- 42% Control flow instructions ( call / ret / jmp ) --- 13%. Conditions ( cmp / test /condition jumps: je / jne ) --- 10%. Basic arithmetic ( add / sub / lea ) --- 12% Simple stack operations ( push / pop ) --- 6% Very interesting observation is that conditions are mostly based on je / jne , i.e. jump if zero/jump if not zero. The first FPU instruction appears at 28-th position. The first integer SSE appears at 167-th position. And the first SSE instruction operating on packed floats appear at 315-th position. Detailed results Whole table as txt file . instruction count % mov 5934098 37.63% call 1414355 8.97% lea 1071501 6.79% movl 760677 4.82% push 655921 4.16% jmp 611540 3.88% add 560517 3.55% je 490250 3.11% test 475899 3.02% pop 441608 2.80% sub 366228 2.32% cmp 326379 2.07% jne 264110 1.67% nop 242356 1.54% ret 238569 1.51% xor 148194 0.94% movzbl 122730 0.78% and 88863 0.56% xchg 66885 0.42% cmpl 64907 0.41% movzwl 64589 0.41% movb 57247 0.36% or 52138 0.33% shl 50908 0.32% cmpb 50152 0.32% jle 41083 0.26% leave 39923 0.25% fldl 37428 0.24% fstpl 37368 0.24% shr 36503 0.23% jbe 32866 0.21% ja 32333 0.21% sar 30917 0.20% flds 29672 0.19% subl 27636 0.18% setne 27626 0.18% testb 27420 0.17% addl 25906 0.16% imul 25569 0.16% jg 24796 0.16% fstp 24349 0.15% fxch 23464 0.15% js 21550 0.14% fstps 21248 0.13% sbb 16607 0.11% inc 16200 0.10% lock 16049 0.10% jae 14825 0.09% sahf 14765 0.09% dec 14276 0.09% fnstsw 14026 0.09% sete 13902 0.09% movw 13895 0.09% adc 13640 0.09% jb 12467 0.08% jl 11700 0.07% repz 11178 0.07% fldcw 11110 0.07% jge 11019 0.07% movswl 10816 0.07% fildl 8852 0.06% cmpw 7601 0.05% jns 7490 0.05% fldz 7331 0.05% fmul 7229 0.05% out 7203 0.05% not 7028 0.04% movsbl 6720 0.04% in 6503 0.04% fld 6309 0.04% faddp 6254 0.04% fstl 5760 0.04% fucom 5753 0.04% neg 5725 0.04% fucompp 5354 0.03% rep 5059 0.03% fmuls 5039 0.03% pushl 4430 0.03% jp 4424 0.03% fnstcw 4400 0.03% fld1 4176 0.03% fmulp 4133 0.03% orl 3927 0.02% fadds 3789 0.02% movq 3779 0.02% fistpl 3709 0.02% cltd 3597 0.02% fmull 3313 0.02% stos 3298 0.02% lret 3183 0.02% scas 3103 0.02% lods 3066 0.02% cwtl 3064 0.02% fadd 2852 0.02% fucomp 2678 0.02% orb 2481 0.02% fildll 2418 0.02% andl 2379 0.02% setb 2337 0.01% andb 2263 0.01% 552 rows more...'],
["notesen/2014-01-26-sse-penalties-of-errors.html", 'Penalties of errors in SSE floating point calculations', 'Penalties of errors in SSE floating point calculations Wojciech Mua Added on 2014-01-26 Updated on 2018-11-26 (measurements from Skylake and SkylakeX) Contents Introduction Enabling exceptions Flush to zero Denormalized numbers Source code Introduction SSE provides not widely known control register, called MXCSR . This register plays three roles: Controls calculations: flag flush to zero , flag denormals are zeros , rounding mode (not covered in this text). Allow to mask/unmask floating-point exceptions. Save information about floating-point errors --- these flags are sticky, i.e. a programmer is responsible for clearing them. Possible errors in SSE floating point calculations are: division by zero, underflow, overflow, operations on denormalized values, invalid operations, like square root of negative number, division zero by zero. Enabling exceptions By default all invalid operations in SSE are masked, i.e. they are not converted into hardware exceptions. When exceptions are unmasked, then standard SIGFPE exception is raised. Important : even if errors are masked, when erroneous situation occurs then calculations\' slowdown is significant. So if our program slows down for unknown reason, it may be an error in SSE-related code --- for example we load \"random\" values to XMM registers. Error flags in the MXCSR are always updated, regardless of which exceptions are reported. Flush to zero The flag \"flush to zero\" forces result 0 on underflow or denormal errors, and what is more important, these errors have no impact on calculations speed. For example in the sample loop underflow occurs, because we try to multiply FLT_MIN by FLT_MIN ( FLT_MIN = [...] completion time of the above loop [in seconds] architecture default settings flush to zero speed-up Core2 0.796s 0.023 30 x Skylake 0.019 0.019 --- SkylakeX 0.028 0.022 1.25 x Denormalized numbers A denormalized floating point number is a very small number of value [...] FLT_MIN by 2. There is a little problem --- if the result of some operation on normalized numbers is a denormalized value it\'s not an SSE error . Error is reported only when one of operands is already denormalized . So, where is the problem? If a result is denormalized, speed is noticeable degraded, but we can\'t detect the point where denormalization has occurred. This can be done only when denormalized value is used in subsequent calculations. MXCSR has the flag \"denormals are zeros\", which forces 0 as result of an operation where at least one operand is denormalized, but do not prevent from obtaining a denormalized result from operation on normalized values. Let summarize this with following program: first FLT_MIN is multiplied by 0.5 resulting in denormalized value; then this value is added to 0. With default settings execution the final value is denormalized (5.877472e-39). With the flag \"denormals are zeros\" execution the result is zero. With the flag \"flush to zero\" the final value is also zero. completion time: in seconds (speed-up to default settings) architecture default settings denormals are zeros flush to zero Core2 1.841 0.858 (2x) 0.121 (15x) Skylake 0.440 0.400 0.033 (13x) SkylakeX 0.524 0.526 0.039 (13x) Source code The test programs are available .'],
["notesen/2014-03-03-slow-strstr.html", 'Slow-paths in GNU libc strstr', 'Slow-paths in GNU libc strstr Wojciech Mua Added on 2014-03-03 I\'ve observed that some patterns issued to strstr cause significant slowdown. Sample program kill-strstr.c executes strstr(data, pattern) , where data is a large string (16MB) filled with the character \'?\'. Patterns are read from the command line. On my machine following times were recorded: Slowdown is visible in case 4 (5 times slower than pattern 3). Pattern has 32 characters, and contains \'?\', except the last char. Even bigger slowdown occurs in case 5 (7 times slower). This pattern also contains 32 chars, but the position of the single letter \'a\' is last but one. Similar slowdown occurs in case 6 (nearly 8 times slower). In this pattern single letter \'a\' is surrounded by thirty \'?\'.'],
["notesen/2014-03-09-asmgoto.html", 'GCC --- asm goto', 'GCC --- asm goto Wojciech Mua Added on 2014-03-09 Starting from GCC 4.5 the asm statement has new form: asm goto . A programmer can use any label from a C/C++ program, however a output from this block is not allowed. Using an asm block in an old form requires more instructions and an additional storage: Above code is compiled to: With asm goto the same task could be writting shorter and easier: Complete demo is available . See also GCC documentation about Extended Asm .'],
["notesen/2014-03-09-mask-zero-nonzero-bytes.html", 'Mask for zero/non-zero bytes', 'Mask for zero/non-zero bytes Wojciech Mua Added on 2014-03-09 The description of Determine if a word has a zero byte from \"Bit Twiddling Hacks\" says about haszero(v) : \" the result is the high bits set where the bytes in v were zero \". Unfortunately this is not true. The high bits are also set for ones followed zeros, i.e. haszero(0xff010100) = 0x00808080 . Of course the result is still valid (non-zero if there were any zero byte), but if we want to iterate over all zeros or find the last zero index, this could be a problem. It\'s possible to create an exact mask: Function nonzeromask requires four simple instructions, and zeromask one additional xor.'],
["notesen/2014-03-09-simd-int-log-10.html", 'Integer log 10 of an unsigned integer --- SIMD version', 'Integer log 10 of an unsigned integer --- SIMD version Wojciech Mua Added on 2014-03-09 Fast calculate [...] Bit Twiddling Hacks , this text show the SIMD solution for 32-bit numbers. Algorithm: populate value in XMM registers. Since maximum value of this function is 10 we need three registers: compare these numbers with sequence of powers of 10: result of comparisons are: 0 (false) or -1 (true), for example: calculate sum of all dwords: save a result, i.e. the lowest dword: Sample program is available .'],
["notesen/2014-03-11-cpp-standard.html", 'C++ standard inaccuracy', 'C++ standard inaccuracy Wojciech Mua Added on 2014-03-11 First we read: 21.4.1 basic_string general requirements [string.require] [...] 3 No erase() or pop_back() member function shall throw any exceptions. ... a few pages later: 21.4.6.5 basic_string::erase [string::erase] basic_string<charT,traits, Allocator>& erase(size_type pos = 0, size_type n = npos); [...] 2 Throws : out_of_range if pos > size().'],
["notesen/2014-03-11-simd-friendly-karp-rabin.html", 'SIMD-friendly Rabin-Karp modification', 'SIMD-friendly Rabin-Karp modification Wojciech Mua Added on 2014-03-11 Update on 2016-01-17 (results from Core i5) This article is obsolete, refer to SIMD-friendly algorithms for substring searching . Contents Algorithm Sample programs Experiments Results from Core i5 (64-bit architecture) Results from Pentium M (32-bit architecture) Summary See also Algorithm Rabin-Karp algorithm uses a weak hash function to locate possible substring positions. This modification uses merely equality of the first and the last char of searched substring, however equality of chars can be done very fast in parallel , even without SIMD instruction. Let packed_byte(x) is a function that fills a CPU register with byte x , for example on 32-bit architecture: In a single iteration two registers are filled with part of string: Then parallel comparison is done with simple xor: Zero bytes in first_zeros and last_zeros indicate equality of chars. The positions of zero bytes have to be equal, so an additional bit or is needed: Getting zeros requires only: two memory fetches, two bit-xor, one bit-or. Now we have to check if zeros has any zero bytes, then iterate through zeros and perform byte-wise comparisons for all zero bytes: Function has_zero_byte(uint32_t word) could be implemented using algorithm from Bit Twiddling Hacks --- Determine if a word has a zero byte . Function is_zero(uint32_t word, int k) may use results from has_zero_byte (warning: this method has a drawback ). The worst case complexity is O(n*m). However the method minimize memory fetches during a string scan, also comparisons are performed in parallel, and no preprocessing is required (except two packed_byte calls before the main loop). Sample programs Sample implementation is available . After run make analyze32 or make analyze64 famous document 386intel.txt is downloaded, split to words and all these words (~4500) are searched in the text. Following function are measured: C++ std::string::find C strlen custom --- implementation of the algorithm presented here Experiments Results from Core i5 (64-bit architecture) GCC 4.9.2: Results from Pentium M (32-bit architecture) Summary For the 32-bit code the presented method is around 2-4 times faster than C++ find , and around 2-6 times faster than C strlen . For the 64-bit code the presented method is faster than C++ find , however plan C strlen beats it. See also SSE4 string search --- modification of Karp-Rabin algorithm --- a specific usage of MPSADBW instruction'],
["notesen/2014-03-16-scalar-sse-movmask.html", 'Scalar version of SSE move mask instruction', 'Scalar version of SSE move mask instruction Wojciech Mua Added on 2014-03-16 Updated on 2015-12-28 (64-bit code) SSE instruction PMOVMSKB gathers all most significant bits from bytes and stores them as a single 16-bit value; similar action is performed by MOVMSKPD and MOVMSKPS . Such operation could be easily done using scalar multiplication. But first see the example (we use 32-bit number, so result has 4 bits): Bits A, B, C and D are important, dots denote zero. The bit A have to be moved to the position 3, the bit B - 2, the bit C --- 1 and the bit D --- 0. The layout of tmpX: Now tmp1..4 have to be ored together: The result bits are located at the lowest byte of the higher 32-bits word, so just single shift & bit-and are required to isolate them. Fact : none of intermediate values tmp1..4 has set bit on the same position. Thanks to that a single multiplication can be used to perform the all shifts and bit-or --- while adding intermediate values never appear a carry bit, that would \"disturb\" result. The constant for multiplication is derived directly from the shift amounts: Sample implementation C function for 32-bit numbers: GCC generated the best possible code: Disassembly of section .text: C function for 64-bit numbers (the type __int128 is the GCC extension ): And disassembly, GCC generated also the shortest possible code: Full source code is available , including the proof written in Python.'],
["notesen/2014-03-19-const-correctness.html", 'Is const-correctness paranoia good?', 'Is const-correctness paranoia good? Wojciech Mua Added on 2014-03-19 Yes, definitely. Lets see this simple example: Only when we turn on the warnings, a compiler tell us about a possible error. Making the parameter const shows us error: All input parameters should be const, all write-once variables serving as a parameters for some computations should be also const.'],
["notesen/2014-03-19-quick-git-server.html", 'Quick and dirty ad-hoc git hosting', 'Quick and dirty ad-hoc git hosting Wojciech Mua Added on 2014-03-19 Recently I needed to synchronize my local repository with a remote machine, just for full backup. It\'s really simple if you have standard Linux tools (Cygwin works too, of course). in a working directory run: in the parent directory start HTTP server: on a remote machine clone/pull/whatever: Step 1 have to be executed manually when the local repository has changed.'],
["notesen/2014-03-22-cpp-bitset-vs-byteset.html", 'C++ bitset vs array', 'C++ bitset vs array Wojciech Mua Added on 2014-03-22 The C++ bitset conserves a memory, but at cost of speed access. The bitset must be slower than a set represented as a plain old array, at least when sets are small (say a few hundred elements). Lets look at this simple functions: The file was compiled with g++ -std=c++11 -O3 set_test.cpp ; Assembly code of the core of any_in_byteset : Statement if (set[data[i]]) return true are lines 28, 2e and 32, i.e.: load from memory, compare and jump. Instructions 2b, 34 and 36 handles the for loop. Now look at assembly code of any_in_bitset : All these instructions implements the if statement! Again, we have a load from memory (5f), but checking which bit is set requires much more work. The input ( edx ) is split to the lower part --- i.e. bit number (67, 6c) and the higher part --- i.e. word index (6c). The last step is to check if a bit is set in a word --- GCC used variable shift left (6f), but x86 has BT instruction, so in the perfect code we would have two instructions less. However, as we see a simple access in the bitset is much more complicated than simple memory fetch from byteset. For small sets memory fetches are well cached and smaller number of instruction improves performance. For really large sets cache misses would kill performance, then bitset is much better choice.'],
["notesen/2014-09-11-convert-to-bin.html", 'Conversion numbers to binary representation', 'Conversion numbers to binary representation Wojciech Mua Added on 2014-09-11 Update 2016-11-20 (SWAR version 3, by Larry Bank , updates results) 2015-04-19 (SWAR version 2, results from Core i5) 2014-09-22 (BMI2 results), 2014-09-16 (+BMI2, lookup, experiments results) Contents Converting byte --- SWAR version 1 Algorithm Notes Converting byte --- SWAR version 2 --- multiplication-based approach Notes Converting byte --- SWAR version 3 --- multiplication-based approach Notes Converting word --- SIMD version Converting byte --- BMI2 version Converting byte --- lookup Speed comparison Results from Pentium M (outdated) Results from Core i5 (Westmere) Results from Core i7 (Skylake) Sample program Converting byte --- SWAR version 1 Algorithm Populate byte v (bits: abcdefgh ) in a 64-bit word: Isolate one bit per byte: Clone each bit to the highest position Move 7th bits to the 0th position and mask the lowest bits: Finally convert to ASCII: Notes Sample implementation: This algorithm requires: 1 multiplication, 1 right shift, 1 bit-and, 1 bit-or, 2 additions. Multiplication and shift are the slowest operations. Converting byte --- SWAR version 2 --- multiplication-based approach In this approach single multiplication is used to scatter 4 bits on 4 bytes, then a single bit-and is used to isolate bits: The magic multiplication constant is build as follows: the bit d must stay at position 0, so the first term of is [...] the bit c must appear at position 8, so we have to shift left by [...] likewise to move the bit b at position 16 we have to shift left by [...] and finally shift left by [...] a . The constant is 1 + (1 << (8 - 1)) + (1 << (16 - 2)) + (1 << (24 - 3)) or 0x204081 . Downside of this method is processing only 4 bits per step. Notes Sample implementation: This algorithm requires: 2 32-bit multiplications (32-bit muls are faster than 64-bit multiplication); 2 shifts; 2 bit-and; 1 bit-or; 1 add. Converting byte --- SWAR version 3 --- multiplication-based approach Author of this method is Larry Bank . We exchanged a few mails and Larry has gave me permission to describe his clever method here. Similarly to the previous SWAR method, this one also uses a single multiplication . The multiplication scatters 7 lowest bit of an 8-bit number. Thus the method is suitable for 64-bit numbers. Assuming we have a 7-bit number abcdefg , following shifts are needed (example for a 32-bit number): To covert all bits of a byte, the specialised path for the MSB is needed. Notes Sample implementation: This algorithm requires: 1 64-bit multiplication 1 shift; 3 bit-and; 1 bit-or; 1 add. Moving the MSB to desired position may be also accomplished with range extending (casting). First we cast unsigned char ( v ) to signed value, extending this value to 64-bit word, efficiently broadcasting MSB on bits 8 thou 63. Then single bit-and forms proper word: This strange cast chain compiles to a single instruction movsx , which is as cheap as a normal move. The modified implementation doesn\'t require a bit-shift. Converting word --- SIMD version The algorithm is similar to SWAR version 1. Instead of cloning bits, shift and mask (points 3 & 4) just a single instruction PCMPEQB is used: Full implementation is available at github (see Sample Programs below). Converting byte --- BMI2 version Bit Manipulation Instruction is a new Intel\'s ISA extension, that add some interesting instructions. One of them is PDEP , parallel deposit , following pseudocode shows how PDEP works (example for 64-bit words): Equivalent procedure in C (64-bit mode): Binary conversion is trivial, single PDEB realizes steps from 2 through 4 of the algorithm. Procedure bswap performs byte-swap and it\'s simply a wrapper for BSWAP instruction: Yes, only three instructions! Converting byte --- lookup Using simple lookup requires 256 * 8 = 2kB, this might be a performance problem. Speed comparison Results produced by program speedup from the samples. Results from Pentium M (outdated) method time [s] speedup naive 0.4061 1.00 lookup 0.0636 6.35 SWAR 0.2226 1.82 SIMD 0.1708 2.38 Notes: The lookup table size is really big, it would destroy L1 cache. The SIMD version is not well written, it just convert 8 bits, while a 16-byte register can hold the result of conversion for two bytes. Pentium M is a 32-bit processor, conversion routines use type uint64_t , i.e. most 64-bit operations in the SWAR version were performed by more than one CPU instruction. Results from Core i5 (Westmere) method time [s] speedup naive 2.4826 1.00 lookup 0.1992 12.46 SWAR 0.2732 9.09 SWAR2 0.2274 10.92 SWAR3 0.2743 9.05 SIMD 0.3622 6.85 Results from Core i7 (Skylake) method time [s] speedup naive 1.1796 1.00 lookup 0.0805 14.66 SWAR 0.3824 3.08 SWAR2 0.2781 4.24 SWAR3 0.4508 2.62 SIMD 0.7077 1.67 PDEP 0.1067 11.05 Notes: Lookup is the fastest. But all register-only implementations aren\'t very bad, and PDEP version is the best in this group. The SIMD version performance is really poor. Sample program Sample programs are available at github.'],
["notesen/2014-09-21-convert-to-hex.html", 'Conversion numbers to hexadecimal representation', 'Conversion numbers to hexadecimal representation Wojciech Mua Added on 2014-09-21 Updates 2016-03-07 (Core i5 results) Contents Branchless converting single nibble Converting nibbles --- SWAR version Converting nibbles --- SIMD version Split nibbles x86 - plain x86 - BMI2 (Bit Manipulation Instructions) SSE Speedup comparison Results from Pentium M Results from Core i5 See also Sample code Branchless converting single nibble For a nibble (0..15) stored in a byte conversion could be coded in this way: If a nibble is greater than 9, then resulting letter have to be ASCII \'a\' .. \'f\' (or \'A\' .. \'F\'). It\'s done with simple correction of the code; value of correction \'a\' - 10 - \'0\' is 39, and for uppercase letters it is 7. The condition have to be replaced by branchless expression . First code is changed to: We\'re bit closer. Now the question is: how to get a mask from condition byte > 9 ? Let\'s examine simple addition: 128 - 10 + x . For values x = 0 .. 9 the result is in range 128 - 10 .. 128 - 9 and for values x = 10 .. 15 the result is in range 128 .. 128 + 5 . Observation : for x in range 10 .. 15 the result has the highest bit set, otherwise it\'s clear. In other words we get 0x80 or 0x00 depending on condition, and now mask could be calculated as: Since correction\'s value is 39 or 7, i.e. is less than 128, the mask could be calculated simpler, yielding values 0x7f/0x00: The final version: Converting nibbles --- SWAR version The trick presented above could be easily used in SWAR procedure. A procedure converts 4 nibbles (32-bit code) or 8 nibbles (64-bit code) at once. Number of operations: 3 additions, 1 subtract, 2 bit-and, 1 shift. Converting nibbles --- SIMD version A SIMD version is based on the straightforward implementation of procedure nibble_to_hex2 , where generating mask is done with single instruction PCMPGTB . The procedure converts 16 nibbles. Split nibbles So far we silently assumed that nibbles are already placed in separated bytes. Expanding nibbles to bytes could be simply saved as: Important : note that order of nibbles is reversed, because in strings the most significant digit is placed at the index 0. However the procedure requires many operations, for 16-bit values these numbers are: 6 shifts, 4 bit-and, 3 bit-or. x86 - plain Multiplication could be used to express two independent shifts and one bit-or: Number of operations decreased to: 2 multiplications, 4 bit-and, 1 bit-or, 1 byte-swap (implemented by the function bswap , merely a wrapper around CPU instruction named the same). Multiplication has bigger latency than shift, but throughput is 1 cycle. Experiments on Pentium M have showed that this approach is not better than naive, but maybe never CPUs will execute this code faster. x86 - BMI2 (Bit Manipulation Instructions) Bit Manipulation Instruction is a new Intel\'s ISA extension, that adds some interesting instructions. One of them is PDEP , parallel deposit . Pseudocode shows how PDEP works (example for 64-bit words): This is exactly what nibble expansion needs: The function pdep is a wrapper around PDEP instruction. SSE With SSE it\'s quite simple (I\'ll use dot instead of 0 for masked values). Load data: Isolate even nibbles: Isolate odd nibbles: Interleave expanded nibbles: Swap bytes Speedup comparison Results produced by program speedup from the samples. All possible combinations of expanding and conversion algorithms were considered. Results from Pentium M expand convert time [s] speedup naive naive 0.4789 1.00 swar 0.1533 3.12 simd 0.1884 2.54 mul naive 0.4629 1.03 swar 0.1621 2.96 simd 0.1905 2.51 simd naive 0.4680 1.02 swar 0.1625 2.95 simd 0.2037 2.35 Notes: An expanding procedure don\'t dominate over the running time. The naive expand is not so bad. Surprisingly the fastest conversion code is scalar SWAR, not SSE. Results from Core i5 CPU: Core i5 CPU M 540 @ 2.53GHz expand convert time [s] speedup naive naive 0.1191 1.00 swar 0.0406 2.93 simd 0.0434 2.74 mul naive 0.1062 1.12 swar 0.0405 2.94 simd 0.0433 2.75 simd naive 0.1061 1.12 swar 0.0404 2.95 simd 0.0433 2.75 See also Article SSSE3: printing hex values --- another unusual PSHUFB usage. Sample code Sample programs are available at github.'],
["notesen/2014-09-23-pdep-soft-emu.html", 'Software emulation of PDEP', 'Software emulation of PDEP Wojciech Mua Added on 2014-09-23 Contents Introduction Naive implementation Branchless implementation Comparison results on Pentium M Sample program Introduction PDEP is a new instruction from BMI2 ( Bit Manipulation Instruction ), pseudocode for 32-bit PDEP variant: Quite complicated, but it is really fast --- latency is just 3 cycles and throughput is only one cycle. I\'ve showed how to use this instruction in conversion integers to binary and haxadecimal representation. I was wondering how this algorithm would execute on an old hardware. Naive implementation Shift right by 1 could be expressed as a simple add, on x86 this could also be encoded using LEA (no register flags dependency). Branchless implementation Comparison results on Pentium M The branchless version is much more complicated, but there is one clear advantage over naive version --- number of iterations is equal to number of bits set in a mask. This is clear when we look at sample results. mask naive [s] branchless [s] speedup 00000000 0.1368 0.0035 38.76 00000001 0.1388 0.0081 17.19 00000003 0.1597 0.0127 12.56 00000007 0.1661 0.0230 7.24 0000000f 0.1691 0.0256 6.60 0000001f 0.1842 0.0328 5.61 0000003f 0.2430 0.0910 2.67 0000007f 0.2904 0.0499 5.82 000000ff 0.2743 0.0481 5.71 000001ff 0.2165 0.0530 4.08 000003ff 0.2139 0.0666 3.21 000007ff 0.2181 0.0764 2.85 00000fff 0.2183 0.0898 2.43 00001fff 0.2159 0.0920 2.35 00003fff 0.2288 0.0950 2.41 00007fff 0.2294 0.1085 2.11 0000ffff 0.2322 0.1086 2.14 0001ffff 0.2330 0.1074 2.17 0003ffff 0.3133 0.1158 2.71 0007ffff 0.2273 0.1216 1.87 000fffff 0.2396 0.1328 1.80 001fffff 0.2381 0.1308 1.82 003fffff 0.2667 0.1376 1.94 007fffff 0.2559 0.1701 1.50 00ffffff 0.2637 0.1511 1.75 01ffffff 0.2721 0.1645 1.65 03ffffff 0.2868 0.1617 1.77 07ffffff 0.2895 0.1878 1.54 0fffffff 0.2816 0.1737 1.62 1fffffff 0.2652 0.1765 1.50 3fffffff 0.2742 0.1949 1.41 7fffffff 0.2369 0.1876 1.26 ffffffff 0.2388 0.1988 1.20 Sample program Sample programs are available at github.'],
["notesen/2014-09-25-interpolation-search.html", 'Interpolation search revisited', 'Interpolation search revisited Wojciech Mua Added on 2014-09-25 Contents Introduction Experiment Results Summary Source code Introduction Interpolation search is the modification of binary search, where the index of a \"middle\" key is obtained from linear interpolation of values at start & end of a processed range: The clear advantage over basic binary search is complexity [...] [...] [...] However, this property is hold only when the distribution of keys is uniform . I guess this the reason why the algorithm is not well known --- enforcing uniform distribution on real data is hard. Also calculating the index c is more computational expansive. Experiment In the experiment array of integers was filled with ascending numbers scaled by function [...] [...] Then every key in range 0 .. array size was searched using both binary and interpolation algorithm. Two values were measured: clock time to complete whole search; average number of calculating a \"middle\" index. Test programs were run on quite old Pentium M, floating point calculations were done on FPU (I\'ve tried also SSE, but improvement was minimal or none). Results Clock time in function of exponent value. Average comparisons in function of exponent value. Functions [...] Summary The experiment proved the main property of interpolation search. However computational complexity of interpolation search is very sensitive to the key distribution. In the worst case it\'s 8 times slower and average number of comparisons is 2,5 times larger than binary search. Binary search keeps constant running time & number of comparisons. Conclusion : keep away from interpolation search unless you can prove that your data has uniform distribution. Source code Sample programs are available at github.'],
["notesen/2014-09-30-win-over-compiler.html", 'Small win over compiler', 'Small win over compiler Wojciech Mua Added on 2014-09-30 There are some places where a low-level programmer can beat a compiler. Consider this simple code: Function min1 is compiled to (GCC 4.8 with flag -O3 ): There is a conditional jump, not very good. When we rewrite the function: Result is this nice branchless code: Conclusion: it\'s worth to check a compiler output. Sometimes.'],
["notesen/2014-10-01-conditionally-fill-word.html", 'Conditionally fill word (for limited set of input values)', 'Conditionally fill word (for limited set of input values) Article Wojciech Mua Added on 2014-10-01 Updated on 2018-03-11 \"Limited\" means a value where at most one bit is set. I.e. values are zero and all powers of two. Specification: if x is zero then result is also zero, if x is power of two result is word full of zeros. Naive implementation: GCC 4.8.2 produces following code: Not bad, but this can be done much simpler. We know that a value is zero or have exactly one bit set --- first we have to copy this bit to the highest position, and then populate the MSB using arithmetic shift right. Copying a bit can be done using single operation --- arithmetic negation : x -x 00000000 00000000 00000001 ffffffff 00000002 fffffffe 00000004 fffffffc 00000008 fffffff8 00000010 fffffff0 00000020 ffffffe0 00000040 ffffffc0 00000080 ffffff80 00000100 ffffff00 00000200 fffffe00 00000400 fffffc00 00000800 fffff800 00001000 fffff000 00002000 ffffe000 00004000 ffffc000 00008000 ffff8000 00010000 ffff0000 00020000 fffe0000 00040000 fffc0000 00080000 fff80000 00100000 fff00000 00200000 ffe00000 00400000 ffc00000 00800000 ff800000 01000000 ff000000 02000000 fe000000 04000000 fc000000 08000000 f8000000 10000000 f0000000 20000000 e0000000 40000000 c0000000 80000000 80000000 Now the procedure could be saved as: The compilation result: Just two simple instructions. 2018-03-11: GCC 7.2 still compiles fill_word_naive the same way, but clang 6.0 produces the final, two-instruction sequence.'],
["notesen/2014-10-01-is-pow-2.html", 'Determining if an integer is a power of 2 --- part 2', 'Determining if an integer is a power of 2 --- part 2 Wojciech Mua Added on 2014-10-01 The idea is simple: precondition : x is not zero; isolate lowest bit set: x & -x ; check if this number is equal to x: x == (x & -x) . Sample code: GCC 4.8.2 generates for is_power_of_two following code: Unfortunately compiler inserted a jump. But when we are sure that arguments are non-zero then only 5 basic instruction are required to perform this check.'],
["notesen/2014-10-02-convert-to-oct.html", 'Conversion numbers to octal representation', 'Conversion numbers to octal representation Wojciech Mua Added on 2014-10-02 Updated 2014-10-07 (core i7 results); 2014-10-05 (lookup table methods) Contents Introduction Algorithms Naive version Lookup tables Improved naive version PDEP version SSE2 version Experiments Results from Pentium M Results from Core i7 Sample code Introduction Conversion to octal isn\'t very computer-friendly, each digit occupy 3 bits, it isn\'t power of two. The smallest number of bits to convert worth to consider is 12 (3 nibbles and 4 digits): Then output is a 32-bit word: Conversion to ASCII require single add of 0x30303030 (0x30 = ord(\'0\')). Algorithms Naive version Naive conversion consists three basic steps: isolate octal digits, i.e. 3-bit fields; shift digits to the desired positions in the output word; finally merge fields in a one word and convert to ASCII. Sample implementation: Lookup tables I think using lookup tables aren\'t good solution. First: shifting on current CPUs is very fast, second: LUT requires memory and pollutes cache. The results from my old Pentium M shows that LUT are the fastest, but I bet that PDEP or SSE2 version win on Core i7 . Two implementations of LUT were tested: Single, big table indexed by 12 bits (4096 entries). Entry of a table contains of course 4 bytes converted to ASCII. Two small tables indexed by lower 8 bits and higher 4 bits of 12-bit word (256 and 16 elements respectively). Tables contain partial results of expand_12bits operations. Variant 1 sample code: Variant 2 sample code: Variant 2 requires less memory than variant 1 (only 6%), but performs 4 operations to calculate result (2 bit-and, 1 shift and add) and issues 2 memory fetches. Improved naive version Using single multiplication we can perform two shifts and one bit-or. Input word have to be split to two subwords: containing digits a , c and b , d . For example digits a , c are converted in following steps: isolate digits (bit-and): the digit a is on the correct position, but c have to be shifted 15 bits to the left. This could be saved as: Or using multiplication: Layout of expanded_ac : Mask out garbage --- the bits marked with red. Downside of this method is that digits are generated in reversed order, so the instruction bswap have to be used on the result. Sample implementation: PDEP version PDEP is a new instruction introduced in BMI2 extension. Please take a look at my previous article where this instructions is discussed in details. PDEP makes conversion easy and very fast --- code have just three instructions ( pdep , add , bswap ). Sample implementation: SSE2 version SSE2 does in parallel the same bit-and & shifts operations as the naive version. Variable shifts are possible with multiplication, instruction PMULHUW multiplies 16-bit words and store higher word of a result. When multiplier is in form (1 << n) then result of this instruction is x >> (16 - n) . Unfortunately a multiplier is always greater than 1, because of that input arguments have to be modified (in step 2) in order to get the correct results. The SSE2 procedure contains following steps: Clone two 12-bit words (we\'ll use dot instead of zero). Shift left by 1 bit all words. This can be done using single PADDWD instruction. Mask octal digits ( PAND ). Parallel shift right ( PMULHUW ): d and g must be shifted 10 bits right, c and h must be shifted 7 bits right, b and f must be shifted 4 bits right, a and e must be shifted 1 bit right. Multipliers are (respectively): 1 << (16 - 10) 1 << (16 - 7) 1 << (16 - 12) 1 << (16 - 15) pack to bytes and convert to ASCII ( PACKUSWB & PADDB ). Experiments Converter naive implements naive algorithm, converter mul implements improved naive, converter SSE2 is a SSE implementation of naive, converter pdep use PDEP instruction, converter 1 LUT is variant 1 from lookup tables, converter 2 LUTs is variant 2 from lookup tables. Results from Pentium M convert time [s] speedup naive 0.2296 1.00 mul 0.3846 0.60 SSE2 0.2629 0.87 1 LUT 0.1122 2.05 2 LUTs 0.1286 1.79 Notes: The SSE2 procedure is slower than scalar one. Simple shifts and bit-or are faster than multiplication. LUT versions are the fastest, even version with two lookup-tables is very fast. Results from Core i7 Statistics from 20 samples. convert time [s] speedup (avg) min max avg naive 0.1630 0.2040 0.1841 1.00 mul 0.1630 0.2200 0.1777 1.04 SSE2 0.2170 0.2570 0.2318 0.79 pdep 0.1360 0.1650 0.1491 1.23 1 LUT 0.1350 0.1680 0.1452 1.27 2 LUTs 0.1350 0.1770 0.1468 1.25 Notes: The SSE2 is the slowest. This is big surprise PDEP and lookup methods has simiar speedup. PDEP is better as doesn\'t require additional memory. On CPUs without BMI2 extension method with two lookup-tables would be good choice. Multiplication is not faster than 2 shifts and bit-or. Another surprise. Sample code Full implementation and program used in experiments are available on github.'],
["notesen/2014-10-06-pext-convert-ascii-bin-to-num.html", 'Using PEXT to convert from binary ASCII to number', 'Using PEXT to convert from binary ASCII to number Wojciech Mua Added on 2014-10-06 Suppose we have a string containing ASCII zeros and ones, for example \"11100100\", and we want to interpret this text as a binary number and get value ( 0xe4 ). New instruction PEXT from BMI2 ( Binary Manipulation Instructions ) is perfect for this task. PEXT --- parallel extract --- forms a word from source bits selected by a mask, for example (32-bit arguments): This is exactly what the conversion needs --- since the code of ASCII \'0\' is 0x30 and \'1\' is 0x31 we need to extract the lowest bit of each byte (of course if we\'re sure that input is valid). Example string \"11100100\" is encoded as 0x3131313030313030: The value of result is 0xe4 = 0b11100100 . Working example is available at github (see parse_string.c ).'],
["notesen/2014-10-09-pext-convert-ascii-hex-to-num.html", 'Using PEXT to convert from hexadecimal ASCII to number', 'Using PEXT to convert from hexadecimal ASCII to number Wojciech Mua Added on 2014-10-09 Naive conversion from an ASCII digit to a value could be coded with a switch instruction or a lookup table --- too simple, right? This is another note where I try to exploit PEXT --- parallel extract , the new instruction introduced in extension BMI2 (Bit Manipulation Instructions). By the way I present nice branchless algorithm to convert an ASCII letter to a number. Let see which codes are assigned to hexadecimal digits: digit code value letter code value \'0\' 0x30 0 \'a\' 0x61 10 \'1\' 0x31 1 \'b\' 0x62 11 \'2\' 0x32 2 \'c\' 0x63 12 \'3\' 0x33 3 \'d\' 0x64 13 \'4\' 0x34 4 \'e\' 0x65 14 \'5\' 0x35 5 \'f\' 0x66 15 \'6\' 0x36 6 \'A\' 0x41 10 \'7\' 0x37 7 \'B\' 0x42 11 \'8\' 0x38 8 \'C\' 0x43 12 \'9\' 0x39 9 \'D\' 0x44 13 \'E\' 0x45 14 \'F\' 0x46 15 Observations: for digits the value is equal to lower nibble; for letter the value is equal to lower nibble plus 9; both small and big letters has set 7-th bit (mask 0x40). Branchless code converting single letter to numeric value: Following operations are performed: 2 bit-and, 2 shifts, 1 bit-or, 1 addition. For a single letter it\'s too expansive, fortunately this algorithm could be easily translated to SIMD and SWAR code (I hope SIMD version appear soon). 32-bit SWAR version: Much better --- now conversion from 4 letters (or 8, when operate on 64-bit words) requires: 1 byte swap, 2 bit-and, 2 shifts, 1 bit-or, 1 addition, 1 pext. Sample implementation is available at github .'],
["notesen/2014-10-12-parsing-decimal-numbers-part-1-swar.html", 'Parsing decimal numbers --- part 1: SWAR', 'Parsing decimal numbers --- part 1: SWAR Wojciech Mua Added on 2014-10-12 Contents Introduction SWAR Improvement 1 Algorithm Sample implementation Improvement 2 Sample implementation Improvement 3 Sample implementation Comparison Sample code See also Introduction Naive parsing of unsigned decimal numbers can be coded as: The procedure parse does not check validity of a string nor check for overflow --- these problems won\'t be discussed in this text. Processing single letter require just 3 operations: subtract, addition, multiplication by 10. On x86 multiplication by 10 is cheap; multiplication x * 10 is equivalent to x << 3 + x << 1 . Shift by 8 is coded with LEA (it\'s executed by addressing unit, not ALU), and shift by 1 is simple addition or another LEA . SWAR In SWAR version we\'ll process 4 letters at once. For shorter strings naive fallback have to be used or proper mask applied on dword. The common phase of all SWAR versions is converting ASCII to digit values, this is simple subtraction. input --- 4 ASCII letters: subtract vector of \'0\': Improvement 1 Suppose we have just two digits x and y stored in separate bytes: Value of w is 256*x + y , but we want to get 10*y + x . By multiplication w by 2561 we get this value in the higher byte. Magic? No, 2561 = 256 * 10 + 1, and: 1 --- keeps x on the original position; 2560 --- moves y multiplied by 10 on the second byte; adds them together. Proof: [...] [...] Full expression: The same trick could be used to join 2-digit values ab & cd stored on 1st and 3rd byte: The \"magic\" multiplier is 6553601, result is 100*cd + ab saved in the higher word. Algorithm input --- 4 digits: form two words suitable to make 2-digits values: form 2-digits values by multiplication t2{a,b} by 2561: prepare dword from t3{a,b} to get 4-digits value: form 4-digit value by multiplication t3 by 6553601: extract higher word from t5 . Sample implementation Improvement 2 Another approach to making 2-digit values: input --- 4 digits: mask 1st and 3rd digit: move one digit left and multiply by 10: This can be done without multiplication. We calculate (x * 10) >> 8 , multiplication is replaced by shifts ((x << 3) + (x << 1)) >> 8 , after simplify shifts: (x >> (8-3)) + (x >> (8-1)) . add t1 and t3 : mask 1st & 3rd digits again: convert t5 to 4-digits value. Sample implementation Improvement 3 Another approach to making 2-digit values: input --- 4 digits: multiply by 10: move digits one position right (shift dword right by 8 bits): add t2 and t3 : mask unneeded bytes 1 and 3: Now word t5 could be converted as in the version 2. Sample implementation Comparison Number of operations required to convert 4 ASCII digits. operation naive version 1 version 2 version 3 bswap 1 1 bit-or 1 bit-and 3 2 1 shift 5 3 2 add 4 2 1 sub 1 1 1 1 mult 3 1 1 mult-by-10 4 1 total 9 13 10 6 Sample code Sample code is available on gitub . See also Parsing decimal numbers --- part 2: SSE'],
["notesen/2014-10-15-parsing-decimal-numbers-part-2-sse.html", 'Parsing decimal numbers --- part 2: SSE', 'Parsing decimal numbers --- part 2: SSE Wojciech Mua Added on 2014-10-15 Updated on 2018-03-22 (added SSSE3 variant) Contents PMADDWD details Algorithm SSSE3 SSE4.1 Sample code Experiments results Core i5 M540 @ 2.53GHz Skylake Core i7-6700 CPU @ 3.40GHz See also SSE procedure is able to convert two 8-digit numbers. The main instruction used in converting to numeric value is PMADDWD . PMADDWD details This instruction is specialized and I guess isn\'t often used. PMADDWD operates on packed words and performs following algorithm: Algorithm Load 16 ASCII digits in order abcdefghijklmnop, and convert to bytes. Each byte a..p is in range 0..9: Split even and odd digits: Calculate partial values of even digits: as 4-digit decimals: Similarly calculate partial values of odd digit: as 4-digit decimals: Add partial results from step 3 and 4 (shown as decimals): Last step is to form 8-digits partial results. Since numbers are less than 10000, higher words of t5 are zero: Calculate results: 64-bit multiplication is available in SSE starting from SSE4.1, so portable way to get final 64-bit value requires a CPU multiplication. SSSE3 SSSE3 introduced instruction PMADDUBSW that works similarly to PMADDWD but operates on packed bytes . The instruction treats numbers in one vector as signed and, in another vector, as unsigned. This limits a little bit usage, but fortunately not in this case. Algorithm for SSSE3 can convert 16-digit numbers and works as follows: Load 16 ASCII digits in order abcdefghijklmnop, and convert to bytes. Each byte a..p is in range 0..9: Calculate partial values of adjacent digits using PMADDUBSW . After this step each 16-bit element contains a 2-digit number: Calculate partial values from adjacent 2-digit numbers using PMADDWD . After this step each 32-bit element contains a 4-digit number. Please note that a 32-bit number can hold an 8-digit decimal number.: Convert into vector of words (16-bit words can hold 4-digit numbers): Build 8-digit numbers using PMADDWD : Get two lowest dwords from t4 and convert into 16-digit number using scalar instructions. SSE4.1 In SSE4.1 conversion of 32-digit numbers is very easy. String is split to 16-digit substrings and each substring is processed in steps 1 .. 5 of the algorithm. After 5th step we have two values: Steps 6 and 7 are different: SSE4.1 supports PACKUSDW , thanks to that t5_lo and t5_hi could be joined with single instruction: Calculate results: SSE4.1 supports also PMULDQ , so producing 64-bit values in SSE registers is possible: However, calculating 128-bit value require CPU instructions. Sample code Sample code is available on gitub . Only SSE and SSSE3 implementations are available. Experiments results The SWAR methods are described in the article linked at the bottom. Core i5 M540 @ 2.53GHz method time [us] speedup naive 247514 1.00 SWAR (1) 158043 1.57 SWAR (2) 148712 1.66 SWAR (3) 125978 1.96 SSE 37704 6.56 SSSE3 27271 9.07 Skylake Core i7-6700 CPU @ 3.40GHz method time [us] speedup naive 131904 1.00 SWAR (1) 84933 1.55 SWAR (2) 84945 1.55 SWAR (3) 75862 1.74 SSE 18698 7.05 SSSE3 17693 7.45 See also Parsing decimal numbers --- part 1: SWAR'],
["notesen/2014-10-22-sse-convert-hex-to-ascii.html", 'Using SSE to convert from hexadecimal ASCII to number', 'Using SSE to convert from hexadecimal ASCII to number Wojciech Mua Added on 2014-10-22 Contents Introduction Converting from ASCII to nibbles Packing nibbles --- reversed input Packing nibbles --- reversing result Converting 32-digit strings Sample code Introduction SSE procedure can convert 16- and 32-digits inputs producing 8- and 16-bytes results. To get correct result\'s order of input, characters have to be reversed. In SSSE3 it can be done with pshufb , but in the earlier versions of SSE this is quite hard. When byte shuffling is not available then reversing can be done on the result word using bswap instructions. Converting from ASCII to nibbles Converting from ASCII to nibbles is reversion of the algorithm described in another text : In SSE the condition correction can be expressed as a compare & a bit-and: Packing nibbles --- reversed input input --- 16 nibbles: join nibbles: mask higher byte of each word, as they contain garbage: convert packed words to packed bytes --- the lower 8 bytes of SSE register is the result word: Packing nibbles --- reversing result input --- 16 nibbles: join nibbles: move higher bytes to lower, discarding lower bytes: convert packed words to packed bytes --- the lower 8 bytes of SSE register is the result word: Converting 32-digit strings This algorithm is able to convert 16 hex digits, but it can be easily extended to convert up to 32 hex digits. Steps 1 ... 3 have to be applied for lower & higher half of an input, and in step 4 arguments of packuswb are the outputs from 3rd step, say t3_lower and t3_higher : Sample code Sample implementation is available at github (file parse.sse2.c ).'],
["notesen/2015-03-21-avx2-is-not-256-bit.html", 'Not everything in AVX2 is 256-bit', 'Not everything in AVX2 is 256-bit Wojciech Mua Added on 2015-03-21 AVX2 has added support for 256-bit arguments for many operations on packed integers, although not all. Some instructions accept the 256-bit registers, but operates on 128-bit lanes rather the whole register. There are three major groups of instructions: packing (narrowing conversion), unpacking (interleave), and permutations Below is a full list of instructions (with intrinsics): valignr ( _mm256_alignr_epi8 ) vpslldq ( _mm256_bslli_epi128 ) vpsrldq ( _mm256_bsrli_epi128 ) vmpsadbw ( _mm256_mpsadbw_epu8 ) vpacksswb ( _mm256_packs_epi16 ) vpackssdw ( _mm256_packs_epi32 ) vpackuswb ( _mm256_packus_epi16 ) vpackusdw ( _mm256_packus_epi32 ) vperm2i128 ( _mm256_permute2x128_si256 ) vpermq ( _mm256_permute4x64_epi64 ) vpermpd ( _mm256_permute4x64_pd ) vpshufd ( _mm256_shuffle_epi32 ) vpshufb ( _mm256_shuffle_epi8 ) vpshufhw ( _mm256_shufflehi_epi16 ) vpshuflw ( _mm256_shufflelo_epi16 ) vpslldq ( _mm256_slli_si256 ) vpsrldq ( _mm256_srli_si256 ) vpunpckhwd ( _mm256_unpackhi_epi16 ) vpunpckhdq ( _mm256_unpackhi_epi32 ) vpunpckhqdq ( _mm256_unpackhi_epi64 ) vpunpckhbw ( _mm256_unpackhi_epi8 ) vpunpcklwd ( _mm256_unpacklo_epi16 ) vpunpckldq ( _mm256_unpacklo_epi32 ) vpunpcklqdq ( _mm256_unpacklo_epi64 ) vpunpcklbw ( _mm256_unpacklo_epi8 ) For me the most surprising are packing instructions ( vpack* ) as they require additional shuffling (after or before the instruction) if we want to keep the order of values. In some cases the order is crucial.'],
["notesen/2015-03-21-sse-generating-mask.html", 'SSE/AVX2: Generating mask where n leading (trailing) bytes are set', 'SSE/AVX2: Generating mask where n leading (trailing) bytes are set Wojciech Mua Added on 2015-03-21 Contents Introduction Big lookup table Small lookup table No lookups Introduction Informal specification: Big lookup table The obvious approach is to use two lookups with 16 entries each, then mask_lower could be expressed by a single movdqa . Downside of this solution is quite large lookup: 2*16*16 bytes = 512 bytes. For AVX/AVX2 it\'s 4 times larger (2KiB). Small lookup table This idea comes from my friend Piotr Wyderski and I have permission to publish his trick. It\'s pretty neat. :) We need just 48 bytes of continuous memory, i.e. three SSE vectors. The memory is filled with following pattern: Then mask_lower is reduced to a single unaligned load movdqu from lookup[index]. Likewise mask_higher loads vector from lookup[16 + index] . It can\'t be done better . No lookups This solution use the instruction palignr . The instruction gets three arguments: two vectors and an immediate index, join vectors into one big 32-bytes vector, and then return subvector starts at the index. See psuedocode: When the vector A is full of ones (zeros), and the B is zero (full of ones), then palignr calculates mask_lower ( mask_higher ). Filling vector with ones or zeros is fast, pcmepeq reg, reg and pxor reg, reg does the job. Unfortunately palignr doesn\'t allow variable index values, just an immediate, so for each value we have to invoke different instruction. This costs two jumps and it\'s too high cost. But if we need to conserve the memory or the operation isn\'t on a hot path then this solution seems to be OK.'],
["notesen/2015-03-22-avx512-ternary-functions.html", 'AVX512: ternary functions evaluation', 'AVX512: ternary functions evaluation Wojciech Mua Added on 2015-03-22 Updates 2020-01-11 Contents Introduction Bit select function Other examples Artificial function OR/AND/XOR all Exactly one bit is set Exactly two bits are set Real-world examples MD5, SHA-1 and SHA-2 hashing Carry-save adder See also Changes Introduction Intel\'s version of SIMD offers following 2-argument (binary) boolean functions: and , or , xor , and not . There isn\'t a single argument not , this function can be expressed with xor reg, ones , however it requires additional, pre-set register. AVX512F will come with a very interesting instruction called vpternlog . There are two variants of the instruction operating on a packed 32-bit ( vpternlogd ) or a 64-bit vector ( vpternlogq ), however they do exactly the same thing --- evaluate a 3-argument ( ternary ) boolean function on each bit of arguments, the function is given as a truth table. The pattern of a truth table: inputs result A B C 0 0 0 a 0 0 1 b 0 1 0 c 0 1 1 d 1 0 0 e 1 0 1 f 1 1 0 g 1 1 1 h A programmer supplies only the result column, i.e. defines values of bits a through h , this is a single 8-bit value. Depending on function complexity, a single vpternlog instruction can replace from one up to eight SIMD instructions. According to Agner Fog\'s documentation on SkylakeX vpternlog has 1 cycle latency and 0,5 cycle reciprocal throughput (there are two execution units able to handle the instruction). It\'s pretty fast, though. Ternary logic function is available as the intrinsic function _mm512_ternarylogic_epi32(a, b, c, imm8) , where the argument a carries most significant bits, and c least significant bits. Bit select function A ternary function may be seen as a select function, i.e. the most significant bit A select one of binary functions of B and C. The function for A=0 is described by bits a..d, the function for A=1 by bits e..h. As @solardiz noted this function is available in OpenCL as bitselect() , AMD XOP has instruction VPCMOV , AltiVec has VSEL , NEON has VBSL , also several GPUs support such instruction. Example A ? B : C . inputs result A B C 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 1 0 1 1 1 1 1 constant 0xca The assembly code using binary functions: Other examples Artificial function Let see for example function (A or not B) and C . The truth table: inputs result A B C 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 1 To express the function using standard SSE instructions we need three operations: With AVX512 it would be very simple: OR/AND/XOR all inputs OR AND XOR A B C 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 1 1 0 0 1 0 0 1 0 1 1 0 1 1 0 0 1 1 0 1 0 0 1 1 1 1 1 1 constant 0xfe 0x80 0x96 The assembly code of or all using binary functions: Exactly one bit is set Function is true when only one bit is set. inputs result C B A 0 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 0 constant 0x16 The C code using binary functions: The procedure uses five instructions. Exactly two bits are set Function is true exactly two bits are set. inputs result C B A 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 0 constant 0x68 The C code using binary functions: The procedure uses five instructions. Real-world examples MD5, SHA-1 and SHA-2 hashing Popular hashing algorithms use several three-argument logic functions in their main loops. Although the functions might seem complicated, they are expressed with single vpternlog instruction. MD5 hashing defines four state changing functions (the order of variables from the most significant bit: x , y , z ). expression vpternlogd const (x and y) or (not x and z) 0xca (x and z) or (y and not z) 0xe4 x xor y xor z 0x96 y xor (x or not z) 0x39 Similarly, SHA-1 uses three ternary logic functions in its main loop (the order of variables from the most significant bit: b , c , d ). expression vpternlogd const (b and c) or (not b and d) 0xca b xor c xor d 0x96 (b and c) or (b and d) or (c and d) 0xe8 Also SHA-2 uses ternary logic functions in its main loop. I omitted a three-argument xor, which is shown above (the order of variables from the most significant bit: e , f , g ; and a , b , c ). expression vpternlogd const (e and f) xor (not e and g) 0xca (a and b) xor (a and c) xor (b and c) 0xe8 Carry-save adder The crucial function of Harley-Seal population count algorithm is carry-save adder. That function calculates two bits of 3-argument sum, i.e. the digit and the carry flag. inputs outputs C B A digit carry 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 The fastest implementation of above functions contains five logic instructions: With help of vpternlogd this can be calculated as: See also Ternary functions for SSE, AVX2 and XOP --- library which allows to use ternary functions in the same way as AVX512, i.e. by passing the function index. The best known instruction sequences are emitted. Ternary logic CLI --- CLI to play with vpternlog constants. Changes 2020-01-11 --- fixes of hash function constants, mistakes spotted by Jack Lloyd 2018-11-05 --- Mark Parker spotted several mistakes; added hashing methods, added latency/throughput parameters of the instruction 2016-11-07 --- more info about bit-select (thank you @solardiz !) 2016-09-04 --- fixed a wrong claim, some practical example. 2016-03-26 --- real-world example'],
["notesen/2015-03-22-compiler-warnings.html", 'Compiler warnings are your future errors', 'Compiler warnings are your future errors Wojciech Mua Added on 2015-03-22 Months ago I was asked to upgrade GCC from version 4.7 to 4.9 and also cleanup configure scripts. Not very exciting, merely time consuming task. Oh, we were hit by a bug in libstdc++ , but simple patch has fixed the problem. Few weeks later I was asked to change GCC switch from -std=c++11 to -std=c++14 --- the easiest task in the world. I had to modify single script, run configure , type make , then run tests... everything was OK. Quite boring so far. Then my coworker noticed that after the last change unit tests started to randomly crash or hang. However, nobody else complained and continuous integration system worked fine. Wait, just a simple change in a compiler flag would cause such problems? I simply rejected this reason, but to be sure for 100% I had done a clean build, run tests and... nothing wrong happened. The conclusion was obvious for me: there is some bug in a coworker branch, and when he merge with the clean master everything will be OK. Recently I\'ve written a very simple console application that use our core modules. The application always hung, so I had started to investigate problem and finally figured the reason. My colleague was right, problem was introduced by the new compiler\'s flag. There was an issue with variable-length arrays (VLA), which are used extensively in a one of core subsystem. Consider this simple program: When compiled with g++ -std=c++11 size.cpp the program prints 5 --- this is perfectly OK. But when we change flag to -std=c++14 the program prints 1 and the compiler displays following warning (output from GCC 4.9.1 and 4.9.2): Weird? Yes and no. GCC implemented proposal N3639 for C++14 (\"Runtime-sized arrays with automatic storage duration\") where sizeof(VLA) is an error (\"ill-formed\"), but as we see authors have chosen a soft warning rather a compile error. BTW, N3639 was rejected and GCC also removed support for this proposal. Lesson learned Because we always have very large build logs I didn\'t notice the new warning. In order to prevent such errors in the future I\'ve written a script that extracts all warnings from the logs and prints them in a easy-to-read form. I also fight with warnings in so called spare time.'],
["notesen/2015-03-22-simd-pattern.html", 'SIMD: detecting a bit pattern', 'SIMD: detecting a bit pattern Wojciech Mua Added on 2015-03-22 Contents Introduction Version 1 Version 2 Version 3 Introduction The problem: there are 64-bit values with some data bits and some metadata bits; the metadata includes a k-bit field describing a \"type\" ( k >= 0 ). The type field is located in a lower 32-bits. Procedure processes two \"types\", one denoted with the code 3 and another with 5. When all items are of type 3 then we can use a fast AVX2 path. If there are some types 5, we have to call an additional function (a virtual method to be precise). Pseudocode: We have to fill condition of the if-statement . Version 1 In total ten instructions. It doesn\'t look well. Let\'s try another approach. Version 2 In this version we change the third step. An addition is used instead of a comparison: A_type + B_type + magic_value --- the magic_value causes to set the highest bit when A_type or B_type is 5. How to calculate this value? Let say the code field is located at 4th bit and it has 3 bits width: All bits after type field and before the most significant bit X are set. If an overflow occur while adding type field, then the carry bit will propagate through ones up to the bit X. In this case magic_value = 0b0111 1111 1111 1111 1111 1111 1000 0000 = 0x7fffff80 . In total nine instructions. A bit better and we\'ve also learned a new trick. Version 3 Now we stop thinking \"in SIMD-way\". Simply compare binary images of 3 and 5: 3 = 0b011 , 5 = 0b101 --- it\'s clear that 5 has set 3rd bit, so this bit must be somehow gathered by the movemask instruction. Here is the solution: Seven instructions. I can\'t do this better.'],
["notesen/2015-04-08-simd-search.html", 'SIMD-ized searching in unique constant dictionary', 'SIMD-ized searching in unique constant dictionary Wojciech Mua Added on 2015-04-08 Updates 2016-05-03 (binary search modifications) Contents Introduction SIMD-ization of binary search Binary search with SIMD search around pivot point Binary search with fallback to linear search Comparison Summary Source code Introduction The problem: there is an ordered dictionary containing only unique keys. The dictionary is read only, and keys are 32-bit (SSE) or 64-bit (AVX2). The obvious solution is to use binary search . Keys can be stored in a contiguous memory thanks to that there is no internal fragmentation, and data has cache locality. And of course indexing the keys is done in constant time (in the terms of computational complexity) or a single memory fetch (hardware). The time complexity of binary search is [...] Another algorithm is linear search which seems to be suitable for small dictionaries . Linear search could be easily SIMD-ized. SIMD-ization of binary search I propose following modification: the key space is split to five independent subspaces and the lookup starts with choosing the proper subspace, then standard binary is used to search in the subspace. The computational complexity remains [...] The trick is to use SIMD operations to choose a subspace. We need four keys k1 , k2 , k3 and k4 which define subspace boundaries, then a single vector compare for greater yields a mask that defines a subspace. Following pseudo code show the idea: SIMD part requires just three instructions: broadcast key to vector; compare with boundaries vector; get mask. This is done in constant time and binary search is executed on subarray of size 20% of input data. Binary search with SIMD search around pivot point Modification of binary search: when the search range is narrowed, then try to find a key near the pivot point. A SIMD equality function is used. Following code shows the idea (check out the implementation ): Binary search with fallback to linear search For short arrays linear search is faster than binary search. In this modification binary search algorithm ends when the search range is small, then linear search is performed on this range. Threshold size shouldn\'t be too large. I would say that the size of cache line (or two lines) is a good starting point. A full C++ implementation : Comparison Results from Core i5 (Westmere). The unit is number of queries per second. size [bytes] binary search linear search (1) default (2) linear fallback (3) SIMD subrange select (4) SIMD search around pivot (5) default (6) SIMD boosted 4 44,277,175 46,899,696 33,078,081 40,488,781 64,679,288 40,058,806 8 16,391,723 18,863,227 16,241,043 15,295,572 22,813,654 27,207,701 16 3,617,123 4,131,163 6,905,724 6,622,157 3,266,917 10,469,538 32 1,444,317 1,784,175 1,926,374 2,437,853 1,268,942 4,130,405 64 586,026 669,683 677,376 822,112 456,542 1,504,841 128 259,413 279,583 269,133 337,367 139,831 442,554 256 114,956 123,168 117,368 134,691 40,075 132,586 512 49,428 56,470 53,368 59,880 10,767 38,690 1024 23,527 25,907 25,402 27,442 2,788 10,141 2048 10,873 12,048 11,193 12,640 707 2,631 4096 5,520 5,632 5,091 5,999 178 692 8192 2,738 2,656 2,531 2,852 45 174 Summary Linear search is suitable for small dictionaries (up to 64-128 elements). SIMD-ized version of binary search (3) is always faster than plain version (1). Binary search with linear search fallback (2) is almost as fast as the fastest binary SIMD search (4). Source code All sources are available at github .'],
["notesen/2015-04-13-faster-popcount-for-large-data.html", 'Speeding up bit-parallel population count', 'Speeding up bit-parallel population count Wojciech Mua Added on 2015-04-13 Contents Introduction Modification Experiments results and source code See also Introduction This well know method requires logarithmic number of steps in term of the word width. For example the algorithm run on a 64-bit word executes 6 steps: In each step k -bit fields are summed together; we start from 1-bit fields, then 2, 4, 8, 16 and finally 32 bits. Single step requires: 2 bit-ands; shift right by constant amount; addition. Modification When counting bits in larger data sets it\'s possible to delay later steps (i.e. operating on wider bit fields) by accumulating partial results from earlier steps as long as a bit field is able to hold the sum value. For example maximum value of single byte in t4 is 8, thus we can perform up to 255/8 = 31 additions without overflow. This example shows the idea: Thanks to that number of operations is smaller comparing to naive version --- when processing n 64-bit words the naive version executes: [...] [...] [...] and the modified version: [...] [...] [...] This is nearly 50% less of bit-ands, 50% less of shifts and 40% less of additions. Experiments results and source code The source code is available at github . Sample results from Core i5: clearly shows the theoretical calculations, optimized version is 48% faster. See also SSSE3: fast population count'],
["notesen/2015-05-25-tricky-mistake.html", 'Tricky mistake', 'Tricky mistake Wojciech Mua Added on 2015-05-25 A programmer wrote: Do you see the mistake? The programmer thought that the expression \"Invalid index: \" + index evaluates to std::string(\"Invalid index: 5\") . In fact the type of the expression \"Invalid index: \" is char[15] , so char[15] + integer results in --- more or less --- char* . For index in range [0, 15] an exception will carry the tail of the message, for example when index=10 then message assigned to the exception object will be \"dex: \" . For indexes larger than 15 and less than 0 a program likely crash . This is why I hate C++, this language has many dark corner, stupid conventions, implicit conversion and not mention UB (\"just\" 150 UB, if you\'re curious).'],
["notesen/2015-10-25-boolean-functions.html", 'Boolean function for the rescue', 'Boolean function for the rescue Wojciech Mua Added on 2015-10-25 The problem is defined as follows: a set of features is saved using bit-sets (usually large), and there is a list/map/whatever of sets containing features of different objects. We have to find which features are unique. Naive solution is to use nested loops: Not good, the method is_set of bit-set is called size * list.size() times. Even if a compiler is able to inline the call and use simple bit tests instructions it\'s still too expansive. Bit-set implementations always use arrays of integers to store the data, thanks to that bit-operations (and, or, xor, etc.) are executed very fast. We try to exploit this with boolean functions. Each feature could be described as: non-existing (count is 0), unique (count is 1), non-unique (count greater than 1). Now these states are encoded using two bits: H L value 0 0 non-existing 0 1 unique 1 1 non-unique Then we define a transition table. For example if a feature is present and the current value is \'unique\' then the next value is \'non-unique\' (row 5th). H L feature H\' L\' 0 0 0 0 0 0 1 0 0 1 1 1 0 1 1 0 0 1 0 1 0 1 1 1 1 1 1 1 1 1 Boolean expressions are: L\' = L or feature ; H\' = H or (feature and L) . We also need to get single bit-set from H and L at the end: H L result 0 0 0 0 1 1 1 1 0 The final boolean expression is: result = L and not H . Now we can rewrite the code: I really like this approach.'],
["notesen/2015-11-15-code-dive.html", 'Short report from code::dive 2015', 'Short report from code::dive 2015 Wojciech Mua Added on 2015-11-15 Few days ago I attended code::dive 2015 , an IT conference in Wrocaw, Poland. It was a one-day conference with a great number of presentations. There were four stages and five sessions, in total 20 talks. Impressive number! But an attender had to choose his own path of just five lectures. I think the decision was pretty difficult. Sometimes less is better. The conference was organized by Nokia Poland for the second time, and these guys did the job very well. The location was perfect. The event was in a big cinema near the city center. There were free food and water. You had only to register online. I decided to watch following presentations: Andrei Alexandrescu \"Writing Fast Code\" part 1. Andrzej Krzemiski \"Constraint yourself\". Urlich Drepper \"Intelligent application configuration data management\". Bartosz Szurgot \"C++ vs. C: the embedded perspective\". Dan Saks \"Representing Memory-Mapped Devices as Object\". I\'m not going to describe here the presentations in details, because videos should eventually appear on the official channel at Youtube . I just point out things which interested me. Writing Fast Code Andrei performed a nice show, however some part were... hm, confusing. For example he claimed that code x = x/10 emits a division instruction. This is not true, all compilers run in so called \"release mode\" will emit multiplication by a reciprocal of a constant. Check this for your own. Another big misunderstanding of the speaker was the cause of slow writing operations on the modern hardware. He claimed that after a write request a CPU loads a line of cache, then modifies it contents according to the request, and finally CPU writes the cache line back to the memory. No. It doesn\'t work like this, simply. Slow down is caused mostly by multicore architecture and required synchronization among cache subsystems. But this is not very important, I think people should remember simple fact: fewer writes means faster programs. Update 2015-11-22 : my friend Piotr reminded me another funny fact, a speculation why division of floats is faster than division of integers. Andrei claimed that the reason is... exponential format of floats. It\'s just a subtraction of exponents, a division of mantissa and viola. I\'m pretty sure that it\'s not the real reason. Andrei showed how he has optimized procedure converting a number to an ASCII representation. He used few tricks, and one of them is worth to mention. He minimize the number of \"real\" conversions by introducing a specialized path for smaller values. Do the same in your program, analyze your data and use an if instruction to select a fast path. It usually works. Andrei gained 3-5 speedup without big effort. From perspective of a programmer who has never worked on code optimization Andrei\'s advice were very valuable. For example: never measure time of debug compilation. Compare your program with good, standard & proved existing solutions. Your optimization of one module could have a negative impact on the whole application. When you measure a time, run tests many times and get the minimum measurement. Pretty obvious, but precious for newbies (the conference was full of students from local universities). Constrain yourself Andrzej\'s presentation was about building restricted data types, making no room for misuse. The starting point of his talk was conclusion that standard C++ data types, like int or char, are a kind of void pointer, i.e. they are transient, untyped entities. It\'s very true. Then he showed three examples from the real life. The first example was a type representing number of minutes since midnight. Basically it was wrapped integer number having a tight API. Surprisingly amount of code required to do this isn\'t very large. Constraints are checked in the run-time during instance construction. And this is the only disadvantage, because everything else is checked in compile-time. The second example was a short string implementation, where length of a string is given as a template parameter. First of all the class conserves memory and avoid dynamic allocation, and also expose a very basic set of methods when compared to std::string. However, thanks to the C++ type system, to distinguish strings of the same length but different purposes, a programmer have to use fake traits class. I really dislike this approach. It\'s ugly, but the only solution. The last example in Andrzej\'s talk was another class hiding from an user a magic values designed to mean \"no value\" or \"no valid\". The speaker compared this solution with boost::optional. The boost template class can wrap virtually all types, but at cost of additional memory. The magic-value approach has no memory footprint, however it is limited mostly to numeric types. The presentation has reminded me two sad facts: The C++ type system is weak, and making it stronger require some effort, especially use templates (which make compilation time longer). The class std::string is the worst class ever, having giant API, lacking useful methods, having no extension points (except allocator). Intelligent application configuration data management Urlich showed a little bit history of configuration files and all related problems. There are three major issues: number of different configuration files (like global in /etc , user dot-files and so on), problem with versioning (and changing values of a running application), and the last one: how to obtain a current settings used by a program. Urlich mentioned also that some aspect of program could be controlled through environment variables, however it is not recommended by the speaker. The first cure was to embed a Lua interpreter in our C++ program, as the interpreter is very small and the language is pretty powerful. Lua scripts gives more flexibility and are easy to extend on the fly. Indeed a nice approach, but in my opinion this just move the problems outside a C++ program. The problem with obtaining a current configuration was resolved really clever. Urlich proposed to expose all parameters as a virtual file system, like procfs . He used well know FUSE --- it works and it doesn\'t require too much code. Thanks to file system an application can react instantly on parameter write, and also versioning is possible. Moreover, an administrator can capture all parameters using standard tools. The talk was interesting. However the presented solution was strictly Linux-related and IMHO was too complex for simple/average applications. Maybe for large, complex applications dealing with significant number of parameters this could be a good method. I didn\'t like Urlich\'s slides, a wall of C++ code doesn\'t look good. C++ vs. C: the embedded perspective A little bit provoking title. But first of all I have to say that Bartosz was speaking fast. Really fast. Really, really fast. He can be a host at auctions. The speaker compared size of executables for different architectures (ARM, Atmega and something else) produced by C and C++ compilers. For me it was a bit surprising that C++ code was smaller in most cases. A C++ code used templates in place of C macros, thanks to that a compiler was able to perform better optimization. Simple CPUs have simple architecture and number of instructions strictly determines an execution time. Thus smaller executable size means less instructions and in fact faster program. Of course a C++ program on an embedded system probably would never use RTTI nor exceptions facilities, but at least a programmer could use classes and templates, which helps a lot. Representing Memory-Mapped Devices as Object Another embedded-related presentation. Dan showed how to use classes to hide hardware obscure details, in the case serial port settings. Dan started from a C-like solution (really ugly and error-prone), and finished with a nice encapsulation in a class. However, overloading new operator to initialize hardware is the most bizarre thing I\'ve ever seen (I\'ve seen many weird things, believe me).'],
["notesen/2015-11-22-another-cpp-nasty-feature.html", 'Another C++ nasty feature', 'Another C++ nasty feature Wojciech Mua Added on 2015-11-22 I\'m fond of C++ weirdness, really. This language is full of traps, and it shocks me once in a while. Let\'s look at this piece of code, a part of a larger module: We would expect that in case of an error following line will be reported: \"user has entered wrong time: 123 PM\". Obvious. But please look closer at the code, do you see any mistake? There is one... dirty... hard to notice. I\'ll give you a minute. So, the mistake is lack of comma between expressions *clock_hour and *am_pm_clock . However, the code is valid! It compiles! And it took me a little longer than a minute to understand what happened. Explanation is: *clock_hour evaluates to expression of type unsigned ; then a compiler sees * - a multiplication operator; so the compiler checks if multiplication of unsigned (on the left side) with boost::optional<unsigned> (on the right side) is possible; it is, because boost::optional<T> has conversion operator to type T . We can rewrite the whole expression, now it should be clear: In result method is called with a single parameter of type const char* . It\'s bizarre, it\'s terrible. A language should help a programmer. In my opinion implicit conversions is the worst feature of C++.'],
["notesen/2015-11-28-implicit-conversion.html", 'Implicit conversion --- the enemy', 'Implicit conversion --- the enemy Wojciech Mua Added on 2015-11-28 I wrote: I forget that pad_left signature is string, int, char and the char parameter has a default value. My mistake, without doubts. This is another example of dark sides of the implicit conversions. C++ converts between characters and integers seamlessly. These two beast are distinct in the nature. Of course characters are represented by the numbers, however it\'s an implementation detail. One can say: you made a mistake and now blame the language. No, I blame language\'s design. I\'m afraid that we end up with something like Integer and int to overcome such problems. Lesson learned: never use default parameters in public API (surprise!)'],
["notesen/2015-12-13-obsession.html", 'Benefits from the obsession', 'Benefits from the obsession Wojciech Mua Added on 2015-12-13 Everything has started few years ago when I found John Regher\'s blog . If you don\'t know the blog I highly recommend it. Among other things (I like the photos!) the author studies bugs in compilers, undefined behaviours and similar things. The word \"overflow\" appears quite often in his posts due to the great number of errors related to improper use of the integer arithmetic. Well, I don\'t know when the obsession has exactly started, but recently I realized that I am alert of all integer operations in my programs. If a variable has type int and later it is incremented then I\'m pretty sure that the application will eventually blow up. When I can\'t prevent it, I left comments like: \"XXX: possible overflow\". This post shows three cases when I haven\'t left a comment, but fixed the issue. Case 1 On the other day I saw such innocent code: The size of result is three fouth of the base64 \'s size, so it is obviously smaller than the maximum value of size_t which is used to store the string size. However, the overflow can occur during multiplying by 3. On 64-bit machines the size of base64 have to be really huge to trigger the error --- it is 1.23e+19. But on 32-bit machines it\'s \"merely\" 28 GB (try to imagine base64-encoded movie sent via e-mail...) Despite the CPU architecture, the problem still exists. And the solution is not very complicated. Expression 3/4 * x is equivalent to x - 1/4 * x . Dividing x by 4 never cause an overflow, but since we operate on integers these two expressions are not equal. The latter expression have to be corrected (rounded up) with following conditional expression (x % 4 != 0) ? 1 : 0 . Thus the final expression is: The expression requires: 2 additions, 1 right shift, 1 comparison and 1 condition expression. And it\'s perfectly safe. Case 2 Later I spotted a similar mistake in a procedure which encodes data to base64. The expression calculating the size of an output buffer: Here the overflow is clearly visible, because value 4/3 * x could be greater than the maximum value of an integer. Again, to trigger the error on 64-bit CPUs the input size have to be greater than 4.61e+18. But on 32-bit CPUs the overflow will occur for 1GB inputs. OK, so how to detect the overflow in this case? After rewriting expression to x + x/3 we can easily detect overflow during addition: In this case the only additional cost is a single comparison before the addition. And, what is more important, the procedure detects the overflows, while the original version silently ignored them. Case 3 The last example: joining a list of strings. The naive implementation looks like this: In my version, before actual appending the items to the results, there is an extra loop which calculates the size of the result string, like this: This case is maybe not the most interesting (this is why is the last one). When joining a really huge number of items we will probably run out of memory before any overflow might occur. However, there are some arguments in favor of the solution. The first positive thing is that we detect the overflow at the early stage, before allocating any memory. The other good point is that there is single call to the reserve method, i.e. one allocation. Thanks to that later appending strings to the result only copies a data. Please remember that most of string implementations grow the memory by factor from 1.5 to 2.0, in result you can run out of memory even without arithmetic overflow. Summary To conclude the text: I showed how paying attention on minor details, considering possible but unlikely conditions led to eliminate some problems in the real code. I\'m pessimist and I do believe that ignored problems will eventually came out. Remember the famous bug in the binary search implementation --- everything was OK for many years, up to the day when somebody was butted.'],
["notesen/2015-12-27-base64-encoding.html", 'Base64 encoding --- implementation study', 'Base64 encoding --- implementation study Wojciech Mua Added on 2015-12-27 Updates 2016-01-17 (results from Core i7, BMI2, 64-bit variant of version B (case #7)) Contents Introduction Loading data and extracting indices (points 1 & 2) Base (version A) Improvement (version B) 64-bit code BMI2 Translating and saving the result (points 3 & 4) Base (version X) Improvement (version Y) Improvement (version Z) Comparison Results from Core i5 Results from Core i6 See also Introduction In a basic step of the Base64 encoding three bytes are processed producing four output bytes. The step consist following stages: load 3 bytes; split these 3 bytes to four 6-bit indices; translate the indices using a lookup table; save four bytes. In this text different implementations of the procedure are examined. Loading data and extracting indices (points 1 & 2) Base (version A) The naive way is to load 3 bytes and then combine them to 4 indices: This solution requires following operations: 3 memory loads; 3 bit-ands; 2 bit-ors 5 bit-shifts. Although some of the instructions could be executed in parallel (this depends on a CPU) the overall speed of the code is not very big. Improvement (version B) Possible modification is to load at once 4 bytes (we use just 3 of them) and then easily extract 6-bit indices: The modified version requires: 1 memory load ; 4 bit-ands; 3 bit-shifts; A drawback is that 4-bytes chunk is loaded, it\'s possible to read off the available process space; this is the drawback of all SWAR/SIMD algorithms. 64-bit code On 64-bit machines an input word could be 64-bit. Thanks to that the number of load decreases two times. However, only 6 bytes is used per iteration. BMI2 The common scheme in this optimization is right shift followed by masking 6 lowest bits. Bit Manipulation Instruction comes with an instruction bext doing exactly the described operation. Translating and saving the result (points 3 & 4) Base (version X) Again, the basic solution is sequentially translate and save separate bytes: Memory loads are needed to properly translate the indices, thus 4 memory loads are unavoidable . The only positive aspect is that size of lookup8 is only 64 bytes, it perfectly fits in the cache line. This solution requires: 4 memory loads (4 lookups); 4 memory stores . Improvement (version Y) Modification of this step is similar to loading, i.e. we build a 32-bit result and store the dword using just one instruction: This modification requires: 4 memory loads (4 lookups); 3 bit-ors; 3 bit-shifts; 1 memory store . Improvement (version Z) Bit shifts introduced in the above version could be avoided if special lookups were introduced. For each index separate, 32-bit lookup is required, and then the code simplifies to: The obvious negative point of this solution is much larger lookups (1 kB) than the lookup used in the base version (64 bytes). Comparison Sample code is available at github . The test program converts 32 MiB of data; this is repeated 10 times and the minimum time is printed. Results from Core i5 # extract indices from ... output tims [s] speedup 1 ... bytes (A) save bytes (X) 0.121 100.0% 2 construct dword from 1 lookup table (Y) 0.146 82.9% 3 construct dword from 4 lookup tables (Z) 0.124 97.6% 4 ... 32-bit word (B) save bytes (X) 0.095 127.4% 5 construct dword from 1 lookup table (Y) 0.122 99.2% 6 construct dword from 4 lookup tables (Z) 0.099 122.2% 7 ... 64-bit word (B) save bytes (X) 0.070 172.8% Summary: The only factor causing significant speedup is minimizing memory reads, i.e. using variant B for input. Case 7 is the brightest example. Fancy methods building a result at once do not help at all. The biggest speedup is merely 25% and I guess the memory throughput limits further improvement. Results from Core i6 # extract indices from ... output tims [s] speedup 1 ... bytes (A) save bytes (X) 0.082 100.0% 2 construct dword from 1 lookup table (Y) 0.082 100.0% 3 construct dword from 4 lookup tables (Z) 0.073 122.3% 4 ... 32-bit word (B) save bytes (X) 0.056 146.4% 5 construct dword from 1 lookup table (Y) 0.064 128.1% 6 construct dword from 4 lookup tables (Z) 0.050 164.0% 7 ... 64-bit word (B) save bytes (X) 0.043 190.7% 8 ... 64-bit word & bextr (B) save bytes (X) 0.060 136.7% 9 ... 64-bit word & bextr (B) construct 64-bit words from 1 lookup 0.072 113.9% Summary: Unlike i5, on Core i7 there is speedup caused by minimizing number of 32-bit writes (clearly visible in cases 3 and 6). However coalescing writes to 64-bit word (case 10) has negative impact. The biggest boost is due to use 64-bit loads (case 7). Using the new shiny instruction bextr doesn\'t help. I\'m underwhelmed and shocked. According to the manuals, throughput and latency are very small, the instruction replaces two other (including quite expansive shift). What a shame. See also Base64 encoding with SIMD instructions --- SSE boosts base64 encoding 2 times'],
["notesen/2015-12-29-float-to-string.html", 'Fast conversion of floating-point values to string', 'Fast conversion of floating-point values to string Wojciech Mua Added on 2015-12-29 Contents Introduction Algorithm Integer part Fraction part Experiments Introduction The conversion of floating-point numbers to a string representation is not an easy task. Such procedure must deal with different special FP values, perform proper rounding and so on. The paper Printing Floating-Point Numbers Quickly and Accurately [PDF] by Robert G. Burger & R. Kent Dybvig describes a procedure which solves the problem correctly. However, in some applications (mostly logging, debugging) rounding and accuracy are not as important as the speed. Sometimes we simply want to know if a number was 1000.5 or 0.5 and even if we read \"0.499999\" nothing wrong would happen. Algorithm A floating-point number could be represented as a fixed-point number of size 64:64 and then fast conversion routines could be used. This approach is several times faster than standard sprintf , moreover the method is also suitable for embedded systems. The biggest drawback is that the method is able to convert only a sub-range of possible floating-point values. However, the sub-range covers reasonable interval of numbers and in the practice it should be acceptable. Integer part The conversion from floating-point to integer require a few simple bit-instructions: bit-ands, bit-ors and shifts. The full procedure is described in article Convert float to int without FPU/SSE . Of course not all values could be converted, and some testing is needed before doing conversion. When an integer is ready we can use any procedure to convert it to the text. Even the simplest, naive method would be good; I\'ve described some other, faster methods in the article SSE: conversion integers to decimal representation . Fraction part The fraction part is obtained in the same way as the integer part: by shifting floating-point binary representation. The layout of fraction part: Such number is then treated as an integer number and the naive method of conversion fraction numbers is used. In each step fraction value is multiplied by 10, then the integer part is extracted from the result: In a single iteration following operations are performed: 1 multiplication by constant (on x86 this may be single lea ); 1 right shift by constant; 1 bit-and. Experiments Sample code is available at github . The program speed does conversion of wide range of float values using sprintf and the described method. Following times were printed on my Core i5 (gcc 4.9.2 with -O3 flag): sprintf : 8.842 s custom: 0.594 s. The speedup is around 15 times . However, sprintf does rounding, parsing a format string, allocates memory etc. I guess the real speedup would be 4 to 8 times , but still it\'s really impressive improvement.'],
["notesen/2016-01-06-swar-swap-case.html", 'Speeding up letter case conversion', 'Speeding up letter case conversion Wojciech Mua Added on 2016-01-06 Contents Introduction Base version Improvement --- SWAR approach Algorithm Trivia Generating mask Experiments Summary Introduction The aim of this text is to show how simple procedure which change case of letters could be rewritten to SWAR version gaining significant boost. In the article method \"to lower case\" is explored, however the opposite conversion is very easy to derive. To be honest I have no idea if changing latter case is crucial task in any problem. My knowledge and experiences suggest that the answer is \"no\", but who knows. Base version The basic version of the procedure reads one character (a byte) and then classifies it. If the character is an upper case ASCII letter then fast conversion could be used; if the character is an extended ASCII then the system procedure tolower is called. Note : lower and uppercase letters in ASCII encoding differs only in single, 5th bit. Improvement --- SWAR approach In SWAR approach a fast-path could be used if all character within a chunk are not from extended ASCII set. Then all character are classified if are uppercase or not, resulting in a mask having set certain bits. The last step is to xor the mask with the input chunk to selective flip the bit in upper-case letters. Algorithm Trivia The first step ( is_ascii ) and the last step ( to_lower_ascii ) of the algorithm are simple. Is ASCII tests only if highest bits and to lower swaps 5th bit: Generating mask Vectorization of comparison s[j] >= \'A\' && s[j] <= \'Z\' is the most interesting part. The key is a vector compare for relation \"greater than\", i.e. x > constant ; x = 0..127 . The expression have to be rewritten: When we add a byte of value 128 - constant , then for x greater than constant result would be 128 + something ; otherwise the result would be less than 128. In other words, the result of comparison is saved in the highest bit of a byte; lower bits contain garbage that have to be cleared later. A comparison is expressed by single addition. Thus the full, rewritten expression requires: 2 additions, 1 negation, and 2 bit-ands: An observation: it\'s not possible that x is less than \'A\' ( A is false) and at the same time greater than \'Z\' ( Z is true). Thanks to that the last expression could be simplified to: Final version requires: 2 additions, 1 bit-xor, 1 bit-and. Experiments The sample program is available at github . The test program loads given file to a 100 MiB memory region and then run the selected procedure: a scalar one, or improved. Two files were examined: 386INTEL.txt --- plain text; English documentation from Intel for their 80386 CPU; sutra_surangama.tex --- TeX file, encoding is ISO-8859-2; Polish translation of Sutra Surangama , a Buddhist text. file size [B] scalar time [s] SWAR time [s] speedup 386INTEL.txt 878\'279 0.1801 0.0573 3.13 sutra_surangama.tex 665\'859 0.2179 0.1720 1.27 Summary Speedup strongly depends on processed text. For English texts speedup is impressive, as SWAR path is used in most cases. However, for Polish text containing many national characters, the fast path isn\'t used very often. In line marked with *** , a chunk is always written back, even if is not modified. Experiments have shown that additional branch slows things down. Since the algorithm require branching in each iteration, SSE wouldn\'t help in my opinion.'],
["notesen/2016-01-12-sse-base64-encoding.html", 'Base64 encoding with SIMD instructions', 'Base64 encoding with SIMD instructions Wojciech Mua Added on 2016-01-12 Last update 2017-01-25 (spelling) Contents Introduction Algorithm outline Loading data SSE version AVX2 version SSE assisted load AVX2 load Splitting bytes Naive SIMD algorithm Improved SIMD algorithm XOP version BMI2 version (with SSE code) Branchless code for lookup table Naive version Improved version Improved version using logic instructions SSE & AVX2 versions pshufb-based lookup method Single pshufb method XOP variant Sample code Experiments Core i5 results (Westmere) Core i7 results (Haswell) Core i7 results (Skylake) AMD Bulldozer See also Changelog Introduction I had supposed that SIMD-ization of a base64 encoder is not worth to bother with, and I was wrong . When compared to scalar code, an SSE code is 2 times faster on Core i5 (Westmere), and around 2.5 times faster on Core i7 (Haswell & Skylake). An AVX2 code is 3.5 times faster on Core i7 (Skylake). 2016-12-18 note: in the initial version of this text I wrongly assumed order of input words, Alfred Klomp noted that the standard imposes a specific order. Today\'s change fixes this error. Algorithm outline In each step 12 (24 for AVX2) bytes are loaded. These bytes are transformed into 16 (32 for AVX2) 6-bit indices, each saved on a separate byte. Then these bytes are translated in parallel to proper ASCII codes, according to the base64 lookup table. So, the first problem is loading data . The next problem is splitting input bytes into these 6-bit indices . This can be done quite fast using a naive approach. But also it\'s a place for the new Bit Manipulation Instruction pdep instruction. The major problem with base64 encoding is the translation of 6-bit indices into ASCII characters. Normally it\'s done with a lookup table. In SIMD approach the lookup table have to be expressed as a program. Loading data The input 12 bytes have to be split into three-byte groups located into individual 32-bit words. These 4-byte words are processed in later steps. The Base64 standard sets order of bytes in group and also order of 6-bit words within a group to the big-endian order. Words are stored starting from the least significant a, b, c and d. On a little-endian CPU we got following layout: SSE version Load 12-bytes, containing four 3-byte groups (X, Y, Z, W) --- a simple load: Move 3-byte groups into separate 32-bit lanes. This is done with one pshufb : Each 32-bit lane contains four 6-bit indices: aaaaaa , BBbbbb , ccccCC and ddddd . The order of bytes is 1, 0, 2, 1, to make unpacking easier: AVX2 version Unfortunately, a direct translation of the SSE version is not possible. The reason is that the AVX2 version of pshufb works on 128-bit lanes rather the whole register. Also it is not possible to perform byte-wide shifts of AVX2 registers in order to move bytes across lanes. Two solutions are possible to overcome that limitations. Although performance tests on Core i7 (Skylake) didn\'t show any significant differences , I think both solutions are worth to describe. SSE assisted load 1a. Perform two loads into XMM registers: 1b. Create an YMM vector from vectors lo and hi . (intrinsic _mm256_set_m128i is translated into single instruction vinsertf128 ): 1c. Shuffle lower and higher lanes: AVX2 load 1a. Perform single load into a YMM register. Obvious drawback of this approach is reading 4 bytes off the input buffer: 1b. Shuffle data in 128-bit lanes: Splitting bytes Note: as SIMD algorithms presented below use simple bit-level instructions, they can be expressed using both SSE and AVX2 instructions. Examples use SSE instructions. Input to this step are 32-bit words, each having following layout: where bits aaaaaa , BBbbbb , ccccCC and dddddd are 6-bit indices. The output of this step has to be: Naive SIMD algorithm Following naive algorithm could be used. Move each index into a separate byte: Merge indices: Number of operations: bit-shift: 4, bit-and: 4, bit-or: 3. This code could be also easily parallelized at instruction level by a CPU. The only serious dependency is caused by pshufb , because its result is used in the next steps. Improved SIMD algorithm The improved algorithm expresses shifts using multiplication instructions. Left indices a and c Shift right the field c by 6, and the field a by 10. This is done by instruction PMULUH which multiplies unsigned 16-bit words and store the higher 16-bit of the result. When we multiply a value by a power of two, this is equivalent to shifting the value left. In this case the instruction is used to evaluate expression (x << amount) >> 16 . When amount > 16 this is the same as x >> (16 - amount) . Left indices d and b . Shift left the field d by 8, and the field b by 4. Again a multiplication instruction is used. Merge results of the previous steps: Number of operations: multiplication: 2, bit-and: 2, bit-or: 1. XOP version AMD XOP extension provides variable shift instructions, where shift amounts are given per item. Moreover, it provides a condition move instruction, which makes merging bit-fields easy. Thanks to that we can simplify the previous procedure: multiplications are replaced by shifts and a single conditional move replace one bitwise or and bitwise and. BMI2 version (with SSE code) BMI2 has introduced instruction pdep ( parallel deposit ), which performs in one step the points 3 and 4 of the above algorithm. The instruction pdep operates on 64-bit words, thus two invocation of the instruction are needed in order to fill an XMM register. However, the order of fields and bytes require some byte-swaps. Load 2 x 6 bytes. Swap order of bytes to join bit-fields. Expand fields using pdep . Build a SSE vector: Swap order of words withing expanded words, and then swap 32-bit words. This is done with single pshufb instruction. There are: 2 loads, 2 bswap , 2 shifts 2 pdep . 1 pshufb , one build_vector operation. The last operation is not a single CPU instruction. When an intrinsic _mm_set_epi64x is used, then GCC 4.9.2 translates it into two instructions movq and movhlps (or pinsrq , depending on architecture flags). To make the things worse, these instructions read data from a temporary memory . Disaster. So in the practice I\'ve decided to insert two pinsrq instructions. This made the code about 15% faster (on Core i7). Branchless code for lookup table The standard base64 lookup table is a sequence of: capital letters A-Z, small letters a-z, digits 0-9, character plus (+), character slash (/). Let i is a 6-bit index, then the lookup\'s output value could be described with following expressions. (Note: ord returns an ASCII code of a character, in C/C++ it\'s not needed.) i range expression 0 .. 25 A-Z i + ord(\'A\') 26 .. 51 a-z i + ord(\'a\') - 26 52 .. 61 0-9 i + ord(\'0\') - 52 62 plus i + ord(\'+\') - 62 63 slash i + ord(\'/\') - 63 Basically the expression scheme is: i plus a constant value (which I called \"shift\".) Branched code implementing the table: Naive version In a branchless version instead of if-statements masks are needed. Please note that building masks for ranges a-z and 0-9 requires two comparisons. However, in both exists a condition (respectively i >= 26 and i >= 52 ) which is simply a negation of already calculated mask. SSE provides an instruction pandn(a, b) which calculates bit-wise and with a negated argument a , thus no explicit negation is required. Armed with above observations, a following branchless code is possible. Number of instructions: comparison: 5, bit-and: 5, bit-andnot: 2, bit-or: 4, add: 1. In total 17 simple instruction. Thus for 16-element SSE vector we have exactly 1.0625 instructions per item. Many instructions in the function are independent (for example these calculating mask, calculating individual shifts), thanks to that a super-scalar CPU will have an opportunity to parallelize the code. Improved version An improved calculation method gradually adjusts the shift value as it check how large the index value is. Initially the algorithm assumes that the index is in range 0..25 (A-Z), thus shift is ord(\'A\') . Then it checks if index is larger than 25, and assumes that the is 26..51 (a-z). Then shift is adjusted by value ord(\'a\') - ord(\'A\') = 6 . And this continue for the rest index\'s ranges. Sometimes an adjustment value is less than zero, but it\'s not a problem because the modulo arithmetic is used. Following code implements the idea: Slightly different approach is SWAR friendly, as all constants are less than 128: Number of instructions in the both variants: comparison: 4, bit-and: 4, bit-andnot: 0, bit-or: 0, add/sub: 5. In total 13 simple instruction. Thus for 16-element SSE vector it is exactly 0.8125 instructions per item --- less than one instruction. Like the naive version, this one has a nice instruction-level parallelism property. Improved version using logic instructions This method uses the same pattern as the previous one, with one exception: binary xor is used to update the shift value. Of course the constants are different: The small drawback of the method is using a 8-bit constant, thus a SWAR algorithm can\'t be easily used. Properties of the method are not different from properties of the previous method. However, thanks to using binary operations this method is suitable for the AVX512 ternary logic instruction . SSE & AVX2 versions All branchless algorithms can be easily translated one-to-one into SSE or AVX2 code, as they use only basic bit and arithmetic instructions. pshufb-based lookup method This method is completely different from the methods described above, the algorithm relies on pshufb instruction. Basically it is a two-level lookup translating 6-bit values into shifts used to calculate the final ASCII codes. A 6-bit input value is split into two parts. A 4-bit subword is used as an index to the first pshufb , which produces a 2-bit value. This 2-bit value is combined with remaining 2 bits of the input value, forming the new 4-bit index. And this new index is issued to pshufb giving a shift value. And finally sum of the shift and the input value gives ASCII code. A scalar procedure: The crucial element of the algorithm is choice which bits of input form index1 and index2 . I used brute-force to find the answer, a Python script which does the job is available in a repository, see Sample code . The first index are bits 1..4, and bits 0 and 5 form the second index. Lookup table: index1 index2 0 1 2 3 0 65 65 71 71 1 65 65 71 71 2 65 65 71 71 3 65 65 71 71 4 65 65 71 71 5 65 65 71 71 6 65 65 71 71 7 65 65 71 71 8 65 65 71 71 9 65 65 71 71 10 65 65 -4 -4 11 65 65 -4 -4 12 65 65 -4 -4 13 71 71 -4 -4 14 71 71 -4 -4 15 71 71 -19 -16 There are four different rows in the table: index1 range index2 row number 0 1 2 3 0 .. 9 65 65 71 71 0 10 .. 12 65 65 -4 -4 1 13 .. 14 71 71 -4 -4 2 15 71 71 -19 -16 3 So, the first lookup translates from index1 to a row number (0..3), and then index2 selects item in the row. SSE procedure: Number of instructions: comparison: 0, bit-and: 1, bit-andnot: 0, bit-or: 2, bit-xor: 1, shift: 2, add/sub: 1, pshufb: 2. In total 11 instructions, it\'s 0.6875 instruction per item. Unfortunately, building both index1 and index2 require some effort, which slows down the procedure. In result speed up is minimal. Single pshufb method The method uses only one pshufb instruction. The main idea is to reduce input\'s range, and then use pshufb to select a proper shift. The first step of reduction is done with saturated subtract , which compresses values 0..52 (mapped to letters A-Z and a-z) into single value 0. Then one comparison is used to distinguish between input 0..25 (A-Z) and 26..51 (a-z). i reduced shift 0 .. 25 0 ord(\'A\') 52 .. 61 1 .. 10 i + ord(\'0\') - 52 62 11 i + ord(\'+\') - 62 63 12 i + ord(\'/\') - 63 26 .. 51 13 ord(\'a\') - 26 The last step is single invocation of pshufb , which translates from reduced value into shift . SSE procedure: Number of instructions: comparison: 1, bit-and: 1, bit-andnot: 0, bit-or: 1, add/sub: 2, pshufb: 1. In total 6 instructions, it\'s 0.375 instruction per item. XOP variant AMD XOP has got an extended pshufb , the instruction vpermb which accepts 5-bit indices. Aside of doing regular lookup it can perform seven different operations selected by three highest bits of the index (encoding doesn\'t need any of them.) We use the fact that the differences between adjacent ASCII codes used by base64 are 1; except difference between code of chars \'+\' and \'/\' which is 4. We get five higher bits of an 6-bit value and use it to translate directly into ASCII. A lookup table contains a half of letters from base64 lookup, picked from even indices: \"ACEGIKMOQSUWYacegikmoqsuwy02468+\". After translation, the least significant bit of input is added to the code, yielding correct code for \"odd\" items. The special care is needed for input values equal to 63, as the fix-up value is 4. Sample code The sample code is available at github , there are three programs: verify --- verifies branchless procedures calculating the lookup table, both scalar and SIMD versions; check --- checks if base64 encoders using different lookup procedures and splitting bytes methods work correctly; speed --- allows to measure speed of all or selected base64 encoder; it encodes 192 MiB of artificial data 10 times, and then print the smallest measurement. Important note : programs use three variants of SIMD-ized lookups: naive --- naive version from this text; improved --- improved version from this text; pshufb --- pshufb-based from this text; pshufb improved --- pshufb improved from this text; other improved --- branchless method not described here; it is slower than version the improved version on Core i5. This method is not included in the experiments\' results. Experiments The program speed was compiled with GCC and was run 5 times. The minimum times were noted. Core i5 results (Westmere) The CPU architecture: Westmere i5 M540 @ 2.53GHz GCC: 6.2.0 (Debian) procedure time [s] speedup scalar (64 bit) 0.19397 1.00 SWAR (64 bit) 0.32158 0.60 SSE (lookup: naive) 0.09459 2.05 SSE (lookup: other improved) 0.09102 2.13 SSE (lookup: improved) 0.08718 2.22 SSE (lookup: pshufb-based) 0.08756 2.22 SSE (lookup: pshufb improved) 0.08383 2.31 SSE (lookup: other improved, unrolled) 0.08532 2.27 SSE (lookup: improved, unrolled) 0.08469 2.29 SSE (lookup: pshufb-based, unrolled) 0.08329 2.33 SSE (lookup: pshufb improved unrolled) 0.08276 2.34 SSE (fully unrolled improved lookup) 0.08416 2.30 Core i7 results (Haswell) The CPU architecture: Haswell i7-4770 CPU @ 3.40GHz. GCC: 5.3.0 (Ubuntu) procedure time [s] speedup scalar (64 bit) 0.12198 1.00 SWAR (64 bit) 0.16465 0.74 SSE (lookup: naive) 0.05572 2.19 SSE (lookup: other improved) 0.04953 2.46 SSE (lookup: improved) 0.04658 2.62 SSE (lookup: pshufb-based) 0.03786 3.22 SSE (lookup: pshufb improved) 0.03534 3.45 SSE (lookup: other improved, unrolled) 0.04428 2.75 SSE (lookup: improved, unrolled) 0.04471 2.73 SSE (lookup: pshufb-based, unrolled) 0.03869 3.15 SSE (lookup: pshufb improved unrolled) 0.03492 3.49 SSE (fully unrolled improved lookup) 0.04503 2.71 SSE & BMI2 (lookup: naive) 0.05265 2.32 SSE & BMI2 (lookup: improved) 0.04924 2.48 SSE & BMI2 (lookup: pshufb improved) 0.03831 3.18 AVX2 (lookup: improved) 0.03499 3.49 AVX2 (lookup: improved, unrolled) 0.03488 3.50 AVX2 (lookup: pshufb-based) 0.03465 3.52 AVX2 (lookup: pshufb-based, unrolled) 0.03474 3.51 AVX2 (lookup: pshufb improved) 0.03469 3.52 AVX2 (lookup: pshufb unrolled improved) 0.03481 3.50 AVX2 & BMI (lookup: pshufb improved) 0.04811 2.54 Core i7 results (Skylake) The CPU architecture: Skylake i7-6700 CPU @ 3.40GHz GCC: 5.3.0 (Ubuntu) procedure time [s] speedup scalar (64 bit) 0.12016 1.00 SWAR (64 bit) 0.15264 0.79 SSE (lookup: naive) 0.05067 2.37 SSE (lookup: other improved) 0.04458 2.70 SSE (lookup: improved) 0.04214 2.85 SSE (lookup: pshufb-based) 0.03481 3.45 SSE (lookup: pshufb improved) 0.03043 3.95 SSE (lookup: other improved, unrolled) 0.04717 2.55 SSE (lookup: improved, unrolled) 0.04502 2.67 SSE (lookup: pshufb-based, unrolled) 0.03360 3.58 SSE (lookup: pshufb improved unrolled) 0.02947 4.08 SSE (fully unrolled improved lookup) 0.04621 2.60 SSE & BMI2 (lookup: naive) 0.05092 2.36 SSE & BMI2 (lookup: improved) 0.04854 2.48 SSE & BMI2 (lookup: pshufb improved) 0.03665 3.28 AVX2 (lookup: improved) 0.02913 4.12 AVX2 (lookup: improved, unrolled) 0.02870 4.19 AVX2 (lookup: pshufb-based) 0.02790 4.31 AVX2 (lookup: pshufb-based, unrolled) 0.02772 4.33 AVX2 (lookup: pshufb improved) 0.02744 4.38 AVX2 (lookup: pshufb unrolled improved) 0.02733 4.40 AVX2 & BMI (lookup: pshufb improved) 0.04339 2.77 AMD Bulldozer The CPU architecture: Bulldozer FX-8150 CPU GCC: 4.8.4 (Ubuntu) procedure time [s] speedup scalar (64 bit) 0.21362 1.00 SWAR (64 bit) 0.37459 0.57 SSE (lookup: naive) 0.07649 2.79 SSE (lookup: other improved) 0.06856 3.12 SSE (lookup: improved) 0.06641 3.22 SSE (lookup: pshufb-based) 0.06082 3.51 SSE (lookup: pshufb improved) 0.05934 3.60 SSE (lookup: other improved, unrolled) 0.06314 3.38 SSE (lookup: improved, unrolled) 0.06381 3.35 SSE (lookup: pshufb-based, unrolled) 0.06607 3.23 SSE (lookup: pshufb improved unrolled) 0.06371 3.35 SSE (fully unrolled improved lookup) 0.06410 3.33 XOP (vpermb) 0.06014 3.55 XOP (pshufb improved) 0.05929 3.60 See also Base64 decoding with SIMD instructions --- decoding could also be boosted Base64 encoding  implementation study --- different scalar method to split 3-byte groups to four 6-bit indices. Fast Base64 encoding/decoding with SSE vectorization by Alfred Klomp Discussion on Hackers News C library base64 by Alfred Klomp --- multiplatform, small and well tested lib; Alfred has employed techniques described here. Changelog 2016-12-31 --- add description of XOP pack and lookup procedures 2016-12-18 --- align order of input words with the base64 spec 2016-12-14 --- added results from AMD Bulldozer 2016-10-30 --- syntax highlighting, wording 2016-09-02 --- new pshufb-based lookup, other approaches of the improved lookup, updated results 2016-04-01 --- new vector lookup method, updated results 2016-03-17 --- improved splitting bytes in SIMD, text reorganization, update experiment results including unrolled procedures 2016-03-11 --- AVX2 implementation, results from Core i7 (Skylake) 2016-01-25 --- minor fixes'],
["notesen/2016-01-17-sse-base64-decoding.html", 'Base64 decoding with SIMD instructions', 'Base64 decoding with SIMD instructions Wojciech Mua Added on 2016-01-17 Last update 2017-11-29 (spelling) Contents Introduction Base algorithm Improved scalar version SSE version Vector lookup (base) Vector lookup (byte blend) Vector lookup (incremental) Vector lookup (pshufb) Vector lookup (pshufb with bitmask) Comparison of vector lookups Gathering data Pack --- naive variant Pack --- multiply-add variant Saving result (SSE variant) BMI2 AVX2 version Sample code Experiments Core i5 results (Westmere) Core i7 results (Haswell) Core i7 results (Skylake) AMD Bulldozer results Acknowledgments See also Changelog Introduction Surprisingly good results of base64 encoding with SIMD instructions forced me to check the opposite algorithm, i.e. the decoding. The decoding is slightly more complicated as it has to check the input\'s validity. A decoder must also consider character \'=\' at the end of input, but since it\'s done once, I didn\'t bother with this in a sample code. 2016-12-18 note: in the initial version of this text I wrongly assumed order of input words, Alfred Klomp noted that the standard imposes a specific order. Today\'s change fixes this error. Base algorithm In a basic scalar version the minimum input quantity is 4 character, which are transformed into 3 bytes. The scalar version uses a lookup table translating from ASCII code into a 6-bit data. For non-base64 characters the lookup table contains a special marker. After decoding four characters and checking for errors, the 6-bit words are merged to form a 24-bit word. The inner loop of the algorithm looks like this. Forming the output is expansive, it requires: 5 bit-shift, 3 bit-ors. Improved scalar version It is possible to get rid off the bit-shift and use four lookup tables for each input byte. Each table contains already-shifted 6-bit data fields, thanks to that only bit-ors are required. It is at cost of bigger memory requirements. The improved version requires 4kB (4*4*256), while the basic one requires only 256 bytes. Following code shows the idea. Another negative feature is that the method saves 4 bytes instead of 3. SSE version Vector lookup (base) In an SSE version the lookup table must be encoded as a sequence of instructions. Such program will perform parallel translation of all input bytes. Following table describes how to map an input character into a 6-bit data ( i is the character code), according to the base64 standard. range expression after constant folding A-Z i - ord(\'A\') i - 65 a-z i - ord(\'a\') + 26 i - 71 0-9 i - ord(\'0\') + 52 i + 4 \'+\' i - ord(\'+\') + 62 i + 19 \'/\' i - ord(\'/\') + 63 i + 16 other error The basic step of the vector version produces a vector of constants (from the third column) for characters matching given range. After checking all five ranges, the vectors are merged. Since none of constants is zero, then if the merged vector has any zero byte, it means that the input contains an invalid character. If everything is OK, then the last step is to simple add the input vector and the merged one. The result vector contains 6-bit data in each byte. Procedure doing the translation. Number of operations: comparison (le/gt/eq): 9, bit-and: 8, bit-or: 4, add: 1, movemask: 1. Number of constants: 9. Total number of operations is 23. This is 1.4375 instructions per character. Note: the SSE compare for less or greater works on signed values, in this case it is not a problem. Vector lookup (byte blend) Instead of creating partial shifts (constants range_AZ , range_az and so on) and then merging them with a series of bit-ors, the shift vector could be updated using the byte blend instruction pblendv ( _mm_blendv_epi8 ). Below is an updated procedure. Number of operations: comparison (le/gt/eq): 9, bit-and: 4, bit-or: 0, byte-blend: 3, add: 1, movemask: 1. Number of constants: 9. The total number of operations is 19, three less than the in base version. This is 1.1875 instructions per character. However, the instruction pblendv has both latency and throughput equal 2 cycles and it seems to be a problem. As experiments showed, sometimes use of the instruction gives small improvement, but sometimes makes things slower. Vector lookup (incremental) This section describes another lookup procedure that employs the technique described in a separate article . The lookup procedure uses pshufb instruction. I very like this instruction, but experiments showed that this version is slower. My heart sank. Vector lookup (pshufb) Instead of checking all possible ranges as in all other methods, this algorithm determines possible range for a byte and the associated shift value. Then validates a byte against that single range and adds the selected shift. To select both the range and the shift, the higher nibble of byte is used. Lets look at the rewritten lookup table: input [hex] valid input [ASCII] valid range shift 0x invalid 1x 2x \'+\' 0x2b .. 0x2b 0x3e \'/\' 0x2f .. 0x2f 0x3f 3x \'0\' .. \'9\' 0x30 .. 0x39 0x34 4x \'A\' .. \'O\' 0x41 .. 0x4f 0x00 5x \'P\' .. \'Z\' 0x50 .. 0x5a 0x0f 6x \'a\' .. \'o\' 0x61 .. 0x6f 0x1a 7x \'p\' .. \'z\' 0x70 .. 0x7a 0x29 8x .. Fx invalid The outline of algorithm (for a single byte): For nibbles in set {0, 1, 8, 9, a, b, c, d, e, f} the LUTs define invalid ranges, always yielding errors. For nibbles {3, 4, 5, 6, 7} the ranges are well defined. The only exception occurs for nibble 2, as there are two distinct values associated with these bytes. The special case is solved by choosing the first, one-element range 0x2b and introducing an additional code handling input equal to 0x2f. The extra code doesn\'t complicate the algorithm too much: The SIMD (SSE) code implementing above algorithm: Number of operations: comparison (le/gt/eq): 3, shift: 1, bit-and: 2, bit-andnot: 1, bit-or: 1, add: 2, movemask: 1 pshufb: 3. Number of constants: 6. Total number of operations is 14. This is 0.875 instructions per character. Vector lookup (pshufb with bitmask) This is a slightly improved version of the previous method, where the range checking is done using bit-masks. First we group all shift values by the lower nibble; zero shift means invalid input. We can note that in each column (except the 3rd) there are two different values: zero or a specific value. The 3rd column needs a special care, but it is not difficult. lower nibble higher nibble (\'.\' denotes zero) 0 1 2 3 4 5 6 7 8 9 a b c d e f 0 . . . 4 . -65 . -71 . . . . . . . . 1 . . . 4 -65 -65 -71 -71 . . . . . . . . 2 . . . 4 -65 -65 -71 -71 . . . . . . . . 3 . . . 4 -65 -65 -71 -71 . . . . . . . . 4 . . . 4 -65 -65 -71 -71 . . . . . . . . 5 . . . 4 -65 -65 -71 -71 . . . . . . . . 6 . . . 4 -65 -65 -71 -71 . . . . . . . . 7 . . . 4 -65 -65 -71 -71 . . . . . . . . 8 . . . 4 -65 -65 -71 -71 . . . . . . . . 9 . . . 4 -65 -65 -71 -71 . . . . . . . . a . . . . -65 -65 -71 -71 . . . . . . . . b . . 19 . -65 . -71 . . . . . . . . . c . . . . -65 . -71 . . . . . . . . . d . . . . -65 . -71 . . . . . . . . . e . . . . -65 . -71 . . . . . . . . . f . . 16 . -65 . -71 . . . . . . . . . Using the higher nibble we can pick a shift from vector of non-zero values from each column: [0, 0, 19, 4, -65, -65, -71, -71, 0, 0, 0, 0, 0, 0, 0, 0]. The lower nibble selects a bit-mask, representing a set of valid values for higher nibble. A bit-mask is derived directly from rows of the table, each non-zero value sets a bit in the mask. There are six different bit-masks. We need an extra fix-up code to distinguish between the \'+\' and \'/\' character, i.e. choose either 16 or 19 from the 3rd column. The core of the algorithm goes as follows: Using the lower nibble we select a bit-mask ( pshufb ). Then we build a vector (1 << higher nibble[i]) & 0xff ( pshufb or AMD XOP vshlb ). Bitwise and is used to check if all higher nibbles match corresponding bit-masks. If any doesn\'t match, we report an error. Finally, using the higher nibble we select shifts and add them to the input. The SIMD (SSE) code implementing above algorithm. Number of operations: comparison (le/gt/eq): 2, shift: 1, bit-and: 3, bit-or: 0, bit-blend: 1, add: 1, movemask: 1 pshufb: 3. Number of constants: 6. The total number of operations is 12. This is 0.750 instructions per character. Comparison of vector lookups operation algorithm base byte-blend incremental pshufb pshufb-bitmask comparison (le/gt/eq) 9 9 9 3 2 bit-and 8 4 0 2 3 bit-andnot 0 0 0 1 0 bit-or 4 0 0 1 0 shift 0 0 0 1 1 add 1 1 10 2 1 sub 0 0 0 0 0 byte-blend 0 3 0 0 1 movemask 1 1 1 1 1 pshufb 0 0 1 3 3 total instructions 23 19 21 14 12 instructions/byte 1.4375 1.1875 1.3125 0.875 0.75 constants count 9 9 10 6 6 Gathering data The result of lookup procedure is a vector fo 32-bit words having following bit-layout: Bits a , b , c and d are data. The expected output is: Once bits are packed into 24-bit words, all bytes are shuffled in order to build a 12-byte result. Please note that also the order of bytes within 24-bit words is changed in this step, i.e. bytes 0 and 2 are swapped: Fortunately everything is done by a single pshufb invocation. Pack --- naive variant The naive variant isolates all 6-bit fields, shifts them to required positions and merges into one word. Isolate fields c , a and d , b : Swap order of c , d and a , b within 16-bit words. Swap order of 12-bit fields ba and cd within a 32-bit word. Mask out garbage Number of operations: 3 bit-and, 4 bit-shift, 2 bit-or. Pack --- multiply-add variant The first merge of adjacent bytes is performed by instruction pmaddubsw . The instruction vertically multiplies signed bytes yielding 16-bit signed intermediate values and then the values are added. Input values are 6-bit, so obviously are non-negative and the instruction could be safely used. The instruction pmaddusbw is used to perform shift & bit-or in a single step. Then merging 12-bit fields is done by another multiply-add instruction pmaddwd . The instruction also operates on signed values, but again --- the inputs are never negative. Number of operations: 2 multiply-add. Saving result (SSE variant) The result is stoed in an XMM register, however only 12 lowest bytes are required. My experiments on Core i5 have showed that saving selected bytes using dedicated instruction maskmovdqu (intrinsic _mm_maskmoveu_si128 ) is slower than ordinary write of 16 bytes which overwrites the previous 4 bytes. BMI2 With help of BMI2 instruction pext making a 24-bit word from 6-bit words is pretty simple. However, bytes 0th and 2nd of each word have to be swapped, that costs extra instructions. Additionally, the instruction works on CPU registers and this require extra instruction to transfer data from the SIMD registers. Here is a procedure which processes 64-bit word It costs: 1 pext , 2 shift, 3 bit-and, 2 bit-or. AVX2 version An AVX2 version of lookup procedure is nearly the same as the SSE version. The only minor difference is caused by lack of comparison \"less or equal\", thus all range checking have to use the \"grater\" relation. An output from the AVX2 lookup could be either processed using standard SIMD operations or BMI2 instructions. Sample code The sample code is available at github , there are three programs: verify --- verifies all decoding procedures, both scalar, SSE and AVX2; check --- checks if base64 decoders work correctly. speed --- allows to measure speed of all or selected base64 decoder; it decodes 64 MiB of artificial data 10 times, and then print the smallest measurement. Experiments Core i5 results (Westmere) The CPU architecture: Westmere i5 M540 @ 2.53GHz GCC: 6.2.0 (Debian) procedure lookup pack time [s] speedup improved scalar N/A N/A 0.04722 1.00 scalar N/A N/A 0.06875 0.69 SSE base naive 0.02892 1.63 SSE byte blend naive 0.02970 1.59 SSE incremental naive 0.03249 1.45 SSE pshufb naive 0.02753 1.72 SSE base multiply-add 0.02554 1.85 SSE byte blend multiply-add 0.02511 1.88 SSE incremental multiply-add 0.02862 1.65 SSE pshufb multiply-add 0.02170 2.18 SSE pshufb bitmask multiply-add 0.02085 2.26 Conclusions: Eliminating 5 shifts from the scalar version boosted code by 1.45. This is impressive. Using the byte-blend instruction gives significant boost. Packing algorithm using two multiply-add instruction is, surprisingly, the best. Multiply-add instructions have pretty high latencies, 4-5 cycles. Core i7 results (Haswell) The CPU architecture: Haswell i7-4770 CPU @ 3.40GHz. GCC: 5.4.1 (Ubuntu) procedure lookup pack time [s] speedup improved scalar N/A N/A 0.02281 1.00 scalar N/A N/A 0.04965 0.46 scalar & BMI2 N/A N/A 0.04485 0.51 SSE base naive 0.01683 1.36 SSE byte blend naive 0.01783 1.28 SSE incremental naive 0.01790 1.27 SSE pshufb naive 0.01286 1.77 SSE base multiply-add 0.01383 1.65 SSE byte blend multiply-add 0.01365 1.67 SSE incremental multiply-add 0.01500 1.52 SSE pshufb multiply-add 0.00967 2.36 SSE pshufb bitmask multiply-add 0.00927 2.46 SSE & BMI2 base N/A 0.02184 1.04 SSE & BMI2 byte blend N/A 0.02288 1.00 SSE & BMI2 incremental N/A 0.02190 1.04 AVX2 base naive 0.01108 2.06 AVX2 byte blend naive 0.01229 1.86 AVX2 pshufb naive 0.00897 2.54 AVX2 base multiply-add 0.00973 2.34 AVX2 byte blend multiply-add 0.00977 2.33 AVX2 pshufb multiply-add 0.00849 2.69 AVX2 pshufb bitmask multiply-add 0.00848 2.69 AVX2 & BMI2 base N/A 0.02236 1.02 AVX2 & BMI2 byte blend N/A 0.02371 0.96 Conclusions: BMI2 doesn\'t help at all. Core i7 results (Skylake) The CPU architecture: Skylake i7-6700 CPU @ 3.40GHz GCC: 5.4.1 (Ubuntu) procedure lookup pack time [s] speedup improved scalar N/A N/A 0.02084 1.00 scalar N/A N/A 0.04980 0.42 scalar & BMI2 N/A N/A 0.04494 0.46 SSE base naive 0.01502 1.39 SSE byte blend naive 0.01645 1.27 SSE incremental naive 0.01684 1.24 SSE pshufb naive 0.01229 1.70 SSE base multiply-add 0.01216 1.71 SSE byte blend multiply-add 0.01405 1.48 SSE incremental multiply-add 0.01198 1.74 SSE pshufb multiply-add 0.00888 2.35 SSE pshufb bitmask multiply-add 0.00847 2.46 SSE & BMI2 base N/A 0.02090 1.00 SSE & BMI2 byte blend N/A 0.02097 0.99 SSE & BMI2 incremental N/A 0.02098 0.99 AVX2 base naive 0.01006 2.07 AVX2 byte blend naive 0.00998 2.09 AVX2 pshufb naive 0.00816 2.55 AVX2 base multiply-add 0.00852 2.45 AVX2 byte blend multiply-add 0.00842 2.48 AVX2 pshufb multiply-add 0.00720 2.89 AVX2 pshufb bitmask multiply-add 0.00705 2.96 AVX2 & BMI2 base N/A 0.01994 1.05 AVX2 & BMI2 byte blend N/A 0.01982 1.05 AMD Bulldozer results The CPU architecture: Bulldozer FX-8150 CPU GCC: 4.8.4 (Ubuntu) procedure lookup pack time [s] speedup improved scalar N/A N/A 0.03223 1.00 scalar N/A N/A 0.06352 0.51 SSE base naive 0.02387 1.35 SSE byte blend naive 0.02316 1.39 SSE incremental naive 0.02626 1.23 SSE pshufb naive 0.02015 1.60 SSE base multiply-add 0.02107 1.53 SSE byte blend multiply-add 0.01971 1.64 SSE incremental multiply-add 0.02215 1.46 SSE pshufb multiply-add 0.01660 1.94 SSE pshufb bitmask multiply-add 0.01656 1.95 Acknowledgments The AVX2 version wouldn\'t be possible without Nathan Kurz\'s help and Daniel Lemire who kindly gave me access to test machines having brand new CPUs (Haswell and Skylake, and also AMD Bulldozer). See also Base64 encoding with SIMD instructions --- SSE boosts base64 encoding 2 times. Base64 encoding  implementation study --- different scalar method to split 3-byte groups into four 6-bit indices. Discussion on Hackers News C library base64 by Alfred Klomp --- multiplatform, small and well tested lib; Alfred has employed techniques described here. Changelog 2016-12-23 --- improved pshufb-based lookup procedure 2016-12-18 --- align order of output words with the base64 spec) 2016-12-04 --- refreshed measurements, added results from AMD Bulldozer 2016-12-01 --- removed a superfluous instruction 2016-11-07 --- syntax highlighting 2016-03-30 --- new lookup algorithm , updated results 2016-03-19 --- new packing methods, updated results 2016-03-13 --- two new lookup algorithms, updated results 2016-03-10 --- AVX2 notes, Skylake results 2016-01-25 --- minor fixes thanks to HN comments 2016-01-18 --- Core i7 results'],
["notesen/2016-03-13-simd-lookup-pshufb.html", 'Implementing byte-wise lookup table with PSHUFB', 'Implementing byte-wise lookup table with PSHUFB Wojciech Mua Added on 2016-03-13 Contents Introduction Algorithm Real world example Introduction In articles about base64 encoding and decoding I\'ve showed how to implement SIMD version of a lookup table using basic vector instruction. This text describes another technique which employs my favourite instruction pshufb . The task is defined as follows: input range (0..255) is split into several subranges; for each subrange a predefined value is assigned. Now, for an input value a proper subrange is determined, and the value associated to the subrange is returned. Of course, everything is done in parallel. Algorithm All subranges span the whole input range (0..255). Subranges are order and each subrange gets its index from 0 to n . Limitation : since the method uses pshufb , the maximum number of subranges is 16. Algorithm finds an subrange\'s index for given value by comparing the value with the upper limit of each subrange and accumulating the comparison value. When the index is know, then it is transformed by pshufb into a value associated with a subrange. Pseudocode: Number of operations: comparison: n , subtracts: n , zeroing: 1, pshufb : 1. Please be aware that both constant vectors used in comparison and a LUT vector could be stored by a compiler in memory and fetched during execution. Real world example Lookup in base64 decoder. index input comment shift 0 00 .. 42 invalid 1 43 \'+\' 19 2 44 .. 46 invalid 3 47 \'/\' 16 4 48 .. 57 \'0\' - \'9\' 4 5 58 .. 64 invalid 6 65 .. 90 \'A\' - \'Z\' -65 7 91 .. 96 invalid 8 97 .. 122 \'a\' - \'z\' -71 9 122 .. ... invalid C++ code:'],
["notesen/2016-04-03-avx512-base64.html", 'Base64 encoding & decoding using AVX512BW instructions', 'Base64 encoding & decoding using AVX512BW instructions Wojciech Mua Added on 2016-04-03 Updated on 2018-12-08 (performance results from Cannon Lake [AVX512VL & AVX512VBMI]), 2018-11-05 (performance results from SkylakeX [AVX512BW]) Contents Introduction Encoding Steps 1 & 2 --- Loading data and splitting bytes AVX512BW AVX512VBMI Step 3 --- moving 6-bit word to separate bytes AVX512F AVX512BW AVX512VL Step 4 --- conversion to ASCII AVX512BW AVX512VBMI Decoding Step 1 --- translation from ASCII AVX512BW AVX512VBMI Step 2 --- Packing bit-fields Step A Step B --- AVX512BW Step B --- AVX512VBMI Performance evaluation SkylakeX Encoding Decoding Cannon Lake Encoding Decoding Assembly dumps Encoding AVX512BW AVX512VBMI AVX512VL Decoding AVX512BW AVX512VBMI Summary Sample code Changes Introduction The SIMD versions of base64 conversion algorithms were described in Base64 encoding with SIMD instructions and Base64 decoding with SIMD instructions . I also described realization of both encoding and decoding using AVX512F (Foundation) instructions. AVX512BW (Byte & Word) comes with a great number of new instructions; following instructions can help base64-related problems: vpshufb (intrinsic _mm512_shuffle_epi8 ) --- does a lookup in 128-bit lanes. For base64 algorithm it\'s sufficient; vpermd ( _mm512_permutexvar_epi32 ) --- moves 32-bit words across the 128-bit lanes; vpsllvw ( _mm512_sllv_epi16 ) and vpsrlvw ( _mm512_srlv_epi16 ) --- shifts individual 16-bit words by a variable amount, saved in a ZMM register. The extension AVX512VBMI adds even more powerful instructions: vpermb ( _mm512_permutexvar_epi8 ) --- does a lookup in a 64-byte table (a ZMM register). Unlike pshufb it doesn\'t destroy the lookup register; vpermi2b ( _mm512_permutex2var_epi8 ) --- does a lookup in a 128-byte table formed by two ZMM registers. The extension AVX512VL adds just one, but really nice instruction: vpmultishiftqb ( _mm512_multishift_epi64_epi8 ) --- moves 8-bit subwords onto selected bytes. 2018-04-18 : In the earlier versions of this text I wrongly assumed that instructions vpermb and vpermi2b are part of AVX512BW. Sorry for that. Encoding The SIMD encoding consist following steps: In each step 48 bytes are loaded (16 * 24 bit). Split each 24-bit words into separate 32-bit lanes. In each 32-bit lane move 6-bit words to separate bytes. Convert 6-bit indices to ASCII, according to base64 lookup. Steps 1 & 2 --- Loading data and splitting bytes In a SSE code loading data and splitting 24-bit words into 32-bit lanes is done by pshufb instruction. In AVX2 the instruction operates on 128-bit lanes, making this step more complicated. AVX512BW In case of AVX512BW two shuffles are needed. Initial layout of the register after loading the data. We need only triplets A .. P : Move 32-bit words across lanes using vpermd : Reshuffle bytes within 128-bit lanes to format required by the AVX512BW/AVX512VL unpack procedure, which is shown in the next section. The input layout of single lane (0th): The layout of lane after shuffling; the order of bytes within 32-bit word is 1, 2, 0, 1: First one moves data across the 128-bit lanes. Then in each lane bytes are shuffled into desired positions. AVX512VBMI In case of AVX512VBMI the problem is solved with one invocation of vpermb . Step 3 --- moving 6-bit word to separate bytes Each 32-bit input word contains four 6-bit fields a , b , c and d ; the expected output from this step: AVX512F Input order of fields is following: Below is an AVX512F version from the article linked above . Lack of byte-level instructions makes the procedure pretty complicated. AVX512BW The unpacking could be performed faster with help of vpsllvw and vpsrlvw instructions. This require a change in the 32-bit lane format from: to: It does require only different vector passed to vpshufb (AVX512BW) or vpermb (AVX512VBMI) used for splitting bytes. Algorithm: Isolate fields a and c . Shift right the field a by 10 bits, and the field c by 6 bits. Shift left the field b by 4 bits, and the field d by 8 bits (note that no masking is done.) Finally copy the selected bits from t2 to t1 . The procedure costs just two shifts and two bitwise operations. AVX512VL AVX512VL defines the instruction vpmultishiftqb , that may replace all variable shift instructions from the previous point. Please note that the layout of 32-bit lanes require the same modification as described in the previous point. The instruction builds a vector of bytes from octets located at any position in a quadword. Following psudocode shows the algorithm: Although vpmultishiftqb produces a vector of bytes and the encoding needs just 6 lower bits, no masking is needed. The instruction vpermb (described above) does masking internally. Below is a code snippet the shows the proper parameters for vpmultishiftqb . Step 4 --- conversion to ASCII The last part of the algorithm is converting, in parallel, all 6-bit indices into ASCII codes. AVX512BW Although vpshufb works on 128-bit lanes it is sufficient for conversion. The fastest procedure from SSE might be translated one-to-one: AVX512VBMI The already introduced instruction vpermb does lookup in an AVX512 64-byte register. This is exactly the size of lookup table needed by the encoding algorithm. Thus, just a single invocation of the instruction is needed. Decoding The SIMD decoding consists following steps: Translate in parallel from ASCII into 6-bit values saved on separate bytes. At this stage the error detection is performed. Pack 6-bit data into continuous bit stream --- the result has 48 bytes. Step 1 --- translation from ASCII AVX512BW In case of decoding the limitations of vpshufb also are not the problem, the fastest SSE decoding solution can be applied. Below is the actual implementation. AVX512VBMI This step is a perfect place to utilize the instruction vpermi2b , it requires three registers: indices, the lower & higher halves of a 128-item lookup table. Valid input characters in base64 are always standard ASCII, so they never have set the most significant bit (MSB). Thanks to that the seven lowest bits of the input could be directly used as indices for vpermi2b . (The instruction simply ignores MSB, so no masking is required.) The lookup table has to be precalculated. It translates from an ASCII code into 6-bit data or an invalid character marker. The marker value is 0x80. Thanks to that both extended ASCII and invalid characters could be easily identified in one step. Step 2 --- Packing bit-fields The final stage of decoding is packing all 6-bit fields into a continues array of 48 bytes. It is done in two steps: Pack four fields within 32-bit words into 24-bit words. Move these 3-byte words into the continuous array. Step A The first step is a direct translation of the SSE code. It uses twice a multiply-add instruction that does, for given constants, two shifts and one bitwise or at once. Step B --- AVX512BW Initial layout of the register after step A: Pack bytes within lanes using vpshufb ; 3rd doublewords in each lane are empty: Move non-empty 32-bit words across lanes using vpermd and form continuous 48-byte array: Below is a sample implementation. Step B --- AVX512VBMI In case of AVX512VBMI this step uses just single vpermb . Performance evaluation Daniel Lemire gave me access to machines that supports the AVX512BW, AVX512VL and AVX512VBMI instruction sets. Below are performance results for both encoding and decoding. SkylakeX CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz Compiler: gcc (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0 Encoding Tested procedures scalar (32 bit) lookup-based method that loads four input bytes at once scalar (64 bit) similarly to the above one, but read 8 input bytes AVX2 (lookup: pshufb improved) code that uses shuffle-based algorithm AVX512BW (lookup: pshufb improved) exactly the same shuffle-based algorithm procedure best avg. speedup [cycles] [cycles] scalar (32 bit) 5.768 6.452 1.00 scalar (64 bit) 5.537 5.599 1.04 AVX2 (lookup: pshufb unrolled improved) 0.681 0.698 8.47 AVX512BW (lookup: optimized2) 0.726 0.734 7.94 AVX512BW (lookup: pshufb improved) 0.425 0.436 13.57 AVX512BW (lookup: pshufb improved, unrolled x 2) 0.425 0.441 13.57 Decoding Tested procedures scalar naive lookup-based implementation improved scalar also lookup-based code, but detection of input errors is done for four input bytes at once AVX2 (lookup: pshufb bitmask, pack: multiply-add) uses the same algorithm as AVX512BW implementation AVX512BW (lookup: N/A, pack: multiply-add) implementation of the described above lookup and pack algorithms procedure best avg. speedup [cycles] [cycles] scalar 1.023 1.091 1.00 improved scalar 1.024 1.085 1.00 AVX2 (lookup: pshufb bitmask, pack: multiply-add) 0.222 0.225 4.61 AVX512BW (lookup: N/A, pack: multiply-add) 0.141 0.144 7.26 Cannon Lake CPU: Intel(R) Core(TM) i3-8121U CPU @ 2.20GHz GCC: gcc (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5) Encoding Tested procedures scalar (32 bit) lookup-based method that loads four input bytes at once scalar (64 bit) similarly to the above one, but read 8 input bytes AVX2 (lookup: pshufb improved) code that uses shuffle-based algorithm AVX512BW (lookup: pshufb improved) exactly the same shuffle-based algorithm AVX512BW (lookup: pshufb improved, unrolled x 2) the above procedure unrolled two times AVX512VBMI step 1 & 2: _mm512_permutexvar_epi8 , step 3: AVX512BW code , step 4: again _mm512_permutexvar_epi8 AVX512VL step 1 & 2: _mm512_permutexvar_epi8 , step 3: _mm512_multishift_epi64_epi8 , step 4: again _mm512_permutexvar_epi8 procedure best avg. speedup [cycles] [cycles] scalar (32 bit) 6.082 6.117 1.00 scalar (64 bit) 6.096 6.134 1.00 AVX2 (lookup: pshufb unrolled improved) 0.752 0.772 8.09 AVX512BW (lookup: pshufb improved) 0.391 0.405 15.55 AVX512BW (lookup: pshufb improved, unrolled x 2) 0.387 0.399 15.72 AVX512VBMI 0.227 0.233 26.79 AVX512VL 0.195 0.202 31.19 Decoding Tested procedures scalar naive lookup-based implementation improved scalar also lookup-based code, but detection of input errors is done for four input bytes at once AVX2 (lookup: pshufb bitmask, pack: multiply-add) uses the same algorithm as AVX512BW implementation AVX512BW (lookup: N/A, pack: multiply-add) implementation of the described above lookup and pack algorithms AVX512VBMI (lookup: N/A, pack: multiply-add) lookup is done by _mm512_permutexvar_epi8 and pack by _mm512_permutex2var_epi8 procedure best avg. speedup [cycles] [cycles] scalar 1.030 1.044 1.00 improved scalar 1.031 1.043 1.00 AVX2 (lookup: pshufb bitmask, pack: multiply-add) 0.232 0.234 4.44 AVX512BW (lookup: N/A, pack: multiply-add) 0.128 0.131 8.05 AVX512VBMI (lookup: N/A, pack: multiply-add) 0.087 0.089 11.84 Assembly dumps Just an inner loops was shown; in case of decoding exception handling was omitted. Code generated by GCC 7.3.0. Encoding AVX512BW AVX512VBMI AVX512VL Decoding AVX512BW AVX512VBMI Summary AVX512BW makes both base64 decoding and encoding much easier. The performance tests shows this code is approx. 1.5-1.6 times faster than AVX2 implementations. It was: AVX512VBMI requires big lookups tables, which can\'t be simply inlined. This require an additional setup code. Update : this is not true, since the lookup tables are known at compile time, they are just stored as regular data and loaded on demand. With AVX512VL the main loop of encoding can be coded using only five instructions: load, permutexvar (lane layout), mutlishift, permutexvar (lookup) and store. Sample code Repository contains implementations of both encoding and decoding procedures. Changes 2018-11-05 --- performance results for AVX512BW implementation 2018-04-18 --- show both AVX512BW and AVX512VBMI solutions 2017-11-29 --- spelling 2017-05-01 --- add info about VPMULTISHIFTQB from AVX512VL 2016-12-21 --- fix pack and unpack procedures 2016-11-21 --- change the title, simplified \"faster procedure\", added link to the AV512F article'],
["notesen/2016-09-14-building-bitmask.html", 'Building a bitmask', 'Building a bitmask Wojciech Mua Added on 2016-09-14 Contents The problem Naive procedure Better procedure (#1) Better procedure (#2) SIMD procedure Algorithm Sample code Performance Sample code The problem There is an array of 32-bit integers and a key --- a specific value. The result have to be a bit vector with bits set on these position where the key is equal to array items. Pseudocode: A C++ interface: Naive procedure The main problem with this code is that it involves at least one bit-shift (likely two) and one bit-or. The first bit-shift is used to find index in bitvector , the second bit-shift moves the result to i % 8 bit. Assembler code produced by GCC 5.3 (with the -O3 flag): Better procedure (#1) This code is suitable for 64-bit machines. The only advantage over the naive version is updating a bitvector in 32-bit portions. Better procedure (#2) This solution maps very well on x86 assembly. And unlike the previous solution, any relation can be used in place of equal/not-equal. The line number 1 should be translated into two instructions: comparison and then setcc . The line number 2 should be translated into single lea. Assembler code produced by GCC 5.3 (with the -O3 flag): The big advantage of this method is that instead of equal/not equal relation all other arithmetic relations could be used. It\'s just a matter of setcc selection. SIMD procedure SSE procedure processes data in 16-element blocks (4 x 4 items). Using a single SSE register is possible but not optimal. Like the previous procedure, this one also allows to use any arithmetic relation. Algorithm A vector comparison yields: Now d0 & d1 and d2 & d3 are converted from 32-bit mask to 16-bit using packssdw (note the signed saturation ): And then from 16-bit to 8-bit masks using packsswb : Finally the byte mask is converted into bit-mask with pmovmskb Sample code Performance Above procedures were tested in a real system. The SIMD and the second scalar version are the fastest on Skylake. Sample code Github repository contains algorithms and a test program.'],
["notesen/2016-09-14-simd-bit-mask.html", 'SIMD bit mask', 'SIMD bit mask Wojciech Mua Added on 2016-09-14 Problem There is a SIMD register (128-, 256-, 512-bit width), we want to set all bits above the given position k ; k is in range from 0 to the register\'s width. Of course a lookup table could be used, but it\'s not a interesting (maybe a little.) SIMD program Treat the register as a set of chunks , where a chunk could be a word, a double word etc. Let chunk_size is the number of bits in a chunk, then n = k / chunk_size . All chunks above n have to be filled, all below cleared. The only exception is n-th chunk which must be filled partially. Algorithm: Prepare constants (examples for k = 71 ). Fill chunks above n . Fill the n-th chunk. Merge results. Sample program Github repository contains an example program with tests.'],
["notesen/2016-09-17-avx512-foundation-base64.html", 'AVX512F base64 coding and decoding', 'AVX512F base64 coding and decoding Wojciech Mua Added on 2016-09-17 Updated on 2018-11-24 (fixed pseudocode mistake, spotted by Gnther Foidl) Introduction Both base64 coding and decoding algorithms can be vectorized, i.e. SIMD instructions can be utilized, gaining significant speed-up over plain, scalar versions. I\'ve shown different vectorization approaches in a series of articles: Base64 encoding with SIMD instructions , Base64 decoding with SIMD instructions and Base64 encoding & decoding using AVX512BW instructions . AVX-512 is the recent extension to the Intel\'s ISA, unfortunately the extension is split into several subextensions. In the last article from the list I described usage of subextension AVX512BW ( Byte-Word ), at the moment of writing both articles AVX512BW was not available. However, in 2016 on the market has appeared processors having subextension AVX512F ( Foundation ). Among many advantages of AVX512F there is one serious problem: lack of instructions working at byte and word level. The minimum vector element\'s size is 32 bits. This article is a study of base64 algorithms realisation with foundation instructions AVX512F, major contributions are: The new, binary search vectorized lookup for base64 encoding. Evidence that SWAR techniques, even seem not optimistic at the first glance, are beneficial. Use of a ternary logic instruction makes code simpler and faster. Evaluation of gather instruction in the context of lookup-based methods. Measurements from a real machine . The text is split into four parts: description of SWAR techniques required for algorithms; details of base64 encoding; details of base64 decoding; experiment results and final remarks. As I don\'t want to repeat myself too much, please refer to the linked articles for other algorithms for SSE and AVX2 and their analysis. 2016-12-18 note: in the initial version of this text I wrongly assumed order of input words, Alfred Klomp noted that the standard imposes a specific order. Today\'s change fixes this error. Table of contents Introduction Before we start: SWAR within an AVX512 register Unsigned compare with constant Building a mask Adding modulo 256 C++ notes Base64 encoding Loading data Gather-based Vectorized approach Unpacking 6-bit words into bytes Vectorized lookup --- incremental Introduction SWAR notes Pseudocode C++ implementation Improved C++ implementation Vectorized lookup --- binary search Introduction C++ implementation Storing data Base64 decoding Loading data Vectorized lookup Introduction SWAR notes Pseudocode C++ implementation Packing data Storing data Scatter-based Vectorized approach Base64 coding and decoding using gather Experiment results Encoding Decoding Conclusions Further work Acknowledgments Source code Changes Before we start: SWAR within an AVX512 register Lack of byte-level instructions forces to use SWAR techniques on 32-bit vector\'s elements. Following operations are needed in both encoding and decoding: unsigned compare for greater or equal, where one argument is a vector of bytes, and the another one is a vector of constants; build a mask based on comparison\'s result; add two vectors with wrap-around arithmetic (modulo 256). In case of SSE, AVX2 and AVX512BW the points 1st & 2nd are performed by single instruction like pcmpgtb (SSE intrinsic _mm_cmpgt_epi8 ). Likewise, the equivalent of the 3rd operation is single instruction paddb (SSE intrinsic _mm_add_epi8 ). Important note : input vectors for the core part of base64 algorithms contain bytes less than 128, i.e. the most significant bit isn\'t set. Unsigned compare with constant The SWAR trick of unsigned comparison for greater or equal is based on following equation: The assumption is that both x and constant are less than 0x80. If x >= constant then the result of the expression is greater or equal to 0x80, less than 0x80 otherwise. It means that the most significant bit indicates the result of comparison. Let see a sample AVX512F code which compares input vector with constant = 26 . Such code requires following instructions: build a constant vector (move constant to a GP register, vpbroadcastd the value to an AVX512 register); add this vector and the input vector. Building a mask Once we have a result of comparison we can easily build: 1-bit value, 7-bit mask ( _mm512_cmpge_mask7bit in sample codes), 8-bit mask ( _mm512_cmpge_mask8bit ). In case of base64 masks are used to conditionally set some constants, thus depending on a constant value masks of different width are needed. A 1-bit value require just one shift right. Building a 7-bit mask requires also a shift and a subtract. An 8-bit mask is simply a 7-bit mask merged with the MSB. Summing things up: building a mask always require masking MSB and shift. Depending on the mask\'s width it would require an additional bit-and or bit-or. Adding modulo 256 The operation for a single 8-bit number is defined as follows: While adding two vectors of 8-bit numbers we must disallow propagating carry bits across byte boundaries. This requires two major steps: add inputs having reset MSB in each byte --- this will never cause the carry propagation (0x7f + 0x7f = 0xfe, obviously 0xfe <= 0xff); combine MSB of inputs with the MSB of result to set final MSB to the correct value. Pseudocode for 8-bit numbers. As it was said above, inputs for the algorithms are smaller than 128, thanks to that some masking is not needed and calculating the final sum is simpler. Following C++ procedure adds a vectors of 7-bit numbers and 8-bit numbers. The procedure requires two logic instructions and one addition, it uses two constants. C++ notes Sample C++ codes use two macros: packed_dword and packed_byte . The first macro fills all 32-bit elements of vector with given value, the second one fills all bytes with a value. The macros are used just for better readability, both use intrinsic _mm512_set1_epi32 . Base64 encoding Base64 encoding consists following steps: Load data: put 3-byte sequences into 4-byte words. Unpack 6-bit words into bytes in each 4-byte word. Translate all 6-bit words into ASCII codes according to the base64 table. The table contains big letters, small letters, digits, the plus and the slash character (\'A\'-\'Z\', \'a\'-\'z\', \'0\'-\'9\', \'+\' and \'/\'). Save the result. Loading data Gather-based Since AVX512F lacks of byte-level shuffling, loading data can be accomplished with a gather instruction. The gather does a parallel lookup in given table, indices are stored in vector\'s elements. Gather is significantly faster than individual loads, especially when it touches a small number of cache lines. In this case single gather would touch at most two cache lines. An input is sequence 48 bytes, or twelve 32-bit lanes. The layout of an input: The result vector\'s layout: The 4th byte of each lane is not important. Vector of indices contains a sequence of multiplies of 3: [0, 3, 6, 9, 12, ... and so on]. Loading data is then performed by a single instruction; please note that the last argument of _mm512_i32gather_epi32 , scale , is 1. Vectorized approach Although the gather-based loading is pretty simple and straightforward, the instruction\'s latency is really huge --- it\'s 15 cycles. A vectorized approach loads 64 bytes, where only 48 bytes are used, and performs all shifting and shuffling within registers. AVX512F offers shuffling instruction vpermd ( _mm512_permutexvar_epi32 ), which works at 32-bit words level and can move words across lanes. The algorithm: Load 64 bytes: The 48-byte array could be split into four 12-byte subarrays: Each 12-byte array is then placed in a separate 128-bit lane. This is done by _mm512_permutexvar_epi32 . Note the order of words: 0, 1, 1, 2. Shift bytes C right by 16 bits ( _mm512_mask_srli_epi64 ). Now bytes A and C are at correct places. Shift bytes D and B left by 8 bit ( _mm512_slli_epi64 ). And now these bytes are also at the correct position. Merge results from 3rd and 4th steps ( _mm512_ternarylogic_epi32 ). The 3rd byte of each word will be omitted by a lookup procedure, thus no masking is needed. An excerpt from sample code. Unpacking 6-bit words into bytes A single 32-bit words layout: An expected output is: Where a , b , c and d are bits of individual 6-bit words. The question mark denotes random, unimportant data. Unfortunately this step can\'t use any fancy AVX512F instruction, a series of shifts followed by a bit merge is the only solution. The bit merge is done by the ternary logic instruction. Number of constants: 6. Number of instructions: bit-and: 1 ternary logic: 5, shift: 6. Total: 12 instructions. Vectorized lookup --- incremental Introduction A lookup procedure considers five ranges assigned to characters: \'A\'-\'Z\', \'a\'-\'z\', \'0\'-\'9\', \'+\' and \'/\'. The procedure associates a range with shift value, a constant that added to the input value gives a proper ASCII code. The simplest algorithm incrementally calculates shift , pseudocode shows the idea. SWAR notes The elementary operation is building a mask according to comparison result, the methods to do this are described earlier. As we see, masks for all but one constants can be 7-bit. However, we could split constant 187 into MSB and lower part. The lower part contributes in shift , while the MSB will be used to adjust sum shift + i . This solution has one important advantage, the sum would never wrap, and plain addition can be used. Pseudocode Rewritten algorithm. C++ implementation Number of constants: 10. Number of instructions: bit-and: 8 bit-xor: 1 ternary: 2 add/sub: 9 shift: 4 Total 24 instructions. Improved C++ implementation An expression like shift ^= cmp(...) & const might be expressed with ternary logic. This transformation makes the above procedure slightly shorter, four bit-ands are replaced with two ternary logic instructions. Vectorized lookup --- binary search Introduction The vectorized lookup uses in fact the linear search , but a kind of binary search can be used: In the first step we select if an input byte belongs to \"letters\" group (\'A\'-\'Z\' or \'a\'-\'z\'), or to \"digits\" group (\'0\'-\'9\', \'+\' and \'/\'). At this step we select both shift value and comparison value for the next step. In the second step the input is compared with value selected in the previous step. At this point we exactly know if input byte should be mapped to \'A\'-\'Z\', \'a\'-\'z\', \'0\'-\'9\' or one of \'+\' or \'/\'. The last step is used to properly select shift value for \'+\' and \'/\' chars. Pseudocode for scalar inputs shows the idea. C++ implementation The C++ implementation simply replaces all ifs with merge operations. Number of constants: 10. Number of instructions: bit-and: 4 bit-xor: 0 bit-or: 2 ternary: 6 add/sub: 7 shift: 3 Total 22 instructions. Storing data Fortunately result vector doesn\'t require any post-processing and can be stored directly. Base64 decoding Base64 decoding consists following steps: Load data, a 64-byte vector. Translate each byte of the vector from base64 ASCII chars back into 6-bit values. At this stage input validation is performed. Pack 6-bit sequences into continuous bit string, forming a 48-byte array. Save the result. Loading data Symmetrically to storing encoded data, loading such data doesn\'t require any effort, it is a simple load. Vectorized lookup Introduction Unlike encoding, decoding has to care about input\'s validity. However, the scheme of decoding is similar to encoding: depending on byte range (A-Z, a-z, 0-9, + or /) a shift value is selected and the shift is added to byte forming a 6-bit value. If a byte doesn\'t match any range, then shift value is zero, denoting an invalid input. Very important observation is that a valid input can\'t contains any extended ASCII characters, i.e. bytes should be less than 0x80. Before doing a lookup procedure the input bytes are reduced to 7-bit value. This leads to simpler code, as SWAR procedures don\'t have to deal with full 8-bit numbers. Information about invalid, extended ASCII chars is used during a validation step. Pseudocode for decoding summing up the above observations. SWAR notes One of the most important part of procedure is range checking. Since we know how to express the relation >= , the range checking could be replaced with: This involves two additions and one and-not operation, followed by mask forming. And since building mask requires MSB value, we can use ternary logic to do all needed binary operations in one instruction: Equality comparison (required for chars \'+\' and \'/\') has surprisingly the same complexity as range checking, so the latter operation is used. Adding shift and input uses arithmetic modulo 256. Pseudocode C++ implementation The vectorized version of pseudocode, most binary operations were expressed with ternary logic instructions: And SWAR procedures for mask calculations: Packing data The result of the lookup procedure is a vector of 32-bit lanes. Each lane has following layout: Intermediate result: And finally, after byte swapping it is: Packing has exactly the same problems as unpacking step in encoding. Only shifts and bit-merges can be used. The code use the same template merge as encoding. Storing data Scatter-based We can store 48 bytes using the scatter instruction, which saves 32-bit lanes at certain offsets [0, 3, 6, 9, and so on]; the vector of offset is exactly the same as encoding use. According to the documentation, scatter stores items sequentially. Since indices are in ascending order, all 4th bytes of lane will be overwritten by data from the next lane. Vectorized approach It is possible to do all shifting within registers, unfortunately there is no instruction allowing to shift across 64-bit boundary. This make decoding procedure more complicated than compared to the encoding counterpart. The algorithm: Input is treated as four 128-bit lanes. The layout of a lane: Shift fields C and A left by 8 bits ( _mm512_mask_slli_epi32 ): Shift fields D, B and A right by 8 and 24 bits ( _mm512_srlv_epi64 ): Now only bytes C2 and C1 have to be moved to word 1, and this is an expansive procedure. Shift the input vector right by a word ( _mm512_alignr_epi32 ): Shift and mask bytes C2 and C1 ( _mm512_maskz_slli_epi32 ): Merge vectors from 3rd and 5th steps ( _mm512_ternarylogic_epi32 ): Shuffle words from 128-bit lanes to form 48-byte result ( _mm512_permutexvar_epi32 ). An excerpt from sample code. Base64 coding and decoding using gather A repository contains also lookup procedures use gather instructions. The procedures are pretty short and clean (no SWAR tricks), however they use quite large tables: encoding 4 * 4 * 64 bytes (1kB), decoding 4 * 4 * 256 (4kB). And the most important fact is that performance of both procedures is worse than vectorized counterparts. Experiment results Sample programs from repository tests dozens of different variants of scalar, SSE and AVX2 implementations. I picked the best methods from scalar, SSE and AVX2 groups. Test programs were compiled by GCC 5.3.0 and run on Knights Landing processor, model 7210 . Note that tests perform whole encoding/decoding procedures, thus memory transfers are included in results. Encoding See all measurements . The best non-AVX512F procedures: scalar --- a 64 bit variant; SSE --- fully unrolled, with an improved lookup; AVX2 --- unrolled with an improved lookup. procedure AVX512 specific time [s] speed-up relative to ... load lookup AVX2 SSE scalar scalar N/A 0.58455 0.52 0.50 1.00 SSE 0.29187 1.04 1.00 2.00 AVX2 0.30332 1.00 0.96 1.93 AVX512 vectorized vectorized 0.12472 2.43 2.34 4.69 vectorized improved 0.11348 2.67 2.57 5.15 gather improved 0.12745 2.38 2.29 4.59 vectorized binary search 0.12521 2.24 2.33 4.67 gather 0.25674 1.18 1.14 2.28 Decoding See all measurements . The best non-AVX512F procedures: scalar --- an improved version; SSE --- base lookup, pack naive; AVX2 --- base lookup, pack naive. procedure AVX512 specific time [s] speed-up relative to ... lookup store AVX2 SSE scalar scalar N/A 0.2289 0.36 0.54 1.00 SSE 0.1234 0.67 1.00 1.85 AVX2 0.0832 1.00 1.48 2.75 AVX512 vectorized scatter 0.0519 1.72 2.55 4.74 vectorized 0.0441 1.89 2.80 5.19 gather 0.0519 1.60 2.38 4.41 Conclusions AVX512F implementation is always faster. Surprisingly, even gather-based decoding is faster than plain vector AVX2 procedure. Although gather and scatter instructions are pretty fast, vectorized versions of load and store outperform hardware. On Knights Landing AVX2 code is merely 1.2-1.3 times faster than SSE code. Further work I\'ve deliberately left two ideas aside: Unrolling loops . My experiments with simpler algorithms showed that unrolling usually makes code slower on KNL. Binary-search based lookup for decoding . Binary search used for encoding is not better than incremental procedure, so at the moment I think it is not worth to bother with decoding. Acknowledgments This work wouldn\'t be possible without Daniel Lemire , who has gave me access to a brand new machine having Knights Landing CPU. I could do all experiments on a real processor. Daniel also shared some ideas about an early version of this text. Thank you! Source code Github repository contains all procedures and sample programs. Changes 2017-01-25 --- spelling 2016-12-18 --- fixed order of bytes according to the base64 standard'],
["notesen/2016-10-08-avx512-sort-register.html", 'Sorting an AVX512 register', 'Sorting an AVX512 register Wojciech Mua Added on 2016-10-08 Introduction Presented method allows to sort a whole AVX512 register or its subrange, it is a variant of counting sort . The time complexity is linear, moreover method works entirely on registers, no extra memory operations are done. It may also be easily extended to sorting more than one register. The method is suitable for sorting 32- and 64-bit integers, and also floating point numbers, both single and double precision. Algorithm A single step of the algorithm consist: Broadcast i-th element of the input. Compare for less the broadcast vector with the input. This yields the number of items less than i-th item. Likewise compare for equality. This yields number of item\'s repetitions Having these two numbers we can form a mask which can be used to merge the broadcast vector with a result vector, putting i-th number at the correct position. This is repeated for every item of input. When sorting 32-bit numbers 16 iterations have to be done. Example Implementation Sample implementation with loop. It is slower than fully unrolled code. Performance results Compiler: GCC 5.3.0 CPU: Knights Landing 7120 Sorting 16 x 32-bit numbers (one AVX512 register) algorithm time [s] std::sort 1.53 insertion sort 5.55 AVX512F unrolled 1.77 AVX512F (for loop) 2.04 Sorting 32 x 32-bit numbers (two AVX512 registers) algorithm time [s] std::sort 5.24 insertion sort 12.99 AVX512F unrolled 5.78 Speed of vectorized algorithms is comparable to std::sort for C++ library. However, the algorithms are not meant to be used as a replacement of library function, but as a part of other algorithms. For instance the unrolled vectorized algorithm was used in quicksort implementation to sort short ranges, making the whole sorting substantially faster. Source code Github repository contains various variants of sorting and a test program.'],
["notesen/2016-10-08-slow-std-string-find.html", 'GNU std::string::find is very slow', 'GNU std::string::find is very slow Wojciech Mua Added on 2016-10-08 Updated on 2016-11-27 (tidy), 2016-10-17 (link to GCC\'s bugtrack) Today\'s weather was a really good excuse for staying at home and hacking. I come back to my old idea of speeding up substring searching exploiting SSE4.1 instruction MPSADBW . Finally I translated my old SSE code into AVX2. Then I transplanted my recent AVX512F code which employs similar techniques. In the end I coded AVX512F and SSE2 versions of SWAR-friendly technique which I developed some time ago. ( Github repository contains all the stuff, if you wish to take a look.) But let\'s put aside vector algorithms performance. Experiments have revealed that method find from C++ std::string is incredibly slow . The method can be slower an order of magnitude than strstr , and it doesn\'t get better with a newer stdlib --- GCC versions varies from 4.9.2 (Debian) to 5.4.0 (Ubuntu). Here is the table I took from the repository\'s README. The slowdown factors, when compared with strstr , are: 12.9 , 12.6 , 9.9 , 7.4 . architecture procedure time in seconds strstr string::find Westemere 0.83 10.71 Haswell 0.48 6.06 Skylake 0.66 6.54 KNL 4.96 36.94 I looked into headers, and I suppose located the culprit in bits/basic_string.tcc . Maybe I\'m wrong, but for me it\'s a linear search , isn\'t it? The assembly dump taken from perf annotate : It must be slow. And I think C++ users should be worried a little bit. See also The problem has been already reported (bug 66414).'],
["notesen/2016-10-16-avx512-byte-alignr.html", 'Byte-wise alignr in AVX512F', 'Byte-wise alignr in AVX512F Wojciech Mua Added on 2016-10-16 Introduction The instruction alignr in Intel SIMD builds a new vector from a subrange of two concatenated vectors; its downside is accepting only compile-time constants. AVX512F lacks of byte-wise instructions, an available variant of alignr works at level of 32-bit words. Byte-wise alignr is viable in AVX512F, using techniques used to handle so called long-numbers. We can do shifts at 32-bit word granulation using vpalignr ( _mm512_alignr_epi32 ), then byte-wide shift inside each 32-bit word is possible. To perform the latter shift we need bytes from the next 32-bit word. This force us to build two vectors, having current and next words at corresponding positions. Then these words are shifted accordingly and finally merged into one 32-bit word. Algorithm Steps required to perform alignr(hi, lo, shift) : Calculate shift amounts for 32-bit words and bytes: If s8 == 0 it means that single 32-bit-wise shift is sufficient: Otherwise build two vectors: Do shifts at byte level: Finally merge these two vectors: Sample program Following sample program is a software implementation of byte-wise alignr . Please note that procedures use run-time shifts. All sources are available at github .'],
["notesen/2016-10-16-detecting-bit-pattern.html", 'Detecting bit patterns with series of zeros followed by ones', 'Detecting bit patterns with series of zeros followed by ones Wojciech Mua Added on 2016-10-16 Problem We want to detect if a pattern is a sequence of zeros followed by ones. Table below lists all 8-bit patterns having this form. bin hex 1000_0000 80 1100_0000 c0 1110_0000 e0 1111_0000 f0 1111_1000 f8 1111_1100 fc 1111_1110 fe 1111_1111 ff Solution Negative number, i.e. -x = ~x + 1 , from the searched pattern forms a bit pattern having just a bit set on position of the first one in string. The negation of any other pattern has got more ones. Lets look at the following example: For all searched patterns bit-and of a pattern with its negation is equal to the negation. Unfortunately this rule applies also to 0, thus an additional test is required. Here is a sample implementation for 16-bit numbers. All source codes are available at github .'],
["notesen/2016-10-23-avx512-conflict-detection.html", 'What does AVX512 conflict detection do?', 'What does AVX512 conflict detection do? Wojciech Mua Added on 2016-10-23 AVX512CD AVX512CD, or conflict detection , is a subset of AVX512 introducing following instructions: broadcast bit-mask to byte-mask ( vpbroadcastmw2d and vpbroadcastmb2q ); parallel lzcnt, i.e. counting leading zeros ( vplzcntd and vplzcntq ); conflict detection ( vpconflictd and vpconflictq ). The first two are not very interesting. Converting bit-mask into byte-mask saves in fact one move ( vmovdqa32 with zero mask and a constant), it isn\'t too innovative. I can\'t find any real usage for lzcnt. Well, I wrote parallel popcount using this instruction (yes, 16 while-loops...), but it was just to show that I could. In my opinion the most interesting are conflict detection instructions. Conflict detection A conflict means existence of duplicated values in a vector. The instructions works on integer vectors of either 32- or 64-bit values. The result is a vector of masks denoting positions of duplicates before given item. For example: Masks equal zero point to unique elements withing a vector. Thus, we can, for example, count unique elements or build a subvector of such values using a compress instruction ( vpcompress{d|q} ). You can play with vpconflictd using a tiny program .'],
["notesen/2016-11-28-simd-strfind.html", 'SIMD-friendly algorithms for substring searching', 'SIMD-friendly algorithms for substring searching Wojciech Mua Added on 2016-11-28 Updated on 2018-02-14 (spelling), 2017-04-29 (ARMv8 results) Introduction Popular programming languages provide methods or functions which locate a substring in a given string. In C it is the function strstr , the C++ class std::string has the method find , Python\'s string has methods pos and index , and so on, so forth. All these APIs were designed for one-shot searches . During past decades several algorithms to solve this problem were designed, an excellent page by Christian Charras and Thierry Lecroq lists most of them (if not all). Basically these algorithms could be split into two major categories: (1) based on Deterministic Finite Automaton, like Knuth-Morris-Pratt, Boyer Moore, etc., and (2) based on a simple comparison, like the Karp-Rabin algorithm. The main problem with these standard algorithms is a silent assumption that comparing a pair of characters, looking up in an extra table and conditions are cheap, while comparing two substrings is expansive. But current desktop CPUs do not meet this assumption, in particular: There is no difference in comparing one, two, four or 8 bytes on a 64-bit CPU. When a processor supports SIMD instructions, then comparing vectors (it means 16, 32 or even 64 bytes) is as cheap as comparing a single byte. Thus comparing short sequences of chars can be faster than fancy algorithms which avoids such comparison. Looking up in a table costs one memory fetch, so at least a L1 cache round (~3 cycles). Reading char-by-char also cost as much cycles. Mispredicted jumps cost several cycles of penalty (~10-20 cycles). There is a short chain of dependencies: read char, compare it, conditionally jump, which make hard to utilize out-of-order execution capabilities present in a CPU. Contents Introduction Solution Algorithm 1: Generic SIMD Algorithm Example First and last? Implementation SSE & AVX2 SWAR AVX512F ARM Neon (32 bit code) AArch64 (64 bit code) Algorithm 2: SSE-specific (MPSADBW) Algorithm Implementation SSE AVX512F Algorithm 3: SSE4.2-specific (PCMPESTRM) Algorithm Implementation SSE Performance results x64 computers ARM computers Conclusions and remarks Acknowledgments Source code History Solution This article shows two approaches utilizing SIMD instructions which I\'ve already described in SIMD-friendly Rabin-Karp modification and SSE4 string search --- modification of Karp-Rabin algorithm . I merged the articles, compared these two methods and extended material. Article shows also performance results for various implementations, ranging from SWAR to AVX512F. The Karp-Rabin algorithm does the exact substring comparison whenever weak hashes are equal. One hash is calculated just once for searched substring, and another one is calculated for string\'s portion; in every iteration the second hash is updated at small cost. Following code shows the idea: SIMD solutions replace the hash predicate with a vector predicate , which is calculated in parallel and, hopefully, is calculated fast. For each \"true\" element of the predicate vector an exact comparison of substrings is performed. This is one source of improvement, another is a careful implementation. A generic implementation calls a function like memcmp to compare substrings. But while we know the length of searched substring, we may provide specialisations for certain lengths, where a subprocedure call is replaced by a few CPU instructions, even just one. Thanks to that the cost of calling the procedure and all internal memcmp costs are simply ridden off. Algorithm 1: Generic SIMD Algorithm This algorithm is suitable for all SIMD instruction sets and also SWAR approach. It uses as a predicate equality of the first and the last characters from the substring. These two characters are populated in two registers, F and L respectively. Then in each iteration two chunks of strings are loaded. The first chunk ( A ) is read from offset i (where i is the current offset) and the second chunk ( B ) is read from offset i + k - 1 , where k is substring\'s length. Then we compute a vector expression F == A and B == L . This step yields a byte vector (or a bit mask), where \"true\" values denote position of potential substring occurrences. Finally, just at these positions an exact comparisons of substrings are performed. Example Let\'s assume 8-byte registers. We\'re searching for word \"cat\", thus: We\'re searching in the string \"a_cat_tries\". In the first iteration the register A gets data from offset 0, B from offset 2: Now we compare: After merging comparison results, i.e. AF & BL , we get following mask: Since the mask is non-zero, it means there are possible substring occurrences. As we see, there is only one non-zero element at index 2, thus only one substring comparison must be performed. First and last? Choosing the first and the last character from a substring is not always a wise decision. Consider following scenario: a string contains mostly \'A\' characters, and a user wants to find \"AjohndoeA\" --- in such situation the number of char-wise would be large. In order to prevent such situations an implementation can pick \"last\" character as the farthest character not equal to the first one. If there is no such character, it means that all characters in substring are the same (for example \"AAAAA\"). A specialised procedure may be used to handle such patterns. Implementation SSE & AVX2 Both SSE and AVX2 versions are practically the same, and both use the minimum number of instruction. Below is a generic AVX2 version. It\'s worth to note that since we already know that the first and the last characters match, we don\'t need to compare them again with memcmp . SWAR In SWAR approach, comparison for equality uses bit xor operation, which yields zero when two bytes are equal. Therefore instead of anding partial results, the bitwise or is used. Clearly this part of algorithm has the same complexity as the SSE/AVX2 code. However, SWAR requires more effort to locate zero bytes. Following procedure calculates an exact byte mask , where MSBs of zeros are set when the corresponding byte in x is zero. Below is the C++ implementation for 64-bit vectors. The while loop contains an additional condition which might look not optimal. But searching the first set bit and later clearing it (as the SSE version does) is slower. AVX512F AVX512F lacks of operations on bytes, the smallest vector item is a 32-bit word. The limitation forces us to use SWAR techniques. Using AVX512F instructions we compare two vectors, like in SWAR version, i.e. two xors joined with bitwise or. There is only one difference, a single ternary logic instruction expresses one xor and bitwise or. Using AVX512F instructions we locate which 32-bit elements contain any zero byte. Then for such 32-bit element check four substrings for equality. Unlike the SWAR procedure, where we need a precise mask for zero bytes, an AVX512F procedure requires just information \"a word has zero byte\". A simpler algorithm, described in Bit Twiddling Hacks is used; below is its C++ implementation. Generic C++ implementation. ARM Neon (32 bit code) The algorithm can be also easily realised using ARM Neon instructions, having 128-bit SIMD registers. The only problem is caused by long round trip from the Neon unit back to the CPU. It was solved by saving back the comparison result in a 64 bit word in memory: lower nibbles come from the lower half of a SIMD register, likewise higher nibbles come from the higher half of the register. Comparison is done in two loops, separately for lower and higher nibbles. This split is required to detect substring occurrences in the correct order. Below is a sample implementation. It appeared that unrolling the two inner loops brought about 1.2 speedup. AArch64 (64 bit code) AArch64 code is almost the exact copy of the above ARM Neon procedure. The only exception is direct reading of SIMD registers lanes, as the architecture made this operation fast. Algorithm 2: SSE-specific (MPSADBW) Algorithm SSE4.1 and AVX2 provide instruction MPSADBW , which calculates eight Manhattan distances (L1) between given 4-byte sub-vector from one register and eight subsequent 4-byte sub-vector from second register. The instruction returns vector of eight words (16-bit values). When two sub-vectors are equal, then the L1 distance is 0, and we may use this property to locate possible substring locations. In other words equality of four leading characters is used as a predicate. Albeit it seems to be a stronger predicate than matching the first and the last characters, a quadratic complexity is unavoidable. For example, when the searched string contains one letter \"a\", and we\'re looking for \"aaaabcde\", then the predicate obviously will be true for all input characters. If it isn\'t enough, there are following problems: This method handles substring not shorter than four characters. Handling three-char substrings is viable, but require additional code. SSE variant of MPSADBW processes only 8 bytes at once, while the generic SIMD variant uses the whole register. AVX2 variant of MPSADBW works on lanes, i.e. 128-bit helves of a register rather than the whole 256-bit register. This imposes additional code to properly load data. Latency of the instruction is pretty hight --- 5 or 7 cycles, depending on CPU architecture. Luckily throughput is 1 or 2 cycles, thus unrolling a loop can hide latency. Implementation SSE The generic, simplest implementation. AVX512F Although AVX512F doesn\'t support MPSADBW (AVX512BW defines it) we still can use 4-byte prefix equality as a predicate, utilizing fact that 32-bit elements are natively supported. In each iteration we generate four AVX512 vectors containing all possible 4-byte prefixes. Example: Vector vec0 contains prefixes for position 0, 4, 8, 12, ...; vec1 --- 1, 5, 9, 13, ..., vec2 --- 2, 6, 10, 14, ...; vec3 --- 3, 7, 11, 15, etc. Building each vector require two shifts and one bitwise or. In each iteration four vector comparison are performed and then four bitmasks are examined. This make a loop, which compares substrings, quite complicated. Moreover, to properly fill the last elements of vectors we need four bytes beyond vector. This is accomplished by having two adjacent vectors per iterations (one load per iteration is needed, though). Finally, instruction VPALIGNR is used to extract required data. Algorithm 3: SSE4.2-specific (PCMPESTRM) Algorithm SSE4.2 introduced String and Text New Instructions (STNI), a set of very complex instructions that were meant to be a building block for string operations. Unfortunately, Intel practically discontinued STNI in newer processors, hasn\'t introduced AVX2 versions of STNI and make them extremely slow (11 cycles latency is unacceptable). Basically PCMPxSTRx instruction exists in four variants, which differs only in: A way to determine string length: the length might be given explicitly or the first zero byte marks string end, as in traditional C strings. How the result is saved, it might be either a bit-mask/byte-mask or the number of first/last bit set in the bit-mask. Additional instruction\'s argument (immediate constant) defines several aspects of execution, specifically the algorithm of comparison. There are four different algorithms available, one we\'re using is called range ordered . Despite the name, this algorithm locates substring, or its prefix if a substring goes beyond register width. For example, when we\'re searching \"ABCD\" in \"ABCD_ABC_ABCD_AB\" the instruction returns bitmask 0b0100001000000001, treating suffix \"AB\" as a match. Thus we can safely assume that only the first character matches , as tail might or might not be present in a register. (Of course it can be determined, but require additional calculations which is not very handy.) Below is a code snippet which does the above operation. Implementation SSE Performance results Performance of various SIMD implementations were measured. Test programs also have got specialisation for short substrings, that are selected at run time. Performance of a C strstr is included for comparison. I omitted C++ string::find due to performance bug in GNU libc which makes the method 10 times slower than strstr . Test programs were run three times. Following computers, running either Debian or Ubuntu, were tested: Westmere i5 M540, GCC 6.2.0, Bulldozer FX-8150 CPU, GCC 4.8.4 Haswell i7 4470, GCC 5.4.1, Skylake i7 6700, GCC 5.4.1, Knights Landing (KNL) 7210, GCC 5.3.0. ARMv7 (Raspberry Pi 3, 32-bit code), GCC 4.9.2 ARMv8 ( ARM Cortex A57 - AMD Opteron A1100 , 64-bit code), Clang 3.8.0 x64 computers procedure time in seconds Westemere Bulldozer Haswell Skylake KNL std::strstr 0.82246 9.37792 0.52786 0.66148 4.94606 std::string::find --- --- --- --- --- SWAR 64-bit (generic) 2.49859 2.93836 1.57715 1.40404 8.17075 SSE2 (generic) 0.74589 0.78871 0.55435 0.48863 6.10786 SSE4.1 (MPSADBW) 1.45040 1.98863 0.89775 0.63875 18.71666 SSE4.1 (MPSADBW unrolled) 1.23849 2.06008 0.99647 0.87919 13.72486 SSE4.2 (PCMPESTRM) 1.69968 2.00681 1.55992 1.39063 6.28869 AVX2 (MPSADBW) 0.61578 0.56981 13.15136 AVX2 (generic) 0.38653 0.36309 4.09478 AVX512F (MPSADBW-like) 2.32616 AVX512F (generic) 1.14057 biggest speed-up to strstr 1.10 --- 1.37 1.82 4.33 Performance of strstr on the machine with Bulldozer is terrible, it\'d pointless to use it as a reference. ARM computers procedure time in seconds ARMv7 ARMv8 std::strstr 7.30405 3.37546 std::string::find 4.17131 1.81368 SWAR 64-bit (generic) 36.65012 0.46269 SWAR 32-bit (generic) 2.45058 0.81075 ARM Neon (32-bit, generic) 1.29861 0.40699 AArch64 (64-bit, generic) --- 0.27897 biggest speed-up to std::string::find 3.1 6.5 Conclusions and remarks The generic SIMD algorithm outperforms C strstr on all platforms. An implementation should use the highest SIMD version available on a certain CPU. MPSADBW performs pretty bad, with an exception for Skylake. Knights Landing performance is terrible. PCMPESTRM performs worse than MPSADBW . ARM Neon performance is pretty good even for SWAR implementation. The SWAR version is 1.7 times faster than string::find , SIMD version is 3.1 times faster. AArch64 performance of scalar SWAR64 is almost as good as 32-bit SIMD procedure. Comparison with strstr might be considered unfair, as the procedure deals with string of unknown length, while my implementations get lengths and take advantage of this. I fully agree. Procedures I implemented are also unsafe, because might read data off the input string. This may lead to access violation if strings are located just before unmapped memory. And for sure address sanitizers will complain. Making the procedures safe is feasible, but it wasn\'t my goal. Acknowledgments Daniel Lemire has gave me access to Haswell, Skylake, KNL, Bulldozer and ARMv8 machines, where I compiled and run test programs. Thank you! Source code All implementations and tests programs are available at github . History 2017-04-29 --- ARMv8 results 2017-01-30 --- better timings from Raspberry Pi 3 2017-01-26 --- ARM Neon & results from Raspberry Pi 3 2017-01-25 --- spelling 2016-12-22 --- added results from Bulldozer 2016-11-30 --- spelling'],
["notesen/2016-12-16-xop-popcnt.html", 'Population count using XOP instructions', 'Population count using XOP instructions Wojciech Mua Added on 2016-12-16 Introduction AMD XOP defines instruction VPTERNB which does lookup in a pair of SSE registers. The instruction is similar to PSHUFB , but apart of wider, 5-bit index, it allows to perform several extra operations based on the higher 3-bits. I showed that PSHUFB can be used to implement population count procedure . With 4-bit indices such procedure is straightforward. We split a byte vector into two halves, and invoke the instruction twice, getting popcount for both nibbles. Next these popcounts are added together, forming 8-bit counters, which are added in the end. Similar procedure can be build around VPTERNB . However, to fully utilize 5-bit indices a slightly different strategy is needed. We process two vectors in one step treating byte pairs as 16-bit words. We call VPTERNB to calculate popcount of three 5-bit fields, one remaining bit of the 16-bit word is counted separately. Algorithm We process two SSE registers ( vec0 and vec1 ) in one step. First we calculate population count of lower five bits of both registers. Then we build a 5-bit word using three remaining bits from vec0 (abc) and vec1 (jk). We merge these bit-fields using XOP-instruction VCMOV , a condition move based on the bit-mask. At this point vectors popcnt1 , popcnt2 and popcnt3 have got population count for all bits except the bit i. This bit is present in vector t4 at position 4th. We separately accumulate popcounts from vectors popcnt{1,2,3} and the bit i. The bit i is not shifted, we simply mask it and keep the counter shifted right, that limits its capacity to 7. We repeat the procedure six times, and then add counters local_a and local_b . The resulting vector local contains in each byte population count of two bytes from the input vectors. Source code Sample implementation is available in file src/xop_hamming_weight.cpp on github repository accompanying our paper Faster Population Counts using AVX2 Instructions . Performance results Following timings were obtained on AMD FX(tm)-8150 Eight-Core Processor with program basic_benchmark from the repository. Comparison includes just three procedures: PSHUFB -based ( sse_bitset64_weight ), SSE Harley-Seal ( sse_harley_seal_bitset64_weight ), and VPTERNB -based ( xop_bitset64_weight ). The Harley-Seal method is the fastest. However, when compare parallel-lookup methods, we see that one presented in this article can be 1.3 times faster than PSHUFB -based. 64-bit words cycles per 64-bit word PSHUFB -based VPTERNB -based Harley-Seal 128 0.35 0.26 0.40 192 0.71 0.59 0.68 256 0.96 0.83 0.81 384 1.11 0.99 0.95 512 1.19 1.12 1.07 768 1.26 1.16 1.13 1024 1.30 1.24 1.15 2048 1.52 1.34 1.26 4096 1.54 1.34 1.26 8192 1.56 1.34 1.26 12288 1.56 1.35 1.26'],
["notesen/2016-12-21-swar-digits-validate.html", 'SWAR check if all chars are digits', 'SWAR check if all chars are digits Wojciech Mua Added on 2016-12-21 Updated on 2017-03-25 (shorter scalar version) Problem We have a string and want to check if all its characters are ASCII digits. It\'s a remnant of my experiments in number parsing: I was curious if separating validation from actual conversion would be profitable. The answer is no in a generic case. For really long numbers there might be some improvement, but in reality inputs are usually short. Solutions The easiest solution uses two comparisons per one character. It\'s possible to write simpler scalar version, with subtraction: The faster scalar version uses just two instructions. Moreover, all optimizing compliers (GCC/clang) will compile the first variant into the faster one. A similar code can be write with SSE/AVX2 instructions, as these ISA have got byte-level compare instructions. However, only the first variant can be translated, because SSE/AVX2 support only signed compare ; AVX512 supports also unsigned byte comparison. A SWAR solution is also possible. ASCII codes for digits are 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37 and 0x39. The higher nibble is equal three, and the lower one is less than 10. Thus a SWAR code (1) checks if all higher nibbles are equal to three, (2) if so, check if all bytes are less than 0x39. To perform the first check we need just one comparison and bitwise and; the second check requires sum and a bit-and. Source code Test programs are available on github .'],
["notesen/2016-12-22-avx512-sparse-bfs.html", 'AVX512 --- first bit set in a large array', 'AVX512 --- first bit set in a large array Wojciech Mua Added on 2016-12-22 Problem There is an array of 64-bit values, we want to find the first bit set; the array is sparse. Scalar version The obvious scalar solution scans whole array. For the first non-zero word it calculates position of the first bit within the word (using the instruction bsf or tzcnt ) and returns the appropriate value. AVX512F The AVX512 solution minimizes number of branches by searching non-zero word in an register. When comparison\'s result is non-zero, we locate which word of the register it is, and process this word in the same way as the scalar version. Performance results A test program was compiled by GCC 5.3.0 and run on Knights Landing processor, model 7210 . The program clears the array of 64-bit words and set the last bit in the last word. size [64-bit words] cycles per word speed-up scalar AVX512 8 4.88 3.25 1.50 16 4.06 2.44 1.66 32 3.66 1.22 3.00 64 3.25 1.02 3.19 128 3.15 0.91 3.46 256 3.10 0.76 4.08 512 3.05 0.69 4.42 1024 3.02 0.66 4.58 Source code Test programs are available on github .'],
["notesen/2017-01-07-base64-simd-neon.html", 'ARM Neon and Base64 encoding & decoding', 'ARM Neon and Base64 encoding & decoding Wojciech Mua Added on 2017-01-07 Updated on 2017-02-13 (correct the author), 2017-02-03 (link to 64-bit code), 2017-01-08 (spelling) Introduction Base64 algorithms were subject of my interest last year and I proposed a few different SIMD approaches for both encoding and encoding. This text sums up my experiments with ARM Neon implementation. For algorithms\' details please refer to Base64 encoding with SIMD instructions and Base64 decoding with SIMD instructions . Contents Introduction ARM Neon Load and store Conditions Bit operations Base64 encoding Base64 decoding Performance results Encoding (quadwords) Decoding (doublewords) See also Source code ARM Neon ARM Neon is a pretty rich instruction set, it supports common SIMD logic and arithmetic operations, as well as vector lookups. The base register size is 64 bit (called doubleword ), but there is support for 128-bit operations ( quadword ). Such a wide register is composed from two 64-bit registers, thus there is no cost of getting lower or higher part of quadword register; however at intrinsics level we need to use pseudo-functions vget_{low,high} or vcompose (to construct a new vector). All instructions accept doubleword registers, most work on quadwords. Load and store Neon has one unique trait when compared with Intel\'s SIMD: it can load/store arrays of registers (up to four). Moreover it\'s possible to treat data as arrays of structures and interleave elements accordingly. In base64 we process three-byte blocks, and thanks to the interleaving we can easily load 8 (or 16) three-byte blocks, placing 0th bytes in the first register, 1st bytes in the second register and 2nd bytes in the third register. Here is a sample code using intrinsics functions. The uint8x16x3_t type represents a sequence of three quadwords registers; no assembly instructions will be generated due to referencing sub-items of value having this (or similar) type. Basically, interleaved load and store are the most important, vital part of Neon implementations. Conditions Base64 decoding requires input validation, i.e. a procedure which translates from ASCII into binary values must detect invalid ASCII letters. Intel SIMD has fast ways to communicate between the vector unit and the scalar unit, that\'s responsible also for jumps. Unfortunately, sending values from the Neon unit to the scalar unit is very slow. I overcome this limitation by using temporary memory buffer, which is independently read by the scalar code. Bit operations Neon supports a bit select instruction ( x ? y : z ) that appeared to be useful in a few places. (AMD XOP also provides such instruction, AVX512F comes with powerful ternary logic instruction .) Neon supports also shifts at byte level that makes some bit operations easier. Base64 encoding Encoding is done in four steps: load three-byte blocks having bit layout [ccdddddd|bbbbcccc|aaaaaabb] ; isolate four 6-bit values, the fields a , b , c and d ; translate them into ASCII codes; save the text. The first step is accomplished with described earlier interleaved loading , we load 16 three-byte fields and after this step the first register has got bytes [aaaaaabb] , the second one [bbbbcccc] and the third one [ccdddddd] . Using standard bitwise and, bitwise or and shifts we build four vectors having bytes [00aaaaaa] , [00bbbbbb] , [00cccccc] and [00dddddd] . Then we translate these values into ASCII codes. I literally rewritten three procedures from Intel SSE: lookup_naive --- the most naive, comparison-based approach; lookup_version2 --- also uses comparisons, but is a bit smarter; lookup_pshufb_improved --- uses vector lookup instruction vtbl (I kept name pshufb , though). The only important note is that vtbl doesn\'t support quadword registers, so two invocation of the instruction are needed. The last step, saving the result, i.e. four vectors, also uses interleaved transfer. The whole encoding template. Base64 decoding Base64 decoding requires four steps: load four-character blocks; translate the characters into 6-bit values; pack four 6-bit values into 24-bit words; save 24-bit words. The first step uses --- no surprise --- interleaved loading; we load 16 four-characters chunks. Then each character is translated into 6-bit value, i.e. each of four register has bytes [00aaaaaa] , [00bbbbbb] , [00cccccc] and [00dddddd] . I rewritten two SSE procedures: lookup_byte_blend --- naive, comparison-based algorithm, it uses the bit select instruction to blend vectors; lookup_pshufb_bitmask --- very compact approach heavily using the vector lookup instruction. Now we compose three registers that will have bytes [aaaaaabb] , [bbbbcccc] and [ccdddddd] . This is done with shifts and bitwise ors. The final step is to save these bytes, and again, we use interleaved store. The decoding template. As it was said, communication between the Neon unit and main unit is expansive. In the result error reporting path uses a temporary memory to save information. Performance results I purchased Raspberry Pi 3 with Cortex-ARMv8, however, the operating system doesn\'t support the 64-bit mode yet. Everything was tested in the 32-bit mode. My first implementations used only doubleword instructions (that performed pretty well), later I used quadword in both encoding and decoding. Performance of encoding become better, but decoding was almost 40% slower. I suppose that I omitted something due to lack of experience. Any hints are warmly welcomed. CPU: ARMv7 Processor rev 4 (v7l) Compiler: GCC 4.9.2 Encoding (quadwords) procedure time [s] speedup scalar (32 bit) 1.06887 1.00 ARM NEON (naive lookup) 0.43296 2.47 ARM NEON (optimized lookup) 0.38450 2.78 ARM NEON (pshufb improved lookup) 0.32139 3.33 Decoding (doublewords) procedure lookup time [s] speedup improved scalar N/A 0.24247 1.00 scalar N/A 0.49157 0.49 ARM NEON byte blend 0.14298 1.70 ARM NEON pshufb bitmask 0.10574 2.29 See also Matthieu Darbois developed a really nice algorithm for base64 decoding that uses 64-bit ARM Neon instructions, see file lib/arch/neon64/codec.c (a part of great base64 library by Alfred Klomp). \"Neon Programmer\'s Guide\", 2013, ARM ( DEN0018A --- free, but required registration) List of all intrinsic functions supported by GCC Source code Github repository contains all procedures and sample programs.'],
["notesen/2017-11-26-code-dive-2017.html", 'A short report from code::dive 2017', 'A short report from code::dive 2017 Wojciech Mua Added on 2017-11-26 Code::dive 2017 was a free conference held in Wrocaw, Poland. The conference was organized and sponsored by Nokia Poland. The fourth edition took two days (14-15 November), it was in a huge cinema near the city center. There were five sessions, in each session one could choose from four lectures. In total 40 talks in two days, awesome. The organization was great, as always. The only downside was a pretty big queue to the registration on the first day. Otherwise it was perfect; there were even free snacks and water. I attended following talks: Miodrag Molivi, \"FPGA for a software developer\" Alex Crichton, \"Concurrency in Rust\" Mark Isaacson, \"C++17 and beyond\" Kamil Witecki, \"Architecture is (not) everything\" Silke Holtmanns, \"Interconnection security -- SS7 and Diameter\" Douglas Crockford, \"The better parts\" Mateusz Pusz, \"Striving for ultimate low latency\" William Kennedy, \"Go: Optimizing for correctness\" Micha Sajdak, \"A story of 3 CCTV cameras - a story of 3 admins\" Alex Crichton, \"Introduction to Rust\" FPGA for a software developer It was one of my favourite talks. Miodrag presented an architecture of typical FPGA, he also showed a number of open source tools that enables us to play with FPGAs. He also got through core parts of Verilog, using as an example a simple 8-bit CPU. The CPU has a fully functional design -- it has got an ALU, a control unit; it was able to decode variable-length opcodes and execute them. At the end the speaker run a sample program on the CPU realized on a real, cheap FPGA hardware. Wow! Although I have already known some bits of FPGA and Verilog, the presentation gave me a grasp of the whole stack needed to use the programmable arrays in practice. Concurrency in Rust Because I don\'t know Rust, I was keen on seeing the talk. I learnt that Rust can precisely track the ownership and lifetime of values and thanks to that many C++-specific problems (like read-after-free) are ridden off. To my surprise Rust doesn\'t support threads. All multithreading work is done by third-part libraries. Due to the ownership tracking, a multithread code is hard to misuse. Libraries won\'t allow to use shared values, which otherwise would be the root of many problems. The existing libraries are pretty rich; for instance, they support fork-join pattern, as well as well-known primitives, like condition variables and mutexes. The latter might make program unsafe, as wrongly used mutexes may lead to deadlocks. C++17 and beyond It was a review of new features introduced in C++17 and C++20. The speaker described in details three upcoming changes from C++17. The first one is std::string_view , a really nice std::string -compatible wrapper for any string data. The only disadvantage of this class is not tracking lifetime of the underlying data, thus a string_view might be dangerous when we forget about that trait. The second feature is possibility of override a dot operator . Yes, it\'s not a mistake. The dot operator. It allows to provide wrappers that are transparent for programmer, i.e. no extra code is needed to properly use such wrapper; it\'s spelled as a normal value. My first impression: it\'s a wolf in sheep\'s clothing. I can\'t imagine how a programmer would easily reason about the code. The last feature is the nicest one: constexpr if . This makes possible to get rid off all this utterly unreadable SFINAE crap and replace with explicit conditions that are executed in compile-time. I\'m grateful for this change. Architecture is (not) everything I didn\'t like this presentation. To be honest the whole talk could be squeezed into a single statement: mind that you, a programmer, don\'t work in void, the result of your work would be used by somebody. Interconnection security -- SS7 and Diameter The best presentation I saw on all code::dives I attended. Silke described the current state of the network which interconnects mobile networks; now there are around 800 networks. The bad news is there\'s no security build in. Would you like to fake a SMS? Not a big deal. Would you like to grab some private keys? No problem, they\'re send in plain text . Would you like to locate a cellphone? You\'re welcome! Approximately 1% of network traffic looks suspiciously. Moreover, entry points to the network, either hardware equipment or APIs, are available on the black markets; not to mention that governments and special forces has open access to that network. As Silke said, attacks on the interconnection network are getting similar to attacks on traditional networks. My conclusion is that we should be worried. The Internet is well known. All its users, even non-technician, are less or more aware of the dangers come from the net. The mobile network has even more users, and they (we!) are basically unaware of technical details and perils. The better parts A nice show of the creator of JSON. He tried to convince people that Javascript used properly is not as bad as it\'s commonly believed. For me the most interesting part was presentation of a new format for decimal floating point numbers -- more details on dec64.com . I like it very much, the format nicely includes integers into the representation. If broadly accepted, it would solve a great deal of problems that people encounter in practice. Striving for ultimate low latency I enjoyed the talk! The speaker, who works in a trading company, showed several ways and solutions to achieve low latency C++ code. For instance he showed how factoring out a rarely called branch into a separate function speed up the code (due to reducing use of the instruction cache size). The well known godbolt.org was used to show how complicated and time consuming std::shared_ptr is; and how cheap std::unique_ptr is. I really like Mateusz\'s call for measuring things. He said his predictions about the performance are almost always wrong. Welcome to the club! Go: Optimizing for correctness I don\'t know Go very well, just read this and that about the language, even though I enjoyed the talk. It was a really nice presentation of tools and builtin facilities that allow to profile both the CPU and memory usage of a go program. William made a live-coding session, where he showed how to use different utilities to track down performance and heap problems. He also showed that one can extend own application with hooks that can report the current measurements, through REST API, I guess. I didn\'t get well that part. A story of 3 CCTV cameras - a story of 3 admins In the Polish comedy \"Va Bank\", a seasoned robber opens a safe and his friend asks him: --- Wow, how have you opened it? --- You should have payed attention. This presentation was like this. The speaker showed that he cracked three different CCTV cameras. However, when it came to details, his answers was like \"I know where to seek for because I\'m experienced\" or \"can\'t give more details\". It was awful. An important take away from this talk is that producers of pretty expansive devices don\'t care too much about security. Introduction to Rust The funny fact is that this talk was given in the last session on the last day. I saw the previous Alex\'s presentation about concurrency in Rust; some information was repeated here. From this presentation I learnt that although Rust is advertised as a \"safe language\", it has unsafe parts. Unsafe is the language keyword, and such an unsafe block of code may be full of dragons. In the real-world case of Firefox there is around 30% unsafe code (if I remember the number correctly). It was also said that thanks to Rust it was possible to build a concurrent CSS parser for Firefox. According to Alex, C++ somehow prevented programmers from this. However, I didn\'t get what these reasons were. I would love to learn more details about the problems imposed by C++.'],
["notesen/2018-03-11-is-power-of-two-bmi1.html", 'Is power of two --- BMI1 version', 'Is power of two --- BMI1 version Wojciech Mua Added on 2018-03-11 To check if a number is a power of two, the instruction BLSR from BMI1 extension can be used. The instruction resets the least set bit of a number, i.e. calculates (x - 1) and x . A sample C procedure that use the bit-trick: If a number has exactly one bit set then BLSR yields zero . However, when input of BLSR is zero, the instruction also yields zero. Fortunately, BLSR sets CPU flags in following way: ZF is set when result is zero, CF is set when input is zero (note that if CF is set, ZF is also set). Thanks to that we can properly handle all cases. Below is an assembly code: Sample program is available .'],
["notesen/2018-03-11-sse-abs-unsigned.html", 'SSE/AVX: absolute value of difference of unsigned integers', 'SSE/AVX: absolute value of difference of unsigned integers Wojciech Mua Added on 2018-03-11 With signed numbers it is really easy. We can subtract two numbers (instruction psub ) and then calculate abs directly, as all Intel\'s SIMD instruction sets support the abs operation. To calculate the abs of difference of two unsigned numbers we can use the saturated arithmetic . The saturated subtract (instructions psubusX ) is equivalent to max(a - b, 0) ; it means that whenever subtraction would yield a negative result, the final result is zero. We need to calculate two saturated subtracts, one for a - b , another for b - a ; then merge them with bitwise or -- it\'s safe, because one of the subtract results is zero. Below is an SSE implementation; full source code is available .'],
["notesen/2018-03-14-set-intersection.html", 'Intersection of ordered sets', 'Intersection of ordered sets Wojciech Mua Added on 2018-03-14 Updated on 2018-03-16 Contents Introduction Binary search When it is profitable? SIMD algorithm Evaluation Westmere M540 (Core i5) Skylake 6700 (Core i7) Conclusions Introduction The intersection of two sets represented by sorted collections (like lists or arrays) can be done in linear time. If we label with [...] [...] [...] Below is a naive C++ implementation; the C++ standard library comes with std::set_intersection . If there is a huge difference between sizes of collections, then we might use two different approaches described below. I use terms \"smaller\" ( [...] [...] Binary search In this approach we iterate over the smaller collection. For each item the binary search on the larger collection is performed. The complexity of this solution is [...] A clear disadvantage is that at least the larger collection must support random access. It must be an array, a vector or something similar. To make a practical implementation faster, we utilize the fact that both collections are sorted. In each iteration we are not looking for an equal element but for the first element which is greater or equal to the searched one. Thanks to that the searched range is narrowed after each iteration: the part of the larger collection containing elements smaller than the elements already tested is never touched again. It doesn\'t change the asymptotic complexity, though. In C++ the function std::lower_bound implements this look up; it\'s a modification of the binary search algorithm. Below is a C++ implementation. When it is profitable? Lets assume that the number of operations in the linear algorithm is exactly [...] [...] We start with an obvious inequality: [...] [...] [...] If the proportion [...] [...] the linear algorithm will perform better . After a simple transformation we get the threshold for size of the smaller set: [...] For example, if [...] [...] [...] [...] SIMD algorithm A SIMD approach is vectorized linear algorithm in which a single value from the smaller set is compared with vectors read from the larger set. Thanks to that the number of comparisons is smaller and we can faster skip parts of the larger collection. In the example below we assume that the first element of the smaller collection is 9, and the head of the larger collection contains values [-5, 1, 2, 5, 7, 8, 9, 12]. Fill the vector A with the first item from the smaller collection: Load into another vector B a part of the larger collection: Compare B < A : If all items in B are smaller (all bits of the comparison vector are set), then load the next chunk into B : And keep comparing with A ; now B < A vector is equal: The result vector contains some zero items. It means that B may contain the value present in A . If it\'s true (in the example it is), save this value in the output collection. In either case fill A with the next value from the smaller collection and again compare with B . Below is a sample implementation that uses SSE instructions. Evaluation Experiment: The larger collection is a C++ std::vector<int32_t> that has got 1024 * 1024 random elements. The size of smaller table varies. It is always a subset of the larger collection. Intersection is done 1000 times and the minimum time is noted. Full source code is available . Westmere M540 (Core i5) size A size B size ratio std [us] SSE [us] binsearch [us] 128 1048576 8192.00 1802 666 16 x 2.71 x 112.62 256 1048576 4096.00 1803 670 37 x 2.69 x 48.73 384 1048576 2730.67 1807 672 53 x 2.69 x 34.09 512 1048576 2048.00 1807 674 69 x 2.68 x 26.19 640 1048576 1638.40 1816 684 84 x 2.65 x 21.62 768 1048576 1365.33 1817 685 97 x 2.65 x 18.73 896 1048576 1170.29 1820 690 112 x 2.64 x 16.25 1024 1048576 1024.00 1823 698 127 x 2.61 x 14.35 1152 1048576 910.22 1824 695 146 x 2.62 x 12.49 1280 1048576 819.20 1825 705 159 x 2.59 x 11.48 2560 1048576 409.60 1844 738 433 x 2.50 x 4.26 6400 1048576 163.84 1889 819 1009 x 2.31 x 1.87 2048 1048576 512.00 1837 724 319 x 2.54 x 5.76 3072 1048576 341.33 1851 750 549 x 2.47 x 3.37 4096 1048576 256.00 1863 770 719 x 2.42 x 2.59 5120 1048576 204.80 1875 796 863 x 2.36 x 2.17 6144 1048576 170.67 1888 817 982 x 2.31 x 1.92 7168 1048576 146.29 1900 836 1092 x 2.27 x 1.74 8192 1048576 128.00 1913 857 1180 x 2.23 x 1.62 9216 1048576 113.78 1927 876 1274 x 2.20 x 1.51 10240 1048576 102.40 1938 893 1349 x 2.17 x 1.44 20480 1048576 51.20 2059 1100 1892 x 1.87 x 1.09 51200 1048576 20.48 2388 1741 2878 x 1.37 x 0.83 Skylake 6700 (Core i7) size A size B size ratio std [us] SSE [us] AVX2 [us] binsearch [us] 128 1048576 8192.00 771 313 190 2 x 2.46 x 4.06 x 385.50 256 1048576 4096.00 772 316 192 8 x 2.44 x 4.02 x 96.50 384 1048576 2730.67 774 318 193 24 x 2.43 x 4.01 x 32.25 512 1048576 2048.00 775 320 195 38 x 2.42 x 3.97 x 20.39 640 1048576 1638.40 780 324 197 50 x 2.41 x 3.96 x 15.60 768 1048576 1365.33 780 326 199 59 x 2.39 x 3.92 x 13.22 896 1048576 1170.29 782 329 201 70 x 2.38 x 3.89 x 11.17 1024 1048576 1024.00 784 331 203 81 x 2.37 x 3.86 x 9.68 1152 1048576 910.22 785 334 204 90 x 2.35 x 3.85 x 8.72 1280 1048576 819.20 786 336 206 98 x 2.34 x 3.82 x 8.02 2560 1048576 409.60 801 361 224 178 x 2.22 x 3.58 x 4.50 6400 1048576 163.84 844 438 274 364 x 1.93 x 3.08 x 2.32 2048 1048576 512.00 796 351 217 148 x 2.27 x 3.67 x 5.38 3072 1048576 341.33 807 372 230 206 x 2.17 x 3.51 x 3.92 4096 1048576 256.00 818 391 244 258 x 2.09 x 3.35 x 3.17 5120 1048576 204.80 830 412 259 305 x 2.01 x 3.20 x 2.72 6144 1048576 170.67 841 431 271 351 x 1.95 x 3.10 x 2.40 7168 1048576 146.29 853 451 285 396 x 1.89 x 2.99 x 2.15 8192 1048576 128.00 864 471 299 438 x 1.83 x 2.89 x 1.97 9216 1048576 113.78 875 490 312 480 x 1.79 x 2.80 x 1.82 10240 1048576 102.40 886 510 325 520 x 1.74 x 2.73 x 1.70 20480 1048576 51.20 995 704 459 880 x 1.41 x 2.17 x 1.13 51200 1048576 20.48 1302 1292 881 1811 x 1.01 x 1.48 x 0.72 Conclusions When differences in size of sets is huge the presented approaches might be significantly faster. The algorithm that use binary search is faster, but the size ratio is strictly limited. Both SSE and AVX2 implementations perform better than linear search in circumstances when binary search become slower.'],
["notesen/2018-03-16-awful-part-of-cpp.html", 'An awful part of C++17', 'An awful part of C++17 Wojciech Mua Added on 2018-03-16 Updated on 2019-05-23 (info about parsing the sign character) The current state I was really happy when saw that C++17 finally introduced standard functions to parse integers and floats. It is a group of functions std::from_chars defined in the header charconv . Unfortunately, it was a fleeting moment of happiness. The proposed API quickly appeared to be awful. Lets look how the integer parser is defined (the floating-point parsers are similar): The API resembles old good C, with one important exception: it\'s not good at all. How one is supposed to use it in C++? Yes, to get a char pointer from a string iterator one need to write &*it . The alternative invocation is std::from_chars(input.c_str(), input.c_str() + input.size(), ...) . Both are ugly, aren\'t they? To make things funnier, from_chars recognizes the minus character, but not the plus character. Yes, it\'s not a misake --- you can convert string \"-42\" but for \"+42\" you\'ll get an error. Compare this with strtol , which was defined several decades ago: Daydreaming The function std::from_char is even more cumbersome than strtol . It adds nothing to the existing, established solution. More important fact is that apart from std::from_chars , the recent C++ standard added several pretty useful things, like std::optional , std::variant or std::string_view . What did prevent the committee from using these new facilities? Why not have a function like this one? We rarely need a detailed information about an error. Moreover, sometimes we even don\'t care about possible input errors. So why not allow a programmer to pass a default value? It\'s a common idiom. Finally, why the structure returned from std::from_chars is so poor? It might be something like this: Then using such a result would be more idiomatic: In conclusion: it might have been done way better. The problem has been already solved by many C++ libraries and programming languages; it\'s nothing new. I still can\'t find any reasonable answer why such a clumsy, unfriendly API was picked.'],
["notesen/2018-03-26-when-lock-does-not-lock.html", 'When lock does not lock --- C++ story', 'When lock does not lock --- C++ story Wojciech Mua Added on 2018-03-26 A few days ago I had compiled fresh GCC 8.0 from trunk and then compiled our product, just to see what we will have to fix in the future. And I found a nasty mistake. Lets start with a class that perhaps every project has. At first glance get() protects the shared resource; thanks to RTTI we don\'t have to care about locking and unlocking our mutex , as std::shared_lock internals care about this. However, the code doesn\'t work that way. Indeed, the line declares std::shared_lock variable. But the name of variable is mutex and the lock is constructed with no associated mutex . Thus, the lock doesn\'t lock anything. Of course, the correct declaration should be: Can we detected this kind of mistake? Yes, GCC has flag -Wshadow that warns when \"a local variable or type declaration shadows another variable, parameter, type, or class member (in C++), or whenever a built-in function is shadowed\": However, I found the mistake thanks to more aggressive -Wparentheses flag in GCC 8:'],
["notesen/2018-04-11-simd-is-sorted.html", 'Is sorted using SIMD instructions', 'Is sorted using SIMD instructions Wojciech Mua Added on 2018-04-11 Updated on 2018-04-25 (sync source codes with github version), 2018-04-18 (links to HN and reddit discussions, test performance of unrolled SSE and AVX2 procedures, and AVX512 procedures) Contents Introduction Vectorization Generic SIMD Sample SSE implementation SSE Sample implementation AVX2 Sample implementation Performance comparison Skylake Skylake-X See also Source code Introduction Recently, I came across a function that checks whether an array is sorted, i.e. if there is no element which would be greater than its successor. Below is a sample implementation: I was sure that such a trivial loop is autovectorized by all decent compilers. I checked this on Compiler Explorer and to my surprise none of compilers does it. This is the state for GCC 7.3 (and upcoming GCC 8.0), clang 6.0 and ICC 19. This text explores possible vectorization schemas. Vectorization In the following examples vectors of signed 32-bit integers are assumed. Generic SIMD The simplest vectorized solution is suitable for all SIMD flavours. In a loop two vectors are filled; one vector contains items a = input[0 .. k - 1] , another b = input[1 .. k] (where k is the vector size; for SSE k=4 , for AVX2 k=8 and for AVX512 k=16 ). Then the comparison for greater yields a vector a[i] > b[i] . If all its elements are zero (false) it means that in the range 0 .. k-1 the relation is not violated. Below is the outline of the algorithm\'s loop (with k=4 ): Load the first vector: Load the second vector: Compare curr > next : If any element of mask is not zero, then return false. Otherwise advance the input pointer by k and go back to 1. Sample SSE implementation SSE The generic approach has one issue. The vector next shares k-1 elements with curr , but we anyway read from the memory all k elements. With help of the SSE instruction _mm_palignr_epi8 ( palingr ) the number of memory accesses can be reduced. The instruction gets two 16-byte vectors, joins them into a 32-byte temporary array and then copies the selected subarray into a 16-byte vector. We keep two vectors ( chunk0 and chunk1 ) containing as a whole an eight-element subarray of the input. In each iteration this subarray is shifted right by one element. In each iteration we read just one chunk, i.e. it done at cost of single memory load. The algorithm works as follows: Before the main loop load into vector chunk0 the first portion of input: In the loop read the next portion of array into chunk1 : Now build the vector curr --- it is simply an alias for chunk0 : The vector next is build from the pair chunk1:chunk0 using _mm_alignr_epi8 : Finally the vectors are compared: If any element of mask is not zero, then return false. Shift right the input view: Advance the input pointer by 4 and go to 1. Sample implementation AVX2 Unfortunately the AVX2 version of _mm256_alignr_epi8 doesn\'t operate on the whole 32-byte register, but on its 16-byte halves ( lanes ). The AVX2 approach uses instruction _mm256_permutevar8x32_epi32 , which moves 32-bit elements across the lanes in the given order. In a single iteration we read eight elements: Then the vector curr is shifted (permuted) by one element right, only the last item ( a7 ) is kept on the same position: The comparison efficiently tests the first seven elements : Sample implementation Performance comparison Tested procedures scalar is_sorted SSE (generic) the generic SIMD algorithm using SSE instructions SSE (generic, unrolled 4 times) the above procedure unrolled 4 times AVX2 (generic) the generic SIMD algorithm using AVX2 instructions AVX2 (generic, unrolled 4 times) the above procedure unrolled 4 times AVX512 (generic) the generic SIMD algorithm using AVX512F instructions SSE SSE-specific procedure SSE (unrolled 4 times) implementation of the above procedure proposed by HeroicKatora on reddit; thank you! AVX2 AVX2-specific procedure AVX2 (unrolled 4 times) the above procedure unrolled 4 times; processes 4*7 items per iteration AVX512 AVX512 variant of the AVX2 approach Skylake Compiler: GCC 7.3.0 CPU: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz procedure time [us] speed-up element count 128 scalar 8080 1.00 SSE (generic) 2970 2.72 SSE (generic, unrolled 4 times) 1917 4.21 SSE 3696 2.19 SSE (unrolled 4 times) 1845 4.38 AVX2 (generic) 1769 4.57 AVX2 (generic, unrolled 4 times) 3216 2.51 AVX2 1945 4.15 AVX2 (unrolled 4 times) 1571 5.14 element count 256 scalar 13982 1.00 SSE (generic) 5022 2.78 SSE (generic, unrolled 4 times) 2865 4.88 SSE 7054 1.98 SSE (unrolled 4 times) 3139 4.45 AVX2 (generic) 4037 3.46 AVX2 (generic, unrolled 4 times) 4395 3.18 AVX2 3722 3.76 AVX2 (unrolled 4 times) 2263 6.18 element count 512 scalar 25039 1.00 SSE (generic) 9222 2.72 SSE (generic, unrolled 4 times) 5951 4.21 SSE 13525 1.85 SSE (unrolled 4 times) 6407 3.91 AVX2 (generic) 6806 3.68 AVX2 (generic, unrolled 4 times) 6850 3.66 AVX2 6759 3.70 AVX2 (unrolled 4 times) 5071 4.94 element count 1024 scalar 46586 1.00 SSE (generic) 17792 2.62 SSE (generic, unrolled 4 times) 10671 4.37 SSE 26160 1.78 SSE (unrolled 4 times) 11598 4.02 AVX2 (generic) 12483 3.73 AVX2 (generic, unrolled 4 times) 11602 4.02 AVX2 12346 3.77 AVX2 (unrolled 4 times) 8770 5.31 element count 2048 scalar 86920 1.00 SSE (generic) 34936 2.49 SSE (generic, unrolled 4 times) 20131 4.32 SSE 51254 1.70 SSE (unrolled 4 times) 21978 3.95 AVX2 (generic) 23776 3.66 AVX2 (generic, unrolled 4 times) 21038 4.13 AVX2 23976 3.63 AVX2 (unrolled 4 times) 17327 5.02 element count 4096 scalar 171457 1.00 SSE (generic) 68884 2.49 SSE (generic, unrolled 4 times) 39006 4.40 SSE 101823 1.68 SSE (unrolled 4 times) 42858 4.00 AVX2 (generic) 46424 3.69 AVX2 (generic, unrolled 4 times) 39651 4.32 AVX2 47139 3.64 AVX2 (unrolled 4 times) 33659 5.09 element count 16384 scalar 671985 1.00 SSE (generic) 311616 2.16 SSE (generic, unrolled 4 times) 210776 3.19 SSE 409935 1.64 SSE (unrolled 4 times) 191207 3.51 AVX2 (generic) 210032 3.20 AVX2 (generic, unrolled 4 times) 207815 3.23 AVX2 219203 3.07 AVX2 (unrolled 4 times) 164703 4.08 element count 65536 scalar 2587279 1.00 SSE (generic) 1258949 2.06 SSE (generic, unrolled 4 times) 870655 2.97 SSE 1645715 1.57 SSE (unrolled 4 times) 796933 3.25 AVX2 (generic) 850206 3.04 AVX2 (generic, unrolled 4 times) 860592 3.01 AVX2 899470 2.88 AVX2 (unrolled 4 times) 724050 3.57 Skylake-X Compiler: GCC 5.4.0 CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz procedure time [us] speed-up element count 128 scalar 6091 1.00 SSE (generic) 2634 2.31 SSE (generic, unrolled 4 times) 2084 2.92 SSE 3329 1.83 SSE (unrolled 4 times) 2327 2.62 AVX2 (generic) 1648 3.70 AVX2 (generic, unrolled 4 times) 2191 2.78 AVX2 1774 3.43 AVX2 (unrolled 4 times) 1657 3.68 AVX512 (generic) 1367 4.46 AVX512 1150 5.30 element count 256 scalar 11445 1.00 SSE (generic) 5008 2.29 SSE (generic, unrolled 4 times) 3363 3.40 SSE 6593 1.74 SSE (unrolled 4 times) 3976 2.88 AVX2 (generic) 3021 3.79 AVX2 (generic, unrolled 4 times) 2954 3.87 AVX2 3455 3.31 AVX2 (unrolled 4 times) 2061 5.55 AVX512 (generic) 1938 5.91 AVX512 2012 5.69 element count 512 scalar 22133 1.00 SSE (generic) 12736 1.74 SSE (generic, unrolled 4 times) 6163 3.59 SSE 14349 1.54 SSE (unrolled 4 times) 7268 3.05 AVX2 (generic) 5937 3.73 AVX2 (generic, unrolled 4 times) 5141 4.31 AVX2 8279 2.67 AVX2 (unrolled 4 times) 4053 5.46 AVX512 (generic) 3094 7.15 AVX512 3562 6.21 element count 1024 scalar 43534 1.00 SSE (generic) 24440 1.78 SSE (generic, unrolled 4 times) 12885 3.38 SSE 27446 1.59 SSE (unrolled 4 times) 13877 3.14 AVX2 (generic) 12664 3.44 AVX2 (generic, unrolled 4 times) 7503 5.80 AVX2 14728 2.96 AVX2 (unrolled 4 times) 8034 5.42 AVX512 (generic) 5380 8.09 AVX512 5443 8.00 element count 2048 scalar 86305 1.00 SSE (generic) 47782 1.81 SSE (generic, unrolled 4 times) 24381 3.54 SSE 53797 1.60 SSE (unrolled 4 times) 27908 3.09 AVX2 (generic) 24044 3.59 AVX2 (generic, unrolled 4 times) 13547 6.37 AVX2 28291 3.05 AVX2 (unrolled 4 times) 15484 5.57 AVX512 (generic) 10813 7.98 AVX512 11200 7.71 element count 4096 scalar 171882 1.00 SSE (generic) 94751 1.81 SSE (generic, unrolled 4 times) 47284 3.64 SSE 106064 1.62 SSE (unrolled 4 times) 54288 3.17 AVX2 (generic) 47036 3.65 AVX2 (generic, unrolled 4 times) 26236 6.55 AVX2 55040 3.12 AVX2 (unrolled 4 times) 29973 5.73 AVX512 (generic) 19904 8.64 AVX512 21735 7.91 element count 16384 scalar 685498 1.00 SSE (generic) 417421 1.64 SSE (generic, unrolled 4 times) 266764 2.57 SSE 438934 1.56 SSE (unrolled 4 times) 239919 2.86 AVX2 (generic) 204391 3.35 AVX2 (generic, unrolled 4 times) 181020 3.79 AVX2 253740 2.70 AVX2 (unrolled 4 times) 165795 4.13 AVX512 (generic) 182358 3.76 AVX512 117629 5.83 element count 65536 scalar 2740076 1.00 SSE (generic) 1663774 1.65 SSE (generic, unrolled 4 times) 1062554 2.58 SSE 1756262 1.56 SSE (unrolled 4 times) 938962 2.92 AVX2 (generic) 973695 2.81 AVX2 (generic, unrolled 4 times) 792764 3.46 AVX2 1011261 2.71 AVX2 (unrolled 4 times) 660586 4.15 AVX512 (generic) 729784 3.75 AVX512 467945 5.86 See also Great discussion on Hacker News . Also an interesting one on cpp/reddit Source code All implementations are available on github .'],
["notesen/2018-04-14-accidental-recursion.html", 'Accidental recursion', 'Accidental recursion Wojciech Mua Added on 2018-04-14 Another bug I bumped into. There is the enum: And the associated ostream operator, which is merely a switch; all operators for enums look like this. The author clearly wanted to handle all possible cases, including invalid enum values, that might appear due to memory corruption or simply as a result of invalid casting. Sadly, the handler would fail in such an erroneous case --- there is an infinite recursion in the default case. The correct solution would be extract enumeration type and print it as a numeric value: This is not the nicest code in the world, but does the job well.'],
["notesen/2018-04-19-simd-parsing-int-sequences.html", 'Parsing series of integers with SIMD', 'Parsing series of integers with SIMD Wojciech Mua Added on 2018-04-19 Updated on 2020-07-05 (fixed a typo in conversion 2-digit numbers , thank to Alexander Vingardt ), 2020-03-30 (added method decimal_digits_mask_version2 by Carl Witty ), 2020-03-29 (fixed a typo, thanks to Carl Witty ), 2018-04-30 (info about overflows ), 2018-04-25 (added speed-up comparison table ) 1 Introduction While conversion from a string into an integer value is feasible with SIMD instructions, this application is unpractical. For typical cases, when a single value is parsed, scalar procedures --- like the standard atoi or strtol --- are faster than any fancy SSE code. However, SIMD procedures can be really fast and convert in parallel several numbers. There is only one \"but\": the input data has to be regular and valid, i.e. the input string must contain only ASCII digits. Recently, I updated article about SSE parsing with the benchmark results. The speed-ups are really impressive, for example the SSSE3 parser is 7 to 9 times faster than a naive, scalar code. The obvious question is how these powerful SIMD procedures can be used to convert real data? By real I mean possibly broken inputs that contain series of numbers of different length separated with characters from a predefined set. In this text I try to answer that question; major contributions of this article are: Methods to efficiently parse and validate such strings using SSE instructions. There is a special variant that handles only unsigned numbers and also a fully featured variant for signed numbers. Boosting the SSE procedure with AVX2 or AVX512 instructions when possible. A way to combine some of SIMD techniques with scalar conversions. The article starts with unsigned conversion, because it is easier than a signed one. The signed conversion shares the core idea, it just adds some extra steps. The text is accompanied with BSD-licensed software, that includes fully functional implementations alongside the programs which validate and benchmark the procedures. Contents 1 Introduction 2 Parser specification 3 SSE conversion capabilities 3.1 Range checking 3.2 Sample implementation 4 Parsing and conversions of unsigned numbers 4.1 Algorithm overview 4.2 Normalizing input 4.3 Precalculating data 4.3.1 Example 4.4 SSE algorithm outline 4.5 Detecting invalid inputs 4.5.1 Detecting digits 4.5.2 Detecting characters from set 4.5.2.1 SSE & AVX2 4.5.2.2 SSE4.2 4.6 Caveats 5 Parsing and conversion of signed numbers 5.1 Algorithm 5.2 Implementation note 5.3 Detecting invalid inputs 5.3.1 AVX512VBMI 5.4 SSE algorithm outline 6 Processing larger inputs 7 Scalar hybrid 7.1 Example 8 Appendix A --- conversion of three-digit numbers 9 Appendix B --- conversion of two four-digit numbers 10 Reference scalar procedures 11 Experiments 11.1 SSE conversion --- execution statistics 11.1.1 Overview 11.1.2 SSE routines calls 11.2 SSE conversion --- runtime analysis 11.2.1 Input size 4,096 bytes 11.2.2 Input size 65,536 bytes 11.3 Performance comparison 11.3.1 Tested procedures 11.3.2 Tests setup 11.3.3 Core i7 results 11.3.3.1 Input size 4096 bytes 11.3.3.2 Input size 65536 bytes 12 Conclusions 13 Acknowledgements 14 See also 15 Source code 2 Parser specification The input is defined as follows: It is a string of arbitrary length; but it should be large, say a few kilobytes or megabytes. The input contains integer numbers. A number is an optional sign character \'+\' or \'-\' followed by a non-empty sequence of digits \'0\'..\'9\'. Numbers are separated with characters from a user-defiend set; for instance, it might be the comma and blank characters (space, new line, etc.). All characters other than digits, separators and signs are considered invalid. Parser must be able to check validity of the input, i.e. lack of invalid characters and the proper input format (numbers are separated with at least one character, sign characters are present only at the beginning of a number). For the input string \"123; -52, +432424 -999; 1234568, +879\", and three separators \',\', \';\' and \' \', an algorithm is expected to extract six integers: [123, -52, 432424, -999, 1234568, 879]. The order of converted numbers must be exactly the same as in the input string. A simplified parser is also tested. This parser simply considers all non-digit and non-sign characters as delimiters. 3 SSE conversion capabilities SSE instructions work on 16-byte vectors. When the input numbers have the same count of digits and the digits of each number are placed --- depending of the digits count --- on bytes, words, double words or quad words of an SSE vector, then an SSE procedure converts them in parallel . Below are required layouts of vectors; the most significant digit is at index 0 of each subword. 16 one-digit unsigned numbers a .. p : 8 two-digit unsigned numbers a .. h : 4 four-digit unsigned numbers a .. d : and 2 eight-digit unsigned numbers a and b : The conversion is done gradually. We start with an input vector filled with ASCII digits \'0\'..\'9\'; each byte of a vector contains single character. For string \"1234567890123456\" we have: A single subtract _mm_subs_epu8 ( psubusb ) converts from ASCII into numbers 0..9: At this point we converted 16 one-digit numbers. Now, by merging adjacent numbers from t0 , we may obtain two-digit numbers. SSSE3 introduced the instruction _mm_maddubs_epi16 ( pmaddubsw ) which multiplies vectors of bytes and adds intermediate 16-bit values producing a vector of 16-bit values. Thus, when we multiply t0 by a vector filled with weights (1, 10) we get eight two-digit numbers, each saved on a 16-bit field: Similarly, these numbers can be merged into four-digit numbers. SSE has the instruction _mm_madd_epi16 ( pmaddwd ) which performs similar operation as _mm_maddubs_epi16 , but works on 16-bit values and yields vector of 32-bit numbers. The other vector is filled with weights (1, 100) and we get four four-digit numbers, each saved on a 32-bit field: Four-digit numbers fits into 16-bit values, we might convert the above result into a 16-bit vector using _mm_packus_epi32 ( packusdw ) and again apply the _mm_madd_epi16 instruction, this time with weights (1, 10000). Then we get two eight-digit numbers: To summarize: conversion from a 16-digit string into two unsigned eight-digit numbers requires only one subtract, three multiply-add instructions and one pack operation. If we need narrower numbers we simply stop the above procedure at an earlier step; for example, for four-digit numbers the result is t2 . Since the intermediate vectors have different element size (8-, 16-, 32-bit) a cast to other vector type might be needed. Widening can be done with the instructions pmovsx (intrinsics _mm_cvtepi16_epi32 , _mm_cvtepi8_epi32 , etc.); narrowing with the mentioned pack instruction which is also available in different variants. The same conversion using a naive scalar procedure would require 16 subtracts, 14 multiplications and 14 additions. More advanced SWAR procedures would require fewer multiplications, but still not as few as the SIMD procedure. 3.1 Range checking The maximum possible value from SSE conversion procedure is [...] [...] [...] never cause overflow (signed nor unsigned). Obviously, for 16-bit outputs, overflow is possible. For such case an extra step would be required, but I do not discuss it in this text. 3.2 Sample implementation Below is a sample SSE implementation which shows all described steps. 4 Parsing and conversions of unsigned numbers 4.1 Algorithm overview 4.2 Normalizing input 4.3 Precalculating data 4.3.1 Example 4.4 SSE algorithm outline 4.5 Detecting invalid inputs 4.5.1 Detecting digits 4.5.2 Detecting characters from set 4.5.2.1 SSE & AVX2 4.5.2.2 SSE4.2 4.6 Caveats 4.1 Algorithm overview The conversion algorithm works in a loop, in each iteration exactly one input vector is loaded from memory and processed. The vector is validated. Depending on the layout of the digits, the input is normalized to the format required by the SIMD procedures. At this step we choose: how many numbers from the input are converted and which SIMD procedure is suitable for conversion. After conversion, the input pointer is advanced and the loop continues. 4.2 Normalizing input Since SIMD procedures impose specific layout of digits within a vector, an arbitrary input has to be properly aligned. In order to do this, we need to identify spans of digits in the input and move each span onto certain subarrays of a vector. Let\'s assume at this point that the input contains either digits or separators (denoted with _ ). For instance, the vector with one-digit numbers 1___2_3__4__5_6_ must be transformed into 123456__________ . Then an SSE procedure will convert in parallel all the numbers into the array [1, 2, 3, 4, 5, 6]. Likewise, the vector with two-digit numbers _12__34___56_78_ must be transformed into 12345678________ and then the result will be [12, 34, 56, 78]. Let\'s consider a more complicated case, when a string has numbers with different count of digits. There are a few ways to convert the input _1_2_34_567_89__ : If we choose conversion of one-digit numbers, then just the two first spans can be converted --- because we need to keep the order of numbers from the input. After normalization the input into 12______________ just two values [1, 2] will be produced. The input\'s tail _34_567_89__ remain untouched. If we choose conversion of two-digit numbers, then the three first spans can be converted. Shorter numbers are completed with zeros, then normalized input is 010234__________ . The result is [1, 2, 34]; this time a bit shorter input\'s tail _567_89__ remain untouched. Finally, if we choose conversion of four-digit numbers, then the four first spans can be converted. Again, shorter numbers are completed with zeros, and normalized input is 0001000200340567 . The result is [1, 2, 34, 567], but still the chunk\'s tail, i.e. _89__ , is unprocessed. We can see that in order to convert given span combination we need to know: How to shuffle bytes in the input vector? Which SIMD procedure can be used then? How many numbers converted by the SIMD procedure must be stored? Obtaining this information seems to be quite complicated, especially when we look at the last example. Fortunately, all parameters can be precalculated . A span combination can be saved as a bit-pattern, where ones represent digits. For example, from vector _1_2_34_567_89__ we get the span pattern 0b0101011011101100 = 0x56ec . A span pattern is used to fetch a record from the precalculated array. The record contains following fields: shuffle_digits --- an array of 16 bytes, which is the argument for the instruction _mm_shuffle_epi8 ( pshufb ); the instruction moves bytes at certain positions; conversion_routine --- an enumeration that selects an SSE conversion procedure; for instance, it tells that shuffled input is an array of two-digit numbers; element_count --- the number of elements from the SSE conversion procedure that must be stored in the output collection. The solution with a precalculated array is suitable only for SSE, as span patterns have 16 bits. In cases of AVX2 and AVX512, where vectors are wider, such a table would be simply too large, respectively [...] [...] pshufb instruction works on lanes, i.e. 128-bit halves of a vector, thus it is impossible to shuffle all inputs. But AVX2 and AVX512 instructions still might be used in some parts of algorithms, especially in input validation. 4.3 Precalculating data To build the whole precalculated table all 65536 span patterns have to be processed. Processing a pattern consists following steps: Determine digit spans . For pattern _ddd__d__ddd_dd_ we have four spans [(1,3), (6,6), (9,11), (14,15)]. But for pattern ____dddd___ddddd there is only one span [(4,7)]. The span at the vector\'s end might be continued in the next chunk, and we don\'t know how to convert it. However, we may assume that a span which starts at the vector\'s beginning is a new number and thus it is included into the span\'s list. Find the best conversion scheme for the spans . We systematically check which SSE conversion is possible, i.e. one-/two-/four-/eight-digit and how many spans each conversion can process --- the procedure which processes the most items is selected. The output from this step are values for the following record fields: element_size --- 1, 2, 4, 8 or 0 if SSE conversion is not possible; element_count --- the numbers of converted spans; total_skip --- how many input bytes are processed; for pattern ____dddd________ we know that the whole input is processed ( total_skip=16 ); for pattern ____d____ddddd_d we process only the first span at index 5, but we know that four non-digit characters after the span can be also skipped, thus total_skip is 9. Construct the shuffle pattern . Having the element size and spans positions the vector shuffle_digits is built. The characters from a span are mapped on the appropriate subarrays in the vector. Also zero completion is done in this step, as the instruction pshufb either copy given byte from the input vector or put zero if the index has got the most significant bit set. 4.3.1 Example Let\'s consider span pattern _ddd__d__ddd_dd_ . It can be converted using four-digit conversion, so the layout of normalized vector should be: There are four numbers a , b , c and d in the vector; note that the bytes at 0th index hold the most significant digits. The first number in pattern has three digits at indices 1, 2 and 3. It means that a1 = 1 , a2 = 2 and a3 = 3 ; value of a0 should be zeroed, so a0 = 0x80 . The second number has just one digit at index 6. Thus b3 = 6 and, since the rest digits have to be zero, b0 = b1 = b2 = 0x80 . The third number has three digits at indices 9, 10, 11. Thus c1 = 9 , c2 = 10 , c3 = 11 , and c0 = 0x80 . The last, forth number, has got two digits at indices 14 and 15. Thus d2 = 14 , d3 = 15 and the rest have to be zero, so d0 = d1 = 0x80 . The final content of the shuffle_digits vector is: 4.4 SSE algorithm outline Below are major steps of the algorithm\'s loop, with snippets from the actual implementation. Load 16 characters into the input vector. Check for invalid characters (will be discussed later ). Build the span pattern: Fetch the block info with the precalculate parameters. From the block info get the shuffle pattern for _mm_shuffle_epi8 . The shuffled vector is then issued to the proper conversion routine. The block info structure keeps the conversion kind ( conversion_routine ) and also the number of items to get from the SSE result ( element_count ). It is not always possible to use any SSE conversion procedure, thus a scalar code is needed to handle odd cases. Advance the input pointer. The block info structure keeps how many bytes were actually covered. 4.5 Detecting invalid inputs In case of unsigned inputs we need to classify input characters into three categories: digits, i.e. chars \'0\' .. \'9\'; user-defined set of separators; invalid numbers. In practise we need two masks: one with positions of digits, another with positions of separators. If the or\'ed mask has some zero elements, it means that there are invalid characters. Below is a schema: 4.5.1 Detecting digits The easiest algorithm implements expression c >= \'0\' and c <= \'9\' : Following C-expression requires only one subtraction and one comparison: However, it requires unsigned comparison, which is not available in both SSE and AVX2. Only AVX512BW defines such instruction _mm512_cmple_epu8_mask ( vcmpgtub ). Fortunately, it\'s possible to use similar trick for signed bytes, we need just different constants. First, we subtract from the input byte value (ord(\'0\') + 128) & 0xff = 176 & 0xff = 80 . This moves codes of \'0\'..\'9\' to range -128..-119. Then it\'s sufficient to compare subtracted value with -118. 4.5.2 Detecting characters from set 4.5.2.1 SSE & AVX2 The most generic SSE implementation works in time proportional to the size of a separators set. Each character from the set is broadcast into a vector and then compared with the input vector. The resulting byte mask is ored with the previous result. If the separators set is known at compilation time, then a compiler may unroll the loop. 4.5.2.2 SSE4.2 The SNTI instruction pcmpestrm ( _mm_cmpestrm ) from SSE4.2 can also be used in same cases. The instruction gets two arguments. One is an input vector. Another one is interpreted either as a set of individual characters (up to 16) or characters ranges (up to 8). The result is a mask for the input characters matching the set (or ranges). In the example below the set variant was used. 4.6 Caveats It is unlikely, and sometimes impossible, to process all digits from the input vector. In a single iteration one to 16 bytes are converted. The table below shows details --- an important conclusion is that almost 95% of patterns process at least half of an input vector. bytes processed patterns % cumulative % 0 17 0.03% 0.03% 2 32 0.05% 0.07% 3 48 0.07% 0.15% 4 176 0.27% 0.42% 5 360 0.55% 0.97% 6 542 0.83% 1.79% 7 693 1.06% 2.85% 8 1084 1.65% 4.50% 9 1620 2.47% 6.98% 10 2274 3.47% 10.45% 11 3057 4.66% 15.11% 12 4526 6.91% 22.02% 13 6193 9.45% 31.47% 14 8952 13.66% 45.13% 15 12890 19.67% 64.79% 16 23072 35.21% 100.00% However, the input validation is always done for the whole vector, all 16 bytes. This problem might be overcome, see Processing larger inputs . SSE units are underutilized. The longest one-digit number sequence is \"1;2;3;4;5;6;7;8;\". It contains eight numbers, while the SSE procedure is able to process 16 numbers. Likewise, the longest two-digit number sequence is \"12;34;56;78;98;;\". It has five numbers, but the SSE procedure is able to convert eight numbers. Similarly, the longest four-digit numbers sequence is \"1234;5678;9123;;\" --- it has three four-digit numbers, the SSE procedure is able to convert four numbers. SSE procedure usage in parser converted numbers average utilization input size converted nums # % avg max N/A --- 264 0.40% --- --- --- 1-digit 16 5799 8.85% 3.52 8 22% 2-digit 8 21241 32.41% 3.99 7 49% 4-digit 4 30924 47.18% 3.48 4 87% 8-digit 2 7308 11.15% 1.97 2 98% 5 Parsing and conversion of signed numbers 5.1 Algorithm 5.2 Implementation note 5.3 Detecting invalid inputs 5.3.1 AVX512VBMI 5.4 SSE algorithm outline 5.1 Algorithm Similarly to the unsigned conversion, the signed conversion also requires a span pattern . But in this case also the sign characters \'+\' and \'-\' are included in the pattern. For this sample string: the span pattern is: The conversion unfortunately requires two shuffles: Shuffle spans onto proper vector elements --- this is exactly the same as in unsigned conversion. Populate the first span characters, i.e. possibly sign character , on the proper vector elements. For input: The conversion processes four four-digit numbers. After shuffling the digit spans we have: and the vector of sign characters is: The shuffled_signs vector does not necessarily contain only \'+\' or \'-\', it might contain also digits, but this is not an error. Then the conversion works as follows: From the shuffled vector the sign characters are removed and ASCII characters are converted into values: Thus we end up with a vector of unsigned numbers, and such an input can be converted by the already defined SSE procedures: Finally, negate appropriate elements; we use a well known equation (~x + 1) , which is expressed in the SSE code as (x xor (-1) - (-1)) . The value -1 is obtained from comparing shuffled_signs with the \'-\': or as vector of int32_t : 5.2 Implementation note Masking of the sign characters in shuffled vector is done at no cost, as the instruction _mm_subs_epu8 ( psubusb ) is used to convert from ASCII to numeric values: The instruction performs subtract with saturation , i.e. calculates max(0, a-b) . Since the ASCII codes of \'-\' and \'+\' are respectively 43 and 45 and the ASCII code of \'0\' is 48, then the result of such expression is zero for both sign characters. 5.3 Detecting invalid inputs The characters \'+\' and \'-\' can be present only at the beginning of a digit span, i.e. we want to reject inputs like \"++12\" or \"1234-,\". To properly validate the input we need four masks for: separators, digits, the character \'-\', the character \'+\'. The first phase is similar to the unsigned conversion, i.e. all masks are or\'ed together, then zero elements point at invalid characters. The second phase checks if sign characters are placed properly. For each span combination we need to precalculate the mask of valid sign positions. Then, after or\'ing the masks for the \'+\' and \'-\' we simply verify if they are placed on valid positions. In practise the precalculated data has a bit-mask for invalid sign positions, thanks to that validation require just a simple and. The snippet below shows the schema of the second step. 5.3.1 AVX512VBMI AVX512VBMI defines the powerful instruction _mm512_permutex2var_epi8 ( vperm2b ) which does a lookup in a 128-byte table using as the indices the seven lowest bits of each byte of a ZMM register. Invocation of the intrinsics function is weird: If the set of valid character fits in the standard ASCII character set, i.e. just seven lowest bits are set, then the validation step might quickly reject extended ASCII (7th bit set) and then translate the input using single invocation of _mm512_permutex2var_epi8 . When full 8-bit input is allowed, then the instruction has to be called twice with two halves of a 256-byte lookup. An invocation (or two) of this instruction allows to classify at once all 64 input bytes into required categories: separators --- it doesn\'t matter how many separator chars are used; digits; and sign characters. Category is encoded as a bit at certain position, in sample implementation following schema is used: separator = 0x01 , digit = 0x80 , sign = 0x80 | 0x40 . If the transformed vector contains zero byte, it means there are invalid characters. The span pattern is obtained from the most significant bits by the instruction _mm512_movepi8_mask ( vpmovb2m ); it works exactly the same way as pmovmaskb from SSE. The sign pattern is obtained by the instruction _mm512_test_epi8_mask ( vptestmb ), by testing bit 7th (mask 0x40 ). Below is a snippet from the implementation: 5.4 SSE algorithm outline Below are major steps of the algorithm\'s loop, with snippets from the actual implementation. Load 16 characters into the input vector. Check for invalid characters (as described above ). Build the span pattern and fetch the conversion parameters. Validate if the sign characters are properly placed. If sign_mask is zero, choose faster unsigned conversion path. Otherwise prepare data for signed conversion. And finally invoke proper conversion routine. 6 Processing larger inputs As it was stated in Caveats section, a single step of algorithm validates the whole input vector but rarely converts all bytes from the input. Although detecting digits and sign characters might be considered cheap, we saw that validating against an arbitrary set of separators might be really time consuming. The idea is to separate the validation from the conversion. In case of the unsigned conversion only the span_mask is needed; in case of the signed conversion we need also sign_mask . In each iteration we process four 16-byte chunks. The result from this step are 64-bit masks. Then, we load 16 bytes into the input vector and use the lower 16-bit part of already calculated mask to get block info for the loaded code. For unsigned conversion the main loop looks like this: And after applying the proposed change: The problem of this solution is multiple reading the input bytes. Moreover, the looping schema is more complicated; especially in practice, where also scalar fallback have to be considered (it is not shown here). 7 Scalar hybrid The idea of separation the validation step from the actual conversion might also be applied for scalar parser. The validation, i.e. building a span_mask is done by SIMD code. Then, each byte of the span_mask is processed by a precompiled code for each of 256 cases. There are two major advantages: 1. Scalar conversions are called with compile-time constants, thanks to that a compiler can perform as many optimizations as possible. 2. Digits spans that cross byte boundary can be processed seamlessly. When a span ends at the byte\'s end, a conversion routine converts all characters from the input\'s chunk and marks that the conversion is not completed. When the next pattern is processed, the mark is checked: if the first bit of the current pattern is zero, it means that the previously converted number is ready and can be saved. If the first bit is one, it means that the first span is continuation and thus conversion must be carried on from the saved point. 7.1 Example Let\'s convert following input 24-byte input (the space separates 8-byte chunks): The first chunk of input is _12_3_45 , i.e. the span_pattern = 0b01101011 = 0x6b . The digit spans are [(1,2), (4,4), (6,7)], following code handles them: The template convert is parametrized by the number of digits to convert and gets a pointer to the first character. The important fact is such code doesn\'t need to validate pointers, sizes etc. All is known in the compile-time. The next input\'s chunk is 6_7890_1 , the digit spans are [(0,0), (2,5), (7,7)]. A variant of template convert that accepts two parameters simple starts conversion from the saved state ( val ). The last, third chunk, is ___99___ , and there is just one digit span [(3,4)]: 8 Appendix A --- conversion of three-digit numbers When the input vector contains an array of three-digit numbers, like \"123;456;789;123;\", we still use four-digit conversion routine. But we might utilize the fact that the most significant digit is always zero. We use _mm_maddubs_epi16 , but with weights 1, 10, 100, 0: two lower digits are converted and the most significant digit is properly scaled. Then simple horizontal add _mm_hadd_epi16 adds the intermediate results. 9 Appendix B --- conversion of two four-digit numbers Where two four-digits are going to be converted, a faster approach can be used. Instead of storing each digit on separate bytes, digits are stored on 16-bit values. Then a single _mm_madd_epi16 is used to multiply all digits by weights 1, 10, 100, 1000. Then the result\'s halves are added with _mm_hadd_epi32 ( phaddd ). 10 Reference scalar procedures There are two reference scalar implementations: a fully specialized, handcrafted parser; parser based on two standard functions: strspn and strtol . The handcrafted source: And implementation based on standard functions: 11 Experiments This part presents evaluation of algorithms in terms of running time (performance tests) and also some statistical measurements that might help in understanding run-time properties. 11.1 SSE conversion --- execution statistics 11.1.1 Overview 11.1.2 SSE routines calls 11.2 SSE conversion --- runtime analysis 11.2.1 Input size 4,096 bytes 11.2.2 Input size 65,536 bytes 11.3 Performance comparison 11.3.1 Tested procedures 11.3.2 Tests setup 11.3.3 Core i7 results 11.3.3.1 Input size 4096 bytes 11.3.3.2 Input size 65536 bytes Following parameters of the input data are being changed: Input size in bytes. Distribution of number of digits: fixed size from 1 to 8 digits [only in overall performance tests]; uniform distribution over range 1 to k, where k = 1..8; Gaussian distribution with mu = 1..8 (sigma = 1.0). Distribution of count of separators between numbers: exactly one separator character, uniform distribution of 1 to 6 separators. Uniform distribution of the set: no-sign-char, \'+\' and \'-\'. 11.1 SSE conversion --- execution statistics Caveats shows statistics of 1) average processed bytes and 2) SSE utilization. This section presents real numbers gathered during conversion of 1000000 bytes containing 1-8 digit signed numbers. 11.1.1 Overview loops 90\'790 ... different span patterns 1\'315 total numbers converted 162\'228 100.00% conversion handled by scalar fallbacks 13\'601 8.38% conversions done by SSE procedures 148\'627 91.62% ... unsigned SSE parser 6\'222 N/A ... signed SSE parser 142\'405 As we see, most conversions were done by the SSE code; moreover, most conversions went through the signed parser, which is slower than unsigned counterpart. Another important number, which may give a hint about possible cache misses to the block_info structure, is the count of different span patterns. It is 1315 (~2% of the whole table size, 65536), but only 120 of them were processed in 75% iterations. The next section shows this parameter in details. 11.1.2 SSE routines calls Below are detailed statistics for SSE routines: calls --- how many times the procedure was called; converted --- how many numbers were parsed; conv/call --- average utilization. Conversions 1-/2-/4-/8-digits are described in section SSE conversion capabilities , the 3-digit procedure in Appendix A --- conversion of three-digit numbers . procedure unsigned path signed path calls converted conv/call calls converted conv/call 1-digit conversion 325 410 1.26 N/A N/A N/A 2-digit conversion 21 48 2.29 1949 3521 1.81 3-digit conversion 21 43 2.05 1409 2246 1.59 4-digit conversion 239 581 2.43 10569 26255 2.48 8-digit conversion 2887 5140 1.78 59769 110383 1.85 The table below shows how many bytes from the input vector were processed in single iteration. It is pretty close to average numbers showed in Caveats . bytes processed patterns % cumulative % 0 0 0.00% 0.00% 1 0 0.00% 0.00% 2 197 0.26% 0.26% 3 583 0.76% 1.01% 4 773 1.00% 2.01% 5 1137 1.47% 3.48% 6 1841 2.39% 5.87% 7 2544 3.30% 9.17% 8 5305 6.87% 16.04% 9 9135 11.83% 27.87% 10 7163 9.28% 37.15% 11 8834 11.44% 48.60% 12 10102 13.09% 61.68% 13 9342 12.10% 73.79% 14 8221 10.65% 84.44% 15 6743 8.74% 93.17% 16 5269 6.83% 100.00% 11.2 SSE conversion --- runtime analysis The lookup table is quite large: in the sample implementation single record occupies 38 bytes, it gives almost 2,5 MiB. This section presents analysis of span_pattern usage during conversion of various inputs. Following parameters are collated: The number of different span patterns that appear during conversion. This is explained in details below. The number of CPU clocks per input byte (on Skylake); the results were directly get from Performance comparison . Both cache miss and branch miss ratios (the same Skylake); these results were obtained by running separate bin/benchmark-hwevents tool. The ratios should give a hint about real-workload penalties. During a conversion a histogram is build. The histogram contains span_pattern and the number of its occurrences; the histogram is sorted by the frequency. Having such a sorted histogram it is easy to estimate how many distinct patterns appear in most iterations. Let\'s analyse sample, made up, histogram: # span pattern frequency cumulative 1 0xaaaa 1 1 2 0xbbbb 1 2 3 0x4444 1 3 4 0xdddd 1 4 5 0xeeee 2 6 6 0xffff 2 8 7 0x1111 3 11 8 0x3333 5 16 9 0x5555 10 26 10 0x7777 17 43 There are 10 different patterns that were used in 43 loops. We can read from the table that in 1/4 of iterations (11 of 43) were used even seven patterns. Most of processing uses just three patterns. It means that only a small portion of the large lookup is actually touched. The tables in following sections have got data processed in this way. Each column contains number of distinct patterns that take part in given percentage of the iterations (25%, 50%, 75%, 95% and all, 100%). The results for various input sizes are available in the repository , below are shown only 4kB and 64kB inputs. 11.2.1 Input size 4,096 bytes parameters distinct span masks count cycles per byte branches cache references < 25% < 50% < 75% < 95% 100% min avg taken mispredicted ratio count missed ratio Fixed length 1 digit, single separator character 32 44 50 52 53 3.095 3.165 26085 633 2.43% 1531 415 27.11% 2 digits, single separator character 12 16 18 19 20 3.305 3.400 25270 485 1.92% 1333 114 8.55% 3 digits, single separator character 5 7 8 8 9 2.533 2.584 21809 247 1.13% 954 63 6.60% 4 digits, single separator character 4 5 6 6 7 3.193 3.231 24145 336 1.39% 926 49 5.29% 5 digits, single separator character 2 3 4 4 5 2.648 2.680 20788 241 1.16% 1067 24 2.25% 6 digits, single separator character 2 4 4 4 5 2.312 2.347 18289 233 1.27% 915 19 2.08% 7 digits, single separator character 2 2 2 2 3 4.121 4.167 25682 313 1.22% 780 6 0.77% 8 digits, single separator character 1 3 3 3 4 5.495 5.592 44188 837 1.89% 836 25 2.99% Uniform distribution 1 .. 1 digit, single separator character 42 54 60 62 63 3.162 3.288 25992 619 2.38% 1618 334 20.64% 1 .. 2 digits, single separator character 71 102 118 126 128 3.201 3.268 26561 465 1.75% 2118 655 30.93% 1 .. 3 digits, single separator character 72 112 134 146 148 2.891 2.941 24393 514 2.11% 2522 663 26.29% 1 .. 4 digits, single separator character 87 135 159 170 172 3.398 3.463 25831 906 3.51% 2480 667 26.90% 1 .. 5 digits, single separator character 92 136 163 177 179 3.495 3.553 25865 806 3.12% 2509 548 21.84% 1 .. 6 digits, single separator character 90 144 168 178 180 3.494 3.557 24943 639 2.56% 2591 627 24.20% 1 .. 7 digits, single separator character 86 125 143 151 153 3.259 3.324 23730 579 2.44% 2137 476 22.27% 1 .. 8 digits, single separator character 95 135 157 166 167 3.828 3.894 28964 859 2.97% 2074 318 15.33% Gaussian distribution max at 1 digit, single separator character 76 133 161 174 176 3.218 3.264 25990 485 1.87% 2658 799 30.06% max at 2 digit, single separator character 77 129 157 170 173 3.122 3.189 24951 686 2.75% 2803 455 16.23% max at 3 digit, single separator character 76 103 115 120 122 3.192 3.246 24812 799 3.22% 3038 256 8.43% max at 4 digit, single separator character 43 57 63 65 66 3.134 3.215 23754 414 1.74% 1650 106 6.42% max at 5 digit, single separator character 32 38 41 43 44 2.822 2.875 21380 346 1.62% 1320 93 7.05% max at 6 digit, single separator character 25 30 33 34 35 2.887 2.935 21765 496 2.28% 1223 79 6.46% max at 7 digit, single separator character 20 22 24 24 25 3.921 3.983 29234 794 2.72% 1096 40 3.65% max at 8 digit, single separator character 11 12 13 14 15 4.825 4.887 37274 1015 2.72% 944 44 4.66% Fixed length 1 digit, 1 .. 6 separator characters 65 131 197 223 227 3.331 3.404 18979 677 3.57% 3111 1581 50.82% 2 digits, 1 .. 6 separator characters 67 135 175 195 198 3.473 3.529 20588 799 3.88% 2858 1287 45.03% 3 digits, 1 .. 6 separator characters 68 119 147 157 158 2.747 2.806 18629 481 2.58% 2728 1150 42.16% 4 digits, 1 .. 6 separator characters 69 101 118 124 125 2.641 2.695 18672 488 2.61% 1919 613 31.94% 5 digits, 1 .. 6 separator characters 53 71 78 81 82 2.748 2.824 19009 530 2.79% 1638 372 22.71% 6 digits, 1 .. 6 separator characters 43 50 53 55 56 2.958 3.002 19989 450 2.25% 1304 208 15.95% 7 digits, 1 .. 6 separator characters 12 14 17 18 19 3.316 3.341 20881 300 1.44% 1058 52 4.91% 8 digits, 1 .. 6 separator characters 33 46 54 57 58 4.302 4.346 34811 728 2.09% 1377 206 14.96% Uniform distribution 1 .. 1 digit, 1 .. 6 separator characters 66 132 198 232 237 3.197 3.268 19319 685 3.55% 2972 1273 42.83% 1 .. 2 digits, 1 .. 6 separator characters 66 132 198 238 243 3.025 3.081 19752 842 4.26% 3186 1247 39.14% 1 .. 3 digits, 1 .. 6 separator characters 67 135 203 233 238 3.070 3.150 19453 743 3.82% 3357 1216 36.22% 1 .. 4 digits, 1 .. 6 separator characters 70 140 210 250 256 3.390 3.477 19640 897 4.57% 3586 1226 34.19% 1 .. 5 digits, 1 .. 6 separator characters 71 142 213 242 247 3.338 3.401 19580 823 4.20% 3170 940 29.65% 1 .. 6 digits, 1 .. 6 separator characters 71 143 207 233 237 3.288 3.375 19457 785 4.03% 2916 807 27.67% 1 .. 7 digits, 1 .. 6 separator characters 74 148 208 228 230 3.304 3.375 19268 761 3.95% 2985 904 30.28% 1 .. 8 digits, 1 .. 6 separator characters 79 159 209 227 230 3.692 3.766 23045 881 3.82% 2946 727 24.68% Gaussian distribution max at 1 digit, 1 .. 6 separator characters 66 133 200 244 249 3.154 3.216 19347 900 4.65% 3515 1060 30.16% max at 2 digit, 1 .. 6 separator characters 67 135 203 241 246 3.155 3.229 19299 786 4.07% 3340 892 26.71% max at 3 digit, 1 .. 6 separator characters 69 139 205 229 233 3.202 3.278 19382 804 4.15% 3188 661 20.73% max at 4 digit, 1 .. 6 separator characters 70 141 180 198 201 2.914 2.978 18669 611 3.27% 2775 692 24.94% max at 5 digit, 1 .. 6 separator characters 74 131 156 164 166 3.147 3.217 19276 586 3.04% 2291 552 24.09% max at 6 digit, 1 .. 6 separator characters 70 93 101 105 106 3.196 3.257 20806 493 2.37% 1719 237 13.79% max at 7 digit, 1 .. 6 separator characters 64 80 87 91 92 3.597 3.646 24974 622 2.49% 1599 251 15.70% max at 8 digit, 1 .. 6 separator characters 56 74 82 87 88 3.994 4.055 29874 848 2.84% 1587 231 14.56% 11.2.2 Input size 65,536 bytes parameters distinct span masks count cycles per byte branches cache references < 25% < 50% < 75% < 95% 100% min avg taken mispredicted ratio count missed ratio Fixed length 1 digit, single separator character 61 74 81 84 85 3.619 3.655 393175 6529 1.66% 13469 974 7.23% 2 digits, single separator character 13 17 20 21 22 3.727 3.754 374164 3451 0.92% 11212 286 2.55% 3 digits, single separator character 4 6 8 8 9 2.839 2.852 328065 829 0.25% 7539 101 1.34% 4 digits, single separator character 4 5 6 6 7 3.495 3.507 361605 2429 0.67% 7148 89 1.25% 5 digits, single separator character 1 2 3 3 4 2.921 2.935 313419 849 0.27% 7335 119 1.62% 6 digits, single separator character 1 2 3 3 4 2.545 2.555 272684 741 0.27% 8704 58 0.67% 7 digits, single separator character 1 2 2 2 3 4.407 4.417 386099 2206 0.57% 5224 27 0.52% 8 digits, single separator character 2 3 4 4 5 7.094 7.135 666950 13453 2.02% 5192 75 1.44% Uniform distribution 1 .. 1 digit, single separator character 59 72 80 82 83 3.627 3.693 393231 6582 1.67% 14582 973 6.67% 1 .. 2 digits, single separator character 236 280 299 308 310 3.908 3.935 397134 5214 1.31% 19011 2176 11.45% 1 .. 3 digits, single separator character 355 420 450 466 469 3.565 3.590 361819 4669 1.29% 21347 1858 8.70% 1 .. 4 digits, single separator character 416 493 523 537 540 5.329 5.387 391117 12854 3.29% 24169 1621 6.71% 1 .. 5 digits, single separator character 444 510 543 556 558 5.270 5.328 390345 11393 2.92% 19020 1568 8.24% 1 .. 6 digits, single separator character 423 492 525 535 537 4.589 4.633 372174 7872 2.12% 19917 1282 6.44% 1 .. 7 digits, single separator character 392 462 481 491 493 4.174 4.218 355907 6263 1.76% 15979 949 5.94% 1 .. 8 digits, single separator character 519 598 620 630 631 5.217 5.273 423108 11289 2.67% 16635 695 4.18% Gaussian distribution max at 1 digit, single separator character 481 587 630 645 648 4.150 4.189 395482 6382 1.61% 25467 1620 6.36% max at 2 digit, single separator character 454 534 570 586 589 4.104 4.143 371930 6882 1.85% 25775 739 2.87% max at 3 digit, single separator character 300 330 344 350 352 4.990 5.050 375961 11571 3.08% 15877 351 2.21% max at 4 digit, single separator character 132 147 153 155 156 3.760 3.814 356129 4522 1.27% 10634 220 2.07% max at 5 digit, single separator character 84 90 93 95 96 3.031 3.045 318232 1548 0.49% 8123 177 2.18% max at 6 digit, single separator character 54 59 62 64 65 3.479 3.499 328097 6041 1.84% 8491 366 4.31% max at 7 digit, single separator character 36 39 41 41 42 5.520 5.560 444157 11932 2.69% 5814 124 2.13% max at 8 digit, single separator character 22 23 24 25 26 6.897 6.946 562307 15610 2.78% 5449 120 2.20% Fixed length 1 digit, 1 .. 6 separator characters 1052 1626 1870 1950 1958 4.371 4.408 280108 7580 2.71% 34860 8289 23.78% 2 digits, 1 .. 6 separator characters 693 909 995 1026 1029 5.044 5.108 308039 12071 3.92% 26297 4481 17.04% 3 digits, 1 .. 6 separator characters 354 438 480 494 496 3.334 3.358 273155 3865 1.41% 17568 2647 15.07% 4 digits, 1 .. 6 separator characters 177 224 246 252 254 3.311 3.335 277306 4944 1.78% 10967 1361 12.41% 5 digits, 1 .. 6 separator characters 100 126 134 137 138 3.648 3.677 284172 7099 2.50% 7727 742 9.60% 6 digits, 1 .. 6 separator characters 69 77 80 82 83 3.675 3.703 297939 5210 1.75% 6470 402 6.21% 7 digits, 1 .. 6 separator characters 46 49 51 53 54 3.662 3.673 315611 2311 0.73% 6077 308 5.07% 8 digits, 1 .. 6 separator characters 30 45 54 58 59 5.735 5.782 532039 10908 2.05% 6292 438 6.96% Uniform distribution 1 .. 1 digit, 1 .. 6 separator characters 1053 1643 1896 1973 1981 4.364 4.396 279251 7676 2.75% 34478 6144 17.82% 1 .. 2 digits, 1 .. 6 separator characters 1066 1792 2104 2212 2221 5.090 5.154 288339 12133 4.21% 39995 5781 14.45% 1 .. 3 digits, 1 .. 6 separator characters 1084 1802 2120 2226 2236 4.974 5.031 286026 10029 3.51% 44877 5187 11.56% 1 .. 4 digits, 1 .. 6 separator characters 1120 1808 2084 2173 2182 5.332 5.395 287345 11700 4.07% 42918 3871 9.02% 1 .. 5 digits, 1 .. 6 separator characters 1141 1713 1959 2031 2039 5.078 5.153 287785 10589 3.68% 40253 2950 7.33% 1 .. 6 digits, 1 .. 6 separator characters 1142 1617 1803 1856 1860 4.888 4.960 286913 10124 3.53% 35625 2229 6.26% 1 .. 7 digits, 1 .. 6 separator characters 1091 1503 1646 1678 1681 4.970 5.033 287420 11059 3.85% 30932 3218 10.40% 1 .. 8 digits, 1 .. 6 separator characters 1109 1476 1598 1619 1622 5.650 5.711 339596 14223 4.19% 28870 2243 7.77% Gaussian distribution max at 1 digit, 1 .. 6 separator characters 1070 1975 2405 2551 2565 5.389 5.456 285670 12734 4.46% 46840 6140 13.11% max at 2 digit, 1 .. 6 separator characters 1094 1862 2174 2283 2293 5.125 5.177 288202 10818 3.75% 43779 3228 7.37% max at 3 digit, 1 .. 6 separator characters 1021 1440 1610 1666 1672 4.927 4.986 284545 10542 3.70% 34647 1690 4.88% max at 4 digit, 1 .. 6 separator characters 715 905 985 1010 1013 4.072 4.129 280545 8310 2.96% 20920 931 4.45% max at 5 digit, 1 .. 6 separator characters 445 534 567 575 577 4.127 4.167 286377 8569 2.99% 14319 651 4.55% max at 6 digit, 1 .. 6 separator characters 296 336 346 351 352 4.025 4.054 312734 6394 2.04% 11762 402 3.42% max at 7 digit, 1 .. 6 separator characters 185 207 214 219 220 4.481 4.520 376654 8042 2.14% 7924 452 5.70% max at 8 digit, 1 .. 6 separator characters 110 133 141 146 148 5.532 5.576 448317 12621 2.82% 7779 821 10.55% 11.3 Performance comparison 11.3.1 Tested procedures Following procedures are tested: scalar --- the hand-coded validating scalar parser ; scalar (std) --- also the hand-coded parser , but use only standard functions strtol and strspn ; scalar hybrid --- the implementation of Scalar hybrid ; SSE --- the implementation of the base SSE algorithm; SSE (block) --- the implementation of variant described in Processing larger inputs SSE (simplified) --- the SSE variant with relaxed delimiters definition. 11.3.2 Tests setup There are two tests approaches: Overall , where rather huge input data is parsed (a few megabytes) and the wall clock is used to measure the time of the whole procedure. Procedures are repeated several times (10, 100, 1000 or more), the minimum running time is noted. To run these tests type make report-overall.rst ; the tests suite uses executable bin/benchmark . The results from various computers are available in the repository . Microbenchmarks , where small inputs are parsed and exact number of CPU cycles is obtained. Procedures are also repeated many times (1000) and then minumum and average cycles to process a single input byte are calculated. To run these tests type make microbenchmarks.rst ; the tests suite uses executable bin/benchmark-cpuclocks . The all results from various computers are available in the repository , below are only the measurements from the Skylake computer. 11.3.3 Core i7 results Compiler: GCC 7.3.0 CPU: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz The table below compares speedup to the reference procedure for various input sizes and data distributions. Detailed measurements for each size and different distribution parameters are presented in the subsequent sections. speedup over scalar procedure scalar (std) scalar (hybrid) SSE SSE (block) SSE (simplified) size [B] distribution samples min avg max min avg max min avg max min avg max min avg max 1024 Gaussian distribution 16 0.45 0.87 1.29 1.65 2.36 3.26 1.53 3.21 5.44 1.66 3.16 4.97 1.58 3.37 5.78 1024 Fixed length 16 0.42 0.87 1.29 1.63 2.41 3.53 1.28 3.32 5.23 1.47 3.30 5.05 1.30 3.54 5.79 1024 Uniform distribution 16 0.40 0.86 1.32 1.64 2.41 3.36 2.04 3.70 5.54 2.22 3.53 4.97 2.13 3.88 5.79 4096 Gaussian distribution 16 0.39 0.69 1.24 1.69 3.01 4.67 1.91 4.56 7.21 2.13 4.88 7.84 2.01 4.77 7.68 4096 Fixed length 16 0.36 0.69 1.39 1.94 2.87 4.32 1.60 4.44 6.86 1.71 4.66 8.34 1.62 4.70 7.83 4096 Uniform distribution 16 0.43 0.78 1.38 2.07 3.24 4.55 3.19 5.33 7.40 3.36 5.61 7.87 3.27 5.61 7.79 65536 Gaussian distribution 16 0.45 0.77 1.30 1.40 1.74 2.13 1.73 4.46 5.88 1.76 4.57 6.00 1.77 4.60 6.25 65536 Fixed length 16 0.40 0.75 1.36 1.55 1.87 2.37 1.46 4.68 6.72 1.48 5.00 7.31 1.50 4.95 7.53 65536 Uniform distribution 16 0.55 0.86 1.36 1.38 1.75 2.34 3.32 4.98 6.39 3.29 5.01 6.52 3.43 5.20 6.89 102400 Gaussian distribution 16 0.46 0.77 1.26 1.38 1.71 2.03 1.78 4.28 5.66 1.81 4.44 5.81 1.82 4.42 6.00 102400 Fixed length 16 0.40 0.75 1.36 1.53 1.84 2.31 1.29 4.59 6.49 1.46 4.91 6.99 1.31 4.85 7.16 102400 Uniform distribution 16 0.54 0.86 1.38 1.35 1.71 2.32 3.22 4.78 6.38 3.21 4.83 6.43 3.31 4.97 6.85 11.3.3.1 Input size 4096 bytes Gaussian distribution (max at 8 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 8.782 9.103 1.00 scalar (std) 22.874 23.586 0.38 scalar (hybrid) 5.005 5.148 1.75 SSE 4.898 4.974 1.79 SSE (block) 4.603 4.651 1.91 SSE (simplified) 4.687 4.730 1.87 Gaussian distribution (max at 8 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 12.729 13.130 1.00 scalar (std) 17.501 18.150 0.73 scalar (hybrid) 4.067 4.273 3.13 SSE 4.002 4.069 3.18 SSE (block) 3.903 3.945 3.26 SSE (simplified) 3.914 3.970 3.25 Gaussian distribution (max at 7 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 8.836 9.191 1.00 scalar (std) 23.365 24.139 0.38 scalar (hybrid) 5.104 5.250 1.73 SSE 4.129 4.195 2.14 SSE (block) 3.476 3.518 2.54 SSE (simplified) 3.975 4.039 2.22 Gaussian distribution (max at 7 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 13.646 14.115 1.00 scalar (std) 18.029 18.596 0.76 scalar (hybrid) 4.042 4.274 3.38 SSE 3.591 3.644 3.80 SSE (block) 3.294 3.334 4.14 SSE (simplified) 3.431 3.481 3.98 Gaussian distribution (max at 6 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 9.434 9.852 1.00 scalar (std) 24.766 25.547 0.38 scalar (hybrid) 5.571 5.728 1.69 SSE 2.833 2.882 3.33 SSE (block) 2.977 3.024 3.17 SSE (simplified) 2.738 2.786 3.45 Gaussian distribution (max at 6 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 14.200 14.750 1.00 scalar (std) 17.992 18.563 0.79 scalar (hybrid) 4.091 4.330 3.47 SSE 3.207 3.266 4.43 SSE (block) 2.885 2.932 4.92 SSE (simplified) 3.058 3.113 4.64 Gaussian distribution (max at 5 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 10.384 10.864 1.00 scalar (std) 25.763 26.495 0.40 scalar (hybrid) 6.102 6.273 1.70 SSE 2.786 2.827 3.73 SSE (block) 2.710 2.744 3.83 SSE (simplified) 2.699 2.752 3.85 Gaussian distribution (max at 5 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 15.168 15.622 1.00 scalar (std) 18.088 18.872 0.84 scalar (hybrid) 4.244 4.442 3.57 SSE 3.023 3.096 5.02 SSE (block) 2.864 2.934 5.30 SSE (simplified) 2.908 2.984 5.22 Gaussian distribution (max at 1 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 18.091 18.877 1.00 scalar (std) 34.484 35.258 0.52 scalar (hybrid) 7.037 7.275 2.57 SSE 3.160 3.213 5.72 SSE (block) 3.282 3.352 5.51 SSE (simplified) 3.120 3.194 5.80 Gaussian distribution (max at 1 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 21.390 22.112 1.00 scalar (std) 18.566 19.088 1.15 scalar (hybrid) 5.160 5.286 4.15 SSE 3.067 3.126 6.97 SSE (block) 2.904 2.963 7.37 SSE (simplified) 2.961 3.022 7.22 Gaussian distribution (max at 4 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 11.966 12.550 1.00 scalar (std) 26.982 27.705 0.44 scalar (hybrid) 5.896 6.082 2.03 SSE 3.234 3.284 3.70 SSE (block) 3.026 3.074 3.95 SSE (simplified) 3.117 3.183 3.84 Gaussian distribution (max at 4 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 16.371 16.967 1.00 scalar (std) 17.832 18.445 0.92 scalar (hybrid) 4.173 4.395 3.92 SSE 2.909 3.001 5.63 SSE (block) 2.760 2.813 5.93 SSE (simplified) 2.848 2.908 5.75 Gaussian distribution (max at 3 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 13.280 13.948 1.00 scalar (std) 29.238 30.157 0.45 scalar (hybrid) 6.225 6.450 2.13 SSE 3.225 3.309 4.12 SSE (block) 2.963 3.012 4.48 SSE (simplified) 3.238 3.286 4.10 Gaussian distribution (max at 3 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 18.193 18.831 1.00 scalar (std) 18.642 19.287 0.98 scalar (hybrid) 4.119 4.246 4.42 SSE 3.126 3.190 5.82 SSE (block) 3.016 3.090 6.03 SSE (simplified) 3.000 3.048 6.06 Gaussian distribution (max at 2 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 15.942 16.733 1.00 scalar (std) 32.551 33.334 0.49 scalar (hybrid) 6.372 6.605 2.50 SSE 3.130 3.190 5.09 SSE (block) 3.041 3.121 5.24 SSE (simplified) 3.020 3.082 5.28 Gaussian distribution (max at 2 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 20.088 20.800 1.00 scalar (std) 18.382 19.013 1.09 scalar (hybrid) 4.574 4.835 4.39 SSE 3.184 3.264 6.31 SSE (block) 3.018 3.069 6.66 SSE (simplified) 2.988 3.042 6.72 Uniform distribution (1 .. 1 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 18.677 19.206 1.00 scalar (std) 34.479 35.207 0.54 scalar (hybrid) 7.953 8.184 2.35 SSE 3.014 3.099 6.20 SSE (block) 3.117 3.172 5.99 SSE (simplified) 2.977 3.062 6.27 Uniform distribution (1 .. 1 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 21.981 22.621 1.00 scalar (std) 16.860 17.391 1.30 scalar (hybrid) 5.285 5.481 4.16 SSE 3.029 3.085 7.26 SSE (block) 2.942 3.000 7.47 SSE (simplified) 3.099 3.179 7.09 Uniform distribution (1 .. 2 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 17.695 18.444 1.00 scalar (std) 34.917 35.633 0.51 scalar (hybrid) 7.245 7.401 2.44 SSE 3.324 3.387 5.32 SSE (block) 3.323 3.398 5.33 SSE (simplified) 3.236 3.321 5.47 Uniform distribution (1 .. 2 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 21.164 21.860 1.00 scalar (std) 18.567 19.126 1.14 scalar (hybrid) 4.937 5.156 4.29 SSE 2.940 2.995 7.20 SSE (block) 2.924 2.975 7.24 SSE (simplified) 2.785 2.826 7.60 Uniform distribution (1 .. 3 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 16.385 17.254 1.00 scalar (std) 33.359 34.075 0.49 scalar (hybrid) 6.877 7.145 2.38 SSE 2.892 2.947 5.67 SSE (block) 3.088 3.158 5.31 SSE (simplified) 2.752 2.844 5.95 Uniform distribution (1 .. 3 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 20.530 21.221 1.00 scalar (std) 18.995 19.580 1.08 scalar (hybrid) 4.647 4.811 4.42 SSE 3.037 3.089 6.76 SSE (block) 2.941 2.992 6.98 SSE (simplified) 2.914 2.972 7.05 Uniform distribution (1 .. 4 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 14.926 15.613 1.00 scalar (std) 31.275 32.210 0.48 scalar (hybrid) 6.445 6.677 2.32 SSE 3.393 3.458 4.40 SSE (block) 3.126 3.184 4.77 SSE (simplified) 3.293 3.344 4.53 Uniform distribution (1 .. 4 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 19.047 19.920 1.00 scalar (std) 19.500 20.130 0.98 scalar (hybrid) 4.539 4.723 4.20 SSE 3.325 3.383 5.73 SSE (block) 3.132 3.193 6.08 SSE (simplified) 3.182 3.235 5.99 Uniform distribution (1 .. 5 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 13.748 14.405 1.00 scalar (std) 30.105 30.941 0.46 scalar (hybrid) 6.144 6.413 2.24 SSE 3.475 3.533 3.96 SSE (block) 3.171 3.238 4.34 SSE (simplified) 3.293 3.356 4.17 Uniform distribution (1 .. 5 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 18.297 19.010 1.00 scalar (std) 19.209 19.845 0.95 scalar (hybrid) 4.477 4.652 4.09 SSE 3.293 3.352 5.56 SSE (block) 3.135 3.188 5.84 SSE (simplified) 3.182 3.230 5.75 Uniform distribution (1 .. 6 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 12.912 13.548 1.00 scalar (std) 29.511 30.337 0.44 scalar (hybrid) 5.958 6.253 2.17 SSE 3.430 3.487 3.76 SSE (block) 3.201 3.265 4.03 SSE (simplified) 3.283 3.337 3.93 Uniform distribution (1 .. 6 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 17.288 17.956 1.00 scalar (std) 19.250 19.841 0.90 scalar (hybrid) 4.356 4.481 3.97 SSE 3.205 3.276 5.39 SSE (block) 2.990 3.046 5.78 SSE (simplified) 3.116 3.172 5.55 Uniform distribution (1 .. 7 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 11.974 12.552 1.00 scalar (std) 27.884 28.562 0.43 scalar (hybrid) 6.214 6.385 1.93 SSE 3.253 3.309 3.68 SSE (block) 3.057 3.100 3.92 SSE (simplified) 3.119 3.167 3.84 Uniform distribution (1 .. 7 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 16.583 17.366 1.00 scalar (std) 18.947 19.528 0.88 scalar (hybrid) 4.265 4.401 3.89 SSE 3.248 3.311 5.11 SSE (block) 2.989 3.048 5.55 SSE (simplified) 3.165 3.215 5.24 Uniform distribution (1 .. 8 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 11.637 12.165 1.00 scalar (std) 27.107 27.851 0.43 scalar (hybrid) 6.079 6.231 1.91 SSE 3.821 3.870 3.05 SSE (block) 3.492 3.550 3.33 SSE (simplified) 3.688 3.745 3.16 Uniform distribution (1 .. 8 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 15.739 16.589 1.00 scalar (std) 18.875 19.563 0.83 scalar (hybrid) 4.335 4.463 3.63 SSE 3.611 3.667 4.36 SSE (block) 3.337 3.400 4.72 SSE (simplified) 3.490 3.538 4.51 11.3.3.2 Input size 65536 bytes Gaussian distribution (max at 8 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 11.852 11.971 1.00 scalar (std) 26.589 26.792 0.45 scalar (hybrid) 8.336 8.411 1.42 SSE 6.911 6.956 1.71 SSE (block) 6.921 6.990 1.71 SSE (simplified) 6.757 6.802 1.75 Gaussian distribution (max at 8 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 17.008 17.110 1.00 scalar (std) 21.492 21.653 0.79 scalar (hybrid) 8.722 8.800 1.95 SSE 5.650 5.692 3.01 SSE (block) 5.679 5.733 2.99 SSE (simplified) 5.426 5.470 3.13 Gaussian distribution (max at 7 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 12.818 12.929 1.00 scalar (std) 27.335 27.609 0.47 scalar (hybrid) 9.246 9.315 1.39 SSE 5.513 5.542 2.33 SSE (block) 5.259 5.296 2.44 SSE (simplified) 5.364 5.405 2.39 Gaussian distribution (max at 7 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 17.978 18.119 1.00 scalar (std) 21.924 22.109 0.82 scalar (hybrid) 9.205 9.286 1.95 SSE 4.537 4.591 3.96 SSE (block) 4.351 4.388 4.13 SSE (simplified) 4.352 4.407 4.13 Gaussian distribution (max at 6 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 13.772 13.862 1.00 scalar (std) 28.295 28.596 0.49 scalar (hybrid) 10.005 10.079 1.38 SSE 3.456 3.479 3.98 SSE (block) 3.358 3.385 4.10 SSE (simplified) 3.379 3.402 4.08 Gaussian distribution (max at 6 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 19.374 19.538 1.00 scalar (std) 22.288 22.489 0.87 scalar (hybrid) 9.660 9.730 2.01 SSE 3.949 3.983 4.91 SSE (block) 3.726 3.751 5.20 SSE (simplified) 3.870 3.918 5.01 Gaussian distribution (max at 5 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 14.989 15.092 1.00 scalar (std) 29.851 30.089 0.50 scalar (hybrid) 10.750 10.842 1.39 SSE 2.933 2.945 5.11 SSE (block) 2.807 2.822 5.34 SSE (simplified) 2.866 2.878 5.23 Gaussian distribution (max at 5 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 20.729 20.888 1.00 scalar (std) 22.536 22.718 0.92 scalar (hybrid) 10.225 10.311 2.03 SSE 4.032 4.086 5.14 SSE (block) 3.762 3.805 5.51 SSE (simplified) 3.985 4.043 5.20 Gaussian distribution (max at 1 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 24.489 24.804 1.00 scalar (std) 38.285 38.540 0.64 scalar (hybrid) 16.088 16.198 1.52 SSE 4.159 4.200 5.89 SSE (block) 4.107 4.142 5.96 SSE (simplified) 4.213 4.250 5.81 Gaussian distribution (max at 1 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 28.265 28.549 1.00 scalar (std) 22.648 22.767 1.25 scalar (hybrid) 13.524 13.622 2.09 SSE 5.201 5.271 5.43 SSE (block) 5.452 5.513 5.18 SSE (simplified) 5.057 5.128 5.59 Gaussian distribution (max at 4 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 16.687 16.790 1.00 scalar (std) 31.153 31.398 0.54 scalar (hybrid) 11.835 11.913 1.41 SSE 3.590 3.614 4.65 SSE (block) 3.466 3.489 4.81 SSE (simplified) 3.496 3.525 4.77 Gaussian distribution (max at 4 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 22.284 22.529 1.00 scalar (std) 22.476 22.653 0.99 scalar (hybrid) 10.916 11.005 2.04 SSE 4.032 4.081 5.53 SSE (block) 3.859 3.898 5.77 SSE (simplified) 3.953 3.991 5.64 Gaussian distribution (max at 3 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 19.121 19.291 1.00 scalar (std) 32.927 33.175 0.58 scalar (hybrid) 13.629 13.718 1.40 SSE 4.848 4.901 3.94 SSE (block) 4.780 4.825 4.00 SSE (simplified) 4.760 4.812 4.02 Gaussian distribution (max at 3 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 24.281 24.611 1.00 scalar (std) 22.530 22.703 1.08 scalar (hybrid) 11.920 12.185 2.04 SSE 4.756 4.823 5.11 SSE (block) 4.781 4.835 5.08 SSE (simplified) 4.607 4.664 5.27 Gaussian distribution (max at 2 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 22.188 22.377 1.00 scalar (std) 36.158 36.461 0.61 scalar (hybrid) 15.232 15.326 1.46 SSE 4.058 4.108 5.47 SSE (block) 3.952 3.990 5.61 SSE (simplified) 4.061 4.110 5.46 Gaussian distribution (max at 2 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 26.633 26.932 1.00 scalar (std) 22.723 22.869 1.17 scalar (hybrid) 13.162 13.267 2.02 SSE 5.097 5.174 5.23 SSE (block) 5.160 5.224 5.16 SSE (simplified) 4.941 5.008 5.39 Uniform distribution (1 .. 1 digit) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 22.963 23.203 1.00 scalar (std) 37.465 37.718 0.61 scalar (hybrid) 13.951 14.058 1.65 SSE 3.389 3.447 6.78 SSE (block) 3.593 3.643 6.39 SSE (simplified) 3.324 3.394 6.91 Uniform distribution (1 .. 1 digit) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 27.116 27.518 1.00 scalar (std) 20.621 20.742 1.31 scalar (hybrid) 11.908 12.006 2.28 SSE 4.128 4.167 6.57 SSE (block) 4.179 4.214 6.49 SSE (simplified) 4.105 4.136 6.61 Uniform distribution (1 .. 2 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 23.675 24.277 1.00 scalar (std) 37.914 38.203 0.62 scalar (hybrid) 15.327 15.432 1.54 SSE 3.896 3.933 6.08 SSE (block) 3.870 3.901 6.12 SSE (simplified) 3.913 3.952 6.05 Uniform distribution (1 .. 2 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 27.811 28.100 1.00 scalar (std) 22.433 22.537 1.24 scalar (hybrid) 13.003 13.113 2.14 SSE 4.947 5.018 5.62 SSE (block) 5.201 5.265 5.35 SSE (simplified) 4.807 4.872 5.79 Uniform distribution (1 .. 3 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 22.512 22.742 1.00 scalar (std) 36.660 36.946 0.61 scalar (hybrid) 15.263 15.362 1.47 SSE 3.474 3.507 6.48 SSE (block) 3.456 3.480 6.51 SSE (simplified) 3.528 3.561 6.38 Uniform distribution (1 .. 3 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 26.841 27.155 1.00 scalar (std) 22.874 23.042 1.17 scalar (hybrid) 13.184 13.284 2.04 SSE 4.815 4.876 5.57 SSE (block) 4.952 5.022 5.42 SSE (simplified) 4.699 4.753 5.71 Uniform distribution (1 .. 4 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 21.123 21.329 1.00 scalar (std) 35.205 35.486 0.60 scalar (hybrid) 14.756 14.856 1.43 SSE 5.217 5.283 4.05 SSE (block) 5.053 5.106 4.18 SSE (simplified) 5.163 5.227 4.09 Uniform distribution (1 .. 4 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 25.877 26.129 1.00 scalar (std) 23.132 23.285 1.12 scalar (hybrid) 12.984 13.084 1.99 SSE 5.211 5.291 4.97 SSE (block) 5.283 5.356 4.90 SSE (simplified) 5.048 5.116 5.13 Uniform distribution (1 .. 5 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 19.780 19.978 1.00 scalar (std) 34.247 34.511 0.58 scalar (hybrid) 14.274 14.371 1.39 SSE 5.099 5.160 3.88 SSE (block) 4.920 4.975 4.02 SSE (simplified) 5.053 5.099 3.91 Uniform distribution (1 .. 5 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 24.749 25.022 1.00 scalar (std) 23.269 23.468 1.06 scalar (hybrid) 12.627 12.718 1.96 SSE 5.046 5.111 4.90 SSE (block) 4.999 5.126 4.95 SSE (simplified) 4.903 4.954 5.05 Uniform distribution (1 .. 6 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 18.656 18.857 1.00 scalar (std) 33.362 33.565 0.56 scalar (hybrid) 13.643 13.742 1.37 SSE 4.433 4.479 4.21 SSE (block) 4.282 4.319 4.36 SSE (simplified) 4.356 4.399 4.28 Uniform distribution (1 .. 6 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 23.975 24.304 1.00 scalar (std) 23.495 23.653 1.02 scalar (hybrid) 12.269 12.358 1.95 SSE 4.883 4.947 4.91 SSE (block) 4.715 4.770 5.08 SSE (simplified) 4.778 4.825 5.02 Uniform distribution (1 .. 7 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 17.632 17.799 1.00 scalar (std) 32.227 32.509 0.55 scalar (hybrid) 13.079 13.177 1.35 SSE 4.114 4.158 4.29 SSE (block) 3.976 4.028 4.43 SSE (simplified) 4.032 4.069 4.37 Uniform distribution (1 .. 7 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 22.878 23.116 1.00 scalar (std) 23.259 23.512 0.98 scalar (hybrid) 12.010 12.113 1.90 SSE 4.926 4.986 4.64 SSE (block) 4.670 4.735 4.90 SSE (simplified) 4.836 4.892 4.73 Uniform distribution (1 .. 8 digits) --- single separator character cycles per one input byte speed-up procedure min avg (min) scalar 16.753 16.923 1.00 scalar (std) 31.309 31.604 0.54 scalar (hybrid) 12.522 12.615 1.34 SSE 5.181 5.232 3.23 SSE (block) 5.263 5.313 3.18 SSE (simplified) 5.089 5.133 3.29 Uniform distribution (1 .. 8 digits) --- 1 .. 6 separator characters cycles per one input byte speed-up procedure min avg (min) scalar 22.070 22.400 1.00 scalar (std) 23.084 23.272 0.96 scalar (hybrid) 11.689 11.777 1.89 SSE 5.666 5.729 3.90 SSE (block) 5.833 5.886 3.78 SSE (simplified) 5.493 5.553 4.02 12 Conclusions The vectorized algorithm can be faster from 2 to 5 times than the scalar base. Although SSE speed-up depends on the count of digits in numbers, negative impact is visible when the numbers are separated by more than one character. This is caused by greater number of distinct span patterns : for \"Gaussian distribution --- max at 1 digit, single separator character\" the number of distinct patterns is approximately 1000 ; for the same distribution, but variable number of separator, this value raises almost 28 times, to 28000 . It means touching more memory locations within the lookup table and, as a result, more cache misses. Also amount of branch mispredictions is greater due to processing greater variety of patterns. Scalar hybrid performs surprisingly well, it can be even 2 times faster than the baseline. However, its compile time is terribly long. 13 Acknowledgements Nathan Kurz and Daniel Lemire gave incredibly valuable feedback and comments on text and experiments. Thank you! 14 See also External links: Daniel Lemire How quickly can you remove spaces from a string? Internal links: Parsing decimal numbers  part 1: SWAR Parsing decimal numbers  part 2: SSE SWAR check if all chars are digits 15 Source code Source code is available on github .'],
["notesen/2018-04-28-be-careful-with-dir-iterator.html", 'Be careful with directory_iterator', 'Be careful with directory_iterator Wojciech Mua Added on 2018-04-28 C++17 finally introduced filesystem library, which is pretty nice. This text shows a caveat my colleague bumped into recently. He wanted to perform a set of different operations on files from a directory; it was something like: In method perform_impl we iterate twice over the range defined by two directory_iterators . Well, we suppose so. Although iterator first is copied, the copy operation is peculiar. It doesn\'t copy the state of iterator , we get merely a new \"handle\" to an existing, single state. Standard libraries from GCC and Clang keep a std::shared_ptr , which holds an instance of internal class responsible for iterating. What it means? When the first loop executes, then first == end . Thus, the second loop never runs. In my opinion this behaviour is counter-intuitive. If the copy operator doesn\'t really make a copy, it should be disabled in API (it can be done with = delete put next to the operator declaration). People will be forced to pass the iterator by reference and, thanks to that, will be aware of the iterator traits. A funny side-effect of the current language feature is that even iterators passed by const reference change their visible state.'],
["notesen/2018-05-13-avx512-jpeg-zigzag-transform.html", 'AVX512 implementation of JPEG zigzag transformation', 'AVX512 implementation of JPEG zigzag transformation Wojciech Mua Added on 2018-05-13 Updated on 2018-11-04 (added 16bit-array shuffling ) Contents Introduction Shuffling 8-bit arrays Scalar implementation SSE implementation AVX512BW implementation AVX512BW implementation --- second variant AVX512VBMI implementation Performance evaluation Shuffling 16-bit array Scalar implementation SSE implementation Shuffle-only Shuffle with insert/extract AVX512F implementation Implementation note AVX512BW implementation Performance evaluation Source code Changelog Introduction One of steps in JPEG compression is zigzag transformation which linearises pixels from 8x8 block into 64-byte array. It\'s possible to vectorize this transformation. This short text shows SSE implementation, then its translation into AVX512BW instruction set, and finally AVX512VBMI code. The order of items in a block after transformation is shown below: Shuffling 8-bit arrays Scalar implementation Following procedure uses auxiliary table to pick proper pixels. It is compiled into a few instructions: SSE implementation Since SSE registers have 128 bits, only four registers are needed to hold the whole block; each register gets two 8-pixels rows. Let\'s label these registers with A, B, C and D: Then, the block after transformation is formed with following indices from the registers: The algorithm produces two 8-pixel lines in a single step. In each step similar operations are performed: Bytes in registers are shuffled to desired position using instruction pshufb ( _mm_shuffle_epi8 ). All these shuffled vectors are or\'ed together. To build rows 0 & 1 we need registers A, B, C; rows 2 & 3 and 4 & 5 use data from all registers; rows 6 & 7 use data from B, C and D. The instruction pshufb either puts a byte at given index or zeroes the destination byte, thanks to that masking is done at no cost. Please also note that in a few cases just single byte from given vector is needed. Then the pair of instructions pextb ( _mm_extract_epi8 ) and pinsb ( _mm_insert_epi8 ) is used. Sample implementation: Number of instructions: 4 loads; 10 shuffles; 4 insert-load-byte; 6 bit-or; 4 stores. AVX512BW implementation The AVX512BW variant of pshufb instruction ( vpshufb , _mm512_shuffle_epi8 ) works on 128-bit lanes. Thus, in this implementation we perform all in-lane shuffles (for pairs of rows) using single vpshufb ; moreover, we get rid of extract/insert operations. In order to do this the 128-bit lanes have to be populated after single load. Sample implementation: Number of instructions: 5 512-bit loads; 4 128-bit loads; 4 broadcasts; 4 in-lane shuffles; 1 ternary logic ; 1 bit-or; 1 store. The initial variant used cross-lane shuffles within registers ( vpermd , _mm512_permutexvar_epi32 ). InstLatX64 proposed to use vbroadcasti32x4 ( _mm512_broadcast_i32x4 ) which broadcasts 128-bit lanes to lanes. While vpermd can be dispatched only on port 5, broadcasts can be issued to ports 2 and 3. As a result average cycles dropped from 15 to 11 (1.35 x times faster). Instead of explicit merging of partial results, it is possible to use masked invocation of vpshufb ( _mm512_mask_shuffle_epi8 ). The tail of above procedure is changed into. Number of instructions: 5 loads; 4 cross-lane shuffles; 4 in-lane shuffles; 1 store. AVX512BW implementation --- second variant AVX512BW supports also cross-lane permutations, but the instruction vpermw ( _mm512_permutexvar_epi16 ) works on 16-bit values. Thus, we can only move pairs of pixels . The idea is to use vpermw to move required bytes into given 128-bit lanes, and then use pshufb to precisely place individual bytes within lanes. Due to the required order of bytes single invocation of vpermw is not sufficient; it must be done in two steps. Lane 0 (rows 1 & 2) contains following bytes (sorted): Lane 1 (rows 2 & 3): Lane 2 (rows 4 & 5): Lane 3 (rows 6 & 7): In the first step of transformation lanes are populated with following pair of bytes (colors match registers A, B, C and D). Please note that there are a few extra values [marked with black] -- lane 0: 19; lane 1: 15, 29; lane 2: 31, 45, 48. Following values are not present in lanes after the first shuffle: lane 0: 32; lane 1: 19, 34, 40, 41, 48; lane 2: 15, 29, 35; lane 3: 31, 45. This is the reason why the second invocation of vpermw is needed. Following diagram shows layout of byte pairs in the second step: The last, third step consists two vpshufb invocation that moves bytes within lanes. These shuffled vectors are or\'ed together and the result is stored. Sample implementation is shown below. The repository has got a python script that calculates all arguments for shuffles (it\'s pretty boring and error prone). Number of instructions: 5 loads; 2 cross-lane shuffles; 2 in-lane shuffles; 1 bit-or; 1 store; AVX512VBMI implementation The whole transformation is done by single instruction vpermb ( _mm512_permutexvar_epi8 ). The instruction shuffles bytes across lanes. ( zigzag_shuffle is defined with scalar code above) Performance evaluation The benchmark program runs zigzag transformation 1,000,000 times. I run it a few times and noted the minimum values. Tested procedures name comments scalar SSE AVX512BW AVX512BW (masks) AVX512BW that use mask stores rather bit-level merging AVX512BW (perm16) The program was compiled with GCC 7.3.0 and run on Skylake Core i7-6700 CPU @ 3.40GHz. procedure best [cycles] average [cycles] scalar 98.000 103.069 SSE 16.000 26.614 AVX512BW 4.000 11.002 AVX512BW (masks) 10.000 16.732 AVX512BW (perm16) 16.000 24.588 AVX512BW code is almost two times faster than SSE. Shuffling 16-bit array Scalar implementation The scalar implementation is basically 8-bit scalar with different types used. Assembly code is: SSE implementation When 16-bit words are stored in an array, then single SSE register holds exactly one row of 8 x 8 pixels block. We can use the same techniques as in 8-bit arrays handling. We can shuffle an input register and merge it with the destination register (with pair PSHUFB / POR ); we just have to keep in mind that PSHUFB must move whole 16-bit blocks. There are two variants of SSE procedure: one that uses only shuffle instructions; simplified one; in same cases there\'s need to copy only single item from one register to another, then a pair of instruction PEXTRACTW and PINSERTW is suitable. Please refer to sources for full SSE implementations; they are auto-generated, thus there is no much sense to copy them here. Shuffle-only Below is a summary which operations are required to build output rows: row 0 --- 3 x shuffle, 2 x bit-or; row 1 --- 5 x shuffle, 4 x bit-or; row 2 --- 6 x shuffle, 5 x bit-or; row 3 --- 4 x shuffle, 3 x bit-or; row 4 --- 4 x shuffle, 3 x bit-or; row 5 --- 6 x shuffle, 5 x bit-or; row 6 --- 5 x shuffle, 4 x bit-or; row 7 --- 3 x shuffle, 2 x bit-or. Total number of instructions: 8 loads; 36 shuffles; 28 bit-or; 8 stores. Shuffle with insert/extract Below is a summary which operations are required to build output rows: row 0 --- 2 x shuffle, 1 x bit-or, 1 x insert-load-word; row 1 --- 3 x shuffle, 2 x bit-or, 2 x insert-load-word; row 2 --- 2 x shuffle, 1 x bit-or, 4 x insert-load-word; row 3 --- 4 x shuffle, 3 x bit-or; row 4 --- 4 x shuffle, 3 x bit-or; row 5 --- 2 x shuffle, 1 x bit-or, 4 x insert-load-word; row 6 --- 3 x shuffle, 2 x bit-or, 2 x insert-load-word; row 7 --- 2 x shuffle, 1 x bit-or, 1 x insert-load-word. Number of instructions: 8 loads; 22 shuffles; 14 insert-load-word; 14 bit-or; 8 stores. AVX512F implementation In AVX512 code the whole 8 x 8 pixels table fits into two registers. Although AVX512F lacks of byte- or word-level operation, we still can move pairs of pixels across register lanes using VPERMD instruction ( _mm512_permutexvar_epi32 ). Then, there are basically three cases we must handle: The lower or higher word of the shuffled pair matches exactly the target position. Then only bit-and is needed to mask out another helve. The lower word of the pair must be placed in higher word of target register. Then we need shift left the permuted vector by 16 bits. Note that unlike VPSHUFB , VPERMD does not zero target elements with a special index value. Thus an explicit bit-and is needed. Likewise, when higher word of the pair must be place in the lower word of target register, then shift left by 16 bits is invoked. The vectors shuffle and mask that are used in the above cases are compile-time constants. The code for AVX512 was also auto-generated, please refer to sources for details. Below is the number of instructions: 16 x shuffle, 16 x ternary logic, 4 x shift right, 4 x shift left. Implementation note Similarly to other approaches, there are cases where just a single item from a source register has to be copied to the destination register. In case of SSE and AVX2 code we can use then specialized instructions for extract/insert 8-bit/16-bit items from a register. AVX512F doesn\'t have such instructions, but copying 16-bit values is still doable. Below is a pattern: As we see, it is pretty complicated. The code consist of five instruction, while the generic algorithm compiles to three or four. The experiment results clearly show that code uses this approach is slower. AVX512BW implementation AVX512BW provides instruction VPERM2I ( _mm512_permutex2var_epi16 ) that does cross-lane shuffling from two AVX512 registers. Since the whole 16-bit array fits into two registers we need to execute VPERM2I twice. Implementation is straightforward. Performance evaluation The test program benchmark_avx512bw was run five times and minimum times were noted. In single run each procedure is invoked 1,000,000 times. Tested procedures name comments scalar scalar (unrolled) scalar unrolled 4 times SSE shuffle-only variant SSE (copy single) shuffle with insert/extract AVX512F shuffle-only variant AVX512F (copy single) shuffle with insert/extract emulation AVX512BW procedure best [cycles] average [cycles] speedup scalar 109.000 113.814 1.00 scalar (unrolled) 94.000 98.745 1.15 SSE 52.000 59.906 1.90 SSE (copy single) 70.000 80.275 1.42 AVX512F 34.000 42.295 2.69 AVX512F (copy single) 46.000 54.455 2.09 AVX512BW 8.000 14.453 7.87 Source code Source code is available on github . Changelog 2018-11-04 --- added 16bit-array shuffling 2018-05-15 --- better broadcasting code in AVX512BW by InstLatX64 2018-05-14 --- another AVX512BW variant , AVX512BW code which uses masked writes'],
["notesen/2018-05-18-avx512-ktest-in-compilers.html", 'AVX512 mask registers support in compilers', 'AVX512 mask registers support in compilers Wojciech Mua Added on 2018-05-18 Update on 2018-05-22 (I was utterly wrong) Introduction AVX-512 introduced the set of 64-bit mask registers , called in assembler k0 ... k7 . A mask can be used to: Conditionally update elements in a destination register; it\'s an incredibly powerful feature, as virtually all vector instructions support it. Hold the result of vector comparison. The latter is also useful, as there is instruction ktest that updates the flags register, EFLAGS . Prior to AVX512 an extra instruction --- like pmovmskb or ptest (SSE 4.1) --- has to be used in order to alter control flow based on vectors content. There are four variants of ktest kx, ky that operates on 8, 16, 32 or 64 bits of mask registers, but basically they perform the same operation: 2018-05-22 update: unfortunately the instruction is not available in AVX512F; 8- and 16-bit variants are available in AVX512DQ, 32- and 64-bit in AVX512BW. Problem I wanted to test if any element in vector of 32-bit integers is non-zero. The intrinsics C code for this: Below is the assembly code, which employs ktest : Compiler output When I compiled the above program with wrong flag -mavx512f obviously none of GCC 8.1 and Clang 6.0.0 emit ktest ; they generated code like this: With the proper flag -mavx512dq both GCC and Clang emit ktestw . GCC 7.3.0 and Clang 3.9.8 were the last versions that didn\'t support this instruction. I still can\'t force ICC to generate ktestw ; with argument -xCORE-AVX512 the version 18.0 emits: ICC does one thing better --- it replaces the pair vpxor / vpcmpneqd with vptestmd instruction. I filled GCC bug to add this optimization.'],
["notesen/2018-10-03-simd-index-of-min.html", 'Finding index of the minimum value using SIMD instructions', 'Finding index of the minimum value using SIMD instructions Wojciech Mua Added on 2018-10-03 Contents Introduction SIMD approach Experiments SSE implementation AVX512F implementation Performance evaluation Skylake Skylake-X Acknowledgements Source code Introduction The goal is to find the first index of the minimum value in a non-empty sequence. Following C code shows the idea. The C++ standard library allows to express the same algorithm in one line. The current versions of compilers (GCC 8.2, clang 7.0.0) are not able to autovectorize the code. However, they do autovectorize finding the minimum value, i.e. statement like return *std::min_element(v.begin(), v.end()) . SIMD approach In a SIMD approach we keep three vectors of: minimum values, corresponding indices and also current scalar indices. When the main loop completes, we select the appropriate single index from these vectors. The algorithm outline is shown below (for four-element vectors). Function compare yields a mask, it can be a byte-mask (SSE, AVX2) or a bit-mask (AVX512). In SSE it might be instruction pcmpgtd ( _mm_pcmplt_epi32 ), in AVX512 it might be vpcmpd ( _mm512_cmp_epi32_mask ). Function blend is a vector selection operator, i.e. mask[i] ? x[i] : y[i] ; it stores items from either vector x or y based on the corresponding mask value. Many SIMD ISAs provides such operation; for instance SSE has the instruction pblendv ( _mm_blendv_epi8 ). Please note that in case of SSE the blend instruction is relative new, as it was introduced in SSE4.1. For really old CPUs the blend operator has to be expressed with binary operations: (x & mask) | (y & ~mask) . Such expression is compiled into a sequence of three instructions: and , and-not , or . Additionally, since blend instructions tend to be slow, it\'s better to update minvalues vector using the min operator. Experiments The above schema was translated into procedures using SSE (including an unrolled version), AVX2 and AVX512. In this article just SSE and AVX512 procedures are shown, but obviously all implementations are available . SSE implementation AVX512F implementation Performance evaluation Following procedures were tested: SSE , SSE unrolled, AVX2, and AVX512F . All procedures work on signed 32-bit integers. Test programs were run three times and minimum measurements were noted. The unit is CPU cycles per array item. Skylake Compiler: GCC 7.3.0 CPU: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 3.006 3.036 1.00 SSE 1.823 1.865 1.65 SSE unrolled 0.624 0.632 4.82 AVX2 0.268 0.272 11.22 size 16384 items scalar 3.010 3.021 1.00 SSE 1.829 1.875 1.65 SSE unrolled 0.636 0.643 4.73 AVX2 0.292 0.298 10.31 size 32768 items scalar 3.013 3.022 1.00 SSE 1.830 1.876 1.65 SSE unrolled 0.640 0.645 4.71 AVX2 0.295 0.300 10.21 Skylake-X Compiler: GCC 8.1.0 CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 2.994 3.408 1.00 SSE 1.721 1.814 1.74 SSE unrolled 0.652 0.656 4.59 AVX2 0.265 0.273 11.30 AVX512F 0.164 0.173 18.26 size 16384 items scalar 2.996 3.430 1.00 SSE 1.605 1.681 1.87 SSE unrolled 0.564 0.568 5.31 AVX2 0.322 0.326 9.30 AVX512F 0.208 0.213 14.40 size 32768 items scalar 3.000 3.548 1.00 SSE 1.622 1.681 1.85 SSE unrolled 0.563 0.567 5.33 AVX2 0.321 0.325 9.35 AVX512F 0.206 0.210 14.56 Acknowledgements I would like to thank my friend Romek, who inspired me to work again on side projects. Source code Source code is available on github .'],
["notesen/2018-10-18-simd-byte-lookup.html", 'SIMDized check which bytes are in a set', 'SIMDized check which bytes are in a set Wojciech Mua Added on 2018-10-18 Updated 2019-03-27 (mistake pointed by Marcus Klaas ) 2018-10-28 (add Geoff\'s algorithm, fixes/updates pointed by Michael) Contents Introduction SIMD algorithms Universal algorithm Example Implementation Alternative implementation Special case 1 --- small sets Special case 2 --- constant nibble Special case 3 --- unique lower and higher nibbles Basic SIMD methods Acknowledgements See also Source code Introduction The problem is defined as follows: there\'s a stream of bytes and we want to get a byte-mask (or a bit-mask) that indicates which bytes are in the predefined set . Thanks to SIMD instructions this task can be performed faster than scalar code. Jobs like input validation or parsing (for instance CSV files), might benefit from a vectorized approach. In this text I show several SIMD methods: The universal algorithm that can handle arbitrary sets (from 1 to 255 elements) with a few instructions. Several specialized algorithms, that handle small sets of peculiar properties. They require fewer instructions than the universal algorithm. However, the algorithms are rather meant for compilers/code generators, where we can statically determine the best code sequence for a predefined set. For sake of completeness I describe basic SIMD methods . If the set has a few elements then no fancy algorithm is needed. Likewise, if the set can be represented as a union of ranges the code is also not complicated. SIMD algorithms The main ingredient of the techniques shown below is instruction pshufb ( _mm_shuffle_epi8 ), which is present in SSE, AVX2 and also AVX512BW. The instruction does parallel byte lookup in a 16-byte register (or lane , in AVX2 and AVX512 variants) using 4-bit indices from another vector. A C-like code shows the pshufb algorithm: Universal algorithm In this algorithm the set is represented as a bitmap of size 16 x 16 bits, where a bit of value 1 indicates that given element is in the set. The bitmap is addressed with nibbles , i.e. 4-bit halves of a byte. The lower nibble of each input byte selects the bitmap\'s row, i.e. a 16-bit value. The higher nibble selects the column on the bitmap --- once we fetched a row row, the higher nibble points at specific bit. Scalar code which deals with such representation is quite simple: Example Let\'s consider following set; for better visibility zeroes are shown with dots, and ones with the \'x\': We want to check if byte 0xa5 is in the set. Its lower nibble is 5, so we select the highlighted row, getting 16-bit value 1100_0101_1101_0011 . The higher nibble is 10 ( 0xa ), thus we\'re testing this bit: It\'s set and that means 0xa5 belongs to the set. Implementation Since the instruction pshufb maps bytes into bytes, it necessary to store two halves of a bitmap, i.e. 16 x 8 bit arrays. These sub-bitmaps are highlighted with blue and magenta below. Fetching a row from the bitmap requires two lookups: to get \"blue\" and \"magenta\" parts of the row. Then, depending on higher nibble, we test a bit in \"blue\" (for higher nibble in range 0..7) or \"magenta\" part (for higher nibble in range 8..15). A note on calculating bitmask . In the scalar code it\'s just 1 << hi_nibble , here we must evaluate (1 << higher_nibble) % 8 . Fortunately, this is possible with single pshufb invocation. Below is a scalar code that show the algorithm: Instructions 1, 2 and 3 are pshufb . The fourth expression might be expressed by vector blend instruction ( x[i] ? t[i] : f[i] ). The last, 5th instruction, is simple bit-and followed by conversion into a bytemask. Following code shows a detailed SSE implementation of the above steps. Load 16 input bytes; hex digits are shown. Extract lower nibbles. Simple bit-and is needed. Extract higher nibbles, this requires also a bit shift. Pick rows for lower nibble (0..7). Likewise pick rows for higher nibble (8..15). Calculate a bitmask, i.e. (1 << hi_nibble % 8) . Choose rows halves depending on higher nibbles. Finally check which bytes belong to the set. Number of instructions: 3 x bit-and; 1 x shift; 3 x shuffle bytes; 2 x comparison; 1 x blend. Alternative implementation Geoff Langdale pointed out that we might get rid of the blend instruction, which is not the fastest one. Instead, we use pshufb , that zeros destination bytes when the highest bit of index is 1. This requires different indices when fetching row_0_7 and row_8_15 . The indices for bitmap_0_7 keep bits 0..3 and also the most significant , i.e. 7th bit of the input. Similarly the indices for bitmap_8_15 have also bits 0..3, but the bit 7th is negated. When the most significant bit is set, it means that the higher nibble is greater or equal 8 --- in such situation bitset_0_7 is zeroed and bitset_8_15 kept. The modified algorithm: Load 16 input bytes. Extract indices for row_0_7 . Extract indices for row_8_15 . Fetch row_0_7 and row_8_15 : Calculate a bitmask, i.e. (1 << hi_nibble % 8) . Choose rows halves depending on higher nibbles. Finally check which bytes belong to the set. Number of instructions: 3 x bit-and, 1 x bit-or, 1 x bit-xor, 3 x shuffle, 1 x compare. Special case 1 --- small sets This method handles up to eight distinct elements. Let\'s consider this sample set: {0x01, 0x31, 0xc1, 0x35, 0x65, 0x77, 0x8b, 0x3e}; elements are labelled with letters K .. R. We separately consider lower and higher nibble, i.e. rows and columns in the diagram above. We associate a subset with each nibble, for lower nibbles there are following subsets: 1: {K, L, M} 5: {N, O} 7: {P} b: {Q} e: {R} For higher nibbles we have: 0: {K} 3: {L, N, R} 6: {O} 7: {P} 8: {Q} c: {M} These subsets are encoded using bit sets , i.e. each element has assigned a bit in a byte (this is the source of size limit). For the example data we might have following mapping: And then lookup tables are: Algorithm consist following steps (SSE code is shown in example): Load 16 input bytes. Extract lower nibbles. Extract higher nibbles. Translate the lower and higher nibbles (the lookup tables are defined above). Test bitsets for intersection. Fix up if necessary. Convert all non-zero elements into 0xff . Number of instructions: 2 x bit-and; 1 x shift 2 x shuffle bytes; 1 x comparison [optional]; 1 x bit-andnot [optional]. Special case 2 --- constant nibble When either higher or lower nibbles of set values are constant, a single invocation of pshufb is sufficient to classify up to 16-element set. The variable nibble addresses a lookup vector which contains elements from the set; nibbles not present in the set are marked with some other value. The translated vector is finally compared for equal with the input vector, yielding zeros for bytes that are not in the set. Let\'s consider set {0x10, 0x12, 0x14, 0x15, 0x17, 0x18, 0x1a, 0x1f}. The higher nibble is constant, equal to 0x10; we will map lower, variable nibbles as shown below. Algorithm consist following steps: Load 16 input bytes. Extract the variable nibble. If it\'s lower one, then simple bit-and is needed; for higher nibble also a shift right is required. Translate the nibbles using lookup table. Compare the translated vector with the input one. Number of instructions: 1 x bit-and; 1 x shift (if higher nibble is variable); 1 x shuffle bytes; 1 x comparison. Special case 3 --- unique lower and higher nibbles When none of lower and higher nibbles repeats then just two invocations of pshufb are needed to classify a vector. In this case up to 16-elements sets are supported. Let\'s consider following 11-element set {0x20, 0x31, 0x42, 0x53, 0x64, 0x75, 0x86, 0x97, 0xa8, 0xb9, 0xca}. Lower nibbles are {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a}, higher nibbles are {2, 3, 4, 5, 6, 7, 8, 9, a, b, c} --- as we see, the both sets contain unique values. The idea is to label each set element with unique index and then map lower and higher nibbles to that index. If the indices are equal, it means that both nibbles form set\'s element. Mapping for nibbles outside the valid set must yield different values, so comparison is always false. For instance, we might have following mapping: Algorithm: Load 16 bytes. Extract lower nibbles. Extract higher nibbles. Translate lower nibbles into indices. Translate higher nibbles into indices. Compare translated nibbles --- if they match, it means that bytes also match. Number of instructions: 2 x bit-and; 1 x shift; 2 x shuffle bytes; 1 x comparison. Basic SIMD methods Just to make this text complete, we\'ll enumerate naive SIMD methods: Tiny sets might be classified by compare each element of set with the input vector and merge partial results using bit-or. For instance, if the set is {\' \', \'t\', \'n\'}, then following code matches it. If a set is described by ranges, like 0-9, A-Z and a-z, it\'s sufficient just to compare input vector with ranges\' boundaries and bit-or partial result. Please be aware that both SSE and AVX2 do not support unsigned byte comparisons. Thus only when boundaries are non-negative, code shown below works correctly. Range with holes. For instance, we want to match range A-Z except K. This can be expressed as sum of two ranges A-J and L-Z. Then we have: four comparisons, two bit-andnot operations, and one bit-or. However, it\'s easier to check the whole range and then check for excluded element(s). Then, there are three comparisons and two bit-andnot operations. Acknowledgements Thanks to Geoff Langdale and Michael Howard for their comments and fixes. See also Intel Hyperscan , that use similar algorithms Source code Source code is available on github .'],
["notesen/2018-10-24-sse-sumbytes.html", 'SIMDized sum of all bytes in the array', 'SIMDized sum of all bytes in the array Wojciech Mua Added on 2018-10-24 Contents Introduction Algorithm used by GCC 32-bit accumulators 16-bit accumulators Straightforward approach 8-bit halves AVX2-specific instruction VPSADBW Experiments Skylake SkylakeX Westmere Conclusions See also Acknowledgements Source code Introduction I was curious how GCC vectorizes function that sums bytes from an array. Below is a loop-based implementation. The same algorithm can be expressed with following C++ code. When I saw the assembly generated by GCC I was sure that it\'s possible to make it better and faster. This text summarizes my findings. I focus solely on Skylake performance and AVX2 code. The sources have got also implementations of SSE procedures and experiments include timings from an older CPU. Algorithm used by GCC Below is the assembly code of the main loop compiled for Skylake by GCC 7.3.0 with flags -O3 -march=skylake : GCC nicely vectorized the algorithm: it keeps multiple 32-bit sub-accumulators in single register, i.e. eight in case of AVX2 (four in SSE code). These 32-bit numbers are added together in the end, forming the scalar result. Now, let\'s look how the type casting is done. Although AVX2 has variant of instruction VPMOVZXBD that converts directly from uint8_t to uint32_t (intrinsic _mm256_cvtepu8_epi32 ) the compiler does the conversion in two steps: First, it extends a vector of uint8_t into two vectors of uint16_t numbers ( VPMOVZXBW ). Then, gets four vectors of uint32_t from the vectors obtained in the previous step ( VPMOVZXWD ). The cast instruction VPMOVZX extends the lower part of a register, in this case the lower half. This is the reason why extractions of helves ( VEXTRACTI128 ) are needed. 32-bit accumulators In this approach we cast directly from uint8_t to uint32_t . But casting isn\'t done by the mentioned VPMOVZXBD --- we use only bit-ands and shifts within 32-bit lanes, that has some benefits. Load the vector: Mask 0th bytes in each 32-bit lane Move 1st bytes into 0th position in each lane. Move 2nd bytes into 0th position in each lane. Move 3rd bytes into 0th position in each lane. Update the accumulator. Here is an actual implementation: The assembly code of the main loop is: This approach is two times faster than the compiler\'s version. There are two reasons of that: We have 10 instructions instead of 13. All of these instruction are simple and they are fast. Let\'s look at the instructions\' parameters for the Skylake architecture taken from Agner Fog\'s site . instruction micro-ops port allocation latency reciprocal throughput compiler version 3 x vextracti128 1 p5 3 1 2 x vpmovzxbw 1 p5 3 1 4 x vpmovzxwd 1 p5 3 1 4 x vpaddd 1 p015 1 0.33 our approach 3 x vpand 1 p015 1 0.33 3 x vpsrlid 1 p05 1 0.5 4 x vpaddd 1 p015 1 0.33 First of all, most instructions emitted by compiler have latency 3 cycles. But latency could be compensated (especially in unrolled loops). Worse is that all instructions except VPADD are dispatched on the same execution port #5. So, it\'s likely that there will be congestion on the port. Instructions used by our approach can be dispatched to different ports (and thus executed in parallel); moreover, all have latency just 1 cycle. 16-bit accumulators Using 16-bit accumulators instead of 32-bit accumulators doubles capacity, so in AVX2 code we\'re updating 16 instead of 8 accumulators in a single iteration. But this approach limits the number of additions that can be performed without overflow to max(uint16_t)/max(uint8_t) = 65535/255 = 257 . The overcome this we need two nested loops. The outer loop keeps 32-bit accumulators, as the initial version does. The inner loop processes 256 * 8 bytes, i.e. iterates 64 times. When the inner loop completes, 16-bit accumulators are extended to 32-bit and the outer accumulators are updated. Straightforward approach Below is a C++ implementation that directly use vectors of uint16_t in the inner loop. 8-bit halves In this approach we also use 16-bit accumulators, but their lower and higher bytes are stored separately in distinct vectors. Thanks to that we use the full capacity of AVX2, i.e. we can perform 32 additions at time. In each iteration the input vector of bytes is added to the lower part of accumulator. Higher part is updated in the second step, getting carry from the previous step. Following scalar code shows the idea: How to detect an overflow? In a scalar code it\'s simple, as we can read the carry flag and react accordingly (GCC provides nice wrappers for this, like __builtin_add_overflow ). But there is no such a thing like vector of carry flags in neither AVX2 or SSE. We can detect overflow with help of saturated addition . In saturated arithmetics, if an operation would cause overflow, then result is the maximum (or minimum) value the target type can hold. Thus, the saturated addition might be expressed as: We perform two operations: normal addition (in wrap-around arithmetic); and saturated one. If results of both sums are not equal , it means there is the overflow. But since AVX2 has no \"not-equal\" relation (there is comparison for \"equal\"), we need to invert the logic. We initialize the higher part of accumulator to the highest possible value, i.e. the number of inner loop iterations. Then, we decrement the higher part with the \"no-overflow\" byte-mask. Following scalar code illustrates the idea. The actual implementation is shown below. AVX2-specific instruction VPSADBW AVX2 defines instruction VPSADBW ( _mm256_sad_epu8 ) that calculates Sum Of Absolute Differences (SAD) of unsigned bytes. Single SAD function works on eight-element subvectors (64-bit slices), and stores the results on corresponding 64-bit elements of the result vector; in case of AVX2 the VPSADB yields four numbers. Below is a sample C++ code that naively implements SAD function. If one of argument vectors is full of zeros, then SAD calculates the sum of bytes from another argument --- which exactly what we need. Moreover, since the instruction calculates 64-bit sums, bigger arrays can be processed without overflow. Below is the simplest, non-unrolled C++ code. Although the VPSADBW instruction has latency of 3 cycles, it has low throughput of 1 cycle. In case of an unrolled procedure the latency is almost ridden of. The performance boost over the compiler code is almost 6 times . Experiments Tested procedures scalar plain loop scalar (C++) std::accumulate SSE convert uint8_t -> uint16_t with PMOVZXWD SSE (v2) 32-bit accumulators SSE (sadbw) PSADBW instruction SSE (sadbw, unrolled) the above procedure unrolled four times SSE (16bit accu) 16-bit accumulators , uint16_t -> uint32_t with PMOVZXBW SSE (16bit accu, v2) 16-bit accumulators , uint16_t -> uint32_t with PAND / PSRLD SSE (16bit accu, v2, unrolled) the above procedure unrolled four times SSE (8bit accu) 8-bit accumulators AVX2 (v2) 32-bit accumulators AVX2 (sadbw) VPSADBW instruction AVX2 (sadbw, unrolled) the above procedure unrolled four times AVX2 (16bit accu, v2) 16-bit accumulators , uint16_t -> uint32_t with VPAND / VPSRLD AVX2 (16bit accu, v2, unrolled) the above procedure unrolled four times AVX2 (8bit accu) 8-bit accumulators The procedures were run three times and minimum values were noted. Skylake CPU: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz GCC: gcc (GCC) 7.3.0 procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 0.294 0.297 1.00 scalar (C++) 0.295 0.297 1.00 SSE 0.440 0.442 0.67 SSE (v2) 0.252 0.254 1.17 SSE (sadbw) 0.129 0.132 2.28 SSE (sadbw, unrolled) 0.129 0.132 2.28 SSE (16bit accu) 0.195 0.197 1.51 SSE (16bit accu, v2) 0.169 0.176 1.74 SSE (16bit accu, v2, unrolled) 0.109 0.111 2.70 SSE (8bit accu) 0.125 0.130 2.35 AVX2 (v2) 0.138 0.140 2.13 AVX2 (sadbw) 0.075 0.077 3.92 AVX2 (sadbw, unrolled) 0.051 0.052 5.76 AVX2 (16bit accu, v2) 0.091 0.093 3.23 AVX2 (16bit accu, v2, unrolled) 0.073 0.075 4.03 AVX2 (8bit accu) 0.080 0.083 3.67 size 16384 items scalar 0.285 0.286 1.00 scalar (C++) 0.285 0.286 1.00 SSE 0.439 0.440 0.65 SSE (v2) 0.251 0.252 1.14 SSE (sadbw) 0.126 0.127 2.26 SSE (sadbw, unrolled) 0.126 0.127 2.26 SSE (16bit accu) 0.191 0.192 1.49 SSE (16bit accu, v2) 0.173 0.181 1.65 SSE (16bit accu, v2, unrolled) 0.107 0.108 2.66 SSE (8bit accu) 0.123 0.126 2.32 AVX2 (v2) 0.134 0.135 2.13 AVX2 (sadbw) 0.072 0.072 3.96 AVX2 (sadbw, unrolled) 0.048 0.049 5.94 AVX2 (16bit accu, v2) 0.089 0.090 3.20 AVX2 (16bit accu, v2, unrolled) 0.070 0.070 4.07 AVX2 (8bit accu) 0.076 0.077 3.75 size 32768 items scalar 0.284 0.285 1.00 scalar (C++) 0.284 0.284 1.00 SSE 0.439 0.440 0.65 SSE (v2) 0.251 0.252 1.13 SSE (sadbw) 0.126 0.127 2.25 SSE (sadbw, unrolled) 0.126 0.127 2.25 SSE (16bit accu) 0.191 0.192 1.49 SSE (16bit accu, v2) 0.169 0.173 1.68 SSE (16bit accu, v2, unrolled) 0.109 0.109 2.61 SSE (8bit accu) 0.124 0.127 2.29 AVX2 (v2) 0.134 0.135 2.12 AVX2 (sadbw) 0.072 0.073 3.94 AVX2 (sadbw, unrolled) 0.048 0.049 5.92 AVX2 (16bit accu, v2) 0.089 0.090 3.19 AVX2 (16bit accu, v2, unrolled) 0.071 0.072 4.00 AVX2 (8bit accu) 0.076 0.077 3.74 SkylakeX CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz GCC: gcc (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0 procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 0.278 0.385 1.00 scalar (C++) 0.278 0.281 1.00 SSE 0.431 0.434 0.65 SSE (v2) 0.216 0.248 1.29 SSE (sadbw) 0.092 0.095 3.02 SSE (sadbw, unrolled) 0.092 0.120 3.02 SSE (16bit accu) 0.188 0.191 1.48 SSE (16bit accu, v2) 0.134 0.138 2.07 SSE (16bit accu, v2, unrolled) 0.120 0.121 2.32 SSE (8bit accu) 0.133 0.140 2.09 AVX2 (v2) 0.123 0.125 2.26 AVX2 (sadbw) 0.060 0.063 4.63 AVX2 (sadbw, unrolled) 0.041 0.043 6.78 AVX2 (16bit accu, v2) 0.076 0.078 3.66 AVX2 (16bit accu, v2, unrolled) 0.064 0.065 4.34 AVX2 (8bit accu) 0.070 0.072 3.97 size 16384 items scalar 0.280 0.282 1.00 scalar (C++) 0.280 0.281 1.00 SSE 0.435 0.437 0.64 SSE (v2) 0.218 0.249 1.28 SSE (sadbw) 0.093 0.094 3.01 SSE (sadbw, unrolled) 0.093 0.125 3.01 SSE (16bit accu) 0.188 0.190 1.49 SSE (16bit accu, v2) 0.134 0.135 2.09 SSE (16bit accu, v2, unrolled) 0.124 0.125 2.26 SSE (8bit accu) 0.142 0.145 1.97 AVX2 (v2) 0.124 0.125 2.26 AVX2 (sadbw) 0.062 0.063 4.52 AVX2 (sadbw, unrolled) 0.044 0.044 6.36 AVX2 (16bit accu, v2) 0.079 0.080 3.54 AVX2 (16bit accu, v2, unrolled) 0.066 0.067 4.24 AVX2 (8bit accu) 0.070 0.071 4.00 size 32768 items scalar 0.281 0.282 1.00 scalar (C++) 0.281 0.281 1.00 SSE 0.436 0.437 0.64 SSE (v2) 0.219 0.250 1.28 SSE (sadbw) 0.095 0.097 2.96 SSE (sadbw, unrolled) 0.096 0.125 2.93 SSE (16bit accu) 0.189 0.191 1.49 SSE (16bit accu, v2) 0.134 0.137 2.10 SSE (16bit accu, v2, unrolled) 0.125 0.125 2.25 SSE (8bit accu) 0.146 0.149 1.92 AVX2 (v2) 0.125 0.126 2.25 AVX2 (sadbw) 0.062 0.063 4.53 AVX2 (sadbw, unrolled) 0.045 0.045 6.24 AVX2 (16bit accu, v2) 0.079 0.080 3.56 AVX2 (16bit accu, v2, unrolled) 0.067 0.068 4.19 AVX2 (8bit accu) 0.071 0.072 3.96 Westmere CPU: Intel(R) Core(TM) i5 CPU M 540 @ 2.53GHz GCC: gcc (Debian 7.3.0-16) 7.3.0 procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 0.370 0.475 1.00 scalar (C++) 0.371 0.374 1.00 SSE 0.320 0.323 1.16 SSE (v2) 0.311 0.311 1.19 SSE (sadbw) 0.142 0.143 2.61 SSE (sadbw, unrolled) 0.141 0.143 2.62 SSE (16bit accu) 0.204 0.207 1.81 SSE (16bit accu, v2) 0.170 0.174 2.18 SSE (16bit accu, v2, unrolled) 0.115 0.117 3.22 SSE (8bit accu) 0.149 0.151 2.48 size 16384 items scalar 0.375 0.376 1.00 scalar (C++) 0.375 0.377 1.00 SSE 0.325 0.327 1.15 SSE (v2) 0.309 0.318 1.21 SSE (sadbw) 0.152 0.153 2.47 SSE (sadbw, unrolled) 0.152 0.153 2.47 SSE (16bit accu) 0.214 0.215 1.75 SSE (16bit accu, v2) 0.176 0.177 2.13 SSE (16bit accu, v2, unrolled) 0.126 0.127 2.98 SSE (8bit accu) 0.159 0.159 2.36 size 32768 items scalar 0.375 0.377 1.00 scalar (C++) 0.375 0.377 1.00 SSE 0.326 0.328 1.15 SSE (v2) 0.292 0.293 1.28 SSE (sadbw) 0.153 0.154 2.45 SSE (sadbw, unrolled) 0.153 0.154 2.45 SSE (16bit accu) 0.215 0.217 1.74 SSE (16bit accu, v2) 0.180 0.181 2.08 SSE (16bit accu, v2, unrolled) 0.140 0.140 2.68 SSE (8bit accu) 0.163 0.164 2.30 Conclusions On Skylake and SkylakeX architectures SADBW method is unbeatable, it\'s 5-6 times faster than compiled code. On Westmere we can be even faster than the SADB method (but not too much). Anyways, we\'re faster 2-3 times than compiled code. It\'s worth to note that GCC compiles plain C and C++ procedures into the same code. It is another proof that C++ templates are not that bad (of course in term of performance). See also There is also second part , dealing with signed bytes Acknowledgements Big thanks to Daniel Lemire who provides access to Skylake/SkylakeX machines, where I can run benchmarks. Source code Source code is available on github .'],
["notesen/2018-10-28-cpp-static-vectors.html", 'SIMD --- why you shouldn\'t use static vector constants', 'SIMD --- why you shouldn\'t use static vector constants Wojciech Mua Added on 2018-10-28 Updated 2018-10-29 Introduction When work with SSE/AVX2/AVX512 it\'s virtually impossible not to use some vector constants, which are defined by _mm_set_epi32 or similar intrinsic functions. If your program is written in C++ NEVER EVER use static const for such constants. Why? From what I can gather, a compiler treats vector types not as PODs ( Plain-Old-Data ), but as fully-featured classes that have to be constructed and destructed by some additional code. I checked this on GCC 7.3.0 from Debian, and then confirmed on GCC 8.2.0 and Clang 7.0.0 on godbolt.org . Details Let\'s consider these trivial functions: GCC 7.3.0 was invoked with options -msse4.1 -O3 , and assembly for increment is as simple as we may expect: There is only paddd instruction with a memory argument, which points to data at label .LC0 . The compiler figured out that values we read are plain integers. Now, let\'s look at the assembly generated for increment_static : The sub-procedures labelled with .L2 and .L4 deal with static initialization of values stored as four longs at .LCO . The details of this are not that important. The performance problem with this code is that upon each call to the procedure there\'s a test whether a vector was initialized or not: To make things worse, for every static vector used in a procedure similar code is generated. Example of performance problem I spotted this problem when profiling procedures that execute dozens of various vectors shuffles. There are a lot of auxilary vector constats, procedure #1 uses 36, and procedure #2 --- 22 constants. I know, it is not a typical case. With static const we have: Without static , just const : Conclusions I\'m not a C++ language lawyer, but suspect that such behaviour of the compilers has roots in the language standard. Update 2018-10-29 Matt pointed out that this is implementation of \"magic constants\" ( standard , explanation ); it can be disabled with -fno-threadsafe-statics flag. But still I don\'t understand why the C++ compilers treat vector types as they were non-PODs, while they surely are PODs; std::is_pod evaluates to true for all vector types ( __m128 , __m128d , __m128i ).'],
["notesen/2018-11-14-simd-multiple-vector-ops.html", 'Speeding up multiple vector operations using SIMD', 'Speeding up multiple vector operations using SIMD Wojciech Mua Added on 2018-11-14 Contents Introduction Baseline Optimization Distance function Multiple distances at once Evaluation Conclusions Source code Introduction One step of k-means algorithm is calculating the distance between all centroids and all samples . Then centroids are recalculated and samples re-assigned. Centroids and also samples are vectors of fixed size . I was curious how SIMD might help in this task (or similar ones). Baseline C++ code that shows the idea of this step: The distance function is often the sum of squares of differences: Optimization Distance function Since we operates on vectors, the most obvious use of SIMD instructions is to vectorize the distance procedure calculate_distance . A decent compiler is able to auto-vectorize such a simple function; GCC and clang require flag -ffast-math to enable this. Here is the assembly code generated by GCC 7.3.1: Below is a hand-coded version, without processing vectors\' tail. Multiple distances at once In the inner loop the expression centroid[i] is constant. We can use this fact and calculate multiple distances at once, minimizing number of memory fetches from centroids array and also utilizing all SIMD resources. So the algorithm becomes: And actual implementation of calculate_multiple_distances , which processes four vectors at once: While in a naive algorithm we fetch numbers from the centroids table K * N times, here we do K * N/4 , just 25%. Evaluation Tested procedures scalar baseline SSE hand-written distance function SSE (custom) multiple distances at once CPU: Intel(R) Core(TM) i5 CPU M 540 @ 2.53GHz Compiler: GCC version 7.3.0 (Debian 7.3.0-16) procedure 8 vectors 16 vectors 32 vectors 64 vectors 128 vectors 256 vectors avg cycles speedup avg cycles speedup avg cycles speedup avg cycles speedup avg cycles speedup avg cycles speedup vector size 64 scalar 7.722 0.77 17.460 0.67 29.995 0.78 59.743 0.78 125.639 0.82 243.951 0.80 SSE 5.918 1.00 11.660 1.00 23.435 1.00 46.609 1.00 103.063 1.00 195.983 1.00 SSE (custom) 4.316 1.37 8.262 1.41 16.068 1.46 31.796 1.47 64.827 1.59 131.814 1.49 vector size 128 scalar 6.324 0.81 12.562 0.80 27.698 0.74 56.080 0.77 112.804 0.78 205.904 0.86 SSE 5.123 1.00 10.104 1.00 20.384 1.00 43.358 1.00 87.848 1.00 176.197 1.00 SSE (custom) 4.071 1.26 7.378 1.37 14.630 1.39 29.439 1.47 59.328 1.48 118.533 1.49 vector size 256 scalar 5.673 0.86 11.791 0.84 24.314 1.26 49.156 0.84 98.680 0.89 199.404 0.87 SSE 4.870 1.00 9.846 1.00 30.579 1.00 41.315 1.00 88.000 1.00 172.773 1.00 SSE (custom) 3.577 1.36 6.997 1.41 13.973 2.19 28.017 1.47 56.665 1.55 122.198 1.41 vector size 512 scalar 5.512 0.95 11.288 0.94 23.021 0.91 46.159 0.92 96.044 0.90 193.548 0.93 SSE 5.263 1.00 10.556 1.00 21.044 1.00 42.326 1.00 86.618 1.00 179.824 1.00 SSE (custom) 3.425 1.54 6.830 1.55 13.708 1.54 27.406 1.54 58.562 1.48 123.773 1.45 vector size 1024 scalar 5.537 0.93 11.006 0.93 22.110 0.95 46.855 0.90 93.629 0.92 186.649 0.92 SSE 5.148 1.00 10.225 1.00 20.995 1.00 42.357 1.00 85.820 1.00 172.297 1.00 SSE (custom) 6.028 0.85 6.840 1.49 13.595 1.54 28.767 1.47 58.689 1.46 118.137 1.46 vector size 4096 scalar 7.279 0.93 11.265 0.95 22.857 0.95 45.792 0.93 99.772 0.95 359.419 0.98 SSE 6.805 1.00 10.667 1.00 21.734 1.00 42.647 1.00 94.667 1.00 352.802 1.00 SSE (custom) 4.504 1.51 7.500 1.42 14.748 1.47 29.902 1.43 64.656 1.46 302.095 1.17 vector size 8192 scalar 8.293 0.98 13.242 0.94 24.831 0.98 53.673 0.99 180.724 0.99 408.179 1.00 SSE 8.160 1.00 12.426 1.00 24.274 1.00 52.892 1.00 178.407 1.00 406.330 1.00 SSE (custom) 4.751 1.72 7.466 1.66 15.167 1.60 32.015 1.65 145.880 1.22 358.551 1.13 Conclusions Results surprised me. I didn\'t expect that such a simple reorganization of computations might be beneficial. In this case we have speedups ranging from 1.10 to 1.60. Which is pretty nice, especially in context of k-means where this operation is the most time consuming. Source code Sample code is available on github .'],
["notesen/2018-11-15-code-dive-2018.html", 'A short report from code::dive 2018', 'A short report from code::dive 2018 Wojciech Mua Added on 2018-11-18 Contents Introduction The Hitchhiker\'s Guide to Faster Builds Clean code in Go GoLand Tips & Tricks Taming dynamic memory - An introduction to custom allocators in C++ Python as C++s limiting case How to do practical Data Science? From real-world examples to recommendations C/C++ vs Security! A trusted trip in the cloud --- working with trusted hardware in practice Augmented Reality - The State of Play Why algebraic data types are important Random bits Introduction In November this year there was new edition of code::dive , an IT conference in Wrocaw, Poland. Practically nothing has changed from the previous edition : it is still great. The place is perfect, it\'s in a huge cinema located in the city center. There were free snack and water, and amazing coffee at decent price (the only downside was huge queues). As always, there were a lot of interesting talks; a new thing were \"lighting talks\", run during lunch break. This edition was a bit different, though. Although Nokia still sponsors the conference, the organizers asked participants to buy tickets (25 zotych, 5 euro) and then gave all income to Polish Association of the Blind; I totally love this approach. BTW, approx 38,000 zotych were collected. Disclaimer : I\'m Nokia employee right now, but am writing this text in my spare time. The employer was so kind that I went to the conference during working hours. The talks I attended: \"The Hitchhiker\'s Guide to Faster Builds\" (two parts) by Viktor Kirilov \"Clean code in Go\" by Mateusz Dymiski \"GoLand Tips & Tricks\" by Florin Pan \"Taming dynamic memory - An introduction to custom allocators in C++\" by Andreas Weis \"Python as C++s limiting case\" by Brandon Rhodes \"How to do practical Data Science? From real-world examples to recommendations\" by Artur Suchwako \"C/C++ vs Security!\" by Gynvael Coldwind \"A trusted trip in the cloud --- working with trusted hardware in practice\" by Gabriela Limonta \"Augmented Reality - The State of Play\" by Rafa Legid \"Why algebraic data types are important\" by Bartosz Milewski The Hitchhiker\'s Guide to Faster Builds This talk, split into two parts, was packed with information. Viktor presented an awful lot of different techniques and tools that might boost building C++ applications. On one hand it\'s good, but on the other hand I fell somehow overloaded. I didn\'t like the slides. They were filled with lots of text, and also have links to other presentations or articles. It might be useful when one goes through the presentation at home, at own pace. On a conference it doesn\'t look well. What I missed the most was real-life examples, hard numbers. There were some, but still not much. Also statements like \"reportedly it\'s faster\" are not too convincing. I really liked the history of C++ modules. I\'m always saying that development of C++ is too slow and it\'s delayed several years to market needs. Modules are a bright example. The first proposal appeared in 2004. Moving fast forward, now we have 2018 and modules have just been accepted for the upcoming standard. Only 14 years, and it\'s almost there! But the idea of modules is not new. For instance, the first Ada edition from 1983 had modules (not to mention Modula by Wirth); Ada 1995 introduced generic modules, that can be parametrized with types. C++ programmers might be envious. Clean code in Go Mateusz tried to defend a thesis that Go programs are by design clean. The definition of \"clean code\" is that something is clean if you see there what you expected to see . The speaker cited all statements from the Go creators. So, we know that Go syntax is simple, there are no exceptions nor classes. That Go is stable, there are no new features and so on, and so forth. A Go source code is simple to read, reason about, etc. I was a bit disappointed with this form, I rather expected some real-world examples; I can always read Go propaganda on Hacker News. And to be honest, I didn\'t get convinced. But I liked the talk, as Matuesz also mentioned not so bright features of Go. Like lack of generics which forces people to copy-paste-driven development. The funny fact is the Go creators thought the language would lure C++ programmers, as they solved some painful C++ problems. It hasn\'t happened, people switched from PHP, Python and other dynamically-typed languages, but not from C++. GoLand Tips & Tricks My English teacher often says that I would do exercises from our textbook much better if I read instructions. Add my glasses to this and you\'ll understand why I was sure I was going to see \"GoLang Tips & Tricks\". The single letter made the difference. It was the live demo of a commercial product, an IDE for Go. During the presentation an extremely easy Go project was edited and refactored. But I\'m not going to complain, to my surprise I enjoyed the show... in a way. Let me start with a bit of personal history. Last time I used an IDE was 15 years ago. It was a pirated copy of Borland Pascal, run in DOS and I was obviously younger. Later, when I moved to Linux, I realized that with multiple shells --- provided natively by the system or programs like screen --- an IDE is overkill, if not a plainly stupid concept. The standard shell commands, VIM and screen are enough to work rather efficiently. So, while I was watching how these colorful boxes popping around, how magic combinations of keystrokes have to be pressed in order to do basic text editing, how many mouse clicks are needed to do this and that, I felt this is not how I want to write my code. Ever. A simple script is better than two clicks. This is my motto coined during writing this paragraph. Taming dynamic memory - An introduction to custom allocators in C++ I enjoyed the talk, one of the best I saw this year. Andreas showed how simple allocation strategies work and also what traits do they have. He described memory pools and another one which name slept my mind (it\'s the allocation algorithm used by Pascal, where you allocate many objects but can free only all objects at once). We also learnt that C++ offers an interface to plug custom allocators, and that the names of related namespace/function are as always counter-intuitive. The C++ committee is bad at names. Python as C++s limiting case I\'m not sure for 100%, but Brandon was the first presenter who wore a tie. The whole lecture was funny. I love the slides --- there were a few words on each slide, typeset in a large font. One can read a slide in an eye blink, and then concentrate on the speaker. Learn from Brandon. It was talk about Python, how the language borrowed and simplified concepts, mostly from C++. He made fun from JavaScript ( \'4\' - 3 is int(3) , but \'4\' + 3 is \"43\" ), saying that such an absurd are almost nonexistent in Python. One really funny thing that caught my attention was hesitation about \"tuple\" pronunciation; English is funny. BTW it was said that CPython has no garbage collection, but only referenced counting. It\'s not true, there\'s a generational garbage collector, which can be accessed via a standard module gc . Simple reference counting doesn\'t deal with cyclic references. How to do practical Data Science? From real-world examples to recommendations A nice description of three cases from Polish companies, huge ones: an insurance company and telecom. Unfortunately, the talk was too technical, most people are not data science practitioners. I expected something lighter and easier to digest, sometimes it was a bit difficult to follow. Most important takeaways from this talk are: 1) the big business is keen on spending money if it can help (save more money, for instance), and 2) data science doesn\'t require top-notch technology, most of work can be done on consumer hardware; I think only the telecom case involved extra servers. C/C++ vs Security! Do not confuse this talk with \"C/C++ vs Security\" (without the exclamation mark)! It was a nice talk, which I didn\'t like. I feel like it was too chaotic, where rather simple problems were mixed with very complex (like Spectre). Try to explain Spectre in five minutes to a person who doesn\'t know modern CPUs\' details; it won\'t work, sorry. A trusted trip in the cloud --- working with trusted hardware in practice My second favourite talk. It was a story about IT reality, about hurdles, about specifications and implementations. I\'m sure everybody listening to Gabriela stories will find there part of their own history. Thus no spoilers, but definitely loved XKCD used wisely! Augmented Reality - The State of Play A good overview of state of the art of augmented reality. The state is that although different solutions appears on the market they are not successful. But according to Rafa, this will finally happen and we should be already prepared. One important takeaway is that we usually thing about augmented reality in terms of vision, but humans have more senses. For instance, these noise-cutting headphones are means of augment reality, which surprised me. Why algebraic data types are important Well, this talk reminded me following joke: \"any web service can be represent by a nine-element tuple, but... it doesn\'t help\". Bartosz showed algebra of functions, which is the foundation of, I guess, all functional languages. He claimed that C++ would be a better language if its type system was designed bottom-down, from these fancy theory. The problem is that all languages meant to replace C++ are either dead or used by few people. Also functional languages haven\'t taken over the IT world. My gut feeling is that a type system is not a crucial problem. The speaker had enormous number of slides, so he managed to show us just a small portion of material. But I liked this, it was a bit like time travel to the past when I was programming in SML, Ocaml and reading about Clean (the language). Random bits The new word: shelfware . This is software which is put on \"a shelf\", i.e. it is not officially dead, but we\'re hoping everybody will soon forget about it. I overheard a phone call, which went like this: \"we learnt a lot of new things, it appears that we have to remove everything and start over\".'],
["notesen/2018-11-18-skylakex-uops.html", 'How many uops are there?', 'How many uops are there? Wojciech Mua Added on 2018-11-18 The current Intel CPUs translate instructions into so called uops (micro-ops), which is a kind of internal ISA. For simple operations, like addition or bitops, translation is one-to-one, i.e. there\'s exactly one uop for given instruction. When an instruction gets a memory argument we usually will get two uops: one for load, another for actual operation; please note that most instructions has many forms, usually reg, reg and reg, mem . I was curious how it looks in case of SIMD instructions. I used data from uops.info , and picked recent SkylakeX architecture; results are from IACA 3.0, Observations: 90% of SIMD instructions are directly (or almost directly) translated into simple uops. It means they\'re likely supported by dedicated circuits. AVX512 scatter , gather and conflict instructions seem not to be backed by hardware. STNI is very dead. uops number of CPU instructions % CPU instructions 0 8 0.17 vgatherdps, vgatherdps, vgatherqps, vpgatherdd, vpgatherdd, vpgatherqq, vpscatterqd, vscatterqps 1 1752 36.17 too many, omitted 2 2616 54.00 too many, omitted 3 234 4.83 too many, omitted 4 140 2.89 too many, omitted 5 38 0.78 dpps, vdpps, vdpps, vgatherdpd, vgatherdpd, vgatherdpd, vgatherdpd, vgatherdpd, vgatherdps, vgatherdps, vgatherdps, vgatherqpd, vgatherqpd, vgatherqpd, vgatherqpd, vgatherqpd, vgatherqps, vgatherqps, vgatherqps, vgatherqps, vmovdqu8, vpgatherdd, vpgatherdd, vpgatherdd, vpgatherdq, vpgatherdq, vpgatherdq, vpgatherdq, vpgatherdq, vpgatherqd, vpgatherqd, vpgatherqd, vpgatherqd, vpgatherqd, vpgatherqq, vpgatherqq, vpgatherqq, vpgatherqq 7 4 0.08 vpscatterdq, vpscatterqq, vscatterdpd, vscatterqpd 8 10 0.21 pcmpestri, rex.w pcmpestri, rex.w vpcmpestri, vpcmpestri, vpconflictd, vpconflictd, vpscatterqd, vpscatterqd, vscatterqps, vscatterqps 9 8 0.17 pcmpestri, pcmpestrm, rex.w pcmpestri, rex.w pcmpestrm, rex.w vpcmpestri, rex.w vpcmpestrm, vpcmpestri, vpcmpestrm 10 4 0.08 pcmpestrm, rex.w pcmpestrm, rex.w vpcmpestrm, vpcmpestrm 11 6 0.12 vaeskeygenassist, vaeskeygenassist, vpscatterdq, vpscatterqq, vscatterdpd, vscatterqpd 12 2 0.04 vpscatterdd, vscatterdps 14 2 0.04 vpconflictd, vpconflictq 15 2 0.04 vpconflictq, vpconflictq 16 1 0.02 vzeroall 19 4 0.08 vpscatterdq, vpscatterqq, vscatterdpd, vscatterqpd 20 2 0.04 vpscatterdd, vscatterdps 21 2 0.04 vpconflictd, vpconflictq 22 4 0.08 vpconflictd, vpconflictd, vpconflictq, vpconflictq 35 1 0.02 vpconflictd 36 4 0.08 vpconflictd, vpconflictd, vpscatterdd, vscatterdps Scripts used to collect the data are available .'],
["notesen/2018-11-18-sse-sumbytes-part2.html", 'SIMDized sum of all bytes in the array --- part 2: signed bytes', 'SIMDized sum of all bytes in the array --- part 2: signed bytes Wojciech Mua Added on 2018-11-18 Updated on 2019-02-04 ( faster PSADBW approach contributed by Matthieu Darbois , update results from GCC); 2019-02-03 ( new method also contributed by Matthieu Darbois ) Contents Introduction Algorithm used by GCC Explicit casting Shift-based casting AVX2-specific instruction VPSADBW --- naive approach AVX2-specific instruction VPSADBW --- faster algorithm AVX2-specific instruction VPMADDUBSW Experiments Haswell Skylake SkylakeX CannonLake Conclusions Acknowledgements Source code Introduction This is the second part of SIMDized sum of all bytes in the array . The first part describes summing unsigned bytes, here we\'re going to experiment with summing of signed bytes. The baseline C implementation is: And the C++ implementation: Algorithm used by GCC Below is the assembly code of the main loop compiled for Skylake by GCC 7.3.0 with flags -O3 -march=skylake : The approach used here by GCC is exactly the same as for summing unsigned bytes. There are multiple 32-bit sub-accumulators in single register, i.e. eight in case of AVX2 (four in SSE code), which are added together in the end, forming the scalar result. To get 32-bit values there\'s two-step casting from int8_t to int32_t : First extend a vector of int8_t into two vectors of int16_t numbers ( VPMOVSXBW ). Then, get four vectors of int32_t from the vectors obtained in the previous step ( VPMOVSXWD ). The cast instruction VPMOVSX extends the lower part of a register, in this case the lower half. This is the reason why extractions of helves ( VEXTRACTI128 ) are needed. Explicit casting There\'s instruction VPMOVSXBD which casts directly from int8_t to int32_t . It get lower 64 bits of input register, thus to convert all bytes from an AVX2 register the instruction has to be called 4 times and some shifting is needed. Below is sample implementation Shift-based casting In this approach we also cast directly from 8 into 32-bit numbers, but we use 32-bit shifts. To convert 3rd bytes in all 32-bit words of registers we simply do arithmetic shift right by 24 bits right. This shift repeats the most significant (a sign bit) of our 8-bit value. However, to do the same for other bytes in a 32-bit we need two shifts. The first one left, which places byte at 3rd position. Then arithmetic shift right is used to extend the type. Algorithm is: Load the input vector. Extend 3rd bytes. Extend 2nd bytes. Extend 1st bytes. Extend 0th bytes. Update the accumulator. Sample implementation: AVX2-specific instruction VPSADBW --- naive approach AVX2 has got instruction VPSADBW ( _mm256_sad_epu8 ) that calculates Sum Of Absolute Differences (SAD) of unsigned bytes. Single SAD function works on eight-element subvectors (64-bit slices), and stores the results on corresponding 64-bit elements of the result vector; in case of AVX2 the VPSADBW yields four numbers. And while the instruction is perfect for summing unsigned bytes, in case of signed bytes it not that great. VPSADBW has to be used twice: for positive and negative elements of input vector, as it works only on unsigned bytes. Below is the outline of algorithm: Load the input vector. Find mask for negative numbers. Left positive elements. Sum the positive elements. Get the absolute value. Left only the absolute values of negative elements. Sum the negative elements. Update the accumulators. Below is the actual implementation. AVX2-specific instruction VPSADBW --- faster algorithm Matthieu Darbois came up with a way batter method that utilizing VPSADBW . The input range of bytes is changed from int8_t range, i.e. -128 .. +128, into uint8_t range by adding 128. This addition sets the input range to 0 .. 255, and thanks to that single invocation of VPSADBW is sufficient to add unsigned bytes. The input adjustment is done with a cheap binary operation, thus the procedure is as fast as its unsigned counterpart. Due to the input adjustments, the final result is increased by 128 times the number of bytes. This value must be extracted to get the real singed sum. Below is the actual implementation. AVX2-specific instruction VPMADDUBSW Matthieu Darbois also proposed to use instruction VPMADDUBSW ( _mm256_madd_epi16 ) to perform horizontal additions of bytes. The instruction itself is more complex, as it multiplies vertically bytes and then adds the pairs of intermediate signed 16-bit results, forming a new vector of 16-bit values. If another vector is filled with 1, then efficiently we add pair of bytes horizontally. The inner loop of algorithm uses VPMADDUBSW to obtain 16-bit counters which update a 16-bit local accumulator. To avoid overflow, after a fixed number of iterations (128), the local accumulator is extended to 32-bit values and added to the global, 32-bit accumulator. Below is the actual implementation. Experiments Tested procedures scalar plain loop scalar (C++) std::accumulate SSE explicit casting SSE (v2) shif-based casting SSE (sadbw) two PSADBW instructions SSE (sadbw, unrolled) the above procedure unrolled four times AVX2 explicit casting AVX2 (v2) shift-based casting AVX2 (sadbw) two VPSADBW instructions AVX2 (sadbw, unrolled) the above procedure unrolled four times AVX2 (sadbw, variant) single VPSADBW instruction AVX2 (maddubs) VPMADDUBSW instruction The procedures were run three times and minimum values were noted. Haswell CPU: Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz (Haswell) Compiler: Apple LLVM version 10.0.0 (clang-1000.11.45.5) procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 0.132 0.153 1.00 scalar (C++) 0.122 0.131 1.08 SSE 0.294 0.300 0.45 SSE (v2) 0.294 0.317 0.45 SSE (sadbw) 0.130 0.141 1.02 SSE (sadbw, unrolled) 0.130 0.135 1.02 AVX2 0.153 0.161 0.86 AVX2 (v2) 0.147 0.150 0.90 AVX2 (sadbw) 0.070 0.072 1.89 AVX2 (sadbw, unrolled) 0.060 0.067 2.20 AVX2 (sadbw, variant) 0.043 0.048 3.07 AVX2 (maddubs) 0.023 0.026 5.74 size 16384 items scalar 0.118 0.127 1.00 scalar (C++) 0.121 0.127 0.98 SSE 0.295 0.298 0.40 SSE (v2) 0.295 0.316 0.40 SSE (sadbw) 0.130 0.136 0.91 SSE (sadbw, unrolled) 0.131 0.134 0.90 AVX2 0.154 0.158 0.77 AVX2 (v2) 0.147 0.149 0.80 AVX2 (sadbw) 0.068 0.072 1.74 AVX2 (sadbw, unrolled) 0.065 0.070 1.82 AVX2 (sadbw, variant) 0.039 0.043 3.03 AVX2 (maddubs) 0.021 0.023 5.62 size 32768 items scalar 0.121 0.129 1.00 scalar (C++) 0.122 0.131 0.99 SSE 0.296 0.296 0.41 SSE (v2) 0.296 0.297 0.41 SSE (sadbw) 0.132 0.133 0.92 SSE (sadbw, unrolled) 0.132 0.133 0.92 AVX2 0.156 0.157 0.78 AVX2 (v2) 0.148 0.148 0.82 AVX2 (sadbw) 0.068 0.069 1.78 AVX2 (sadbw, unrolled) 0.064 0.064 1.89 AVX2 (sadbw, variant) 0.040 0.040 3.02 AVX2 (maddubs) 0.023 0.024 5.26 Skylake CPU: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz GCC: g++-8 (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0 procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 0.264 0.265 1.00 scalar (C++) 0.263 0.265 1.00 SSE 0.404 0.407 0.65 SSE (v2) 0.233 0.235 1.13 SSE (sadbw) 0.191 0.193 1.38 SSE (sadbw, unrolled) 0.191 0.193 1.38 AVX2 0.206 0.208 1.28 AVX2 (v2) 0.128 0.129 2.06 AVX2 (sadbw) 0.112 0.114 2.36 AVX2 (sadbw, unrolled) 0.099 0.102 2.67 AVX2 (sadbw, variant) 0.069 0.071 3.83 AVX2 (maddubs) 0.063 0.065 4.19 size 16384 items scalar 0.260 0.261 1.00 scalar (C++) 0.260 0.261 1.00 SSE 0.403 0.405 0.65 SSE (v2) 0.231 0.232 1.13 SSE (sadbw) 0.188 0.189 1.38 SSE (sadbw, unrolled) 0.188 0.189 1.38 AVX2 0.203 0.204 1.28 AVX2 (v2) 0.125 0.126 2.08 AVX2 (sadbw) 0.109 0.110 2.39 AVX2 (sadbw, unrolled) 0.097 0.099 2.68 AVX2 (sadbw, variant) 0.066 0.066 3.94 AVX2 (maddubs) 0.064 0.064 4.06 size 32768 items scalar 0.260 0.261 1.00 scalar (C++) 0.260 0.261 1.00 SSE 0.403 0.405 0.65 SSE (v2) 0.231 0.232 1.13 SSE (sadbw) 0.188 0.189 1.38 SSE (sadbw, unrolled) 0.188 0.189 1.38 AVX2 0.202 0.203 1.29 AVX2 (v2) 0.125 0.126 2.08 AVX2 (sadbw) 0.109 0.109 2.39 AVX2 (sadbw, unrolled) 0.098 0.099 2.65 AVX2 (sadbw, variant) 0.066 0.066 3.94 AVX2 (maddubs) 0.063 0.064 4.13 SkylakeX CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz GCC: gcc (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0 procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 0.284 0.289 1.00 scalar (C++) 0.285 0.288 1.00 SSE 0.437 0.441 0.65 SSE (v2) 0.243 0.246 1.17 SSE (sadbw) 0.177 0.186 1.60 SSE (sadbw, unrolled) 0.177 0.185 1.60 AVX2 0.222 0.224 1.28 AVX2 (v2) 0.135 0.137 2.10 AVX2 (sadbw) 0.106 0.109 2.68 AVX2 (sadbw, unrolled) 0.104 0.109 2.73 AVX2 (sadbw, variant) 0.055 0.059 5.16 AVX2 (maddubs) 0.061 0.066 4.66 size 16384 items scalar 0.281 0.284 1.00 scalar (C++) 0.282 0.283 1.00 SSE 0.437 0.438 0.64 SSE (v2) 0.242 0.243 1.16 SSE (sadbw) 0.176 0.182 1.60 SSE (sadbw, unrolled) 0.176 0.182 1.60 AVX2 0.219 0.220 1.28 AVX2 (v2) 0.132 0.134 2.13 AVX2 (sadbw) 0.103 0.105 2.73 AVX2 (sadbw, unrolled) 0.102 0.104 2.75 AVX2 (sadbw, variant) 0.052 0.053 5.40 AVX2 (maddubs) 0.055 0.057 5.11 size 32768 items scalar 0.281 0.283 1.00 scalar (C++) 0.281 0.282 1.00 SSE 0.437 0.438 0.64 SSE (v2) 0.242 0.243 1.16 SSE (sadbw) 0.177 0.182 1.59 SSE (sadbw, unrolled) 0.177 0.182 1.59 AVX2 0.219 0.220 1.28 AVX2 (v2) 0.133 0.134 2.11 AVX2 (sadbw) 0.103 0.105 2.73 AVX2 (sadbw, unrolled) 0.103 0.105 2.73 AVX2 (sadbw, variant) 0.052 0.054 5.40 AVX2 (maddubs) 0.057 0.058 4.93 CannonLake CPU: Intel(R) Core(TM) i3-8121U CPU @ 2.20GHz Compiler: g++ (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5) procedure best avg. speedup [cycles] [cycles] size 4096 items scalar 0.203 0.205 1.00 scalar (C++) 0.203 0.205 1.00 SSE 0.303 0.306 0.67 SSE (v2) 0.175 0.177 1.16 SSE (sadbw) 0.154 0.155 1.32 SSE (sadbw, unrolled) 0.154 0.155 1.32 AVX2 0.153 0.155 1.33 AVX2 (v2) 0.102 0.104 1.99 AVX2 (sadbw) 0.089 0.091 2.28 AVX2 (sadbw, unrolled) 0.072 0.075 2.82 AVX2 (sadbw, variant) 0.061 0.062 3.33 AVX2 (maddubs) 0.055 0.058 3.69 size 16384 items scalar 0.196 0.198 1.00 scalar (C++) 0.196 0.197 1.00 SSE 0.302 0.304 0.65 SSE (v2) 0.173 0.174 1.13 SSE (sadbw) 0.152 0.153 1.29 SSE (sadbw, unrolled) 0.152 0.153 1.29 AVX2 0.151 0.153 1.30 AVX2 (v2) 0.099 0.101 1.98 AVX2 (sadbw) 0.087 0.088 2.25 AVX2 (sadbw, unrolled) 0.071 0.073 2.76 AVX2 (sadbw, variant) 0.058 0.059 3.38 AVX2 (maddubs) 0.054 0.056 3.63 size 32768 items scalar 0.195 0.197 1.00 scalar (C++) 0.195 0.197 1.00 SSE 0.302 0.305 0.65 SSE (v2) 0.173 0.174 1.13 SSE (sadbw) 0.151 0.153 1.29 SSE (sadbw, unrolled) 0.151 0.153 1.29 AVX2 0.151 0.153 1.29 AVX2 (v2) 0.099 0.101 1.97 AVX2 (sadbw) 0.087 0.087 2.24 AVX2 (sadbw, unrolled) 0.071 0.072 2.75 AVX2 (sadbw, variant) 0.058 0.059 3.36 AVX2 (maddubs) 0.055 0.057 3.55 Conclusions On Skylake and SkylakeX architectures VSADBW method is fastest, 2.5 times faster than compiled code. On Haswell VPMADDUBSW method significantly outperforms other approaches, it\'s faster 1.7 times than single VPSADBW method . However, on Skylake and newer architectures both methods are comparable. The results from GCC presented in this article before 2019-02-04 were worse for SkylakeX --- to my surprise the flag -O3 doesn\'t enable -funroll-loops . Thanks to Richard Startin and Travis Downs for pointing this out. Acknowledgements Big thanks to Daniel Lemire who provides access to Skylake, SkylakeX and CannonLake machines, where I can run benchmarks. Source code Source code is available on github .'],
["notesen/2018-11-24-python-stat-float.html", 'Python --- file modification time perils', 'Python --- file modification time perils Wojciech Mua Added on 2018-11-24 I need to copy a file to another directory whenever it got changed. The easiest way to do this is to check the modification time of file, a number of seconds since epoch: It\'s not the most reliable way, but in my case it was good enough. Up to the time when I noticed that sometimes files didn\'t get updated. I figured out that for a reason get_mtime returned an integer value, while the file system was able to deal with higher resolution than a second; system command stat printed microseconds. The culprit was the setting of os module. It is possible to select in runtime, by os.stat_float_times(boolean) , whether the module reports times as integers or floats. For an unknown reason my python installation defaulted to integers. Thus it was possible to have two files with different modification times having the same integer parts. Finally, I forced float times everywhere ( os.stat_float_times(True) ).'],
["notesen/2019-01-05-avx512vbmi-remove-spaces.html", 'AVX512VBMI --- remove spaces from text', 'AVX512VBMI --- remove spaces from text Wojciech Mua Added on 2019-01-05 Updated on 2019-01-13 (added Zach Wegner implementation, compare with fast AVX2 code by Michael Howard) Contents Introduction Scalar code SSE solution AVX512VBMI solution Algorithm outline Single whitspace More isolated whitspaces Runs of whitespaces Implementation PEXT-based algorithm AVX512VBMI2 algorithm AVX512VBMI evaluation Microbenchmark Performance test Conclusions Acknowledgements See also Source code Introduction Removing spaces from a string is a common task in text processing. Instead of removing single character we often want to remove all the white space characters or the punctuation characters etc. In this article I show an AVX512VBMI implementation. The algorithm is not faster than the scalar code for all cases. But for many it can be significantly faster, and what is more important, in tests on real-world texts it performs better. Update 2019-01-13 : this article pop up on twitter and Hacker News where provoked an incredibly fruitful discussion. Travis Downs noticed that branch mispredictions can be compensated by unrolling the loop in the initial algorithm. Zach Wegner came up with an algorithm which works in constant time by using PEXT instruction. Michael Howard shared with his scalar and AVX2 variants of \"despacing\" procedure. I\'d like to thank all people discussed this topic both on HN and twitter. Scalar code A scalar code which does this task is really simple: The function returns the pointer to last written character. This implementation work correctly also for an in-place scenario, i.e. when src and dst point the same memory area. SSE solution In SSE code we process 16 bytes of input text. We determine a byte-mask for characters that must be removed --- usually with a comparison: This mask is converted into a 16-bit number using instruction PMOVMSKB (intrinsic function _mm_movemask_epi8 ). The number is used to fetch a byte pattern from a precompiled set , which is the argument to PSHUFB ( _mm_shuffle_epi8 ). The shuffle instruction allows to change order of bytes in an SSE register --- in our case it skip all spaces. Please note that in the example the last three indices are -1 and bytes past compressed characters are zeros. In practise it doesn\'t matter what will be there. A clear drawback of the SSE solution is a huge lookup table. It has 65536 entries, each entry occupies 16 bytes, thus all data has exactly 1MB. AVX512VBMI solution AVX512 operates on 64-byte register. The extension AVX512VBMI introduced instruction VPERMB ( _mm512_permutexvar_epi32 ) which similarly to PSHUFB can change order of bytes within an AVX512 register. For readers who are not familiar with AVX512 nuances, the extension AVX512BW also defines a byte shuffling instruction, but it operates on the register lanes (16-byte subvectors) not the whole register. Since AVX512 registers are so wide, use of a lookup table to fetch shuffle patterns is simply impossible. Such table would occupy [...] [...] Instead of precalculating shuffle patterns, I propose to build them in runtime . This might seem not optimal on the first sight, but the evaluation shows that it\'s not that bad. Algorithm outline In AVX512 code we process 64-byte block. From the input vector we obtain a 64-bit mask for spaces, and then modify the shuffle vector using this mask. Initially the shuffle vector defines identity transformation, i.e. if applied to the shuffle instruction it would copy all i-th input bytes onto i-th output byte. Technically, the vector contains sequence of bytes from 0 to 63. Single whitspace Let\'s assume there\'s exactly one space in the input vector, say at the position 5; this will be our building block for the rest of algorithm. The shuffle vector: must become: In other words we must perform following vector addition: To do this we use a nice AVX512 facility, the masked add . But how to cheaply calculate a proper mask? From mask 000...000100000 , we have to get 111...111100000 , i.e. all bits above the set bit must also be ones. The input mask has exactly one bit set; we subtract 1: Now all bits below become 1, thus a bit negation yields the required bit pattern. The full expression in C is like this: More isolated whitspaces Now let\'s consider a more complex case. The input vector contains two non-adjacent spaces. Assume the first one is at index 2, and the second one at 5, thus the bit mask is 000...000100100 . First we isolate the lowest bit set using expression (x & -x) , or x & (~x + 1) ; on an AVX512VBMI CPU this expression should be compiled into single instruction BLSI : Since the mask first has exactly one bit set, we use the procedure described in the previous section to modify the shuffle pattern: Now, we reset the first bit set from mask: And we can again extract the lowest bit set. Hold on, can we? No, it\'s not possible as the shuffle pattern has just been changed, thus our initial 5th bit doesn\'t indicate the space character. Since one character was skipped, the another space character is at index 4. To reflect this change the mask must be shifted right by 1 : Now, we might safely extract the lowest bit set and modify the shuffle pattern: Obviously, if there are more ones in the mask, we need to carry on the above procedure (extract bit, reset, shift). If mask becomes zero we stop modifying the shuffle vector. Runs of whitespaces There\'s still one problem to solve, what if there are more spaces in a row. For instance, the run has three ones starts at index 2: 000...00011100 . We need to modify shuffle vector starting from index 2, but increment is 3 not 1: Firstly, we must save the position (mask) for the first bit of run. Then we need detect if the next set bit (a) continues the run, or (b) starts a new one. If it\'s a continuation, we increment by one a vector that holds run\'s length. If it\'s a new run, the shuffle vector is modified with length vector. How to detect the continuation? We need to keep the previously extracted mask, if it\'s equal to the currently extracted mask, it\'s a continuation. Equality works because after each extraction the mask is shifted. Below is sequence of values which appear during analysing the second bit of a run; as we see the mask curr is equal to prev . Implementation Below is an actual AVX512VBMI code which implements all the techniques presented above. PEXT-based algorithm Zach Wegner proposed to utilize instruction PEXT ( _pext_u64 ) which does compression of bits based on given mask. Suppose we have a binary value: and mask of whitespace characters: PEXT(v, m) yields: The idea is to compress in this way individual bits of indices (\"layers\") and then rebuild numeric values from these bits. Let\'s start with an example for 4-bit indices: Each bit \"layer\" is then compressed with PEXT according to negation of whitespace mask : The last step is reconstruction of index values from individual bits. This is done by masked add of bit weights, which are 1, 2, 4, 8, 16, 32 etc. Below is an actual implementation. Please just note that in case of AVX512 indices are 6-bit numbers. AVX512VBMI2 algorithm The extension AVX512VBMI2 defines instruction VPCOMPRESSB ( _mm512_mask_compress_epi8 ) that performs the operation we just programmed. AVX512VBMI evaluation The AVX512VBMI code shown above was compared with the scalar implementation. CPU: Intel(R) Core(TM) i3-8121U CPU @ 2.20GHz GCC: 7.3.1 20180303 (Red Hat 7.3.1-5) name comments scalar a naive implementation AVX512VBMI input-sensitive implementation with unrolling as suggested by Travis Downs AVX512VBMI-pext Zach Wegners\' implementation AVX2 a vector implementation provided by Michael Howard, which calculates prefixed sum without use any precalculated tables (procedure despace_avx2_vpermd ); it\'s a very neat procedure Microbenchmark Microbenchmark tests removing spaces in a 64-byte block. Number of spaces in a block varies from 1 to 64. There were 10 random patterns, and for each patter a tested procedure was executed 10.000 times. The microbenchmark reports two pairs of measurements (in CPU cycles/input byte): 10 times: average number over 10.000 runs; 10 times: the best time. number of spaces scalar [cycles/byte] AVX512VBMI [cycles/byte] AVX512VBMI-pext [cycles/byte] AVX2 [cycles/byte] avg (min) avg (max) best avg (min) avg (max) best avg (min) avg (max) best avg (min) avg (max) best 1 1.129 1.517 1.062 0.227 1.178 0.156 0.428 0.479 0.375 0.359 0.367 0.281 2 1.134 1.608 1.062 0.264 0.273 0.188 0.423 0.439 0.375 0.359 0.369 0.281 3 1.136 1.352 1.062 0.310 0.313 0.250 0.425 0.440 0.375 0.357 0.428 0.281 4 1.132 1.574 1.062 0.345 0.361 0.281 0.428 0.478 0.375 0.358 0.363 0.281 5 1.130 1.349 1.062 0.388 0.436 0.344 0.425 0.474 0.375 0.359 0.368 0.281 6 1.129 1.143 1.062 0.430 0.450 0.375 0.426 0.478 0.375 0.358 0.408 0.281 7 1.137 1.979 1.062 0.470 0.501 0.406 0.428 0.454 0.375 0.359 0.413 0.281 8 1.134 1.330 1.062 0.482 0.514 0.438 0.429 0.476 0.375 0.358 0.419 0.281 9 1.131 1.436 1.062 0.596 0.700 0.531 0.427 0.436 0.375 0.358 0.366 0.281 10 1.145 1.255 1.094 0.641 0.766 0.594 0.424 0.447 0.375 0.358 0.365 0.281 11 1.139 1.349 1.062 0.671 0.801 0.594 0.426 1.148 0.375 0.357 0.366 0.281 12 1.139 1.188 1.062 0.737 0.838 0.656 0.426 0.445 0.375 0.358 0.410 0.281 13 1.151 1.188 1.094 0.817 0.899 0.719 0.423 0.439 0.375 0.357 0.893 0.281 14 1.154 1.235 1.094 0.838 0.972 0.781 0.423 0.475 0.375 0.358 0.369 0.281 15 1.145 1.240 1.062 0.849 1.598 0.781 0.427 0.488 0.375 0.359 0.366 0.281 16 1.156 1.450 1.094 0.969 1.043 0.906 0.428 0.446 0.375 0.358 0.367 0.281 17 1.144 1.236 1.062 0.938 1.077 0.875 0.427 0.442 0.375 0.359 0.365 0.281 18 1.176 1.239 1.094 1.012 1.147 0.938 0.425 0.438 0.375 0.360 0.370 0.281 19 1.163 1.712 1.094 1.062 1.978 0.969 0.431 0.440 0.375 0.360 0.386 0.281 20 1.175 1.270 1.125 1.108 1.210 1.031 0.429 0.442 0.375 0.361 0.364 0.281 21 1.188 2.201 1.125 1.176 1.329 1.094 0.426 0.443 0.375 0.359 0.373 0.281 22 1.163 1.370 1.094 1.215 1.314 1.125 0.427 0.478 0.375 0.360 0.413 0.281 23 1.187 1.374 1.125 1.250 1.349 1.156 0.427 0.443 0.375 0.360 0.374 0.281 24 1.172 1.342 1.094 1.317 1.429 1.219 0.429 0.439 0.375 0.360 0.416 0.281 25 1.195 1.318 1.125 1.328 1.460 1.219 0.426 0.528 0.375 0.359 0.369 0.281 26 1.201 1.354 1.125 1.322 1.464 1.250 0.427 0.482 0.375 0.359 0.364 0.281 27 1.197 1.425 1.125 1.418 1.558 1.344 0.427 0.446 0.375 0.360 0.750 0.281 28 1.196 1.454 1.125 1.453 1.591 1.344 0.427 0.437 0.375 0.359 0.917 0.281 29 1.190 1.385 1.125 1.514 1.602 1.469 0.426 0.441 0.375 0.360 0.365 0.281 30 1.243 1.400 1.156 1.518 1.659 1.438 0.428 0.441 0.375 0.355 0.373 0.281 31 1.192 1.345 1.125 1.555 1.705 1.469 0.430 0.440 0.375 0.360 0.370 0.281 32 1.215 1.392 1.125 1.637 1.702 1.500 0.428 0.485 0.375 0.360 0.412 0.281 33 1.229 1.384 1.125 1.674 1.735 1.562 0.427 0.436 0.375 0.358 0.410 0.281 34 1.247 1.397 1.156 1.716 1.826 1.594 0.431 0.440 0.375 0.356 0.388 0.281 35 1.225 2.084 1.156 1.720 1.906 1.625 0.430 0.444 0.375 0.359 0.367 0.281 36 1.232 1.857 1.156 1.786 2.128 1.656 0.426 0.439 0.375 0.358 0.375 0.281 37 1.225 1.407 1.125 1.839 1.905 1.750 0.427 0.488 0.375 0.358 0.366 0.281 38 1.226 1.435 1.156 1.869 2.434 1.750 0.427 0.485 0.375 0.358 0.368 0.281 39 1.223 1.497 1.156 1.849 2.038 1.750 0.428 0.436 0.375 0.359 0.371 0.281 40 1.237 1.357 1.156 1.934 2.104 1.750 0.427 0.477 0.375 0.359 0.368 0.281 41 1.222 1.447 1.156 1.956 2.060 1.875 0.427 0.443 0.375 0.362 0.364 0.281 42 1.254 1.360 1.156 1.988 2.357 1.906 0.428 0.443 0.375 0.359 0.366 0.281 43 1.241 1.391 1.188 2.033 2.155 1.906 0.427 0.488 0.375 0.360 0.367 0.281 44 1.241 1.370 1.188 2.057 2.177 1.969 0.427 1.012 0.375 0.360 0.368 0.281 45 1.257 1.381 1.188 2.100 2.274 1.938 0.427 0.439 0.375 0.362 0.954 0.281 46 1.266 1.350 1.188 2.178 3.041 2.062 0.430 0.440 0.375 0.359 0.368 0.281 47 1.260 1.328 1.188 2.196 2.299 2.062 0.427 0.443 0.375 0.360 0.369 0.281 48 1.285 1.337 1.219 2.203 2.532 2.062 0.428 0.490 0.375 0.361 0.367 0.281 49 1.286 1.682 1.219 2.250 2.605 2.156 0.426 0.435 0.375 0.355 0.370 0.281 50 1.297 1.330 1.219 2.295 2.605 2.156 0.429 0.440 0.375 0.357 0.363 0.281 51 1.303 1.335 1.250 2.343 2.447 2.219 0.430 0.439 0.375 0.360 0.415 0.281 52 1.315 1.640 1.250 2.383 2.871 2.250 0.426 0.480 0.375 0.358 0.368 0.281 53 1.319 1.606 1.250 2.401 2.604 2.281 0.428 0.439 0.375 0.358 0.369 0.281 54 1.342 1.653 1.281 2.438 2.840 2.312 0.430 0.480 0.375 0.358 0.370 0.281 55 1.342 1.387 1.281 2.470 3.336 2.375 0.426 0.441 0.375 0.359 0.414 0.281 56 1.362 1.716 1.281 2.556 2.893 2.438 0.429 0.437 0.375 0.361 0.379 0.281 57 1.364 1.619 1.312 2.573 2.875 2.406 0.428 0.441 0.375 0.362 0.370 0.281 58 1.386 2.069 1.312 2.665 3.150 2.562 0.428 0.436 0.375 0.358 0.365 0.281 59 1.384 1.743 1.312 2.677 2.954 2.531 0.429 0.440 0.375 0.358 0.370 0.281 60 1.411 1.747 1.344 2.911 3.152 2.781 0.428 0.439 0.375 0.358 0.370 0.281 61 1.417 1.761 1.344 2.929 3.240 2.750 0.426 0.483 0.375 0.358 0.368 0.281 62 1.416 2.010 1.344 2.745 3.615 2.656 0.427 0.437 0.375 0.358 0.368 0.281 63 1.453 2.195 1.375 3.046 3.357 2.688 0.427 0.440 0.375 0.359 0.368 0.281 64 1.646 1.654 1.594 3.107 3.208 2.938 0.429 0.443 0.375 0.359 0.407 0.281 Performance test In performance tests several text files were loaded into memory, then the tested procedure removed spaces 10 time, saving result to a separate memory region. file scalar AVX512VBMI AVX512VBMI-pext AVX2 time [us] speed-up time [us] speed-up time [us] speed-up time [us] speed-up tom-sawyer.txt 978 267 3.66 39 25.08 52 18.81 moby-dick.txt 2881 742 3.88 118 24.42 156 18.47 sherlock.txt 1402 376 3.73 55 25.49 72 19.47 census-income.data 123950 46847 2.65 13690 9.05 14574 8.50 weather_sept_85.csv 74037 44637 1.66 9866 7.50 10523 7.04 book file file size [B] The Adventures of Tom Sawyer tom-sawyer.txt 428,104 The Adventures of Sherlock Holmes sherlock.txt 594,933 Moby Dick moby-dick.txt 1,276,201 census-income.data 16,022,599 weather_sept_85.csv 75,137,158 Conclusions Both AVX2 by Michael and AVX512VBMI by Zach work at constant time . Although in microbenchmarks the AVX2 variant performs better than the AVX512VBMI code, the real-world cases are handled better by the latter one. When spaces occupy more than 1/3 of an AVX512 register, the scalar code performs better than the naive vectorized counterpart. Acknowledgements As always this work wouldn\'t be possible without Daniel Lemire , who gave ma access to a Cannon Lake machine. See also How quickly can you remove spaces from a string? by Daniel Lemire Source code Source code is available on github .'],
["notesen/2019-01-07-cpp-read-file.html", 'C++ --- how to read a file into a string', 'C++ --- how to read a file into a string Wojciech Mua Added on 2019-01-07 Updated on 2019-01-17 (performance of POISX read ) Contents Introduction Evaluation Computer #1 Computer #2 Computer #3 Source code Introduction To my surprise I quite often need to read the whole contents of a file into a string. Sometimes it\'s easier to generate data with an external program, sometimes unittests require to read generated file, etc. A signature of such loader function is: In C++ an official way to deal with files are streams. There are at least two methods to load data into a string: use streambuf iterators to construct a string, use an auxilary string stream to handle a streambuf object. Both functions do their jobs, but reportedly are slow. While C++ still exposes good old C API, i.e. fread (libc) or read (POSIX), I compared performance of all solutions. Although the C solution using fread --- which is shown below --- is much longer than the C++ counterparts, its performance is significantly better than anything based on C++ streams. Performance of read is almost identical to fread , differences are negligible. Of course, the performance boost highly depends on a machine type, hard drive, etc., but clearly the overhead of C++ streams is really huge compared to libc and POSIX calls. Implementation using fread : Implementation using read : Evaluation Performance tests were run on three Linux machines. Different sizes of files were tested, each file was read 10 times and minumum times were noted. Computer #1 size [MB] istreambuf_iterator stream::rdbuf LibC fread POSIX read time [us] time [us] speed-up time [us] speed-up time [us] speed-up 1 5301 845 6.27 207 25.61 218 24.32 2 10780 2123 5.08 854 12.62 833 12.94 4 22971 4327 5.31 2280 10.07 2206 10.41 8 47589 8520 5.59 4550 10.46 4550 10.46 16 98424 17620 5.59 9381 10.49 9336 10.54 32 202870 52075 3.90 18755 10.82 18756 10.82 Computer #2 size [MB] istreambuf_iterator stream::rdbuf LibC fread POSIX read time [us] time [us] speed-up time [us] speed-up time [us] speed-up 1 3817 438 8.71 171 22.32 163 23.42 2 7214 874 8.25 362 19.93 358 20.15 4 14586 2156 6.77 813 17.94 803 18.16 8 28785 4746 6.07 2034 14.15 2028 14.19 16 59732 9553 6.25 4213 14.18 4337 13.77 32 114713 31419 3.65 8028 14.29 8017 14.31 Computer #3 size [MB] istreambuf_iterator stream::rdbuf LibC fread POSIX read time [us] time [us] speed-up time [us] speed-up time [us] speed-up 1 2544 184 13.83 76 33.47 75 33.92 2 4801 448 10.72 151 31.79 149 32.22 4 9688 1103 8.78 372 26.04 365 26.54 8 19749 2484 7.95 1088 18.15 1087 18.17 16 39414 5149 7.65 2524 15.62 2526 15.60 32 78949 19692 4.01 5059 15.61 5051 15.63 Source code Test programs are available on github .'],
["notesen/2019-01-08-pyahocorasick-debugging.html", 'pyahocorasick stabilisation story', 'pyahocorasick stabilisation story Wojciech Mua Added on 2019-01-08 Contents Introduction The bug Problems Cure #1 --- unit tests Cure #2 --- code coverage Cure #3 --- memory leaks detection Cure #4 --- injecting memory allocation faults Cure #5 --- injecting Python API faults Unresolvable #1 --- string representation Unresolvable #2 --- Windows build Random bits See also Introduction pyahocorasick is a python module I started in 2011. That time I was interested in stringology and the Aho-Corasick algorithm appeared to be quite challenging. It was a sufficient reason to program it. However, I also decided that the result shouldn\'t be another proof-of-concept, that nobody --- except me --- would use. Since I like Python, I chose form of a C extension, which nicely combines a friendly Python API with an efficient C implementation. Moving fast forward, the module gained a few users worldwide. Maybe this is not the most popular package on pypi , but people keep installing it. Many users contributed to the code, documentation and infrastructure, or reported bugs and helped with debugging. Philippe Ombredanne helped a lot with different aspects of development --- without him the project wouldn\'t be so great. This text is a result of recent work on stabilisation the module, that was propelled by fixing a long-standing bug . The bug was driving me crazy for more than a year. I want to show what means were used to eliminate this and many other bugs. And also how the code quality was improved as a side effect. I hope some of you find an inspiration or solution. The bug Before we start I have to describe the bug, nobody should repeat my stupid mistake. The bug was caused by misuse of python function PyBuild_Value , which is used by a pickling mechanism. Basically, pickling used to be done as a simple memory dump --- the module created single memory area filled with some binary data. The invocation Py_BuildValue(\"y#\", ptr, size) constructs a bytes object with a copy of memory pointed by ptr , having given size. The problem is that such a format string gets size of type int . I wrongly assumed that on 64-bit machines int is a 64-bit number. It\'s not true, int has only 32 bits. Because of that, when size of the memory area was larger than 2GB, strange things happen, as shown in the table below. 64-bit size outcome range 0 to 0x7fffffff (up to 2GB) no errors from 0x80000000 to 0xffffffff int is negative, empty buffer created but no error is reported anything larger than 4GB, but bit 32th equals zero created buffer of size & 0x7fffffff anything larger than 4GB, but bit 32th one int is negative, empty buffer created but no error is reported The solution was pretty simple: a huge memory area is split into several smaller regions and the list of such regions is pickled. The size of single region is limited to a few megabytes, it will never be close to the 2GB boundary (although all data still can be larger than 2GB). Problems The module is written in ANSI C, thus obviously it suffers from common problems known in this language; also some python-specific issues are there. Here is a brief list: logic errors : regular bugs, behaviours not matching documentation (or common sense). memory leaks : there are two sources of leaks: lack of free() calls; leaks of Python object references. Each python object has a reference counter, there\'s a leak when we forget about decreasing the RC, causing the object to live forever. memory errors : like double free, or decrease the reference of a not owned Python object. failures returned by API calls : communication between a C extension and python interpreter is done via the set of function; most of these functions may fail and we have to handle erroneous conditions properly. string types and their representation : Python 2 and Python 3 have different string types: there are strings, bytes and Unicode strings; a Unicode string can be represented in UCS-16 or UCS-32. Windows builds : Python extensions for Windows has to be compiled with MSVC 2010. It can\'t be helped. Cure #1 --- unit tests It might sound obvious, but unit tests are crucial when one develops a programming library. In pyahocorasick unit tests have been existing from the very start. They are written in Python using its standard library unittest ; there are no C-level tests. Firstly, unit tests have to cover basic functions --- i.e. prevent from logic errors. For instance, pyahocorasick has functionality of a word dictionary, thus unit tests check if adding a word really adds it or if looking up a non-existing word fails, etc. Most tests are really simple, but surprisingly detected a lot of mistakes. Secondly, unit tests can check some very specific scenarios, also serve as a regression tests repository. For example, I wrote a very detailed tests for the unpickling code, where some binary data is manually constructed and then handled by the module. This set of tests is useful during development, regular users don\'t need to run them. Unit tests are the base for any serious work and further refactoring. Cure #2 --- code coverage Getting code coverage for a Python extension is really simple. Just compile the module with -coverage option: Then run unit tests, or other programs which use the module, and get a coverage report using --- for instance --- gcovr : The coverage report reveals which parts of C code are untested. We instantly see whether we\'re able to trigger that untested part via a regular Python test or maybe a branch relies on the result of external function call. Then, we might consider intercepting this function and force returning certain value --- this approach is described in following sections. Cure #3 --- memory leaks detection A problem with a C extension for Python is that your C code is run within the same process as the interpreter. The standard compilation of C Python interpreter enables a custom allocator. That allocator makes the valgrind output unreadable, as valgrind reports tons of leaks or wrong writes/reads, while in fact none of them are bugs. It\'s possible to compile python interpreter with special valgrind-friendly flags. While compilation of a Python interpreter is not a big deal, I decided to wrap malloc , free and (recently) realloc procedures. A special compile-time definition enables memory debug mode, thus in normal compilation there\'s no overhead. There are two modes of debugging I implemented: dump all memory-related events to a file; inject memory allocation faults --- described in the next section . The output of dump is a list of actions given in plain text, like this: \"A 1 0x7fafd9741148 40\" is read as: allocation #1 of 40 bytes retuned address 0x7fafd9741148; \"R 2 (nil) 0x7fafd9d89738 8\" is read as: \"reallocation #1 of 8 bytes, old address was NULL, returned address 0x7fafd9d89738\"; finally \"F 0x7fafd9da51a0\" means \"free address 0x7fafd9da51a0\". A simple python script parses such file and points which allocations have no corresponding free. Since each allocation/reallocation has unique id, we might simply figure out where exactly in the code the leaked object was created. I considered dumping also backtraces (there\'s nice backtrace function in GNU libc), but in practise it was way easier to run program in gdb and obtain backtrace from debugger --- I introduced an additional environment variable that triggers __builtin_trap() on allocation failure. Dumping allocation events helped several times in last two years, and this solution proved to be really helpful. Cure #4 --- injecting memory allocation faults For given allocation id we can force returning NULL in runtime; it\'s done by setting an environment variable, thanks to that no recompilation is needed when we want to check different scenarios. It appeared that some users of pyahocorasick can allocate all memory they have on their computers, thus failures of malloc are likely. In such case, the expected behaviour of C module is to properly report the error to a python interpreter (usually by setting MemoryError ), not to segfault. Injecting memory faults appeared to be an amazing solution. I know the word \"amazing\" is overused, but in this context is highly appropriate. While the cost of introducing this was minimal, it revealed many latent problems in the existing code and prevented other problems after introducing the technique. Before each release I get the number of allocations for all unit tests and then check failure of each allocation. There are roughly 3000 allocation, so it\'s not a big problem, just time consuming. Cure #5 --- injecting Python API faults Since injecting of memory allocation faults was so successful, I decided to do similar thing with Python API calls. Although the number of public functions one can find in /usr/include/python is huge, the module itself uses a small portion of them. Right now there are only ~25 functions used across the code. All wrapped calls share the same call id and we can set, also via environment variable, which call is expected to fail. The wrappers are also enabled with a preprocessor definition. In a C code a wrapped invocation looks like this: Here the \"F\" is a preprocessor definition which either expands to the original name of argument ( PyTuple_GetItem ) or into its wrapped counterpart ( PyTuple_GetItem_custom ). The definitions of wrapped functions are similar, and looks like this: The only C code is function check_and_set_error , which is the same for all wrapped functions. Depending on the type of API function, the failure result can be the NULL pointer (like in case of PyTuple_GetItem ), or a negative number or the zero --- this distinction is done within #define . A side note: in most cases returning NULL is a sign of exception. Python expects that a C extension sets also an error using one of designated API functions. If NULL is returned but no error is set, the interpreter unconditionally aborts execution! As you might guess, I found a few cases when this problem appeared. This solution also helped to solve many issues, fortunately not reported yet by the users. Not to mention that the code coverage went up. Unresolvable #1 --- string representation The existence of Python 2 and Python 3 adds a lot of problems. As I mentioned earlier, internal string representations differs between major python versions. There are also problems with Python 3 string representation. Depending on a minor version, platform, compilation setting and other factors I have no idea about, strings can be saved in UCS-2 or UCS-4, and perhaps in UTF-8 --- I got lost now. All these issues mean that the module code has to deal with three different data types and solve nuisances --- whether a string is temporary (and we need to keep its copy) or is a reference. Of course it\'s doable, but costs dozens of defines, which lowers testability of code. Unresolvable #2 --- Windows build The python official builds for Windows are done with MSVC 2010. This compiler is maybe not an ancient one, but does not support the C11 standard. In other words, declaring variables at any place in code is not possible --- all variable declarations have to be placed before the first statement. Well, it\'s not a real problem, it\'s rather... a constraint. I just got used to it, but wish I didn\'t have to. Random bits I described the most important methods, here\'s a list of things that also help: Automate what you can. I wrote several dead-simple shell and python scripts that run certain procedures (like naive benchmarks, memory consumption analysis etc.). State of most of them is \"works for me\" --- they can be improved later, if needed. They save time of re-typing the same commands over and over. And they really help if one has short memory, as I do have. If you can, include in error messages as much details as you have at certain point of program. The bug I mentioned at the very beginning was manifested with short message \"data truncated\". It was silly, now I see how silly. Later, I added to the message more date, like the number of currently processed node (\"error during unpickling node #1241094\"). When I saw a really huge node number in user\'s report, something finally clicked. When you deal with complex data structures write dumpers. Start with dumpers! A dumper is a procedure that shows, in a human readable way, details of data. Procedure can print something on console or save data on disc which can be later visualized. Aho-Corasick automaton is a graph structure, thus I coded dumper that produces graphviz input. Being able to see how graph nodes are connected (or disconnected...) saved hours of debugging at early stages of developing. Use CI servers. For open source projects there are free and easy to setup solutions: Travis and AppVeyor . pyahocorasick uses both, and is tested on both Windows and Linux, it is build with Python 2 and Python 3, and unit tests are run on all these builds. See also Efficient trie representation --- the review of different trie representations, a side-effect of work on pyahocorasick. pyDAWG --- a python module for DAWG (directed graphs of words), which implements a clever algorithm to build graphs with minimal memory footprint.'],
["notesen/2019-01-23-std-function-problems.html", 'std::function and overloaded functions', 'std::function and overloaded functions Wojciech Mua Added on 2019-01-23 C++ 11 introduced std::function which is useful when one deals with lambdas or methods. However, in case of plain functions this class might not be that handy. Overloaded functions Let us consider this simple use case, where we want to invoke a function: Everything works fine when a callback is a lambda. When we have overloaded functions , there are problems, as the compiler is not able to select a proper overload. The above code leads does not compile, error report from GCC is: To make this compilable we need to insert a weird casting to pointer to function . As far I know it\'s not possible to obtain from std::fuction any member type for this, so retyping the whole function type is required. This is pretty verbose. I ended up with bare pointers to function in the signature of invoke_callback . Performance considerations Since std::function can wrap any callable object one might expect that this comes at some cost. Below is the assembly generated by GCC 9 for two methods: Assembly for invoke_function : Assembly for invoke_pointer : Because std::function has to check validity of object, so there\'s an extra check. In a production code we\'d probably add explicit test for null pointers in invoke_pointer . Arguments to callable from std::function are passed through the stack, so it costs extra stores and loads. Apart from this, the overhead of use std::functions is negligible.'],
["notesen/2019-01-29-simd-count-byte.html", 'SIMDized counting byte in byte stream', 'SIMDized counting byte in byte stream Wojciech Mua Added on 2019-01-29 Contents Introduction GCC vectorization AVX2 and SSE vectorization 8-bit counters Population count AVX512BW vectorization Evaluation Skylake Skylake-X CannonLake Conclusions Source code Introduction We want to count how many times given byte occurs in a byte stream; here is a C program doing this: GCC vectorization The current GCC vectorization algorithm is able to handle the presented procedure, but its output is not optimal. For an AVX2 target GCC keeps four 64-bit sub-counters which are updated in every iteration and then added in the end. In a single iteration 32 bytes are loaded and then compared with vector filled with given byte: Result of this operation is vector of bytes filled with either ones (0xff) or zeros. Then 0xff are converted to ones by bit-and operation: The last step of algorithm is casting these 8-bit numbers to 64-bit value and updating the mentioned counters. The conversion is done gradually: first from 8-bit numbers to 16-bit ones; then from 16-bit to 32-bit and finally from 32-bit to 64-bit values. This conversion must be done for each 4-byte subarray of input register. It means that following code is repeated eight times : Below is the full dissasembly from GCC 9 (snapshot from 2019-01-17, options: -O3 -march=cannonlake ). AVX2 and SSE vectorization 8-bit counters The byte-wise comparison in both AVX2 and SSE yields vector of 0 or -1. Accumulation can be done in two steps: sum up to 255 elements in a vector register --- in means we have 32 (for AVX2) or 16 sub-counters (for SSE2), where each byte will hold count in range 0 .. 255; calculate the sum of 8-bit sub-counters in a wider type. The second point can use instruction PSADBW ( _mm256_sad_epu8 ), which calculates the sum of absolute values of differences between bytes. When one of arguments is full of zeros, the instruction effectively calculates sum of bytes from the second argument. This is the fastest option according to my experiments described in SIMDized sum of all bytes in the array . Below is the main loop of AVX2 implementation: Population count Since in this problem we just want to tell whether given byte in a registers is equal or not the searched value, we might consider encoding this information as a bit-set. And then, once we have a number, count ones in it, using a population count instruction. The obvious solution would require just three instructions: However, I think it\'s not the best solution. A better way is to calculate eight byte-masks , merge them into 256 (AVX2) or 128 (SSE) bit set and then count bytes. Unfortunately, SSE nor AVX2 has a bit-level blend, so we resort to basic bit operations. Below is the main loop: AVX512BW vectorization Since AVX512 comparisons yield bitmasks, we can directly use population count instruction. Naive implementation is shown below. Evaluation procedure description scalar in fact code vectorized by GCC for either AVX2 or AVX512BW SSE 16 x 8-bit counter summed up every 255 iterations SSE (popcount) population count of 128-bit words build from eight byte-masks AVX2 32 x 8-bit counter summed up every 255 iterations AVX2 (popcount) population count of 256-bit words build from eight byte-masks AVX512BW AVX512BW (unrolled) the above procedure unrolled four times Each procedure was run three times and minimum measurements were noted. Skylake CPU: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz Compiler: g++-8 (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0 procedure time in cycles per byte speed-up average best scalar 0.613 0.610 1.0 SSE 0.107 0.104 5.9 SSE (popcount) 0.100 0.098 6.2 AVX2 0.077 0.075 8.1 AVX2 (popcount) 0.107 0.104 5.9 Skylake-X CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz Compiler: GCC version 8.1.0 (Ubuntu 8.1.0-5ubuntu1~16.04) procedure time in cycles per byte speed-up average best scalar 0.452 0.446 1.0 SSE 0.118 0.115 3.9 SSE (popcount) 0.113 0.111 4.0 AVX2 0.094 0.090 5.0 AVX2 (popcount) 0.111 0.107 4.2 AVX512BW 0.072 0.062 7.2 AVX512BW (unrolled) 0.055 0.049 9.1 CannonLake CPU: Intel(R) Core(TM) i3-8121U CPU @ 2.20GHz Compiler: g++ (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5) procedure time in cycles per byte speed-up average best scalar 0.288 0.280 1.0 SSE 0.099 0.093 3.0 SSE (popcount) 0.091 0.085 3.3 AVX2 0.073 0.070 4.0 AVX2 (popcount) 0.084 0.081 3.5 AVX512BW 0.070 0.065 4.3 AVX512BW (unrolled) 0.049 0.042 6.7 Conclusions In case of SSE & AVX2, the popcount-based procedures are not that bad. I suspected that due to complex procedures that postprocess the comparison results, the performance would be much worse. On AVX512 machines the AVX512BW code is faster than AVX2 procedures, but unrolling does not help that much. My rough guess is that the culprit is popcnt , as this instruction can be dispatched only on single port and latency is three cycles. Source code All implementation are available at github .'],
["notesen/2019-02-02-autovectorization-gcc-clang.html", 'Auto-vectorization status in GCC, Clang, ICC and MSVC', 'Auto-vectorization status in GCC, Clang, ICC and MSVC Wojciech Mua Added on 2019-02-02 Updated on 2021-02-18 (MSVC didn\'t vectorize accumulate_custom_epi8 , noticed by Harold Aptroot ; my mistake), 2019-02-04 (results for ICC and MSVC) Contents Introduction Comparison Compiler versions Compiler flags Results See also Source code Introduction Update 2021-02-17 : please check the newest status of GCC & Clang , and MSVC . The term \"auto-vectorization\" means the ability of a compiler to transform given scalar algorithm into vectorized one, i.e. express dominating operation(s) using SIMD instruction. I\'m sure nobody would argue that auto-vectorization is as important as scalar optimizations performed by compilers. Now vectorization is a must. From what I can gather, one of the first commonly used compiler of C/C++ which automatically vectorized code was Intel compiler; by the time, luckily for us, GCC and Clang caught up. Comparison In this comparison we consider only two targets: AVX2, AVX512 with all possible extensions (AVX512BW, AVX512VL, AVX512VBMI, etc.) A few basic algorithm available in C++ algorithm library were picked. For each algorithm two specialisations were created: one operating on int8_t values and int32_t values. (Efficient use of float or doubles would require -ffast-math and while it\'s not always allowed, we stuck to integers.) Compiler versions I used compilers installed on amazing godbolt.org . The compilers versions: g++ (GCC-Explorer-Build) 9.0.0 20190120 (experimental) clang version 9.0.0 (trunk 352942) icc (ICC) 19.0.1.144 20181018 Microsoft (R) C/C++ Optimizing Compiler Version 19.16.27023.1 for x86 Compiler flags GCC, Clang: AVX2: -O3 -mavx2 AVX512: -O3 -mavx512f -mavx512dq -mavx512bw -mavx512vbmi -mavx512vbmi2 -mavx512vl ICC: AVX2: -O3 -axAVX2 -xAVX2 AVX512: -O3 -mavx512f -mavx512dq -mavx512bw -mavx512vbmi -mavx512vbmi2 -mavx512vl MSVC: AVX2: /O2 /arch:AVX2 AVX512: /O2 /arch:AVX512 Results algorithm procedure GCC Clang ICC MSVC AVX2 AVX512 AVX2 AVX512 AVX2 AVX512 AVX2 AVX512 accumulate --- custom accumulate_custom_epi8 no no no no no no no no 1 accumulate_custom_epi32 yes yes yes yes yes yes yes no 1 accumulate --- default accumulate_epi8 yes yes yes yes no yes yes no 1 accumulate_epi32 yes yes yes yes yes yes yes no 1 all_of all_of_epi8 no no no no no no no no all_of_epi32 no no no no no no no no any_of any_of_epi8 no no no no no no no no any_of_epi32 no no no no no no no no copy copy_epi8 no no no no no no no no copy_epi32 no no no no no no no no copy_if copy_if_epi8 no no no no no no no no copy_if_epi32 no no no no no no no no count count_epi8 yes yes yes yes yes yes yes no 1 count_epi32 yes yes yes yes yes yes yes no 1 count_if count_if_epi8 yes yes yes yes yes yes no no count_if_epi32 yes yes yes yes yes yes no no fill fill_epi8 no no no no yes yes no no fill_epi32 yes yes yes yes yes yes no no find find_epi8 no no no no no no no 2 no 2 find_epi32 no no no no no no no no find_if find_if_epi8 no no no no no no no no find_if_epi32 no no no no no no no no is_sorted is_sorted_epi8 no no no no no no no no is_sorted_epi32 no no no no no no no no none_of none_of_epi8 no no no no no no no no none_of_epi32 no no no no no no no no remove remove_epi8 no no no no no no no no remove_epi32 no no no no no no no no remove_if remove_if_epi8 no no no no no no no no remove_if_epi32 no no no no no no no no replace replace_epi8 no yes no 3 yes yes yes no no replace_epi32 yes yes yes yes yes yes no no replace_if replace_if_epi8 no yes no yes yes yes no no replace_if_epi32 yes no no no yes yes no no reverse reverse_epi8 yes yes no no no no no 4 no 4 reverse_epi32 yes yes no no no no no 5 no 5 transform --- abs transform_abs_epi8 yes yes yes yes yes yes yes no 1 transform_abs_epi32 yes yes yes yes yes yes yes no 1 transform --- increment transform_inc_epi8 yes yes yes yes yes yes yes no 1 transform_inc_epi32 yes yes yes yes yes yes yes no 1 transform --- negation transform_neg_epi8 yes yes yes yes yes yes no no transform_neg_epi32 yes yes yes yes yes yes no no unique unique_epi8 no no no no no no no no unique_epi32 no no no no no no no no 1 emits AVX2 code 2 calls memchr 3 loads input\'s chunk into a vector register, but all comparisons and stores are scalar 4 calls ___std_reverse_trivially_swappable_1 5 calls ___std_reverse_trivially_swappable_4 A few notes: In most compilers std::fill for int8_t ends up with memset invocation. MSVC does not emit AVX512 instruction, only AVX2. I was wondering why std::replace for int8_t cannot be vectorized for AVX2 targets. Following code would do the job: Travis Downs pointed out that such code behaves differently than original replace , as it always overwrites all bytes, regardless comparison results. To make things more interesting, ICC vectorizes std::replace using the above approach, which seems to be a compiler bug . However, if we rewrite replace algorithm, into form where each byte is always overwritten, then compilers GCC and clang vectorize it for the AVX2 target: See also SIMDized sum of all bytes in the array --- std::accumulate for int8_t Is sorted using SIMD instructions Source code All implementations are available at github .'],
["notesen/2019-02-03-malloc-internal-memory-fragmentation.html", 'Malloc internal memory fragmentation footprint', 'Malloc internal memory fragmentation footprint Wojciech Mua Added on 2019-02-03 Contents Introduction malloc in GNU libc Experiments Fixed size Random size Conclusions Source code Introduction When we allocate memory using malloc or another interface, like operator new in C++, we get a pointer and promise that nobody else would acquire the same memory area. But underneath, more memory is needed. For instance the allocator has to keep the size of block to implement realloc . More important is that the allocator unlikely allocate the exact number of bytes we requested, rather it will round the size up. Internal memory fragmentation is how we call this extra memory --- which is allocated, but not legally available for a program. This text shows internal memory fragmentation effects in different synthetic scenarios. However, memory fragmentation is a real problem. I came across this issue when was developing pyahcorasic module, that is built around multi-way trees --- tries . To build a trie we need to allocate a large number of quite small fixed-size nodes associated with (also rather small) edge structures of variable size. It appeared that while theoretical size of all structures is smaller than memory I had available in my system, malloc reported no memory. malloc in GNU libc GNU libc provides a set of functions which allow to query statistics of the allocator; function mallinfo seems to be most friendly, as it returns a structure. The structure has two fields interesting : uordblks --- total allocated space in bytes; fordblks --- total free space in bytes. Experiments In experiments we allocate a defined memory by multiple calls of malloc ; target sizes are: 1MB, 10MB and 100MB. Each malloc call gets either a fixed number, or a random number from given range. Fixed size allocations libc memory usage count min [B] max [B] total [B] allocated [B] free [B] waste [B] waste [%] approx target memory usage: 1,048,576 1,048,576 1 1 1,048,576 33,627,744 29,088 32,550,080 96.80 524,288 2 2 1,048,576 16,850,528 45,472 15,756,480 93.51 349,526 3 3 1,048,578 11,258,144 95,968 10,113,598 89.83 262,144 4 4 1,048,576 8,461,920 53,664 7,359,680 86.97 209,716 5 5 1,048,580 6,784,224 109,344 5,626,300 82.93 174,763 6 6 1,048,578 5,665,728 11,328 4,605,822 81.29 149,797 7 7 1,048,579 4,866,816 134,400 3,683,837 75.69 131,072 8 8 1,048,576 4,267,616 57,760 3,161,280 74.08 116,509 9 9 1,048,581 3,801,600 118,272 2,634,747 69.31 104,858 10 10 1,048,580 3,428,768 85,600 2,294,588 66.92 95,326 11 11 1,048,586 3,123,744 120,288 1,954,870 62.58 87,382 12 12 1,048,584 2,869,536 104,160 1,716,792 59.83 80,660 13 13 1,048,580 2,654,432 48,928 1,556,924 58.65 74,899 14 14 1,048,586 2,470,080 98,112 1,323,382 53.58 69,906 15 15 1,048,590 2,310,304 122,720 1,138,994 49.30 65,536 16 16 1,048,576 2,170,464 127,392 994,496 45.82 61,681 17 17 1,048,577 2,047,104 115,584 882,943 43.13 58,255 18 18 1,048,590 1,937,472 90,048 798,834 41.23 55,189 19 19 1,048,591 1,839,360 52,992 737,777 40.11 52,429 20 20 1,048,580 1,751,040 6,144 696,316 39.77 49,933 21 21 1,048,593 1,671,168 86,016 536,559 32.11 47,663 22 22 1,048,586 1,598,528 23,488 526,454 32.93 45,591 23 23 1,048,593 1,532,224 89,792 393,839 25.70 43,691 24 24 1,048,584 1,471,424 15,424 407,416 27.69 41,944 25 25 1,048,600 2,086,624 76,064 961,960 46.10 40,330 26 26 1,048,580 2,009,152 18,368 942,204 46.90 38,837 27 27 1,048,599 1,937,488 90,032 798,857 41.23 37,450 28 28 1,048,600 1,870,912 21,440 800,872 42.81 36,158 29 29 1,048,582 1,808,896 83,456 676,858 37.42 34,953 30 30 1,048,590 1,751,056 6,128 696,338 39.77 33,826 31 31 1,048,606 1,696,960 60,224 588,130 34.66 32,768 32 32 1,048,576 1,646,176 111,008 486,592 29.56 21,846 48 48 1,048,608 1,471,456 15,392 407,456 27.69 16,384 64 64 1,048,576 1,384,032 102,816 232,640 16.81 8,192 128 128 1,048,576 1,252,960 98,720 105,664 8.43 4,096 256 256 1,048,576 1,187,424 29,088 109,760 9.24 2,048 512 512 1,048,576 1,154,656 61,856 44,224 3.83 1,024 1,024 1,024 1,048,576 1,138,272 78,240 11,456 1.01 512 2,048 2,048 1,048,576 1,130,080 86,432 -4,928 -0.44 approx target memory usage: 10,485,760 10,485,760 1 1 10,485,760 335,617,632 4,512 325,127,360 96.87 5,242,880 2 2 10,485,760 167,845,472 33,184 157,326,528 93.73 3,495,254 3 3 10,485,762 111,921,440 132,832 101,302,846 90.51 2,621,440 4 4 10,485,760 83,959,392 115,104 73,358,528 87.37 2,097,152 5 5 10,485,760 67,182,176 131,488 56,564,928 84.20 1,747,627 6 6 10,485,762 55,997,376 97,344 45,414,270 81.10 1,497,966 7 7 10,485,762 48,008,224 111,584 37,410,878 77.93 1,310,720 8 8 10,485,760 42,016,352 20,896 31,509,696 74.99 1,165,085 9 9 10,485,765 37,356,032 85,504 26,784,763 71.70 1,048,576 10 10 10,485,760 33,627,744 29,088 23,112,896 68.73 953,251 11 11 10,485,761 30,577,344 105,792 19,985,791 65.36 873,814 12 12 10,485,768 28,035,360 79,584 17,470,008 62.31 806,597 13 13 10,485,761 25,884,416 67,840 15,330,815 59.23 748,983 14 14 10,485,762 24,040,768 19,136 13,535,870 56.30 699,051 15 15 10,485,765 22,442,944 130,112 11,827,067 52.70 655,360 16 16 10,485,760 21,044,832 41,376 10,517,696 49.98 616,810 17 17 10,485,770 19,811,232 58,464 9,266,998 46.78 582,543 18 18 10,485,774 18,714,688 73,664 8,155,250 43.58 551,883 19 19 10,485,777 17,733,568 108,608 7,139,183 40.26 524,288 20 20 10,485,760 16,850,528 45,472 6,319,296 37.50 499,322 21 21 10,485,762 16,051,616 33,376 5,532,478 34.47 476,626 22 22 10,485,772 15,325,344 83,808 4,755,764 31.03 455,903 23 23 10,485,769 14,662,208 71,104 4,105,335 28.00 436,907 24 24 10,485,768 14,054,336 3,136 3,565,432 25.37 419,431 25 25 10,485,775 20,206,000 69,200 9,651,025 47.76 403,299 26 26 10,485,774 19,431,664 32,528 8,913,362 45.87 388,362 27 27 10,485,774 18,714,688 73,664 8,155,250 43.58 374,492 28 28 10,485,776 18,048,928 63,584 7,499,568 41.55 361,578 29 29 10,485,762 17,429,056 7,616 6,935,678 39.79 349,526 30 30 10,485,780 16,850,560 45,440 6,319,340 37.50 338,251 31 31 10,485,781 16,309,360 45,968 5,777,611 35.43 327,680 32 32 10,485,760 15,801,952 12,704 5,303,488 33.56 218,454 48 48 10,485,792 14,054,368 3,104 3,565,472 25.37 163,840 64 64 10,485,760 13,180,512 65,952 2,628,800 19.94 81,920 128 128 10,485,760 11,869,792 24,992 1,359,040 11.45 40,960 256 256 10,485,760 11,214,432 4,512 724,160 6.46 20,480 512 512 10,485,760 10,886,752 61,856 339,136 3.12 10,240 1,024 1,024 10,485,760 10,722,912 90,528 146,624 1.37 5,120 2,048 2,048 10,485,760 10,640,992 37,280 117,952 1.11 approx target memory usage: 104,857,600 104,857,600 1 1 104,857,600 -939,450,784 29,088 -1,044,337,472 111.16 52,428,800 2 2 104,857,600 1,677,794,912 45,472 1,572,891,840 93.75 34,952,534 3 3 104,857,602 1,118,554,400 95,968 1,013,600,830 90.62 26,214,400 4 4 104,857,600 838,934,112 53,664 734,022,848 87.49 20,971,520 5 5 104,857,600 671,161,952 82,336 566,222,016 84.36 17,476,267 6 6 104,857,602 559,313,856 11,328 454,444,926 81.25 14,979,658 7 7 104,857,606 479,422,368 18,528 374,546,234 78.12 13,107,200 8 8 104,857,600 419,503,712 57,760 314,588,352 74.99 11,650,845 9 9 104,857,605 372,900,352 28,160 268,014,587 71.87 10,485,760 10 10 104,857,600 335,617,632 4,512 230,755,520 68.76 9,532,510 11 11 104,857,610 305,113,632 95,712 200,160,310 65.60 8,738,134 12 12 104,857,608 279,693,600 104,160 174,731,832 62.47 8,065,970 13 13 104,857,610 258,184,352 121,696 153,205,046 59.34 7,489,829 14 14 104,857,606 239,747,840 40,192 134,850,042 56.25 6,990,507 15 15 104,857,605 223,769,536 68,672 118,843,259 53.11 6,553,600 16 16 104,857,600 209,788,512 127,392 104,803,520 49.96 6,168,095 17 17 104,857,615 197,452,352 28,096 92,566,641 46.88 5,825,423 18 18 104,857,614 186,486,848 44,992 81,584,242 43.75 5,518,822 19 19 104,857,618 176,675,616 124,128 71,693,870 40.58 5,242,880 20 20 104,857,600 167,845,472 33,184 62,954,688 37.51 4,993,220 21 21 104,857,620 159,856,352 47,392 54,951,340 34.38 4,766,255 22 22 104,857,610 152,593,472 11,200 47,724,662 31.28 4,559,027 23 23 104,857,621 145,962,176 19,264 41,085,291 28.15 4,369,067 24 24 104,857,608 139,883,456 15,424 35,010,424 25.03 4,194,304 25 25 104,857,600 201,399,904 416 96,541,888 47.94 4,032,985 26 26 104,857,610 193,656,592 39,152 88,759,830 45.83 3,883,615 27 27 104,857,605 186,486,832 45,008 81,584,219 43.75 3,744,915 28 28 104,857,620 179,829,232 79,376 74,892,236 41.65 3,615,780 29 29 104,857,620 173,630,752 60,128 68,713,004 39.57 3,495,254 30 30 104,857,620 167,845,504 33,152 62,954,732 37.51 3,382,504 31 31 104,857,624 162,433,504 38,432 57,537,448 35.42 3,276,800 32 32 104,857,600 157,359,712 111,008 52,391,104 33.29 2,184,534 48 48 104,857,632 139,883,488 15,392 35,010,464 25.03 1,638,400 64 64 104,857,600 131,145,312 102,816 26,184,896 19.97 819,200 128 128 104,857,600 118,038,112 98,720 13,081,792 11.08 409,600 256 256 104,857,600 111,484,512 29,088 6,597,824 5.92 204,800 512 512 104,857,600 108,207,712 61,856 3,288,256 3.04 102,400 1,024 1,024 104,857,600 106,569,312 78,240 1,633,472 1.53 51,200 2,048 2,048 104,857,600 105,750,112 86,432 806,080 0.76 Random size allocations libc memory usage count min [B] max [B] total [B] allocated [B] free [B] waste [B] waste [%] approx target memory usage: 1,048,576 63,377 1 32 1,048,590 2,356,896 76,128 1,232,178 52.28 42,870 1 48 1,048,612 1,901,488 126,032 726,844 38.23 32,159 1 64 1,048,601 1,684,192 72,992 562,599 33.40 16,345 1 128 1,048,634 1,391,984 94,864 248,486 17.85 8,197 1 256 1,048,725 1,252,976 98,704 105,547 8.42 4,133 1 512 1,048,794 1,187,664 28,848 110,022 9.26 2,041 1 1,024 1,048,722 1,154,272 62,240 43,310 3.75 987 1 2,048 1,048,660 1,137,552 78,960 9,932 0.87 approx target memory usage: 10,485,760 635,815 1 32 10,485,774 22,964,288 14,272 12,464,242 54.28 428,303 1 48 10,485,797 18,340,320 42,528 7,811,995 42.59 322,582 1 64 10,485,762 16,204,048 16,112 5,702,174 35.19 162,503 1 128 10,485,761 13,235,776 10,688 2,739,327 20.70 81,377 1 256 10,485,792 11,859,472 35,312 1,338,368 11.29 41,028 1 512 10,485,769 11,205,568 13,376 706,423 6.30 20,448 1 1,024 10,485,813 10,879,072 69,536 323,723 2.98 10,258 1 2,048 10,485,956 10,718,912 94,528 138,428 1.29 approx target memory usage: 104,857,600 6,357,646 1 32 104,857,611 228,927,488 47,104 124,022,773 54.18 4,279,460 1 48 104,857,606 182,670,512 76,624 77,736,282 42.56 3,226,147 1 64 104,857,639 161,384,448 6,144 56,520,665 35.02 1,626,125 1 128 104,857,633 131,760,032 28,768 26,873,631 20.40 815,436 1 256 104,857,712 117,968,464 33,200 13,077,552 11.09 408,507 1 512 104,857,727 111,360,416 18,016 6,484,673 5.82 204,830 1 1,024 104,858,013 108,128,288 6,112 3,264,163 3.02 102,413 1 2,048 104,859,345 106,524,928 122,624 1,542,959 1.45 Conclusions Allocating small objects might bring huge memory overhead. If it\'s a real problem, we might consider using other allocation strategies, like memory pools . But please be aware of problems with address sanitizers , as sanitizers wrap system calls while these alternative allocators work --- in fact --- at application level and possible memory misuses likely won\'t be detected. For larger memory blocks and for more diverse sizes of memory block the cost of internal memory fragmentation is acceptable. Source code Sample programs are available at github .'],
["notesen/2019-02-03-simd-switch-implementation.html", 'SIMDization of switch statements', 'SIMDization of switch statements Wojciech Mua Added on 2019-02-03 Contents Introduction Example of binary search code Example of jump lookup SIMD approaches SIMDization of plain function Implementation SIMD-ization of code dispatching Implementation Performance Practical example Source code Introduction There are two main purposes of a switch statement: Express simple function that translate from one set of values into another, like getting a string representation of enum values. Dispatch different code sequences based on switch argument, as an alternative to \"if-ladder\". Compilers usually transform switch statements using following approaches: Binary search on constant keys: a compiler emits series of comparisons and jumps interleaved with case code. When the key values span a small range (even non-continuous one), the values are used to index a lookup table of jump targets. Of course, a compiler might optimize some specific cases, for some neat examples look at tree-switch-conversion.cc from GCC. However, switch statements can be expressed also with SIMD instructions. Vector instructions are used used to translate from the argument value into case ordinal number. Then, the index is used either to 1) fetch a value from a precalculated table, or 2) get a jump target (the address) which is used to dispatch code fragments. Example of binary search code Following C++ code is compiled by GCC 7.3.0 into a binary search procedure. Example of jump lookup SIMD approaches SIMDization of plain function Let\'s see how palette function might be vectorized: Load the key values into a SIMD register. In this case we have exactly eight 32-bit numbers; when compiled to an AVX2 target, all values fit in single AVX register. Broadcast the switch argument in a SIMD register: Compare the argument with all keys. Obtain a bitmask from the 32-bit mask. If the bitmask is non-zero it means argument is equal to one of keys. The key index is determined by position of first (and only) bit set in bitmask . If bitmask is zero, we have to return the default value. In this example the function value is equal to index of key, but for more complex mappings we need an extra lookup table. The 5th point of the above algorithm would be like this: Please note one trick we used. If SIMD vector is not fully filled, and switch has got a default label, we might use one bit of the bitmask to include the default value in the result. Thanks to that an extra if is ridden off. Implementation SIMD-ization of code dispatching In procedure code_block the keys {0, 3, 4, 7, 8, 11} are mapped into addresses of code sequences or basic blocks in the compiler construction vocabulary. Assembly code generated by GCC which does the mapping: Firstly, it determines whether the input is in range 0 .. 11. When it is, then fetch the address of case code and jump there. Below is an AVX2 algorithm that does exactly the same. Load into SIMD register key values. This time we match six keys, so two 32-bit words in an AVX2 register are not used (filled with -1). Broadcast switch argument in AVX2 register. Compare the argument with all keys. Obtain a bitmask from the 32-bit mask. Here we also set the 7th bit of bitmask. Get index of set bit and jump to appropriate label. Please note that the 7th label ( end ) points to basic block which is equivalent to a no-match condition in the switch statement (there\'s no default label in code). Here the C++ code uses a GCC extension which allows to store label addresses and jump to runtime-selected address. On the assembly code level this maps into indirect jump instruction. Implementation Performance In case of code involving jumps, it\'s hard to say anything. Performance of dispatching depends mostly on a branch predictor, as mispredicted branches can cost several cycles. It\'s likely that in typical scenarios, where just one or two cases are really executed, SIMD code will not be faster. However, for simple lookup functions, SIMD code is likely to be faster for switches with large number of cases. First of all, such a function is almost branch free, as the default case can be resolved also by the vector code. SIMD code depends only on the number of cases not their values. Practical example Use of SIMDized case in parsing of RFC dates . Source code Sample programs are available at github .'],
["notesen/2019-12-31-avx512-pospopcnt-8bit.html", 'AVX512 8-bit positional population count procedure', 'AVX512 8-bit positional population count procedure Wojciech Mua Added on 2019-12-31 Table of contents Introduction SAD instruction recap Pospopcnt algorithm overview Pospopcnt algorithm details Summary Source code Introduction Positional population count (pospopcnt) is a procedure that calculates the histogram for bits placed at given position in a byte, word or double word etc. from larger stream of such entities. This is a very naive implementation of 8-bit pospopcnt: For example [3, 3, 2, 4, 1, 2, 3, 1] is the pospopcnt result for following five bytes: 0b0110\'1001 , 0b1100\'1000 , 0b0000\'1111 , 0b0001\'0011 , 0b0110\'1110 . A few 16-bit pospopcnt procedures were described in article Efficient Computation of Positional Population Counts Using SIMD Instructions by Marcus D. R. Klarqvist , Daniel Lemire and me. The library maintained by Marcus provides pospopcnt procedures for 8, 16 and 32-bit words. This article shows a neat utilization of SAD instruction to calculate 8-bit pospopcnt. It\'s not the fastest one, but I really like the whole algorithm. SAD instruction recap SSE, AVX2 and AVX512BW have instruction SAD ( PSADBW , VPSADBW ) which calculates the sum of absolute differences of bytes. SAD procedure is always applied to 8-byte lanes of SIMD registers, thus in case of the AVX512 variant there are eight SAD results. It means that the maximum value of procedure is 255 * 8 = 2040, it fits in the lower 16 bits of lane. Observation: when one of SAD arguments is zero, then the procedure yields the sum of bytes from the non-zero argument. Pospopcnt algorithm overview The simplest way to use SAD to calculate pospopcnt would be mask each bit: 0, 1, ..., 7 and invoke SAD eight times. However, since the sum of an isolated bit never exceeds 8, we may use single SAD to calculate two sums for pairs of bits: 0-4, 1-5, 2-6 and 3-7. Such sums are then stored on 4-bit subwords of 8-bit word. Additionally, if we shift right the pairs of bit to position 0-4, then combined sums never exceed the byte boundary, as the maximum value is 0x88 . Thanks to these tricks we need only four invocations of SAD instruction to get pospopcnts from 8-byte lanes --- we call them partial pospopcnts. These partial results are stored in separate 64-bit words of four registers. The next step is to gather the bytes having sums for given bit in the same lane, and then place the lanes in single register. That can be done with byte-shuffling instructions and basic bit-ops instructions. The last step is to mask out either lower on higher nibbles of combined sums, and invoke SAD for the last time. At this point each 64-bit word of the result vector has got the total pospopcnt for bytes from the input register. Such resulting vector can be easily used to update the global histogram. The global histogram can also be kept in a register during the main loop, as it fits in single AVX512 register. Pospopcnt algorithm details In a loop over input: Calculate partial pospopcnts: Following picture shows bit layout in a 64-bit word during calculation of pospopcnt of bits 0 and 4. Please note that only the lowest byte of 64-bit word is non-zero. This is the layout of non-zero bytes in all registers sum04 , sum15 , sum26 and sum37 . As we see there are only 64 non-zero bytes. Gather the non-zero bytes in lanes of a register. We use the VPERM2B lookup instruction that builds a new vector from the bytes fetched from two other vectors. At this stage the bytes in t0 still hold two counters, there\'s need to mask out one of them: Finally we can invoke the last SAD instruction which produce final pospopcnt for all bytes from the input vector. Note : In fact the partial pospopcnts stored on higher nibbles (for bits 4, 5, 6 and 7) are multiplied by 16. We might shift them right prior the SAD invocation, but it\'s faster to adjust these counters after the main loop. That solution limits the size of input from [...] [...] Now each 64-bit word of t2 holds pospopcnts for the corresponding bit and this register can be used then to update a global histogram with single add: Summary In order to get pospopcnt of 64 bytes stored in an AVX512 register we need to execute following instructions: 5 x bit-and, 3 x shift right, 5 x SAD, 2 x byte shuffle, 1 x ternary logic (I suppose bit-or would be also sufficient), 1 x add. Source code Implementation is available'],
["notesen/2020-01-19-avx512-galois-field-for-bit-shuffling.html", 'Use AVX512 Galois field affine transformation for bit shuffling', 'Use AVX512 Galois field affine transformation for bit shuffling Wojciech Mua Added on 2020-01-19 Contents Introduction What affine transformation does? How can we (ab)use affine transformation? Bit shuffling Gathering bits 64x64 bit matrix transposition Sample code Introduction This article was inspired by Geoff Langdale\'s text Why Ice Lake is Important (a bit-bashers perspective) . I\'m also grateful Zach Wegner for an inspiring discussion. The AVX512 extension GFNI adds three instructions related to Galois field : VGF2P8MULB ( _mm512_gf2p8mul_epi8 ) --- multiply 8-bit integers in the field [...] VGF2P8AFFINEINVQB ( _mm512_gf2p8affineinv_epi64_epi8 ) --- inverse affine transformation in the field [...] VGF2P8AFFINEQB ( _mm512_gf2p8affine_epi64_epi8 ) --- affine transformation in the field [...] While the two first instructions perform quite specific algorithms, the third one is the most generic and promising. What affine transformation does? Below is a C-like pseudocode for VGF2P8AFFINEQB . The main properties of the instruction are: It transforms 64-bit lanes ( qwords ) separately. Each byte gets transformed by the same procedure affine_byte . It is important to note that the arguments for the procedure are a byte and qword. We\'re combining one byte from the first vector ( x ) with eight bytes from the second vector ( A ). A constant imm8 allows to negate selected bits of result. Unfortunately, it\'s a compile-time constant (saved as a part of instruction opcode). How can we (ab)use affine transformation? The crucial observation is that the parity function can be used to copy selected bit . This function calculates bit-xor for all bits of input, i.e. it returns 1 when number of ones in input is odd. We know that 0 xor 0 = 0 , thus parity(0) = 0 . If the input has exactly one bit set, i.e. its form is 1 << k , we hit the case 1 xor 0 = 1 during computations, which means that parity(1 << k) = 1 . The function parity is called with the result of bit-and of two bytes fetched from the two argument vectors ( qword[7 - i] & byte ). If we assure that one of bytes is constant and has the k-th bit set, than parity yields k-th bit from another, non-constant byte. We may conclude that at least two bit-shuffling operations are possible: Arbitrary reshuffle bits within a byte. We may reverse bits, rotate, set the order of bits, broadcast selected bit(s), etc. Gather in a byte selected bit from a lane. There are also two extra degrees of freedom: Since all operations are done on lanes, each lane might have different settings. As it was mentioned, imm8 can be used to negate selected bits ( parity(x) ^ imm8.bit[i] ). Bit shuffling Let\'s do some inlining on the sample psuedocode to make that ability clearly visible: Bit shuffling requires to setup a pattern in argument A . The pattern for each lane is a 64-bit number in form: where constants bit0 , bit1 , ..., bit7 have to be in range 0..7. Please bear in mind that the order of bytes in a constant has to be reversed, as procedure affine_byte fetches bytes from A using index 7 - i . For instance, to interleave bits, i.e. set the output order to 0, 4, 1, 5, 2, 6, 3, 7, the constant has to be 0x0110022004400880 (not 0x8008400420021001 ). If we want to reverse bits within a byte, the constant is 0x8040201008040201 . If we want to populate one bit, let say 5th, the constant is 0x2020202020202020 . Usage in code requires only setup a proper constant and invocation of _mm512_gf2p8affine_epi64_epi8 intrinsic function: Below is a sample bit flow for interleave operation in one iteration of affine transformation. Gathering bits To build a byte from selected bit we must fill the argument x with proper masks, argument A is then treated as \"variable\". Again, we do some simplifications to the pseudocode to reveal this property: Please note that the order of bits is reversed, because in affine_byte bytes from A are fetched from index 7 - i . 64x64 bit matrix transposition If we treat a 64-bit lanes as matrices 64x64 of bits, then transposition with VGF2P8AFFINEQB is quite simple. Sample code Sample code is available at github .'],
["notesen/2020-03-21-avx512-binomial-coefficient.html", 'Use AVX512 to calculate binomial coefficient', 'Use AVX512 to calculate binomial coefficient Wojciech Mua Added on 2020-03-21 Contents Introduction SIMD algorithms Reference scalar algorithm AVX512 algorithm 1 AVX512 algorithm 2 Conclusions Comparison of inputs ranges Source code Introduction The value of binomial coefficient [...] [...] [...] [...] Fast divisionless computation of binomial coefficients how efficiently evaluate the latter expression. Can SIMD instructions be utilized to get binomial coefficients? I wish I could write \"yes, they can\", but the answer is not optimistic. SIMD instructions can be used to perform in parallel several pairs of multiplications, however it\'s a quest to properly setup registers and deal with different numbers of arguments that depend on the [...] [...] What I checked and described here is utilization of AVX512 with a different numeric system. An important fact is that calculation of binomial coefficients involves only multiplication and (integer) division. We do know that all natural numbers can be factorized , i.e. represent as a product of prime numbers raised to some non-negative powers. For instance, 20200320 is equal to [...] [...] [...] The core idea is to represent input integers as factored numbers . We setup the fixed number of primes and then operate only on exponents. We make sure that exponents fit in 8-bit values, thus in case of AVX512 we have 64-element products. With such representation, the vector addition and subtraction instructions are sufficient to calculate binomial coefficients. So far everything might sounds nice, but unfortunately there are some serious problems: Factorization is not cheap, we must cache exponents. Since we must cache intermediate values, why not pre-calculate binomial coefficients? Getting back from factorized representation is also not cheap. It requires multiplication and getting integer powers (also multiplication). To my surprise, the range of inputs covered by a SIMD-ized algorithm is smaller than a scalar version. I supposed that cancellation of primes present in both nominator and denominator would be beneficial. SIMD algorithms Reference scalar algorithm AVX512 algorithm 1 Below is the AVX512 procedure, which is a direct translation of the scalar one. There are three major stages of the procedure: Calculation of the nominator and denominator, which requires fetching the pre-calculated exponents and summing them up using vector additions ( _mm512_add_epi8 ). Division the nominator by denominator: just a vector subtraction ( _mm512_sub_epi8 ). Get back from the product world into a single, 64-bit value. At this stage we have exponents either positive or negative. We separately calculate products for powers with negative and positive exponents and finally divide them. AVX512 algorithm 2 Instead of pre-calculating factors for separate numbers, we can pre-calculate valeues of factorials ( [...] [...] This algorithm has one disadvantage: if we want to keep 8-bit exponents, the maximum value of exponent must be 63 as we do addition (so maximum would be 126). Conclusions While using AVX512 for this particular problem is highly inefficient and should be seen as an another weird use of SIMD, I do see a potential in large number multiplication. For instance, if we have 128-bit numbers (16 bytes), the maximum value we can store is [...] [...] Comparison of inputs ranges Following picture show results for all combinations of [...] [...] [...] red cell: both the scalar and AVX512 procedures overflow on 64-bit operations; green cell: both produces yield valid results; yellow cell: only the scalar procedure does not overflow. Source code All code is available on github .'],
["notesen/2021-01-18-autovectorization-gcc-clang.html", 'Autovectorization status in GCC & Clang in 2021', 'Autovectorization status in GCC & Clang in 2021 Wojciech Mua Added on 2021-01-18 Contents Introduction Comparison Compiler versions Compiler flags Results Summary Vectorization of is_sorted Source code Introduction Almost two years ago I did an in-depth comparison of autovectorization abilities of popular compilers: GCC , clang , ICC and MSVC . In this text only GCC and clang are considered, as I don\'t see any new versions of ICC nor MSVC on godbolt.org (drop me a line if I got lost in the multitude of compiler versions). Update 2021-02-17 : MSVC 19.28 status . The question is: \"what has changed between GCC 9 and GCC 10, and between clang 9 and clang 11?\". Comparison In this comparison we consider only two targets: AVX2, AVX512 with all possible extensions (AVX512BW, AVX512VL, AVX512VBMI, etc.) A few basic algorithm available in C++ algorithm library were picked. Compiler versions Debian GCC 10.2.1 20210108 Debian clang version 11.0.1-2 Compiler flags AVX2: -O3 -mavx2 AVX512: -O3 -mavx512f -mavx512dq -mavx512bw -mavx512vbmi -mavx512vbmi2 -mavx512vl Results algorithm procedure GCC 9 GCC 10 Clang 9 Clang 11 AVX2 AVX512 AVX2 AVX512 AVX2 AVX512 AVX2 AVX512 accumulate --- custom accumulate_custom_epi8 no no no no no no no no accumulate_custom_epi32 yes yes yes yes yes yes yes yes accumulate --- default accumulate_epi8 yes yes yes yes yes yes yes yes accumulate_epi32 yes yes yes yes yes yes yes yes all_of all_of_epi8 no no no no no no no no all_of_epi32 no no no no no no no no any_of any_of_epi8 no no no no no no no no any_of_epi32 no no no no no no no no copy copy_epi8 no no no no 1 no no no no copy_epi32 no no no no 1 no no no no copy_if copy_if_epi8 no no no no 1 no no no no copy_if_epi32 no no no no 1 no no no no count count_epi8 yes yes yes yes yes yes yes yes count_epi32 yes yes yes yes yes yes yes yes count_if count_if_epi8 yes yes yes yes yes yes yes yes count_if_epi32 yes yes yes yes yes yes yes yes fill fill_epi8 no no no 2 no 2 no no no 2 no 2 fill_epi32 yes yes yes yes yes yes yes yes find find_epi8 no no no no no no no no find_epi32 no no no no no no no no find_if find_if_epi8 no no no no no no no no find_if_epi32 no no no no no no no no is_sorted is_sorted_epi8 no no no no no no no no is_sorted_epi32 no no no no no no no no none_of none_of_epi8 no no no no no no no no none_of_epi32 no no no no no no no no remove remove_epi8 no no no no no no no no remove_epi32 no no no no no no no no remove_if remove_if_epi8 no no no no no no no no remove_if_epi32 no no no no no no no no replace replace_epi8 no yes no yes no 3 yes yes yes replace_epi32 yes yes yes yes yes yes yes yes replace_if replace_if_epi8 no yes no yes no yes no no replace_if_epi32 yes no yes yes no no no no reverse reverse_epi8 yes yes yes yes no no no no reverse_epi32 yes yes yes yes no no no no transform --- abs transform_abs_epi8 yes yes yes yes yes yes yes yes transform_abs_epi32 yes yes yes yes yes yes yes yes transform --- increment transform_inc_epi8 yes yes yes yes yes yes yes yes transform_inc_epi32 yes yes yes yes yes yes yes yes transform --- negation transform_neg_epi8 yes yes yes yes yes yes yes yes transform_neg_epi32 yes yes yes yes yes yes yes yes unique unique_epi8 no no no no no no no no unique_epi32 no no no no no no no no 1 SIMD instructions present, but not in the main loop 2 calls memset 3 loads input\'s chunk into a vector register, but all comparisons and stores are scalar Summary The answer to the initial question is pretty sad: there is no progress. GCC learnt how to vectorize replace_if_epi32 for AVX512 targets. At the same time clang lost this ability. These are the only changes. BTW, it\'s worth to note that MSVC gained support for AVX512 in 2020 . Vectorization of is_sorted Tomasz Duda showed that following C++ code is nicely vectorized by clang 9 and newer: I purposely called it \"vectorization\" not \"autovectorization\", as the main loop of algorithm has to be manually adjusted to let a compiler discover vectorization opportunity. Personally I\'d reserve the term \"autovectorization\" for procedures that don\'t need such hints from a programmer. Source code All implementations are available at github .'],
["notesen/2021-02-02-all-bytes-in-reg-are-equal.html", 'How to detect if all bytes in SIMD register are the same?', 'How to detect if all bytes in SIMD register are the same? Wojciech Mua Added on 2021-02-02 Updated on 2021-02-03 (added SSE variant #2 ) Contents Introduction SSE SSE --- variant #2 AVX2 AVX512F AVX512BW Better AVX512 Source code Introduction We want to detect if all bytes stored in a SIMD register (SSE, AVX2, AVX512, Neon etc.) are the same. For example for byte layout in an SSE register like this: We see that all bytes are equal to 42. For this one not all bytes have the same value: The algorithm which uses basic vector operations: broadcast the 0th byte of register into a new vector: perform a vector-wide compare for equality: check whether all elements of cmp vector are \"true\". Depending on a SIMD flavour, these simple steps may not be that simple. SSE Broadcasting byte is done with _mm_shuffle_epi8 . Then, a vector comparison yielding a byte mask is used ( _mm_cmpeq_epi8 ). Finally, the byte-mask is converted into a bit-mask and tested with regular instructions. Assembly code generated by GCC 10.2: SSE --- variant #2 Travis Downs & Robert Clausecker noted that instead of broadcasting a byte we may also perform byte rotate by one (or any odd number) using _mm_alignr_epi8 . Unfortunately, this is only applicable for SSE, because the AVX2 counterpart works on 128-bit lanes, rather the whole register. Algorithm: A sample implementation: Assembly code generated by GCC 10.2: AVX2 In case of AVX2, a byte shuffle instruction works on individual 128-bit lanes. We use fact that SSE registers ( xmm ) are aliased to lower lanes of AVX/AVX2 registers ( ymm ). The intrinsic function _mm256_castsi256_si128 does not generate any instruction, it just satisfies C/C++ type systems. The 0th byte is populated exactly like in the SSE variant, and then a new 256-bit vector is built from 128-bit lanes. Finally, the comparison procedure is very similar to SSE\'s variant. Assembly code generated by GCC 10.2: AVX512F First of all, AVX512F does not support byte-level operations. Luckily, SSE registers ( xmm ) are mapped on the 0th lane of AVX512 registers ( zmm ). This, broadcasting of the 0th byte is done similarly in the AVX2 variant. Lack of byte-level comparison is not a problem in our case, as we seek for equality of whole registers, it doesn\'t matter what units are used in comparison. Assembly code generated by GCC 10.2: AVX512BW AVX512BW let to express the problem directly as it was stated. There is a specialised instruction that broadcasts the 0th byte ( _mm512_broadcastb_epi8 / vpbroadcastb ). Also the extension supports byte-level comparison, however it\'s not crucial in our problem. Assembly code generated by GCC 10.2: Better AVX512 Both AVX512BW and AVX512F variants can be a bit shorter in terms of assembly output. We want to tests whether bit-vector is full of ones. There\'s a dedicated CPU instruction _mm512_kortestc that works on the mask registers ( k0 , k1 , ...) which does exactly the test we need. Below is psuedocode showing this instruction. Below is a AVX512BW code which uses that instruction. Assembly code generated by GCC 10.2: Source code All implementations are available at github .'],
["notesen/2021-02-14-avx512bw-count-bytes.html", 'Counting byte in byte stream with AVX512BW instructions', 'Counting byte in byte stream with AVX512BW instructions Wojciech Mua Added on 2021-02-14 Updated on 2021-02-18 (add new, faster implementation suggested by Travis Downs ; fixed info about port usage, as noted by InstLatX64 ) Contents Introduction AVX512BW --- bitmask algorithm AVX512BW --- bytemask algorithm AVX512BW --- bytemask algorithm with mask registers Experiment results from Skylake-X Conclusions Source code Introduction This is a follow up to article SIMDized counting byte in byte stream . In this article only AVX512BW variants are discussed. Performance is analyzed only for the Skylake-X CPU. We want to count how many times given byte appears in a byte stream. The following C++ code shows the naive algorithm: AVX512BW --- bitmask algorithm AVX512 allows to express the problem in a really elegant way. Unlike other common SIMD extensions, the result of a vector comparison in AVX512 is a bitmask stored in a mask register . A mask register in AVX512BW is a 64-bit word. We only have to produce such bitmask for equals to comparison, and then count bits in the bitmask. The bit count operation is cheap (1 cycle latency on current CPUs). The following C++ procedure shows the actual implementation. The key lines are: Where _mm512_loadu_si512 --- loads 64 bytes into a register; _mm512_cmpeq_epi8_mask --- compares the register with the counted byte, yield a bitmask; __builtin_popcountll --- count bits in the bitmask. GCC 10.2 compiles the while loop into: The code is short, both in C++ and assembly. The loop consists only seven instruction. Also it is fast, and unrolling makes it even faster --- see the results in the following section . AVX512BW --- bytemask algorithm Even if we unroll the loop, we will be hit by congestion on execution ports. Both instructions vpcmpeqb and kmovq can be executed only on port #5. While latency of both AVX512 instructions is only one CPU cycle, popcnt has three cycles of latency. Obviously this is not bad, but it made me think if we can do better. The main idea is to avoid moving data between register sets. In the original approach we are using 1) vector, 2) mask and 3) generic purpose registers. The goal is to keep the comparison result in a vector register and follow the algorithm used for AVX2 and SSE instruction set. This algorithm updates byte counters 255 times, and then sums byte counters in some wider accumulator to avoid overflows on bytes. Below is the main loop of AVX2 implementation: Porting that procedure to AVX512 is straightforward, the only missing equivalent is _mm256_cmpeq_epi8 . Fortunately, it\'s quite easy to build one. We use the fact that if two numbers x and y are equal then x xor y = 0 . If the operands are not equal, then x xor y has some non-zero value. Note that if bytes are interpreted as unsigned numbers, than non-zero values are in range [1..255]. Now the question is, can we reduce such unspecified non-zero value into something nice, like -1 from the AVX2 case? Yes, we can use the minimum operator. Our expression is min(x xor y, 1) : when x = y then min(0, 1) = 0 ; when x != y then min(non-zero, 1) = 1 . AVX512BW defines vpminub ( _mm512_min_epu8 ) that calculates the minimum value of unsigned bytes, thus the translation of the byte-wise algorithm is possible. Below is the C++ implementation: It\'s almost identical to the AVX2 version, with just two exceptions: we initialize local_sum to the maximum possible value, because our comparison procedure yields zero when bytes are equal; we need two instructions to perform the byte-wise comparison: _mm512_xor_si512 and _mm512_min_epu8 . GCC 10.2 compiles the while loop into: The vector instructions that appear in the listing have following characteristics: vpxord can be executed on ports #0 and #5, vpminub can be executed on port #0, vpsubb can be executed on ports #0 and #5, vmovdqa64 does only register renaming. When the loop is unrolled, then it is more likely that vector instructions will be run in parallel. AVX512BW --- bytemask algorithm with mask registers The third variant is a modification of the bytemask algorithm. The byte counters are updated with by a masked operation. True, we get back to mask registers, however loop unrolling hides longer latencies of the masked operation. This modification was proposed by Travis Downs , I merely coded it. Below is the unrolled while loop: GCC 10.2 compiles the while loop into: Experiment results from Skylake-X CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz Compiler: GCC version 8.4.0 (Ubuntu 8.4.0-1ubuntu1~16.04.1) Procedures: scalar --- the naive C++ code shown at the beginning; AVX2 --- the procedure shown above; AVX512BW --- bitmask algorithm; AVX512BW (ver 5) --- bytemask algorithm; AVX512BW (ver 6) --- bytemask with masked operations. procedure time in cycles per byte speed-up average best scalar 0.458 0.435 1.0 AVX2 0.071 0.069 6.3 AVX512BW 0.061 0.057 7.6 AVX512BW (unrolled 4x) 0.044 0.044 9.9 AVX512BW (ver 5) 0.040 0.040 10.9 AVX512BW (ver 5 unrolled 2x) 0.033 0.032 13.6 AVX512BW (ver 5 unrolled 4x) 0.035 0.035 12.4 AVX512BW (ver 6 unrolled 4x) 0.029 0.029 15.0 Conclusions The approaches using byte-wise comparison (versions 5 & 6) are 1.3-1.5 times faster than the initial AVX512BW code that uses bitmask. The drawback of the faster procedures is that minimum amount of data is almost 16kB (255 * 64). An interesting fact is that too much unrolling doesn\'t help for version #5 --- 0.35 cycles/byte for 4 x unroll versus 0.33 cycles/byte for 2 x unroll. Source code All implementation are available at github .'],
["notesen/2021-02-17-autovectorization-msvc.html", 'Autovectorization status in MSVC in 2021', 'Autovectorization status in MSVC in 2021 Wojciech Mua Added on 2021-02-17 Updated on 2021-02-18 (MSVC 19.6 didn\'t autovectorize accumulate_custom_epi8 , my mistake; noticed by Harold Aptroot ) Contents Introduction Comparison Compiler versions MSVC compiler flags Results Summary Source code Introduction This year I re-checked the status of autovectorization in the latest GCC and Clang . MSVC was omitted because I didn\'t see any new version of this compiler on godbolt . More precisely, I didn\'t believe that there is a difference between versions 19.28 and 19.16 (that was tested two years ago ). Harold Aptroot pointed out that there are some differences in code generated for the AVX2 target. Additionally, in 2020 MSVC started to support AVX512 . These two reasons forced me to recheck MSVC too. Comparison In this comparison we consider two targets: AVX2, AVX512 with all possible extensions (AVX512BW, AVX512VL, AVX512VBMI, etc.) A few basic algorithm available in C++ algorithm library were picked. Compiler versions Microsoft (R) C/C++ Optimizing Compiler Version 19.28.29333 for x86 (version from 2021) Microsoft (R) C/C++ Optimizing Compiler Version 19.16.27023.1 for x86 (version from 2019) For sake of completeness also GCC and Clang results are included. Please refer to the article dedicated to these compilers . Debian GCC 10.2.1 20210108 Debian clang version 11.0.1-2 MSVC compiler flags AVX2: /O2 /arch:AVX2 AVX512: /O2 /arch:AVX512 Results algorithm procedure MSVC 19.28.29333 MSVC 19.16.27023.1 GCC 10 Clang 11 AVX2 AVX512 AVX2 AVX512 AVX2 AVX512 AVX2 AVX512 accumulate --- custom accumulate_custom_epi8 no no no --- no no no no accumulate_custom_epi32 yes yes yes --- yes yes yes yes accumulate --- default accumulate_epi8 yes yes yes --- yes yes yes yes accumulate_epi32 yes yes yes --- yes yes yes yes all_of all_of_epi8 no no no --- no no no no all_of_epi32 no no no --- no no no no any_of any_of_epi8 no no no --- no no no no any_of_epi32 no no no --- no no no no copy copy_epi8 no no no --- no no 1 no no copy_epi32 no no no --- no no 1 no no copy_if copy_if_epi8 no no no --- no no 1 no no copy_if_epi32 no no no --- no no 1 no no count count_epi8 yes yes yes --- yes yes yes yes count_epi32 yes yes yes --- yes yes yes yes count_if count_if_epi8 no no no --- yes yes yes yes count_if_epi32 no no no --- yes yes yes yes fill fill_epi8 no 2 no 2 no --- no 2 no 2 no 2 no 2 fill_epi32 no 3 no 3 no --- yes yes yes yes find find_epi8 no 4 no 4 no 4 --- no no no no find_epi32 no no no --- no no no no find_if find_if_epi8 no no no --- no no no no find_if_epi32 no no no --- no no no no is_sorted is_sorted_epi8 no no no --- no no no no is_sorted_epi32 no no no --- no no no no none_of none_of_epi8 no no no --- no no no no none_of_epi32 no no no --- no no no no remove remove_epi8 no no no --- no no no no remove_epi32 no no no --- no no no no remove_if remove_if_epi8 no no no --- no no no no remove_if_epi32 no no no --- no no no no replace replace_epi8 no no no --- no yes yes yes replace_epi32 no no no --- yes yes yes yes replace_if replace_if_epi8 no no no --- no yes no no replace_if_epi32 no no no --- yes yes no no reverse reverse_epi8 no 5 no 5 no 5 --- yes yes no no reverse_epi32 no 6 no 6 no 6 --- yes yes no no transform --- abs transform_abs_epi8 yes yes yes --- yes yes yes yes transform_abs_epi32 yes yes yes --- yes yes yes yes transform --- increment transform_inc_epi8 yes yes yes --- yes yes yes yes transform_inc_epi32 yes yes yes --- yes yes yes yes transform --- negation transform_neg_epi8 yes yes no --- yes yes yes yes transform_neg_epi32 yes yes no --- yes yes yes yes unique unique_epi8 no no no --- no no no no unique_epi32 no no no --- no no no no 1 SIMD instructions present, but not in the main loop 2 calls memset 3 emits rep stosd 4 calls memchr 5 calls ___std_reverse_trivially_swappable_1 6 calls ___std_reverse_trivially_swappable_4 Summary First of all, kudos to the MSVC team for bringing AVX512 to the Windows world. Unfortunately, there\'s no big progress in autovectorization. MSVC learnt only how to deal with a transform with negate operation. The MSVC optimizer correctly detected reverse algorithm and inserted calls to some already optimized library functions ___std_reverse_trivially_swappable_{1,4} . The set of algorithms MSVC can autovectorize is smaller than GCC & Clang can handle. Source code All implementations are available at github .'],
["notesen/2021-03-11-any-word-is-zero.html", 'How to check if any word is zero', 'How to check if any word is zero Wojciech Mua Added on 2021-03-11 Problem We want to check if at least one integer value is zero. In other words, we are evaluating following expression (for reasonably small N): For a three-argument expression GCC 10.2 produces (with -O3 switch) the following x86 code: Clang 11.0 generates almost identical code: ICC and MSVC added some jumps, but generally also use basic building block: test followed by a conditional set sete . Can we do better? It\'s possible with help of function min . Our initial condition can be rewritten as [...] The minimum of two numbers can be calculated on x86 with a branch-free code: When min gets more arguments, we simply repeat this code, accumulating the minimum value in a selected register. Finally, we have to compare it with zero. Hand-written code for the three arguments expression: But how compilers would compile this? GCC 10.2: Clang 11.0:'],
["notesen/2021-11-23-uint-to-ascii.html", 'Conversion uint32 into decimal without division nor multiplication', 'Conversion uint32 into decimal without division nor multiplication Wojciech Mua Added on 2021-11-23 Last update 2023-03-12 (moved from the repo) Introduction This is follow up to Daniel Lemire\'s Converting integers to fix-digit representations quickly . The method described here does not use multiplication nor division instructions. It relies only on addition and byte-level comparison. It\'s weird and slow, though. The main idea is to work directly on the BCD representation. First, we pre-calculate BCD images (16-byte arrays) for individual bytes of a 32-bit number. The following values are considered: 0x00 , 0x01 , ..., 0xff ; 0x0000 , 0x0100 , ..., 0xff00 ; 0x000000 , 0x010000 , ..., 0xff0000 ; 0x00000000 , 0x01000000 , ..., 0xff000000 ; Then, when converting a number, we fetch the BCD images and add them together. The next step of algorithm is fixing up the sum, as some bytes might be greater then 9. After this step all bytes are in range 0 .. 9. The last step is simple conversion into ASCII by adding ord(\'0\') = 0x30 . Sample scalar implementation is shown below. Example Let x = 20211121 = 0x13465b1 . We split the value into separate bytes 0xb1 , 0x65 , 0x34 and 0x01 . Then, for each byte, we fetch the appropriate BCD image: 0xb1 => [ 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 1| 7| 7] (177) 0x65 => [ 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 2| 5| 8| 5| 6] (101 * 256 = 25\'856) 0x34 => [ 0| 0| 0| 0| 0| 0| 0| 0| 0| 3| 4| 0| 7| 8| 7| 2] (52 * 65536 = 3\'407\'872) 0x01 => [ 0| 0| 0| 0| 0| 0| 0| 0| 1| 6| 7| 7| 7| 2| 1| 6] (1 * 16777216 = 16\'777\'216) This step requires six 64-bit loads. For byte #0 and byte #1 the higher 8 bytes of BCD image are always zero. For bytes #2 and #3 all 16 bytes of images are required. Once we have all the BCD images, we simply add them together. We have four inputs, where none of bytes exceed 9, thus it\'s safe to perform 64-bit additions. For our sample data we have: There are some bytes greater than 9, we need to fix them up: The carry value between bytes never exceeds 3. Since we have four inputs, then maximum value of byte at 0th position is 4*9 = 36. Any subsequent carry value cannot be greater than 3, as 4*9 + 3 is 39. This means that the carry value can be obtained with a series of comparisons. BCD addition Adding two BCD numbers, where each decimal digit occupies either a byte or nibble, can be done with single addition. However, fixing up the digits grater than 9 is non-trivial. The fix up step is needed, as a regular addition does not propagate the carry values between adjacent decimal digits. It would be perfect if we somehow forced such propagation across the whole input word. Good news is that\'s possible, although at cost of modifying input values and result. These modifications are easily SIMD-izable. Lets assume just two decimal digits a and b stored on a byte. We need to have a + b + carry = 0x1?? if the left-hand size sum is greater than 9 ( 0x0?? otherwise). We can achieve this by shifting one of the operands to the upper bound of byte range, so that exceeding 9 will result in carrying to the next byte. The following expression holds this property (see proof_single_digit.py in sources): At this point we have the result in form 0x1?? if the sum is greater than 9. We now want to obtain from the byte marked with ?? the desired digit, i.e.: digit = (a + b + carry) mod 10 . We need to consider two cases: If there was overflow, then the byte equals the digit: If there was no overflow, than the sum stored in the byte remain intact and we need to subtract the shift value: These two facts are hold for all possible values of a , b and carry (see proof_digit in sources). The whole calculations for a single pair of digits looks like this: The initial shifting (line 1) can be even done in SWAR. Getting back to BCD representation (lines 5 and 6) is easy to do with SIMD (in SWAR is feasible, too). Source code Sample implementation is available at GitHub .'],
["notesen/2021-12-22-test-and-clear-bit.html", 'Bit test and reset vs compilers', 'Bit test and reset vs compilers Wojciech Mua Added on 2021-12-22 Contents Problem Bit-test-and-reset Naive Alternative Inline asm Looping Testing MSB Avoiding jumps Additional info Problem The problem: there is a bitmask (16-, 32-, 64-bit). We need to scan it backward, starting from the most significant bit. We finish at the last set bit. For instance we scan bits from 15 to 11 in a 16-bit mask 0b1100\'1000\'0000\'0000 . Depending on the bit\'s value we perform different tasks. Since x86 has instruction BTR it was obvious for me that I should use the idiom bit-test-and-reset. Thus my initial code was straightforward. Function test_and_clear_bit wraps the BTR instruction. Below is an example how this function behaves. Bit-test-and-reset Naive As I didn\'t like to use inline asm , I wrote a plain C++ function. And asserted that the instruction introduced in 1986 with 80386 CPU is already well known to compilers. To my surprise GCC compiled the procedure into: Apart from some ABI-related stuff, the code is almost one-to-one translation of C++ code. The compiler emitted ANDN instruction, this is the optimization enabled by the target CPU supporting the BMI extension. There\'s no BTR instruction. Clang did it a bit better: However, BTR is used only to reset the bit. To read the bit\'s value the compiler emitted a separate instruction BT . Alternative Bit-test-and-reset can be also solved in the following way: reset i-th bit, if the new unsigned value of smaller than the input value it means i-th bit was 1. Now GCC and clang compiled the code into exactly the same code: However, it\'s still not perfect. BTR is used only to reset the bit, its outcome --- setting the carry flag --- is ignored. Thus we have an explicit compare ( CMP ). Inline asm For the sake of completeness, there\'s version uses inline asm. As a separate function it\'s not that short (due to ABI), when get inlined by a compiler, then it\'s reduced to 2-3 instructions. Looping Testing MSB Since we iterate over sequence of bits, I tried another approach: we test the most significant bit and shift left the mask in every iteration. Testing the MSB on x86 is done by checking if a signed number is negative. Shifting by 1 bit is performed by a cheap addition. The second version of algorithm is shown below. I didn\'t want to put actual code in the if-branches, and think that calls to external functions are more fair. Let\'s examine output from GCC: That look quite complicated. Is clang better? The conditional jump instructions are ordered differently. Yet the code complexity is similar to GCC output.: Avoiding jumps Since I decide to experiment with calls to external functions, it\'s worth to show a solution which avoids few conditional jumps. The solution uses a two-element table of function pointers. Below is the GCC output: And clang: Both compilers convert the MSB into 0 or 1 ( shr $0x3f, %reg ) and use it as an index to the indirect call instruction. Additional info Compilers: GCC: gcc version 10.2.1 20210108 (Debian 10.2.1-5) clang: Debian clang version 11.0.1-2 Compiler flags: -O3 , -march=skylake Source code is available .'],
["notesen/2022-01-17-validating-hex-parse.html", 'Parsing hex numbers with validation', 'Parsing hex numbers with validation Geoff Langdale Wojciech Mua Added on 2022-01-17 Last update 2022-01-29 Contents Introduction Algorithm #1 Algorithm #2 Algorithm #3 --- by Geoff Langdale Comparison Converting nibbles to binary value Sample code Introduction A non-validating parsing from hexadecimal string can be vectorized: Using SSE to convert from hexadecimal ASCII to number . This text shows two validating and vectorized approaches. Parsing algorithms convert 16-byte inputs. They consists two major parts: Validate and convert ASCII digits and letters into 4-bit values (value [0..15]) stored on separate bytes. Merge the 4-bit words into a continues 64-bit word. Below are the valid ASCII hexadecimal digits: 0 ... 9 --- 0x30 ... 0x31, a ... f --- 0x61 ... 0x66, A ... F --- 0x41 ... 0x46. We can note that: Valid characters have higher nibbles equal to 0x3, 0x4 or 0x6. Values of decimal digits equal to the lower nibble. Values of hex digits (above 9) equal to the lower nibble plus 9. Algorithm #1 This algorithm is a straightforward application of the above observations. The following scalar code shows the steps we perform: The vectorized algorithm #1. Sample input: \"0123456789aBcDeF\": Isolate the lower nibbles: Convert lower nibbles as they were decimal digits. If a nibble is not valid (above 9) set bit #7 to indicate error. Set also bit #6 to store the character class (constant digits ). Similarly, convert lower nibbles as they were hex letters. If a nibble is not valid (less than 1 or greater than 6) set bit #7 to indicate error. Set also bit #5 to store the character class (constant letters ). Classify ASCII characters based on the higher nibbles. Split bytes into three classes: decimal digits, hex letters, invalid. Keep only the decimal digits using the classification from point #4. Likewise, keep only the hex: letters using the classification from point #4. Check for errors: or together the converted characters and the classification. If the result vector has any 7th bit set, it means an error. Keep only lower nibbles. Reverse nibbles and join into a single 64-bit word --- see separate section . Algorithm #2 In this algorithm we change the validation rules. We use higher nibbles to fetch allowed ranges for lower nibbles. For decimal digits (higher nibble 0x3 ) the range is 0..9. For hex letters (hi nibble 0x40 or 0x60 ) the range is 1..6. Once we validated that the lower nibbles are correct, we have to add 9 to hex letters and keep decimal digits intact. The following observation lets to obtain the 9 quite easily: for hex letters the upper bound ( hi hereafter) is 6, for digits it is 9. The expression ~hi & 9 yields 9 for hi=6 and zero when hi=9 . This branchy algorithm illustrates the whole idea. The vectorized algorithm #2. Sample input. Get higher nibble. Get the lower bounds. Get the upper bounds. Validate lower nibbles against the ranges. Please note that SSE does not provide unsigned comparison, however in our case we use only lower nibbles, so never hit signed numbers. Keep only lower nibbles. Add 9 to hex letter, keep digits intact. Reverse nibbles and join into a single 64-bit word --- see separate section . Algorithm #3 --- by Geoff Langdale The Geoff\'s approach does not use PSHUFB , it is based on shifting number ranges. The algorithm works in two phases, separately converting the digits and hex letters. First, digits are shifted from range \'0\'..\'9\' to 0xf6..0xff and then 0xf0..0xf9. All other bytes --- above \'9\' and below \'0\' --- become smaller than 0xf0. After subtracting 0xf0, the ASCII digits are transformed into valid nibbles (0..9), while other values become greater than 0x0f. The second step converts the hex digits. At the very beginning, the ASCII letters are converted into upper case by resetting the 5th bit. Then, in a similar way as with the digits, we shift ASCII letters \'A\'..\'F\' into range 0..5. Any other bytes become bigger than 5. Then we adjust range 0..5 to 10..15, keeping the non-hex bytes greater than 0x0f. At this point we have the following possibilities: digits --- the result of step #1 is a valid nibble (0..9), the result of step #2 is greater than 0x0f. hex letters --- the result of step #1 is greater than 0xf0, the result of step #2 is a valid nibble (10..15). other --- results of both steps are greater than 0x0f. It is sufficient to find the minimum of both steps. If either step resulted in valid nibble it will be chosen. Otherwise, the minimum operation yields some byte greater than 0x0f. Thus, to detect errors we have only check if the result of minimum is greater than 0x0f. The vectorized algorithm #3. Move digits \'0\'..\'9\' into range 0xf6..0xff. And then correct the range to 0xf0..0xf9. All other bytes become less than 0xf0. Convert \'0\'..\'9\' into nibbles 0..9. Non-digit bytes become greater than 0x0f. Convert into uppercase \'a\'..\'f\' => \'A\'..\'F\'. Move hex letter \'A\'..\'F\' into range 0..5. And correct the range into 10..15. The non-hex letters bytes become greater than 0x0f. Finally choose the result: either valid nibble (0..9/10..15) or some byte greater than 0x0f. Detect errors, i.e. bytes greater than 15. As SSE does not provide an unsigned compare, we have to use a trick with the saturated add. Reverse nibbles and join into a single 64-bit word --- see separate section . Comparison The total number of instructions instruction algorithm #1 algorithm #2 algorithm #3 shift 1 1 -- pshufb 3 2 -- bit-and 7 3 1 bit-or 2 1 -- comparison 2 2 -- move mask 1 1 -- add/sub -- 1 6 min -- -- 1 sum 16 11 8 Converting nibbles to binary value After completing any of the above algorithms we have the following layout of 16 nibbles (from a to p ): The target is 64-bit word, where nibbles are reversed : What we need to do, is: 1) first put two from adjacent nibbles in a byte, and 2) store only bytes having proper nibble pairs. Joining adjacent nibbles can be easily done with shift, followed by bit-and and bit-or. A single instruction pmaddubsw can do that too. It multiplies two pairs of bytes, add the products and yield 16-bit words. Then we need to store only single bytes from 16-bit words in a 64-bit result word (the lower half of an SSE register). Below is a code snippet that shows constants for pmaddubsw and pshufb . Sample code Sample code is available. https://github.com/WojciechMula/toys/tree/master/simd-parse-hex'],
["notesen/2022-01-24-avx512vbmi2-varuint.html", 'AVX512VBMI2 and packed varuint format', 'AVX512VBMI2 and packed varuint format Wojciech Mua Added on 2022-01-24 Last update 2022-01-25 Contents Introduction Base variant AVX512VBMI2 variant Benchmarks Sample code Introduction A quite popular varuint format lets to save an arbitrary integer number on a sequence of bytes. Each byte stores seven bits of information, and the most significant bit indicates whether the given byte is the last one. Decoding such numbers is quite easy, but is not fast. This is the reason why Google came up with their packed varint format, that stores four numbers (from 1 to 4 byte each). In this format control bits and data bits are separated. The control bits are grouped into single byte: four pairs of bits encode lengths of four numbers. Handling this format is way easier and is vectorizable . The control byte is used to fetch a shuffle pattern, which is then issued to PSHUFB . Then, this single instruction expands 4-16 data bytes into sixteen 32-bit numbers. Details are shown in the next section. The packed format can be slightly modified to utilize the instruction VPEXPANDB defined in AVX512VBMI2. The instruction expands bytes according to an AVX512 write mask --- it\'s exactly what the packed varint format needs. Base variant The byte layout of a single packed varuint: A pack is saved on 5 to 17 bytes. The control byte is split into four 2-bit sub-words L{0,1,2,3} . A sub-word encodes the length of the corresponding number: 00 --- one byte, 01 --- two bytes, 10 --- three bytes and 11 --- four bytes. Below is shown a sample SSE implementation. It requires two 256-element auxiliary tables: 16-byte shuffle patterns, total number of bytes. An obvious drawback of the above code is that it may touch memory outside buf and output , but the key was simplicity not safety. As we see, the procedure is really simple. There are three fetches from memory (control byte, shuffle pattern and input length) and a single byte shuffle. AVX512VBMI2 variant In the SSE implementation we can handle up to 16 input bytes. The AVX512 gives us 64 bytes, thus a single pack can store sixteen 32-bit numbers. We keep the base format of control byte: 2-bit sub-words encode lengths. Since we handle 16 numbers, it means we need four control bytes. Thus the memory layout is as follows: To simplify encoding of the lengths we interleave pairs of lengths (nibbles) in the following way ( Lx is a 2-bit sub-word): Thanks to that we can easily expand nibbles. Having the nibbles separated, we can then convert them quickly with PSHUFB into a bitmask required by VPEXPANDB . The AVX512 decoding algorithm: Load control words. Expand nibbles into a 64-bit word. Convert lengths into a four-bit bitmask. For 1-byte numbers the bitmask is 0001 , for 2-byte numbers: 0011 , for 3-byte numbers: 0111 and for 4-byte numbers: 1111 . Since each byte of nibless contains two lengths, we convert both into an 8-bit bitmask with a single PSHUFB . Load data into AVX512 register. Convert packed bytes in sixteen 32-bit numbers. Yes, this is one instruction . Store the result and advance pointers. Please not the unlike the SSE variant, we obtain the number of consumed byte by a cheap population count on the mask . Benchmarks The benchmark utility from repository was used. It encodes the given count of 32-bit words into one of packed varint formats. Then decoding procedure decodes it 100 times into the same output array. CPU : Ice Lake Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz Compiler : GCC 10.3.1 20210422 (Red Hat 10.3.1-1) procedure input size [32-bit words] best cycles/op avg cycles/op SSE 100,000 2.785 2.800 AVX512VBMI2 100,000 1.044 1.079 SSE 1,000,000 2.792 2.808 AVX512VBMI2 1,000,000 1.059 1.077 SSE 10,000,000 2.857 2.875 AVX512VBMI2 10,000,000 1.330 1.385 Note that these procedures were not tuned in any way. I am sure there is room for improvement in the both implementations. The AVX512VBMI2 procedure is more than two times faster than the SSE version. Seems it should be rather close to 4 times, as the AVX512 routine processes four times more data. The AVX512VBMI2 format requires exactly the same number of bytes as the base variant. Sample code Sample code is available .'],
["notesen/2022-01-29-ddos.html", 'DDoS-ed by a service runs on AWS', 'DDoS-ed by a service runs on AWS Wojciech Mua Added on 2022-01-29 Every year in January I download the Apache logs for my home page. I run a simple script on the logs to see which articles were popular last year. Sometimes I\'m surprised that some old stuff is still being read. The script counts the total number of visits and the unique number of visitors. And this year something strange happened. Below is the head of list: The trend is clear --- a thousand visits is normal, few thousands is something very popular. But the top article got visited 600 thousands times! It was added on Hacker News , but never hit its main page (gained only ~30 upvotes). Below is a daily number of visits: For whole four days, every ~2 seconds, somebody performed HTTP GET on this very URL. I collected the IPs visiting the article. Almost all of the IPs are registered by Amazon Web Services . Below is the detailed histogram of visits per IP. An catching-eye pattern is that the number of visits is shared across groups of different IPs. Looks like somebody did a silly synchronisation mistake and let workers pick the same same job over and over. The end. :)'],
["notesen/2022-01-29-http-verb-parse.html", 'Fast parsing HTTP verbs', 'Fast parsing HTTP verbs Wojciech Mua Added on 2022-01-29 Contents Introduction Experiment results Skylake Skylake-X Source code Implementations Boost::beast approach Matching more characters at once 64-bit procedure 32-bit procedure 32-bit procedure (variant #2) Minimal perfect hashing function Introduction When we started to use boost::beast library at work, obviously I downloaded its source code. Can\'t say I am good at navigation across boost libraries, I was just opening random files waiting for compilation completion . My attention was caught by procedure string_to_verb , that translates a HTTP verb into a number, in fact an enum. The most common verbs are GET POST , PUT and DELETE , however in total there are 33 verbs, the longest ones have 12 characters. Why the boost implementation seemed to me to be odd? It\'s basically a hardcoded Trie . There is the main switch statement that selects a subtree based on the first character . Then: When there is exactly one verb starting with given letter, just equality of the suffix is checked. For example \"BIND\" or \"TRACE\" are handled like this. When more words start with the same letter but they don\'t share any prefix --- there\'s a plain ladder of if checking equality of the suffix. For example pairs of verbs \"LINK\" and \"LOCK\" or \"SEARCH\" and \"SUBSCRIBE\" are matched in this way. Otherwise, there are more switches resolving the subsequent letters. This is how a group of verbs \"PATCH\", \"POST\", \"PROPFIND\", \"PROPPATCH\", \"PURGE\" and \"PUT\" is matched. This looks like a lot of branches and we do know that branches might be a source of performance problems. A mispredicted branch penalty is several CPU cycles. I thought it would be good to check if other solutions would be better. The first solution is to match not a single letter prefix, but take into account four or eight characters at time. It costs exactly one load and comparison. The only drawback is padding with zeros strings shorter than 4 chars. Since the set of verbs is small and given statically, we may build a minimal perfect hash function (MPH). GNU gperf can be used to generate a C++ program implementing a MPH. The major drawback of gperf is that it generates function \"exists\", while we need a \"lookup\". I had to manually edit the generated program. Experiment results Experiment setup. We generate predefined number of random HTTP verbs. Verbs are either selected from the whole set of 33 verbs, or from subset GET / POST / PUT . Then a procedure is called given number of times and the total time is noted. We tested five procedures: original boost::beast ; SWAR64 --- match string in 8-byte chunks; SWAR32 --- match string in 4-byte chunks; SWAR32v2 --- match string in 4-byte chunks, with a fast path for strings not longer than 4 bytes; MPH --- minimal perfect hash function . Summary: When we match random HTTP verbs, then --- as it was supposed --- the branchy boost::beast algorithm is slower due to penalties. However, when the limited set of verbs is matched, the boost::beast procedure is the fastest one. Minimal perfect hash function shines! It\'s pity that gperf cannot generate \"lookup\" style functions out of the box. Skylake CPU : Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz compiler : gcc version 8.4.0 (Ubuntu 8.4.0-1ubuntu1~16.04.1) All HTTP verbs procedure input size iterations time [us] boost::beast 100 10000 2956 SWAR64 100 10000 6922 SWAR32 100 10000 7200 SWAR32v2 100 10000 7024 MPH 100 10000 5464 boost::beast 1000 1000 9315 SWAR64 1000 1000 7932 SWAR32 1000 1000 8834 SWAR32v2 1000 1000 9485 MPH 1000 1000 10352 boost::beast 10000 100 16457 SWAR64 10000 100 21809 SWAR32 10000 100 23204 SWAR32 10000 100 21766 MPH 10000 100 11089 GET/POST/PUT verbs procedure input size iterations time [us] boost::beast 100 10000 3334 SWAR64 100 10000 7321 SWAR32 100 10000 6502 SWAR32v2 100 10000 6421 MPH 100 10000 7891 boost::beast 1000 1000 5839 SWAR64 1000 1000 8820 SWAR32 1000 1000 8899 SWAR32v2 1000 1000 10027 MPH 1000 1000 7531 boost::beast 10000 100 8339 SWAR64 10000 100 14289 SWAR32 10000 100 13722 SWAR32v2 10000 100 12117 MPH 10000 100 7498 Skylake-X CPU : Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz compiler : gcc version 8.4.0 (Ubuntu 8.4.0-1ubuntu1~16.04.1) All HTTP verbs procedure input size iterations time [us] boost::beast 100 10000 9466 SWAR64 100 10000 16286 SWAR32 100 10000 9970 SWAR32v2 100 10000 8432 MPH 100 10000 6956 boost::beast 1000 1000 24203 SWAR64 1000 1000 13758 SWAR32 1000 1000 17132 SWAR32v2 1000 1000 11872 MPH 1000 1000 12606 boost::beast 10000 100 31449 SWAR64 10000 100 25088 SWAR32 10000 100 26211 SWAR32v2 10000 100 25921 MPH 10000 100 13683 GET/POST/PUT verbs procedure input size iterations time [us] boost::beast 100 10000 3579 SWAR64 100 10000 8458 SWAR32 100 10000 7687 SWAR32v2 100 10000 7713 MPH 100 10000 9542 boost::beast 1000 1000 6940 SWAR64 1000 1000 12876 SWAR32 1000 1000 11868 SWAR32v2 1000 1000 11431 MPH 1000 1000 9194 boost::beast 10000 100 10500 SWAR64 10000 100 16237 SWAR32 10000 100 15809 SWAR32v2 10000 100 14582 MPH 10000 100 9134 Source code All implementations are available at github . Implementations Boost::beast approach This is a verbose copy of boost::beast code. Matching more characters at once 64-bit procedure Below is a procedure that matches 8-byte prefixes. 32-bit procedure Below is a procedure that matches 4-byte prefixes. Another 32-bit variant 32-bit procedure (variant #2) This is a slightly modified 32-bit procedure. It separately matches strings shorts string (0..4 bytes) and longer ones. Minimal perfect hashing function Below is MPH implementation manually adjusted to return the value assigned to given key, not only the information whether key is valid or not.'],
["notesen/2022-01-31-faster-hack.html", 'Faster hack', 'Faster hack Wojciech Mua Added on 2022-01-31 The other day I came across the following line: My first reaction was \"WTF\", but later I realized that such a hackish code has to be a response to poor compiler optimizations. And taking into account that the code might be quite old, this is a perfect solution. Only a bit unreadable. In fact we have something like len * coefficient(type) > 4 , where coefficient is a value from the set {1, 2, 4, 8}. I want to show that this problem can be solved not only cleaner but also faster. First, let\'s examine the compiler output for the original expression. We assume both variables are unsigned integers. And the output from gcc -O3 -march=skylake -s ; GCC version is 10.2.1.: It\'s worth to note that the compiler knows that for type >= 14 , we always fetch the value \"11124811248484\"[0] - \'0\' that equals one. Thus, jumps instantly to the comparison. Optimization #1 We may omit subtraction of constant \'0\' , if we don\'t use ASCII digits, but hex strings. Maybe for older compiler we need to use octal digits. Either way, we avoid a subtraction. The assembly code: Optimization #2 We removed one instruction. Can we do it better? The comparison type < 14 cannot be avoided,b ut the constants are {1, 2, 4, 8}. All are powers of two, thus we can replace the multiplication with a binary shift left just by adjusting the constants. The assembly code: Since we are targeting the Skylake, it was possible to use the instruction SHLX from the BMI extensions. The instruction performs shift left, but does not alter the CPU flags register. By not doing this, it does not create any indirect dependencies between instructions. Optimization #3 Seems we reached the end? Not really. We are calculating four cases: Remembering that len is an unsigned integer, we may rewrite the expressions: We just figured out the minimum value of len for which the expression len * coefficient > 4 is true. As a result, we may get rid of multiplication/shift. The compiler output: Conclusions: All in all, the trick with subscripting a string is neat. This is what a compiler may do underneath for switch statements, but it is not guaranteed. Clang uses conditional moves instead of jumps.'],
["notesen/2023-01-06-avx512-popcount-4bit.html", 'AVX512: histogram of sixteen nibbles', 'AVX512: histogram of sixteen nibbles Wojciech Mua Added on 2023-01-06 Contents Introduction AVX-512 counting nibbles in 64-bit words Converting nibbles Source code Introduction At Sneller we had the following problem: there are sixteen 4-bit values, we need a histogram for that limited set. Since the input set has the fixed size of 64 bits, the problem is not that difficult as a generic case. The basic problem we solve is counting how many nibbles are present in the given 64-bit set. Then, the solution to the initial problem is performing the basic step for each possible nibble value. And it\'s is done in parallel. AVX-512 counting nibbles in 64-bit words We obviously might expand 4-bit words into bytes, and then use the byte-level comparison (like VPCMPEQB ). But expansion is not very fast. A better solution works at the nibble level. The input is the following 16-element set x : First we populate the wanted nibble in a 64-bit word. Let the nibble is 0xb ; it\'s present in the x word 5 times. Next, we XOR the input word with constant one: The 0 nibble indicates the nibble is equal to b . Now our goal is to convert 0 nibbles into 1, and non-zero nibbles into 0. The exact procedure is shown in the next subsection. The next step is to add nibbles together. Since we\'re targeting AVX-512, we may use VPSADBW that adds bytes in 64-bit lanes. Note that bytes in word t1 are only: 0x00, 0x01, 0x10, 0x11. If we add eight bytes having these values, there won\'t be overflow. We get a byte whose nibbles are sum of nibbles (0 or 1) from the input.: The final step is to add the nibbles from the lowest byte. Note that the t2 as uint64 is never bigger than 0x88 , thus we may freely use 32-bit or 64-bit arithmetic instructions.: Note: if the extension AVX-512VPOPCNTDQ is available, the steps #4 and #5 fold into a single invocation of VPOPCNTQ . The full AVX-512 solution uses two pairs of registers: One pair contains the broadcast input word. Another pair contains 64-bit words filled with nibbles from 0 to f Then the counting algorithm is performed on these registers. The final pair of registers contains the required histogram. Converting nibbles The following algorithm can be applied to bitfields of any size; here we focus on nibbles. The initial nibbles (examples show just two cases: zero and non-zero): Mask out the most significant bits of nibbles: Add 0b0111 to each nibble. If any lower bit -- 0, 1 or 2 -- was set, the carry bit from addition will appear the 3rd bit. Combine 3rd bits of nibbles from the initial word with the addition result. Now the 3rd bit is set if any bit of the nibble was 1. Leave only the 3rd bit and negate it. Note that the AVX-512 ternary logic instruction ( VPTERNLOG ) is sufficient to evaluate expression t4 = ~(t2 | t1) & 0b1000_1000 . Finally, we have to convert 0b1000 into 0b1111 and keep 0b0000 intact. Simple shift right by 3 does the job: Source code Sample implementation is available at GitHub .'],
["notesen/2023-01-19-avx512-consts.html", 'AVX512: generating constants', 'AVX512: generating constants Wojciech Mua Added on 2023-01-19 Updated on 2023-02-02 Contents Introduction Integer constants Zero (0x00000000) All ones (0xffffffff) All decimal ones (0x00000001, 0x00010001, 0x01010101) Powers of two (0x2, 0x4, 0x8, ...) Decimal numbers (from 0 to 32) Bit-mask 0x80808080 or 0x80008000 Bit-masks: span of ones (like 0b00111000) Bit-mask: span of zeros (like 0b11000111) Any bit-pattern Any bit-pattern --- byte level Any bit pattern --- GF2P8AFFINEQB Floating point constants 0.0 Integer values 90.0, 1.0, -1.0, +0.0, -0.0, 1/2, Pi/2, MAX_FLOAT, MIN_FLOAT Sample code Introduction AVX512 code often needs constants that repeat in 64-, 32-, 16- or 8-bit lanes. Instead of pre-computing such constants as whole 64-byte arrays, we can reduce memory consumption by using explicit or implicit broadcasts. While broadcasts have high throughput, their latencies are quite high. According to uops.info , latencies are 5 cycles (on Skylake-X, Cannon Lake, Ice Lake, Adler Lake-P) when broadcasting from either a 32-bit or 64-bit register. When the source is memory location, latencies are even higher. When an AVX512 procedure is quite short, or often loads different constants from memory, broadcast latencies might become visible. To overcome this problem, we might compute some values using few cheap instructions. We can quickly fill an AVX512 all zero bits (with XOR) or ones (with ternary log instruction) and then use shifts, bit operations and other instructions to construct desired value. This article show some ways to calculate different simple constants. Examples are focused mostly on 32-bit values, although in most cases we might generalize the methods to other lane widths. Integer constants Zero (0x00000000) A well known zeroing idiom: All ones (0xffffffff) Ternary logic with immediate 255: All decimal ones (0x00000001, 0x00010001, 0x01010101) The word 0xffffffff interpreted as a signed number is -1. AVX512 provides instruction to calculate an absolute value, thus getting 1 is straightforward: Powers of two (0x2, 0x4, 0x8, ...) Starting from 0x00000001 , we may use left shift with a constant to produce 1 << 1 , 1 << 2 , 1 << 3 up to 1 << 31 . Decimal numbers (from 0 to 32) We start from 0xffffffff and then shift it right by the number n we want to get. The result is a word having n zeros followed by 32-n ones. Then we may use VPLZCNTD to count the leading zeros of word. In our case it will be exactly n . A sample program for n=17: In a similar way we may utilize VPOPCNTD , but this instruction is not widely available yet. Bit-mask 0x80808080 or 0x80008000 We start with two words 0xffffffff and 0x00000000 . Then we use either the instruction AVGB or AVGW . Both calculate expression [...] When x = 0xff and y = 0x00, then x + y + 1 = 0x100 , and finally 0x100 / 2 = 0x80 . Sample program for bytes: As Wunk & Harold Aptroot showed, this constant can be generated by the expression AVG(x, ~x) for any x . Bit-masks: span of ones (like 0b00111000) Starting from 0xffffffff , we may obtain any bit-mask in form 00..0011..11 by shifting the word right. Likewise, a bit-mask in form 11..1100..00 by shifting the word left. When we need a mask in form 00..0011..1100..00 , then two shift are required. The first one produces a mask 00..0011..11 with the wanted number of ones. The second shift left moves the ones to the desired position. For example a bit-mask with 11 bits that starts at the 3rd bit can be constructed with the following program: Bit-mask: span of zeros (like 0b11000111) We starting from 0xffffffff , and we will use two instructions: shift left and rotate left The shift produces as many zeros at the word\'s beginning as we want. The rotation places the string of zeros at the desired position. For example a bit-mask with 7 zeros that starts at the 14 bit can be constructed with the following program: Any bit-pattern Any bit pattern can be generated with a sequence of shifts and rotates. The algorithm to construct a program for the given constant works as follows. Convert the constant into its binary representation. Initialize a register with 0xffffffff . Starting from the most significant bits consider spans of bits of the same value. When a span contains zeros, then use shift left on the register. When a span contains ones, then use rotate left on the register. The number of shifts equals the number of spans, thus this method is suitable for a limited set of constants. Let\'s analyse algorithm for constant 0x00ff1f01. Its binary representation is 0b00000000111111110001111100000001. Our program starts with VPTERNLOGD $0xff, Z1, Z1, Z1 . The first span of zero bits contains 8 bits. Thus the next instruction is shift left by 8. Then there\'s 8-bit span of ones. Thus we\'re issuing rotate left by 8. Next we have three zeros -- it\'s shift left by 3. Then five ones equal to rotate left by 5. Next seven zeros yields a shift left by 7. And finally sole one is generated by rotate by 1 bit. The full assembly program is shown below: Any bit-pattern --- byte level When a 32-bit pattern contains a repeated byte, like 0xdddddddd , we may use the generic method to build the zero-th byte, i.e. 0xffffffdd . Then we populate the byte with PSHUFB , as indices are zeros (and we know how to get them). A sample program: Any bit pattern --- GF2P8AFFINEQB InstLatX64 showed in 2020, that the instruction GF2P8AFFINEQB (Galois Field Affine Transformation) can be used to broadcast any compile-time 8-bit constant. Floating point constants 0.0 Since binary representation of float32(0.0) is 0x00000000 , it\'s sufficient to use VPXOR . Integer values Obviously, we may first obtain an integer value, and then convert it into a floating point number, using for instance VCVTDQ2PS . 90.0, 1.0, -1.0, +0.0, -0.0, 1/2, Pi/2, MAX_FLOAT, MIN_FLOAT Instruction VFIXUPIMMPS can be used to generate the following constants: 90.0, 1.0, -1.0, +0.0, -0.0, 1/2, Pi/2, MAX_FLOAT , MIN_FLOAT . Downside of this instruction is high latency. The instruction works in two steps. It first classifies the input numbers into eight classes: QNaN/SNaN, zero, one, +/- infinity, positive number, negative number. Then, the class is used to fetch a single nibble from the second argument; the nibble encodes what to do with given value. The nibbles in range 0..6 transform the input number; for instance negate it, thanks to that we can calculate absolute value. The nibbles in range 7..15 force writing one of the listed constants: -0.0 --- nibble=7: +0.0 --- nibble=8: -1.0 --- nibble=9: +1.0 --- nibble=0xa: [...] 90.0 --- nibble=0xc: [...] MAX_FLOAT --- nibble=0xe: MIN_FLOAT --- nibble=0xf: Sample code Sample programs are available on Github .'],
["notesen/2023-01-21-avx512-any-eq.html", 'AVX512: check if value belongs to a set', 'AVX512: check if value belongs to a set Wojciech Mua Added on 2023-01-21 Introduction We want to check if a value belongs to a set. More formally, we want to evaluate the following expression: (x == word_0) or (x == word_1) or ... or (x == word_n) , where x is a vector of words, and word_i is a constant vector. For a four-element set, a naive version of AVX512 assembly code: The above code tests a vector register Z1 against const values stored in an array pointed by AX , and sets result in kreg K1 . The tool uICA reports the following timings (for Skylake-X): Another approach Using the de Morgan\'s Law we may rewrite the expression (x == word_0) or (x == word_1) or ... or (x == word_n) into not ((x != word_0) and ... and (x != word_n)) . Then, we can use the fact that the AVX512 masked comparison performs operation mask and (comparison result) . Compared with the naive version, we get rid of most explicit k-reg operations. However, the performance of the snippet is not better than the naive version. We only decrease the number of upos by 2, that might have impact on the overall performance. uICA results: Result in a vector register This approach produces the result in a vector register. We use fact that the bit-xor of two values yields 0 if both values are equal, and a non-zero result otherwise. Then, we may convert any non-zero value into 1 by using expression min(xor-result, 1) . This requires an extra register with preloaded 1. uICA results:'],
["notesen/2023-01-31-avx512-bsf.html", 'AVX512: count trailing zeros', 'AVX512: count trailing zeros Wojciech Mua Added on 2023-01-31 Updated on 2023-02-02 (better method by Harold Aptroot & InstLatX64 ) Contents Introduction Trailing zeros counting with population count Trailing zeros --- simplified Trailing zeros counting with bits reverse Source code Introduction AVX512 lacks of counting trailing zeros ; it supports counting of leading zeros via instruction VPLZCNTD in 32- and 64-bit words. There is the scalar instruction BSF (Bit Scan Forward). To recall how counting the leading zeros is supposed to work, let\'s see sample 32-bit word: An obvious solution would be reversing bits in a word and then use the VPLZCNT instruction. Source code for this approach is shown in a following section. Basically, with PSHUFB we can reverse order of bytes. Then, with two additional invocations of that instruction, we swap order of bits within bytes. However, a solution which is really clever uses population count ; it is explained in the next section. Trailing zeros counting with population count The core observation: when we subtract 1 from a non-zero number, then the least significant bit is reset, but all leading zeros are turning into ones. Let\'s see an example. That\'s our initial word: After subtracting one it becomes: If we count bits in the initial word and in the word after subtraction, we can derive the number of leading zeros. Initial population count is increased by one and by leading bits count. More formally: initial popcount + 1 + leading bits count = popcount after subtraction 1 . There\'s one special case when the initial word is zero. VPLZCNT defines that for zero, the result is 32 or 64 (depending on the lane width). In this approach we simply do not add 1. The only problem with this approach is that VPOPCNT instruction is available when a CPU supports AVX512_BITALG and AVX512_VL extensions. Sample implementation in Go asm: Trailing zeros --- simplified A better method by Harold Aptroot && InstLatX64 --- we use the following identity: ~x & (x - 1) . The x - 1 term sets to one the bits before the first bit. But the bit and with negation of word resets the bits above the first bit. Initial word: Then ~x & (x - 1) : Now we may use population count, that gives the answer instantly. Alternatively we may use expression 32 - VPLZCNT(...) . Sample implementation in Go asm: Trailing zeros counting with bits reverse Sample implementation in Go asm: Source code Sample source code is available on Github'],
["notesen/2023-02-05-float-to-ratio.html", 'Converting binary fraction to ratio', 'Converting binary fraction to ratio Wojciech Mua Added on 2023-02-05 Introduction Suppose we have a binary fraction, that is positive and less than 1: We want to express it as a ratio of two integer numbers. Algorithm The value of the sample number is: We want to add these fractions, and to do this we have to find the common denominator. In our case it will be the product of all denominators we have: [...] Note that the exponent is simply sum of positions (counted from 1) of bits equal 1. The numerator has the sum of four products; each product contains all but single power: [...] It is simpler to express products using the denominator\'s power: [...] Finally, we need to reduce the fraction. To do this, we simply find the minimum exponent from the numerator (it is 9) and subtract it from all powers of two present in the fraction. Thus finally we have: [...] [...] [...] [...] The algorithm uses only simple arithmetic and bit operations. Sample code Sample source code is available on Github .'],
["notesen/2023-02-05-fraction-pow.html", 'Faster fractional exponents', 'Faster fractional exponents Wojciech Mua Added on 2023-02-05 Contents Introduction Float to fraction Evaluation Sample code Introduction A well known method of calculating powers of integers is based on the binary representation of an exponent. Let\'s consider a simple example. Exponent equals y = 9 = 0b1001 ; its value can be expressed as [...] [...] [...] [...] The main observation is that the product contains [...] An algorithm utilizing this observation is quite simple: Exactly the same schema can be used if an exponent is fractional; for simplicity let\'s assume the exponent is positive and less than 1. We also use binary representation of fraction, we just need to remember that weights of bits are fractions: [...] The algorithm is almost identical: we scan bits starting from the most significant one --- bit weights are decreasing by factor 1/2. Value [...] a square root . Let\'s assume that we have a fraction expressed as a uint64 , where the decimal dot is before the most significant bit. For instance fraction [...] uint64 : In the next section we will see how to convert a normalized float into that representation. The algorithm is: Float to fraction A normalized 64-bit floating point value has the bit following layout: Biased exponent spans 11 bits and significand spans 52 bits. The significand has implicit 1 at 53rd position. We assume only positive floats less than 1. The algorithm to convert such number into a fraction goes as follows. Get the float64 as raw bits. Then extract the significand bits. Complete the significand with the implicit 1. The integer value can be interpreted as [...] Extract the exponent value; the bias equals 1023. The exponent will always be negative. Adjust the fraction. We first shift left fraction by 11 bits left; we do it to place the most significant bit at bit #63. Then we shift right by -exp - 1 . Why : [...] [...] [...] [...] Evaluation The square root function is a native instruction SQRTSD on x86 CPUs, and compilers emit this instruction. Here is a part of objdump of powfracaux function: The problem with SQRT instruction is its hight latency. And the latency is the major issue here, as we have dependencies between iterations. It\'s not possible to calculate SQRT independently, even the hardware is capable of doing this. Latency for the instruction varies from 13 to 19 cycles; while latency for multiplication is 4 cycles. The timings are the same for Skylake-X, Cannon Lake, Ice Lake and Adler Lake-P. The number of square root calculation equals the number of significant bits in the fraction --- in the case of 64-bit floats, this is 53 max. Below are benchmark results, comparing the default Go math.Pow with implementation of the algorithm. The benchmarks were run on an Ice Lake machine with Go 1.20. As we can observe, the complexity of Go algorithm is not value-sensitive. The linear algorithm wins for a quite small set of numbers. Only approx [...] However, detecting if the linear algorithm can be used is cheap. It costs counting of trailing zero bits and a single comparison. Sample code Sample source code is available on Github .'],
["notesen/2023-02-05-tree-lca.html", 'Finding lowest common ancestor of two nodes', 'Finding lowest common ancestor of two nodes Wojciech Mua Added on 2023-02-05 Content Introduction Algorithm Time analysis Sample code Introduction There are several approaches to find lowest common ancestor (LCA). The algorithm showed here does not need extra memory. There\'s an assumption that we can get the parent node of given node in constant time. Algorithm The main idea is to first move node pointers to the same depth . When the nodes are at the same level, then finding their LCA requires just moving both pointers upwards until they meet. For instance, if we want to find the LCM of nodes L and E , we first move the pointer to L until it reaches level of E --- it\'s node F . Then we move both pointers upwards and they meet at B which is LCM(L, E). Algorithm: Time analysis Let h be maximum depth of the input nodes. To find node\'s depth we need to traverse the tree from the node to the root; it\'s done twice (lines 1 and 2). Then we move one of node pointers up in the tree (lines 3-11). The maximum number of iterations in the for loops (lines 4-6 and lines 8-19) equals to h . The final while-loop (lines 12-15) also may iterate up to h times. Thus the asymptotic complexity is O(h) . The exact numbers of parent invocations: Best case --- one of nodes is the root: line 1: h , line 2: 0 , lines 4-6: h , lines 8-10: 0 , lines 12-15: 0 , total: 2*h . Worst case --- the LCA of nodes is the root; assume their depths is the same: line 1: h , line 2: h , lines 4-6: 0 , lines 8-10: 0 , lines 12-15: 2 * h , total: 4*h . Sample code Sample source code is available on Github .'],
["notesen/2023-02-06-avx512-find-first-byte-in-lane.html", 'AVX512: finding first byte in lanes', 'AVX512: finding first byte in lanes Wojciech Mua Added on 2023-02-06 Introduction The problem is defined as follows: we have separate lanes (32-bit or 64-bit) and want to find the position of the first occurrence of the given byte in each lane. For example, when we look for byte 0xaa in 32-bit lanes: The result should be a vector of uint32 = {1, 0, 3, 4, ...} . With AVX512 an obvious solution would be producing a bitmask from byte-level comparison and then doing some permutations to convert parts of bitmasks into 32-bit values. While it\'s feasible, I want to show a method that uses trick from my previous article AVX512: count trailing zeros . Algorithm In the first step we XOR lanes with lanes having the byte populated. Bytes equal 0 denotes presence of 0xaa , and non-zero bytes any other value. Then, we convert non-zero values into 1, using unsigned min(byte, 1) function; zeros remain intact: The next step is simple negation of result. This is achieved with bit xor instruction: Now we can apply the counting trailing zero procedure. First, we subtract uint32(1) : Then we can clear upper bits by bit-and the last vector ( t4 ) with the initial one ( t3 ): We are almost done. With VPLZCNTD we count number of leading zeros in each lane: The last step is to divide the result by 8 (by shifting right) and subtract it from 4: [...] Source code Sample source code is available on Github'],
["notesen/2023-03-06-swar-find-any.html", 'SWAR find any byte from set', 'SWAR find any byte from set Wojciech Mua Added on 2023-03-06 Contents Introduction Faster SWAR procedure Comparison Reference implementation Faster SWAR procedure Benchmark results Summary Source code Introduction When I was browsing the source code of project Ada ( WHATWG-compliant and fast URL parser written in modern C++ ) the following procedure caught my attention: The above procedure finds the position of the first occurrence of a char from the set @ , / , ? and / . It returns the length of input string if nothing was found. The procedure uses SWAR techniques: it processes several bytes at once, taking advantage on the current CPUs architecture that process 64-bit values. The procedure implementation comes from src/helpers.cpp , and more function from that file follow exactly the same SWAR approach. These two functions are crucial: has_zero_byte is non-zero if a multi-byte word has at least one zero byte; note that the procedure also keeps only the most significant bits. index_of_first_set_byte returns the index of first non-zero byte; it uses the fact it is called on word formed with bytes 0x00 and 0x80. The pattern used is quite straightforward. If we bit-xor input bytes with a word filled with one of bytes from set, then the result has zero byte if the byte was there. We check then if it least one result of bit-xor has zero-byte and if it is true, we\'re looking for its position. While the production code processes multi-word inputs, let\'s focus on a basic building block that processes a single 64-bit word. The following assembly is produced by GCC 12.2.0 from Debian for the IceLake Server architecture ( gcc -O3 -march=icelake-server ). The assembly contains: 11 x constants, 6 x xor, 6 x and, 4 x add, 3 x or, 1 x multiplication ( imul ), 1 x shift right, 1 x branch. Faster SWAR procedure While the approach used by Ada library is universal and can be used for locating any byte, there\'s faster method that can be used with the set contains only ASCII chars, i.e. bytes that do not have set the 7th bit. The set @ , / , ? and \\\\ falls into this category. In this approach we pretend that the input is 7-bit. If the input has any 8-bit byte (for instance UTF-8 characters) we\'ll fix up wrongly detected bytes at the end. We also use bit-xor to produce zero bytes for matching bytes. However, we then convert the result into a bit. The result of bit-xor can be zero or non zero ( x - bit 0 or 1, but at least one is 1): If we add 0x7f = 0b0111_1111 then the result is: We can see that the most significant bit expresses relation \"byte is not zero\". Let\'s review the basic algorithm steps, that use the above observation. Input 8-byte string is a\\\\xc0@b?c : And we\'re looking for \'@\' = 0x40 : Xor input and mask: Mask MSB from input: Add 0x7f to locate non-zero bytes. Note that two bytes were found, but the first one is not valid.: At this point, MSBs equal zero denote byte position. To fix up the result we bit-or the t2 with input. If input byte has MSB set, it will discard wrong results.: Now, we keep only MSBs: Negate the MSBs --- ones would point found positions. As we can see, now we have exactly one non-zero byte: To find the position of byte we simply looking for first bit set and divide result by 8. The above algorithm was used to code the fully functional procedure. The following assembly is produced by GCC 12.2.0 from Debian for the IceLake Server architecture ( gcc -O3 -march=icelake-server ). The assembly contains: 6 x constants, 5 x xor, 5 x and, 4 x add, 1 x or, 1 x count trailing zeros, 1 x shift right, 1 x condition move. Comparison Reference implementation Since the reference assembly contains the jump instruction, I rewrote it to: For the above procedure uICA give the following analysis. Faster SWAR procedure uICA output: Benchmark results Microbenchmarks run on an IceLake machine: Summary The throughput reported by uICA for the faster procedure is 8.25 cycles, for original code 13.19 cycles. In theory, we may expected 1.5x speedup of the procedure, but in practice it\'s not that significant. Source code Sample source code is available on Github'],
["notesen/2023-04-09-faster-parse-ipv4.html", 'SIMD-ized faster parse of IPv4 addresses', 'SIMD-ized faster parse of IPv4 addresses Wojciech Mua Added on 2023-04-09 Contents Introduction SIMD improvements SIMD validation and preprocessing Selecting parsing schema Hash functions Number conversions and validation Scalar conversions Sequential conversion Unrolled conversion Unrolled conversion (group by input length) SIMD conversion Selecting procedure Conversion of 1-digit numbers Conversion of 1- and 2-digit numbers Conversion of 1-, 2- and 3-digit numbers Benchmarks Tested procedures Results from SkyLake machine Results from IceLake machine Source Appendix Appendix A --- the Go source Appendix B --- the Glibc source Introduction Just for recap, an IPv4 address written in the textual form consists four decimal numbers separated by the dot character. Each number represents an octet (byte), that is in range from 0 to 255. Here are some examples: \"10.1.1.12\", \"127.0.0.1\", \"255.255.255.0\". An IPv4 address is stored in the big-endian byte order . Parsing IPv4 addresses seems to be a trivial task. For example, the Go builtin module netip implements parsing with full validation in 35 lines. The inet_pton specialisation for IPv4 addresses, that can be found in Glibc , spans approx 40 lines of plain C code. For completeness, their full sources were put in appendix . These two procedures share the same schema of parsing and validation: Read the input string byte by byte. When the current byte is an ASCII digit (\'0\' ... \'9\') add it to the current octet. If the octet value becomes larger than 255 or the leading zero was detected, then report an error. When the current byte is the dot (\'.\'), check if we read at least one digit. If not, it\'s an error (for example \".1.1.20\" or \"192..0.12\"). When the current byte is not a digit or the dot, report an error. At the very end, check if exactly four octets were read. I bet 99.999% of ever written IPv4 parsers use similar schema. And that is pretty hard to see any obvious inefficiency in this approach. Additionally, when we take into account that compilers are getting smarter and smarter, we may assume that a compiler would do a decent job for us. However, it\'s possible to make the conversion faster, using SIMD instructions . The best solution is two-three times faster than a reference scalar procedure. The actual C++ code snippets with SSE instructions are used to illustrate solution. Full source code is available . They include a SWAR implementation and also different SSE variants. SIMD improvements Since SIMD instructions process many bytes in parallel, we can approach the parsing problem from a slightly different direction. First we load all the data. Since a valid IPv4 string contains from 7 to 15 bytes, such string fits in a single 16-byte SSE register. Then, we can quickly validate all bytes at once. As the first substep, we determine positions of the decimal dots (\'.\', hex code 0x2e ). There have to be exactly three dots, so this trait may be used to early filter out garbage inputs. As the second substep, we check if all remaining characters are digits (\'0\'...\'9\', hex codes from 0x30 to 0x39 ). The positions of dots determine the further parsing. Moreover, not all positions all valid: the decimal numbers have to span from 1 to 3 digits. Our goal is to transform the position of dots into \"something\" that can be an input to the subsequent step --- actual number conversion. The last step is conversion of numeric fields, with additional validation regarding their ranges: numbers cannot excess the byte range (0..255, for example \"1.2.300.4\". We need also to reject fields with leading zeros (like \"01.2.3.4\"). Conversion can be done by a scalar or SIMD code. Both variants are shown in this article. With the help of SIMD instructions we may quickly get a 15-bit mask, where each 1 denotes the dot, and 0 a digit byte. The following table shows all 81 valid patterns. Valid dot patterns length in bytes # of patterns masks (binary) masks (hex) 7 1 0101010 002a 8 4 01001010 , 01010100 , 00101010 , 01010010 004a , 0054 , 002a , 0052 9 10 001001010 , 010101000 , 001010010 , 010010100 , 010010010 , 001010100 , 000101010 , 010001010 , 010100100 , 010100010 004a , 00a8 , 0052 , 0094 , 0092 , 0054 , 002a , 008a , 00a4 , 00a2 10 16 0100010010 , 0100010100 , 0100100100 , 0010100100 , 0010010010 , 0010100010 , 0010010100 , 0001001010 , 0100101000 , 0101001000 , 0010001010 , 0001010010 , 0010101000 , 0001010100 , 0100100010 , 0101000100 0112 , 0114 , 0124 , 00a4 , 0092 , 00a2 , 0094 , 004a , 0128 , 0148 , 008a , 0052 , 00a8 , 0054 , 0122 , 0144 11 19 00010001010 , 01010001000 , 01000100010 , 00010010010 , 00100100100 , 00100010100 , 00010100010 , 01000100100 , 00100010010 , 00101001000 , 01000101000 , 00100100010 , 01001000100 , 00100101000 , 00010010100 , 01001001000 , 00010100100 , 00101000100 , 00010101000 008a , 0288 , 0222 , 0092 , 0124 , 0114 , 00a2 , 0224 , 0112 , 0148 , 0228 , 0122 , 0244 , 0128 , 0094 , 0248 , 00a4 , 0144 , 00a8 12 16 001000100100 , 010010001000 , 010001001000 , 000100100100 , 000101000100 , 000100010100 , 000100101000 , 001001000100 , 001000100010 , 010001000100 , 000100010010 , 001010001000 , 001001001000 , 001000101000 , 000101001000 , 000100100010 0224 , 0488 , 0448 , 0124 , 0144 , 0114 , 0128 , 0244 , 0222 , 0444 , 0112 , 0288 , 0248 , 0228 , 0148 , 0122 13 10 0001001000100 , 0010010001000 , 0010001001000 , 0100010001000 , 0001010001000 , 0010001000100 , 0001001001000 , 0001000100100 , 0001000100010 , 0001000101000 0244 , 0488 , 0448 , 0888 , 0288 , 0444 , 0248 , 0224 , 0222 , 0228 14 4 00010001000100 , 00100010001000 , 00010010001000 , 00010001001000 0444 , 0888 , 0488 , 0448 15 1 000100010001000 0888 total 81 SIMD validation and preprocessing In the first step we reject inputs that are too short or too long. Next, we load the input string into an SSE register. In the following code there\'s the assumption we can read past the end of string. In the terms of C++, we assume s.capacity() >= 16 . In the real-world applications it\'s not always hold, thus we need to use a masked load. An address \"195.42.3.0\", having 10 bytes, has the following byte layout in an SSE register: Then we locate the dots. Please note that we have garbage bytes past the string end, thus there\'s need to have a bitmask for valid positions. At this point we can count the number of dots (using cheap POPCNT ). Yet, that is not necessary, as the wrong dot-patterns can be detected later. It depends on the method we choose for the dot mask processing. Now, we check if all other bytes are ASCII digits. It requires just one SIMD subtraction and compare. Selecting parsing schema There are different ways the dot bitmask can be used to select the parsing path. The first, and quite obvious solution, is to sequentially scan the bitmask. Finding the first bit set is a cheap instruction ( TZCNT ). We set artificial 1 after the last field, thanks to that we use the same code to handle all four fields. The number of digits has to be in range 1 to 3, otherwise the input is wrong. This schema can be applied literally, and is shown in details the section Scalar conversion . We iterate over fields, read the number of digits and use code specialised to convert and validate the given number of digits. It is better, as we do not have to deal with numbers of an unknown length. We may do it faster, by selecting specialised conversion of four fields, in other words unroll the loop described earlier for given lengths of fields. As we learned, there are only 81 different length combinations to consider. For example, the address \"123.45.6.7\" has to be converted by code path that would parse-and-validate 3-digit number, 2-digit number and two single digits. The only remaining issue is how to get the id/address of conversion path from the dot bitmask. We have a number of possibilities: The four numbers of field digits can be seen as a number in the base of 3. We may sequentially calculate [...] [...] An easier way is to treat the lengths as digits of a number in the base 4. It means that we simply store the lengths as two-bit subfields of an eight-bit number. In other words map a bitmask into 256 distinct values, with spare slots (for any [...] We may treat the dot bitmask as a natural number. The maximum value then is either 2184, but with three repetitions (due to three possible lengths of the last field). If we want to get unique numbers, we have to either add 1 after the last field, or combine bitmask with a 4-bit input length. Either way, that leads to max number ~30,000 --- it\'s too big to have reasonable lookup table. Thus we have the following possibilities: Hash the dot bitmask, so we end up with acceptable table size. A disadvantage is the additional cost of hash calculation. Relay on a compiler, by using the switch statement and enumerate all possible values. A compiler may use binary search , which is not that bad. However, the practice show that we can speed it significantly by pre-classifying the bitmasks by the input length . In other words, instead of a single switch we have nested ones, where the outer switch is on the input length. The common trait of these methods is that we do not have to check the number of dots. Such wrong patterns will not match anything. Hash functions There are two hashing functions that were designed during the research: A quite complex function, having the maximum value 137. This is the hash used by function \"SSE (v5)\". The simpler hash has maximum much bigger: 1228. This function is used by function \"SSE (v7)\". Number conversions and validation Scalar conversions In scalar conversion we do not take advantage of having data already in an SSE register However, we know upfront that all characters are valid and there are exactly three dots. Thus we have only to validate number ranges. Sequential conversion This is the procedure \"SSE\" from sample code. Before we start iterating over dots, we add artificial one to the dot bitmask, after the last character. Thanks to that we can handle all fields in exactly the same way. In the next step we repeat the code four times. In each iteration we find the position of the first 1 in the dot mask. It tells us how many digits we have to convert. This is the place where we do additional validation: we check if the number of digits is 1, 2 or 3. Depending on the number of digits we use a specialised code path. Each path converts a number, validate its range and update the output word accordingly. We let the compiler to do its best. In each step we also shift out the processed bits from the dot mask. Unrolled conversion While we can learn upfront what are widths of all fields , we utilize this fact. For each possible valid combination we pre-compute a specialised path that converts given combination of numbers. This is the procedure \"SSE (v2)\" from sample code. As in the previous solution, we add an artificial one to the dot mask, just after the last character. Convert from byte mask into 8-bit code. Although there are only 81 valid dot masks, they are stored as variable-length codes. We iterator over fields and encode their lengths on two bits, forming a byte. For our sample IPv4 \"195.42.3.0\" we have lengths [3, 2, 1, 1] and it\'s encoded as [0b11, 0b10, 0b01, 0b01] => 0b11100101 = 0xe5 . In parallel to code building, we validate if all fields have valid lengths (1, 2 or 3 chars). The next step is to use the code value to choose specialised converter. It\'s a huge switch generated by a program; here we show just a single case. Unrolled conversion (group by input length) The approach is almost exactly as the previous one. The only difference is in how we choose the parsing specialisation. We\'re doing that in two steps. First, we use the input length. This already limits the number of possibilities (see the table above). Next, we match the bitpattern as is, without any transcoding. This is the procedure \"SSE (v3)\" from sample code. Below is shown the part of switch that handles pattern [3, 2, 1, 1]. SIMD conversion Since the digit validation and dot-pattern generation is done by SIMD code, getting back to the scalar domain seems not to be optimal. We can use SIMD to perform full conversion. From the dot bitmask we determine how to layout the input bytes to make them processable by SIMD instructions. This is done by single PSHUFB , then we pick a proper procedure. Unlike the scalar unrolled code, we do not have to enumerate all 81 possibilities. We roughly classify an IPv4 address as: having only single-digit numbers (like \"1.2.3.4\"); having 1- and 2-digit numbers (like \"11.2.33.44\"); having 1-, 2- and 3-digit numbers (like: \"1.222.111.44\"). In fact we may enumerate eight classes (for instance: only 2-digit numbers, only 2- or 3-digit numbers), but it\'s not clear if such fragmentation has much sense. Using the maximum numeric field length is good enough. Selecting procedure A SIMD conversion procedure requires the following parameters: Pattern for the PSHUFB instruction --- to layout input in the format required by a conversion procedure. Procedure number --- a proper conversion procedure id (in practise maximum length of numeric field). The exact dot mask, that is compared with the current dot mask to filter out false negatives. These parameters fit in 20 bytes. When we express the dot mask as a base-3 number or hash function #1 , we may have a single array of parameters, having --- respectively --- 81 or 137 entries. Procedures \"SSE (v5)\" and \"SSE (v6)\" follow the pattern: However, when we use hash function #2 which max value is 1228, we use two tables. The first lookup encodes transition from the hash value into length pattern. It should be number from 0 to 80 plus one special value for \"not found\". The second table of size 82 has actual parameters. Procedure \"SSE (v7)\" follows the pattern: Conversion of 1-digit numbers In this case there\'s no need to validate anything, just pick the bytes from even indices. PSHUFB layouts the input digits in the lower 32-bit word of an SSE register and we simply copy them with single instruction. Conversion of 1- and 2-digit numbers In this case we have only to check if the 2-digit fields do not contain ASCII \'0\' on their most significant position. We lay digits in two 32-bit words. The lower one contains the most significant ASCII digits, or value 0 for 1-digit fields. The higher 32-bit word contains the least significant digits. Let\'s see how we would parse address \"12.3.45.6\". First, we split the input in the described way. The actual byte layout is: Next, compare the t1 vector with ASCII \'0\' (hex 0x30). We are interested only in the lowest 32-bit result. As the next step, we extract that lowest word from t2 . If it is not zero, that means there is at least one 2-digit field having the leading zero. Once we know the input is valid, we extract the lower 64 bits from t1 and get back to scalar code. There is simply too few data to use SIMD instructions for that. Finally, we convert the individual digits into actual values. We may freely multiply by 10 and add, as we will never get an overflow; the SWAR solution works fine. Conversion of 1-, 2- and 3-digit numbers In this case we split input into four sets of digits. Let\'s analyse parsing of \"127.45.6.222\". We split the input into four subwords: digits #0; digits #1 or zero for single-digit numbers; digits #2 or zero for 1- and 2-digit numbers; most significant ASCII digits of 2- and 3-digit numbers, 0 otherwise. The actual layout after PSHUFB : Check if any significant digit is ASCII \'0\'. We only use the results for odd bytes from the higher half of word t1 , thus masking with 0xAA00 . Convert from ASCII to digits. It\'s sufficient to subtract with saturation value 0x30 (ASCII \'0\'). Then, we calculate 10 * digit #1 + digit #0 in the lower half, and 100 * digit #2 . To do this, we use instruction PMADDUBSW that multiplies horizontally bytes and add adjacent results into 16-bit values. The multipliers for most significant digits from upper half are set to zero, thanks to that we do not need any extra masking. Now we have to combine these partial results. Simply shift right the t3 by 8 bytes (with PALIGNR ) and add with the original constant of t3 . The almost final result is stored in t4 on 16-bit values. We have to check if all are not greater than 255. It\'s done by a regular comparison. Finally, we need to convert from uint16 to uint8 . Since we know the values in t4 fit in a byte, pack with unsigned saturation is sufficient. Benchmarks As the baseline we selected the best result from scalar procedures: go , glibc and naive . Tested procedures Tested procedures procedure comment go A translation into C++ the Go procedure . glibc A C procedure from Glibc with a thin wrapping for C++. naive A from scratch implementation of sequential parsing, as described in introduction . naive (no validation) It converts only valid IPv4 addresses; used to estimate the lower bound of the naive implementation. SSE It uses the SIMD validation, and scalar sequential conversion . SSE (v2) It uses the SIMD validation, and unrolled scalar conversion with parsing schema based on a single switch. The switch statement takes lengths pattern encoded as an 8-bit values. SSE (v3) It uses the SIMD validation, and unrolled scalar conversion with parsing schema using nested switches. The outer switch uses the input length, nested switches are based on explicit dot mask values. SSE (v4) It uses both the SIMD validation, and SIMD number conversion with nested switches: the outer one uses the input length, nested ones are based on explicit dot mask values. SSE (v5) It uses both the SIMD validation, and SIMD number conversion with parsing schema selection using complex hash function SSE (v6) It uses both SIMD validation, and SIMD number conversion with parsing schema selection using base-3 numbers . SSE (v7) It uses both SIMD validation, and SIMD number conversion with parsing schema selection using simpler hash function . Results from SkyLake machine CPU Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz Compiler g++-9 (Ubuntu 9.3.0-10ubuntu2~16.04) 9.3.0 procedure best avg. speedup [cycles] [cycles] naive 79.962 80.001 0.97 glibc 77.893 78.201 1.00 go 85.522 85.918 0.91 naive (no validation) 48.328 48.458 1.61 SWAR 84.235 84.258 0.92 SSE 47.295 47.344 1.65 SSE (v2) 56.745 56.792 1.37 SSE (v3) 40.779 40.823 1.91 SSE (v4) 31.922 31.938 2.44 SSE (v5) 28.127 28.139 2.77 SSE (v6) 34.278 34.287 2.27 SSE (v7) 26.239 26.251 2.97 SSE (v8) 33.645 33.655 2.32 Results from IceLake machine CPU Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz Compiler gcc (GCC) 7.3.1 20180712 (Red Hat 7.3.1-14) procedure best avg. speedup [cycles] [cycles] naive 42.217 42.601 1.00 glibc 58.327 58.717 0.72 go 51.779 51.914 0.82 naive (no validation) 32.414 32.491 1.30 SWAR 54.670 54.718 0.77 SSE 28.496 28.550 1.48 SSE (v2) 38.016 38.108 1.11 SSE (v3) 23.586 23.711 1.79 SSE (v4) 16.716 16.778 2.53 SSE (v5) 19.385 19.438 2.18 SSE (v6) 25.097 25.129 1.68 SSE (v7) 17.041 17.110 2.48 SSE (v8) 23.761 23.793 1.78 Source All programs are available on Github . Appendix Appendix A --- the Go source Appendix B --- the Glibc source'],
["notesen/2023-04-30-lookup-in-strings.html", 'Modern perfect hashing for strings', 'Modern perfect hashing for strings Wojciech Mua Added on 2023-04-30 Updated on 2023-04-02 (grammar corrections) Contents Introduction PEXT recap Constructing perfect hashing function Open addressing Hash functions Splitting by input length Using the minimum number of bits Variable-length set of words Finding mask Loads Compile-time switches Experiments Input sets Input data Tested procedures Skylake timings Summary Sources Introduction Looking up in a static set of strings is a common problem we encounter when parsing any textual formats. Such sets are often keywords of a programming language or protocol. Parsing HTTP verbs appeared to be the fastest when we use a compile-time trie : a series of nested switch statements. I could not believe that a perfect hash function is not better, and that led to a novel hashing approach that is based on the instruction PEXT (Parallel Bits Extract). Briefly, when constructing a perfect hash function, we are looking for the smallest set of input bytes that can be then the input for some function combines them into a single value. The instruction PEXT allows to quickly construct any n-bit subword from a 64-bit word; the latency of the instruction is 3 CPU cycles on the current processors. This allows us to extend the schema for looking for the smallest subset of bits . This n-bit word is then the input for a function that translates the word into the desired value. Instead of something like: We have: Please note that depending on the strings set, the number of bytes read in both schemas can vary. It is not the rule that a bit-level hash function would touch fewer bytes than a byte-level hash function. Apart from the above hashing schema, this text describes also constructing a compile-time hash table and compile-time switch. All source codes are available. PEXT recap The instruction PEXT gets two arguments: the input word and the input mask. Bits from the input word for which the input mask is 1 are copied to the output. For example: Constructing perfect hashing function Short recap: A collision of hashes occurs when a hash function yields the same value for two different keys. A perfect hash function is a hash function that does not yield any collisions for the given set of keys. A minimal perfect hash function (MPH) is a perfect hash function that maps the keys into the range from 0 to N-1, where N is the number of keys. While minimal hash functions are hard to find, perfect hash functions are quite easy to compute. We will describe two methods: using open addressing, using the minimum number of bits. Open addressing When we build a generic hash table implementation, collisions are unavoidable. The most common solution to this problem is using some kind of container (a linked list or balanced tree) to keep all objects sharing the same hash value. A less common strategy is open addressing . We store values directly in the table. If there is a collision --- that is, the given index is already allocated --- we try another index. There are several approaches to pick a new index; it simply may be the next index (called linear probing ), but there are of course more sophisticated procedures (quadratic probing, double hashing, etc.). In our case, where we have a static set of strings, we use the simplest solution. Our goal is to find the minimum size of table ( N ) in which the number of collisions ( k ) is also the least possible, preferably without collisions. Input parameters are: 1) a set of strings and 2) hash function; to avoid calling the hash function over and over, we cache the hash value for each string. The main procedure is responsible for settings the maximum number of collisions; it starts from 1 and increases it until we succeeded. The number of collisions depends on the quality of hash function, but often it is just 2 or 3 collisions. The Go implementation of procedure is shown below. Then, for some range of table sizes, we check the actual number of collisions, and we report the minimum table size. Below is the implementation of a helper function. It checks the table size starting from the size of input set, up to its tenfold; the multiply of 10 appeared to be a quite good upper bound. Now, having the parameters N and k , we can finally write a procedure for lookup. The following C++ procedure lookups for one of Go keywords. First we have a call to hash1 on the input string. Its result is taken modulo 38 --- that is the value N found by the above algorithm. Likewise, the magic constant 2 is parameter k , and it is the number of collisions we have to handle. The lookup procedure contains two auxiliary tables of size N * k = 76 : one for strings and another for values; the not-found-value was set to -1. (Note that we can have a single array of structures, however it\'s hard to tell what\'s better for typically small arrays.) After getting the index idx we just run two times the following check: Please note that all parameters for hash table are known in compile time, thus a compiler can rid of division and apply additional optimizations. Below is the assembly code of the procedure, compiled for Skylake architecture with GCC 12.2.0. Hash functions Following hash functions were tested: hash1 --- sum of the first and last char multiplied by the string length; hash2 --- sum of the first and last char bit-xor\'ed with the string length; hash3 --- first, second and last characters combined with the string length: ((f << 8) | s) + l + (n * 0x111) ; hash_sum0 --- sum of all bytes; hash_sumN --- sum of all bytes plus the string length; hash_djb2 --- Berenstein\'s hash ; hash_sdb --- sdbm hash . Splitting by input length I observed that the string length is a decent discriminator: STL: map with string as key --- access speedup . In most cases we obtain the length of strings in constant time; for instance this C++ function simplifies to a few CPU instructions. Taking this into account, we first split the set of strings into the subsets of strings having the same length. These subsets are usually small. We can fine-tune looking up in these subsets independently. One common optimization that is present in sample code is using plain if-ladder of compares when a subset is small (has at most two or three elements). Additionally, working with same-length strings enables more low-level optimizations: The length of string is usually known in the compile-time. Thus, bound checks can be eliminated. Equality of two strings from a subset is simple memcmp , and this procedure may be further inlined and optimized by a compiler. Using the minimum number of bits Note : this method was inspired by the hashing procedure found in GNU gperf . The presented method requires input string to have the same lengths. We guaranteed that property by pre-classifying the input string by its length, as described in the previous section. gperf uses the following observation: not all input characters contribute to uniqueness of set. In most cases we may discard many input characters and such modified set still holds unique items. For instance, five-letter Go keywords are break , const , defer , and range . The last character is sufficient to distinguish them: In the case of six-letter keywords, we need two characters, as shown below. The letter \'t\' repeats at the last position, but the second character makes this set unique. The major problem is that we need to combine somehow these unique characters into a unique and relatively small value. gperf adds the characters after passing them through an auxiliary lookup table. Like: lookup[s[0]] + lookup[s[5]] . Similarly to discarding individual bytes, we may discard individual bits , ending up with a bitmask that can be used to extract significant bits. To do this, we use a very fast instruction PEXT . Before we dig into details, let us re-examine the examples. For five-letter Go keywords we have: And for six-letter ones: Thus, in the first case we need just 2 bits, and in the second bits only 3 bits. The 2-bit subset contains all possible values ( 00 , 01 , 11 , 10 ), while 3-bit subset is not full ( 001 , 101 , 011 , 111 , 110 ). A skeleton of C++ procedure that uses this approach is: Once we know which bits are significant, we need to find which bytes have to be loaded (1); a byte is the minimum amount of data we can transfer. As we can see, for five-letter keywords it is sufficient to load just one byte. But for six-letter keywords we need three bytes --- in practise it is still a single load, but done on an 32-bit entity. Then, we extract the bits using the instruction PEXT (2) --- these bits form an n-bit index . We need an auxiliary table(s) of size [...] hashing . We compare the input string with keyword (3) and if they equal, we return the associated value. This is a snippet from procedure for looking up the Go keywords: Variable-length set of words Having strings of the same length is not a strict requirement. We always can complete the past-end characters with some easy-to-compute values. The following values were tested during writing this text: zero (0x00), the first character, the last character, the input length, the first/last character combined with the input length. Depending on the chosen method and string set, the outcome differs. Including length and one of chars seems to help. However, pre-classifying inputs by their length appeared to be easier and faster, thus this topic is not covered here. Finding mask Finding the mask is surprisingly straightforward. We start with a full mask, and iterate over all bits. For each bit we unset it, and then we check if the set of masked bytes is still unique. If it\'s true, we keep that bit unset, otherwise revert the change. Below are shown two procedures that compute the mask. Loads As it was shown in examples above, often a single load is sufficient, as the significant bits fit in a 8-, 16-, 32-, or 64-bit word. However, sometimes more loads are needed. In the generic case we concatenate results of individual loads, forming a 32- or 64-bit word. Below is an example of such code, where we combine 8-bit and 16-bit input words into a single 32-bit word, which is the final argument to PEXT . Note that the we need only to concatenate values in runtime, the mask for PEXT is know in the compile-time. Another possibility is when we have exactly two loads and their masks do not collide, their bit-and result is zero. Then we can merge these two words; sample code for such case is shown below. Compile-time switches To complete the image, we present a better alternative to compile-time trie expansion. As the first step, the method splits input by the length. Then we compute switch expression for same-lengths strings; each subset is processed separately. Like in the trie approach, we use a single character to select further processing. But since we deal with subset of strings having the same sizes, we can pick a character at any index . We select an index that splits the subset into the greatest number of smaller subsets, ideally into single-element subsets (singletons). The process is repeated recursively, we need only to remember which indices were already used. For example, the six-letter keywords of Java , can be fully classified by the second character. Five-letter keywords are classified by the last character, but for one case (the letter \'t\') more tests are needed. Below is shown the corresponding fragment of lookup procedure. Experiments Input sets The input sets contains mostly keywords from programming languages. Input sets name number of words notes ada-pred 54 gperf tests ada-res 63 gperf tests ada 63 gperf tests adadefs 54 gperf tests c 32 gperf tests countries 192 English names of countries cplusplus 106 gperf tests cpp 47 gperf tests go 25 gpc 35 gperf tests irc 45 gperf tests java 47 gperf tests jscript 53 gperf tests modula 53 gperf tests modula2 40 gperf tests modula3 53 gperf tests pascal 36 gperf tests sneller 240 SQL keywords and some functions from Sneller snellerbuiltin 119 builtin functions from Sneller states 50 USA state names Input data The input words were repeated in random order to produce approx 1MB block of text, not counting the new line character. Keywords were mutated by changing a single letter (at random position) into a random character or digit. Chances that keyword is added intact were set to: 0%, 25%, 50% and 75%. This is what we call \"valid words density\". Tested procedures Tested procedures procedure comments pext PEXT-based, bit-level function split Compile-time switches hash1 Compile-time hash table with hash1 function hash2 Compile-time hash table with hash2 function hash3 Compile-time hash table with hash3 function hash_sum0 Compile-time hash table with hash_sum0 function hash_sumN Compile-time hash table with hash_sumN function hash_djb2 Compile-time hash table with hash_djb2 function hash_sdb Compile-time hash table with hash_sdb function Skylake timings CPU Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz Compiler g++-9 (Ubuntu 9.3.0-10ubuntu2~16.04) 9.3.0 The numbers are given in CPU cycles. valid words density procedure 0% speed-up 25% speed-up 50% speed-up 75% speed-up dataset ada pext 33.20 1.000 41.47 1.000 45.67 1.000 39.57 1.000 split 61.81 0.537 67.50 0.614 67.69 0.675 65.62 0.603 hash1 75.38 0.440 77.63 0.534 73.33 0.623 64.66 0.612 hash2 72.78 0.456 76.73 0.540 72.23 0.632 64.01 0.618 hash3 55.63 0.597 67.57 0.614 68.79 0.664 63.79 0.620 hash_sum0 47.63 0.697 60.64 0.684 69.10 0.661 69.96 0.566 hash_sumN 50.68 0.655 61.91 0.670 70.02 0.652 68.14 0.581 hash_sdb 39.91 0.832 50.90 0.815 61.03 0.748 56.61 0.699 hash_djb2 41.22 0.805 51.66 0.803 60.32 0.757 55.12 0.718 dataset ada-pred pext 37.41 1.000 45.55 1.000 46.60 1.000 41.09 1.000 split 63.65 0.588 68.54 0.665 66.71 0.699 62.59 0.657 hash1 87.09 0.430 88.23 0.516 84.02 0.555 70.16 0.586 hash2 88.20 0.424 89.78 0.507 79.61 0.585 70.49 0.583 hash3 64.07 0.584 64.80 0.703 60.81 0.766 49.78 0.825 hash_sum0 49.99 0.748 62.74 0.726 70.37 0.662 71.98 0.571 hash_sumN 52.95 0.706 64.19 0.710 75.90 0.614 74.72 0.550 hash_sdb 49.55 0.755 61.30 0.743 72.63 0.642 66.59 0.617 hash_djb2 46.79 0.800 58.65 0.777 66.92 0.696 64.21 0.640 dataset ada-res pext 33.28 1.000 41.21 1.000 45.13 1.000 39.77 1.000 split 65.65 0.507 71.41 0.577 67.72 0.666 69.91 0.569 hash1 74.25 0.448 76.05 0.542 73.33 0.615 62.88 0.632 hash2 73.24 0.454 78.54 0.525 72.33 0.624 65.06 0.611 hash3 54.56 0.610 66.09 0.623 69.05 0.654 62.02 0.641 hash_sum0 47.62 0.699 58.82 0.700 72.94 0.619 68.58 0.580 hash_sumN 50.34 0.661 63.12 0.653 70.00 0.645 65.14 0.610 hash_sdb 40.05 0.831 51.05 0.807 61.46 0.734 56.13 0.709 hash_djb2 41.53 0.801 52.13 0.790 60.56 0.745 56.34 0.706 dataset adadefs pext 37.85 1.000 45.68 1.000 46.70 1.000 41.30 1.000 split 62.59 0.605 67.59 0.676 67.50 0.692 63.26 0.653 hash1 90.23 0.419 91.55 0.499 82.56 0.566 72.14 0.573 hash2 85.91 0.441 86.50 0.528 82.34 0.567 67.33 0.613 hash3 66.51 0.569 67.66 0.675 58.06 0.804 52.81 0.782 hash_sum0 48.92 0.774 60.24 0.758 74.57 0.626 68.25 0.605 hash_sumN 53.62 0.706 66.31 0.689 73.98 0.631 78.04 0.529 hash_sdb 50.43 0.750 62.91 0.726 72.20 0.647 64.81 0.637 hash_djb2 45.90 0.824 58.03 0.787 69.26 0.674 62.68 0.659 dataset c pext 31.99 1.000 40.50 1.000 44.03 1.000 38.06 1.000 split 50.58 0.632 55.28 0.733 58.78 0.749 53.15 0.716 hash1 61.26 0.522 62.69 0.646 58.98 0.746 49.40 0.770 hash2 61.59 0.519 62.57 0.647 53.50 0.823 48.16 0.790 hash3 51.56 0.620 58.94 0.687 56.15 0.784 45.65 0.834 hash_sum0 50.07 0.639 62.08 0.652 69.28 0.635 67.87 0.561 hash_sumN 45.62 0.701 58.30 0.695 66.23 0.665 61.98 0.614 hash_sdb 42.02 0.761 52.80 0.767 61.86 0.712 52.40 0.726 hash_djb2 40.45 0.791 51.62 0.784 58.87 0.748 55.34 0.688 dataset countries pext 36.51 1.000 45.13 1.000 47.62 1.000 41.73 1.000 split 97.77 0.373 103.25 0.437 102.72 0.464 94.96 0.439 hash1 132.88 0.275 129.03 0.350 116.18 0.410 100.02 0.417 hash2 129.50 0.282 126.89 0.356 118.28 0.403 99.82 0.418 hash3 92.53 0.395 97.42 0.463 88.54 0.538 79.79 0.523 hash_sum0 62.07 0.588 78.25 0.577 86.10 0.553 88.92 0.469 hash_sumN 63.41 0.576 80.48 0.561 84.76 0.562 89.56 0.466 hash_sdb 50.96 0.716 64.70 0.698 76.18 0.625 76.97 0.542 hash_djb2 63.47 0.575 74.61 0.605 87.23 0.546 86.02 0.485 dataset cplusplus pext 33.82 1.000 42.58 1.000 46.32 1.000 40.12 1.000 split 67.07 0.504 72.82 0.585 72.88 0.636 71.07 0.565 hash1 109.82 0.308 109.25 0.390 101.32 0.457 90.27 0.444 hash2 96.47 0.351 97.92 0.435 92.32 0.502 81.82 0.490 hash3 86.25 0.392 91.60 0.465 87.83 0.527 78.80 0.509 hash_sum0 51.95 0.651 66.86 0.637 76.79 0.603 80.85 0.496 hash_sumN 57.29 0.590 70.77 0.602 81.49 0.568 87.37 0.459 hash_sdb 44.25 0.764 56.91 0.748 67.76 0.684 59.27 0.677 hash_djb2 45.77 0.739 56.94 0.748 66.75 0.694 62.54 0.642 dataset cpp pext 31.13 1.000 39.15 1.000 43.77 1.000 37.27 1.000 split 60.01 0.519 64.33 0.609 61.03 0.717 61.17 0.609 hash1 79.09 0.394 80.43 0.487 79.58 0.550 64.79 0.575 hash2 77.41 0.402 79.82 0.490 71.89 0.609 64.33 0.579 hash3 52.87 0.589 58.08 0.674 54.88 0.798 45.60 0.817 hash_sum0 47.12 0.661 60.08 0.652 67.08 0.653 65.49 0.569 hash_sumN 48.65 0.640 62.08 0.631 68.92 0.635 67.31 0.554 hash_sdb 42.10 0.740 52.74 0.742 61.94 0.707 55.81 0.668 hash_djb2 40.41 0.770 50.86 0.770 58.90 0.743 55.69 0.669 dataset go pext 34.09 1.000 42.02 1.000 44.33 1.000 38.98 1.000 split 53.48 0.638 57.68 0.729 53.66 0.826 52.37 0.744 hash1 77.18 0.442 80.18 0.524 73.74 0.601 67.21 0.580 hash2 75.88 0.449 79.44 0.529 77.16 0.575 64.39 0.605 hash3 50.11 0.680 60.97 0.689 52.59 0.843 49.99 0.780 hash_sum0 45.55 0.748 55.76 0.754 64.22 0.690 59.05 0.660 hash_sumN 43.86 0.777 54.65 0.769 60.94 0.728 56.83 0.686 hash_sdb 44.85 0.760 56.65 0.742 65.52 0.677 55.36 0.704 hash_djb2 47.05 0.725 57.45 0.731 65.85 0.673 59.28 0.658 dataset gpc pext 31.63 1.000 39.37 1.000 43.57 1.000 37.99 1.000 split 54.04 0.585 58.34 0.675 60.28 0.723 55.08 0.690 hash1 67.64 0.468 77.23 0.510 77.72 0.561 67.73 0.561 hash2 56.41 0.561 61.56 0.640 55.65 0.783 49.95 0.761 hash3 36.41 0.869 51.94 0.758 53.33 0.817 44.76 0.849 hash_sum0 48.02 0.659 59.74 0.659 68.07 0.640 69.51 0.547 hash_sumN 48.15 0.657 59.59 0.661 67.78 0.643 64.33 0.591 hash_sdb 39.74 0.796 51.98 0.757 60.72 0.718 55.70 0.682 hash_djb2 45.31 0.698 56.10 0.702 62.26 0.700 56.72 0.670 dataset irc pext 30.92 1.000 39.45 1.000 43.61 1.000 35.90 1.000 split 61.98 0.499 66.63 0.592 67.25 0.649 63.39 0.566 hash1 91.91 0.336 91.33 0.432 84.69 0.515 75.90 0.473 hash2 73.70 0.420 76.54 0.515 75.02 0.581 61.11 0.587 hash3 49.63 0.623 58.92 0.670 50.82 0.858 46.29 0.776 hash_sum0 52.71 0.587 65.81 0.600 73.05 0.597 67.20 0.534 hash_sumN 57.54 0.537 71.23 0.554 75.28 0.579 70.94 0.506 hash_sdb 41.56 0.744 52.76 0.748 61.69 0.707 56.09 0.640 hash_djb2 41.20 0.751 52.06 0.758 62.05 0.703 56.49 0.636 dataset java pext 32.81 1.000 41.97 1.000 44.86 1.000 40.05 1.000 split 61.79 0.531 63.11 0.665 67.20 0.668 60.71 0.660 hash1 84.10 0.390 87.53 0.479 80.63 0.556 70.61 0.567 hash2 79.72 0.412 79.53 0.528 74.78 0.600 61.47 0.652 hash3 54.22 0.605 61.39 0.684 52.91 0.848 48.92 0.819 hash_sum0 50.32 0.652 64.39 0.652 73.70 0.609 79.53 0.504 hash_sumN 51.68 0.635 64.23 0.654 70.61 0.635 72.76 0.550 hash_sdb 43.18 0.760 55.42 0.757 64.60 0.694 57.78 0.693 hash_djb2 43.35 0.757 53.60 0.783 64.25 0.698 59.08 0.678 dataset jscript pext 32.62 1.000 41.07 1.000 45.48 1.000 39.26 1.000 split 55.46 0.588 60.59 0.678 63.60 0.715 57.62 0.681 hash1 76.26 0.428 78.06 0.526 76.60 0.594 63.68 0.617 hash2 74.21 0.440 75.27 0.546 67.39 0.675 60.76 0.646 hash3 53.13 0.614 60.49 0.679 57.44 0.792 49.12 0.799 hash_sum0 50.57 0.645 62.13 0.661 71.23 0.639 71.21 0.551 hash_sumN 53.58 0.609 64.87 0.633 76.94 0.591 76.87 0.511 hash_sdb 46.41 0.703 57.42 0.715 68.15 0.667 58.71 0.669 hash_djb2 44.39 0.735 54.69 0.751 63.35 0.718 59.26 0.663 dataset modula pext 32.74 1.000 40.76 1.000 45.30 1.000 39.60 1.000 split 60.07 0.545 64.43 0.633 63.79 0.710 61.26 0.646 hash1 69.22 0.473 71.27 0.572 66.81 0.678 58.11 0.682 hash2 71.44 0.458 76.04 0.536 71.22 0.636 62.85 0.630 hash3 43.89 0.746 56.34 0.723 51.91 0.873 45.92 0.862 hash_sum0 48.84 0.670 60.48 0.674 69.19 0.655 69.94 0.566 hash_sumN 50.78 0.645 61.46 0.663 70.09 0.646 70.17 0.564 hash_sdb 44.64 0.733 55.30 0.737 63.62 0.712 57.84 0.685 hash_djb2 42.33 0.773 52.38 0.778 61.94 0.731 56.49 0.701 dataset modula2 pext 31.87 1.000 40.22 1.000 44.70 1.000 38.37 1.000 split 58.01 0.549 62.07 0.648 57.86 0.773 58.33 0.658 hash1 69.44 0.459 74.37 0.541 67.05 0.667 60.74 0.632 hash2 69.66 0.458 78.43 0.513 77.69 0.575 65.48 0.586 hash3 41.98 0.759 56.11 0.717 51.12 0.874 47.33 0.811 hash_sum0 45.71 0.697 57.02 0.705 71.58 0.624 64.89 0.591 hash_sumN 53.05 0.601 63.66 0.632 74.12 0.603 68.24 0.562 hash_sdb 45.22 0.705 55.33 0.727 63.21 0.707 59.78 0.642 hash_djb2 40.88 0.780 51.74 0.777 61.84 0.723 56.80 0.676 dataset modula3 pext 32.15 1.000 40.28 1.000 45.30 1.000 39.02 1.000 split 56.67 0.567 61.46 0.655 63.68 0.711 58.65 0.665 hash1 70.24 0.458 73.43 0.549 70.79 0.640 60.96 0.640 hash2 71.59 0.449 76.39 0.527 69.77 0.649 63.72 0.612 hash3 43.70 0.736 56.68 0.711 55.22 0.820 46.28 0.843 hash_sum0 50.16 0.641 61.09 0.659 68.90 0.657 70.24 0.556 hash_sumN 50.20 0.640 61.30 0.657 69.35 0.653 69.73 0.560 hash_sdb 40.66 0.791 51.76 0.778 61.05 0.742 51.66 0.755 hash_djb2 40.96 0.785 51.04 0.789 59.26 0.764 56.20 0.694 dataset pascal pext 32.61 1.000 40.32 1.000 44.18 1.000 38.97 1.000 split 56.47 0.578 61.20 0.659 58.03 0.761 58.26 0.669 hash1 66.03 0.494 75.19 0.536 70.14 0.630 65.05 0.599 hash2 57.36 0.569 59.72 0.675 56.49 0.782 46.41 0.840 hash3 39.59 0.824 55.37 0.728 51.04 0.865 48.82 0.798 hash_sum0 42.79 0.762 52.50 0.768 59.01 0.749 54.74 0.712 hash_sumN 49.75 0.656 60.97 0.661 67.10 0.658 66.58 0.585 hash_sdb 45.78 0.712 56.05 0.719 63.83 0.692 56.62 0.688 hash_djb2 41.33 0.789 52.38 0.770 62.20 0.710 55.77 0.699 dataset sneller pext 36.32 1.000 45.18 1.000 48.15 1.000 41.59 1.000 split 84.98 0.427 91.96 0.491 91.27 0.528 85.14 0.489 hash1 111.37 0.326 109.84 0.411 101.95 0.472 87.03 0.478 hash2 107.71 0.337 108.25 0.417 99.64 0.483 84.69 0.491 hash3 85.25 0.426 91.38 0.494 86.67 0.556 76.52 0.543 hash_sum0 63.46 0.572 79.08 0.571 87.85 0.548 90.40 0.460 hash_sumN 68.17 0.533 81.57 0.554 90.65 0.531 92.30 0.451 hash_sdb 50.37 0.721 64.13 0.705 77.16 0.624 80.36 0.518 hash_djb2 67.26 0.540 80.46 0.562 92.01 0.523 94.85 0.438 dataset snellerbuiltin pext 39.24 1.000 47.75 1.000 49.16 1.000 43.15 1.000 split 67.34 0.583 72.82 0.656 70.72 0.695 70.04 0.616 hash1 118.59 0.331 116.16 0.411 109.08 0.451 89.63 0.481 hash2 123.17 0.319 120.14 0.397 105.14 0.468 90.62 0.476 hash3 105.75 0.371 109.16 0.437 102.81 0.478 87.78 0.492 hash_sum0 62.24 0.630 74.92 0.637 84.30 0.583 86.59 0.498 hash_sumN 59.27 0.662 70.96 0.673 82.69 0.594 81.20 0.531 hash_sdb 53.43 0.734 68.37 0.698 81.32 0.604 74.38 0.580 hash_djb2 59.08 0.664 72.51 0.658 83.62 0.588 86.05 0.501 dataset states pext 37.22 1.000 45.84 1.000 47.53 1.000 41.11 1.000 split 66.25 0.562 71.06 0.645 69.24 0.686 64.75 0.635 hash1 88.44 0.421 88.77 0.516 80.99 0.587 67.90 0.605 hash2 95.52 0.390 95.42 0.480 87.17 0.545 73.57 0.559 hash3 66.76 0.557 67.49 0.679 60.97 0.779 52.47 0.784 hash_sum0 48.00 0.775 62.88 0.729 69.39 0.685 64.14 0.641 hash_sumN 51.32 0.725 63.15 0.726 68.72 0.692 64.42 0.638 hash_sdb 45.26 0.822 59.31 0.773 71.25 0.667 60.47 0.680 hash_djb2 48.32 0.770 59.57 0.770 70.71 0.672 64.98 0.633 Summary The PEXT-based hash is the fastest. Fast hashesh ( hash1 , hash2 , hash3 ) indeed do not touch all input bytes, but their quality is poor, and as a result, performance is not good. Surprisingly, summing all input bytes is comparable to more complex djb2 or sdbm hashes. Sources All sources are available on Github: https://github.com/WojciechMula/toys/tree/master/lookup-in-string-set .'],
["notesen/2023-05-06-avx512-conflict-detection.html", 'AVX-512 conflict detection without resolving conflicts', 'AVX-512 conflict detection without resolving conflicts Wojciech Mua Added on 2023-05-06 Contents Introduction Core AVX-512 instructions Histogram Reference Intel algorithm Downsides of Intel approach Alternative algorithm Experiment results Source code Introduction One of the hardest problem in SIMD is dealing with non-continuous data accesses, that appear pretty common. Data structures based on indices, like graphs or trees, are a good example. CPU vendors introduced instructions GATHER and SCATTER to address these needs. A gather instruction builds a SIMD vector from N values loaded from N addresses. A scatter instruction stores N values from a SIMD vector at N addresses. Both instructions allow repeated indices. Repeated indices are the real issue if an algorithm uses the SCATTER --- that is, it either sets or updates values. Then we need to define how to handle repeated stores. To solve that particular problem AVX-512 introduced a complex instruction called conflict detection . The instruction builds a vector containing masks that mark repeated values in the input vector. Intel proposed a pattern that uses the gather, scatter and conflict detection instructions to efficiently handle repeated indices. It is described in the freely available \"Intel 64 and IA-32 Architectures Optimization Reference Manual\", in chapter \"18.16.1 Vectorization with Conflict Detection\". The problem of calculating a histogram is used there as an example. The core of Intel\'s approach is a conflict resolution loop in which the repeated values are aggregated into a single element. The number of iterations varies, and depends on data : it is 0 to 4, when we process 16-item vectors (32-bit elements). We propose a modified approach, that avoids any additional looping at the cost of additional storage. It is faster 1.4 times than the Intel algorithm when the input size is larger than 100,000 items. The text contains a recap of AVX-512 instructions, a detailed overview of the Intel algorithm, the presentation of our procedure, and evaluation results. All source codes are available. Core AVX-512 instructions Before we start, let\'s see how the crucial AVX-512 instructions are defined. We are focused on instruction variants processing 32-bit items; there are also 64-bit counterparts. GATHER --- vectorized load of N elements from given indices; its scalar implementation for 32-bit items is below. SCATTER --- vectorized store N elements at given indices. It is important that the hardware implementation performs stores in the order of items in the vector. For example if all indices are equal, the last, 15th value will be stored. CONFLICTDETECTION --- build N bitmasks, where each bitmask points out which previous elements are equal to the i-th element. The following example shows conflict detection for an 8-element vector. This procedure implements conflict detection for a 16-element vector. Histogram For the sake of completeness, there is a Go implementation of byte histogram procedure. We assume that input[i] < 256 . Reference Intel algorithm In this section we show the reference implementation of Intel solution for histogram computation. The implementation presented in the article is the Go . The assembly translation is available in sources . The main loop of the algorithm works as follows. First we load 16 indices. For simplicity we assume that we already have these bytes expanded into 32-bit values. In our example we have a set of only three values: {1, 22, 33} . Next, we perform the conflict detection on the loaded indices. The contents of conflicts is presented in binary. We initialize the increment vector to all decimal ones. If there are no conflicts, that is a ready to use increment value. When all words of conflict vector are zeros, it means there are no conflicts. We may skip a conflict resolution loop, and increment counters (step 5). But in our example there are repeated indices, thus we are entering the conflict resolution loop. The prerequisite to handle the repeated values is computing a permutation vector. The permutation vector contains the indices to the previous occurrence of the given element. The index is -1 when the i-th element is the first occurrence of a value. This calculation is possible with LZCNT (Leading Zeros Count) instruction. The previous index equals to 31 - LZCNT(conflicts[i]) ; if there is no conflict ( conflicts[i] = 0 ), then the result is -1. The next step is to set active elements. We are processing only the repeated items --- those having the previous element ( position[i] != -1 ). Initially, the active mask equals to the conflicts mask. We repeat this step until active mask is not zero. We use the position vector to pull previous values of indices to the vector conflicted , zeroing non-active elements (lines 1 and 2). Then we update only the active elements of increment (line 3) --- in our case it is a single, masked addition. Finally, we pull the previous positions of the position vector itself (line 4), and update active mask accordingly (lines 5 to 8). Let\'s see in details how these vectors change across iterations. Because the increment vector is full of ones, we named elements of this vector as i{index} . In the first iteration we have: After updating the increment vector (line 3) its content is: The permutation of position yields the following vector. Note that now we have twice as much -1 values. In the second iteration we have: After updating the increment vector (line 3) its content is: The permutation of position yields the following vector. In the third iteration we have: After updating the increment vector (line 3) its content is: The permutation of position yields the vector full of -1. This means active mask is zero, and we finished the conflict resolution. Before moving to the final step, let\'s look closer on increment collated with the input vector chunk . The last step is histogram update. First, we gather the counters for the bytes we loaded in the step 1 (line 1). Then, we update all counters with the increment vector calculated earlier (line 2). Finally, we scatter the updated values back (line 3). The real counts of repeated values are stored at position corresponding the last occurrence of given value. The vector newValues contains garbage for earlier occurrences of a repeated value. It is not a problem, as the scatter instruction guarantees that the value written to the memory will be the correct, last one. Note : due to high latency of the gather instructions, in the assembly code the gather instruction is issued before the conflict resolution loop. Here we put it closer just to make the algorithm more readable. Downsides of Intel approach The core algorithm has to be repeated twice -- in the conflict resolution loop and in the main loop. The histogram algorithm requires just a simple addition, thus that is not that visible. But when we need more operations, it becomes more significant. Likewise, when the algorithm needs more than one variable, then all variables have to be permuted in the same way we permute the increment vector. Unpredictable number of iterations. Underuse of available resources: in each iteration we process fewer and fewer items. The following table shows how many active elements were processed in the conflict resolution loop for various inputs. input characteristics all elements active elements active [%] constant value 40960 31360 76.56 random values from 0 to 3 31088 14754 47.46 random values from 0 to 14 19280 4888 25.35 random values from 0 to 63 9776 1155 11.81 random bytes 4000 294 7.35 Alternative algorithm The solution we propose completely rids of the conflict resolution loop. The key observation is that in a single iteration of the main loop we have up to 16 conflicts. Each input item might have assigned the unique repetition id (from 0 to 15) within the subset of the same values. By extending the algorithm state by the factor of 16, we can update without conflicts all values at once. While the original algorithm updates counters at indices chunk[i] , we update a sub-counters at chunk[i] * 16 + subbucket , where subbucket is a number from 0 to 15. After the main loop completes, we finalize computations by merging these sixteen sub-states into one. Let\'s look how this approach would assign subbucket numbers in our example input vector. The following Go code shows how the histogram problem can be solved with this new approach. Experiment results The assembler implementations of the Intel and new approach were tested using the standard Go benchmarking tool. Various inputs were tested: constant value, random values from 0 to 3, random values from 0 to 14, random values from 0 to 64, random bytes, all of above sorted. CPU: Xeon W-2104 Processor size [32-bit words] Intel algorithm [MB/s] Alternative algorithm [MB/s] Speedup constant value 1,024 860.61 227.23 0.26 5,120 869.37 656.92 0.76 10,240 870.25 861.90 0.99 102,400 867.46 1182.99 1.36 512,000 850.11 1221.05 1.44 1,048,576 849.96 1226.56 1.44 2,097,152 838.58 1206.70 1.44 5,242,880 786.06 1118.72 1.42 10,485,760 777.66 1117.22 1.44 sorted values from 0 to 3 1,024 860.67 227.21 0.26 5,120 869.26 657.08 0.76 10,240 870.47 861.83 0.99 102,400 866.41 1177.93 1.36 512,000 849.94 1220.74 1.44 1,048,576 849.05 1226.69 1.44 2,097,152 835.50 1200.06 1.44 5,242,880 784.94 1115.10 1.42 10,485,760 779.75 1114.16 1.43 sorted values from 0 to 14 1,024 860.75 227.22 0.26 5,120 869.33 657.22 0.76 10,240 862.62 849.14 0.98 102,400 868.60 1190.50 1.37 512,000 848.46 1219.15 1.44 1,048,576 850.39 1228.37 1.44 2,097,152 834.96 1198.63 1.44 5,242,880 782.96 1114.30 1.42 10,485,760 778.32 1112.89 1.43 sorted values from 0 to 63 1,024 860.72 227.22 0.26 5,120 869.31 641.37 0.74 10,240 870.51 861.93 0.99 102,400 863.03 1175.73 1.36 512,000 851.23 1224.23 1.44 1,048,576 851.38 1226.58 1.44 2,097,152 832.73 1194.05 1.43 5,242,880 782.41 1119.39 1.43 10,485,760 779.38 1112.67 1.43 sorted bytes 1,024 860.77 227.22 0.26 5,120 869.25 657.24 0.76 10,240 870.45 861.94 0.99 102,400 863.78 1180.33 1.37 512,000 849.81 1223.83 1.44 1,048,576 849.93 1225.23 1.44 2,097,152 831.93 1194.59 1.44 5,242,880 785.46 1116.25 1.42 10,485,760 778.15 1110.47 1.43 constant value 1,024 860.73 227.22 0.26 5,120 869.30 657.21 0.76 10,240 859.60 849.05 0.99 102,400 862.47 1180.54 1.37 512,000 849.13 1223.81 1.44 1,048,576 850.00 1227.04 1.44 2,097,152 835.06 1199.79 1.44 5,242,880 785.40 1117.14 1.42 10,485,760 779.17 1114.66 1.43 random values from 0 to 3 1,024 860.73 227.21 0.26 5,120 844.43 657.25 0.78 10,240 870.48 861.93 0.99 102,400 863.60 1180.64 1.37 512,000 850.54 1221.42 1.44 1,048,576 850.45 1227.06 1.44 2,097,152 834.29 1199.90 1.44 5,242,880 785.20 1117.01 1.42 10,485,760 777.80 1112.16 1.43 random values from 0 to 14 1,024 860.67 227.23 0.26 5,120 869.34 657.10 0.76 10,240 870.50 861.89 0.99 102,400 864.86 1182.81 1.37 512,000 846.93 1220.55 1.44 1,048,576 848.47 1227.36 1.45 2,097,152 834.09 1199.69 1.44 5,242,880 784.80 1118.62 1.43 10,485,760 779.74 1113.79 1.43 random values from 0 to 63 1,024 860.77 227.24 0.26 5,120 869.31 656.93 0.76 10,240 860.87 849.00 0.99 102,400 867.53 1182.82 1.36 512,000 849.01 1220.70 1.44 1,048,576 849.53 1226.27 1.44 2,097,152 832.92 1198.14 1.44 5,242,880 785.25 1116.44 1.42 10,485,760 779.28 1112.75 1.43 random bytes 1,024 860.73 227.21 0.26 5,120 869.36 641.30 0.74 10,240 860.29 861.87 1.00 102,400 868.43 1190.52 1.37 512,000 846.36 1223.07 1.45 1,048,576 849.26 1228.86 1.45 2,097,152 834.57 1198.15 1.44 5,242,880 786.23 1120.11 1.42 10,485,760 779.94 1116.79 1.43 Source code All sources are available on Github: https://github.com/WojciechMula/toys/tree/master/avx512-conflict-detection'],
["notesen/2023-11-20-popcount-suggestions.html", 'Simple suggestions using popcount', 'Simple suggestions using popcount Wojciech Mua Added on 2023-11-20 Contents Introduction Alternative approach Example Evaluation Git commands Python str methods Source Introduction One great feature that some of CLI applications and compilers recently gained is providing suggestions in the case of misspellings arguments or options. For instance, Python suggests possible method/fields names, like: If we want to include similar feature in our program, then a quite obvious solution is to use Levenshtein distance . Its basic implementation is simple and short. If we want suggestion for larger corpus, we may use tries to speedup matching --- see: Fast and Easy Levenshtein distance using a Trie by Steve Hanov . Despite that, I was curious if simpler algorithm would do the job. We may assume that our users know what they are doing. Their inputs will be sane, with an exception of minor mistakes. Like omitting a single letter, swapping two adjacent letters or maybe hitting a wrong key from time to time. The two additional assumptions I made: we search suggestions in small sets, and we use only ASCII letters (128 possible bytes). Alternative approach To estimate edit distance we use two histogram-based approaches: byte histogram --- exact histogram for each byte of a string, bit histogram --- mark in a bit-set which bytes from a string are present. In the first case, histogram takes 128 bytes. Similarity is calculated as the sum of absolute values. In the second case histogram uses 128 bits = 16 bytes. Similarity uses Hamming distance --- it is the number of 1 bits in the word calculated as a XOR of two corresponding words from histograms. Let\'s assume a valid word \"rebase\" (the git command). And a misspelled sample is \"revase\" --- the letter \'b\' got replaced with the \'v\'. The Levenshtein distance is 1. Example The byte histograms for the words are: The estimated distance is 2. Bit histograms are: The estimated distance is also 2. Evaluation The two sets of words were tested: git commands ( clone , init , add , mv , restore , rm , bisect , diff , grep , log , show , status , branch , commit , merge , rebase , reset , switch , tag , fetch , pull , push ), Python\'s str methods ( capitalize , casefold , center , count , encode , endswith , expandtabs , find , format , format_map , index , isalnum , isalpha , isascii , isdecimal , isdigit , isidentifier , islower , isnumeric , isprintable , isspace , istitle , isupper , join , ljust , lower , lstrip , maketrans , partition , removeprefix , removesuffix , replace , rfind , rindex , rjust , rpartition , rsplit , rstrip , split , splitlines , startswith , strip , swapcase , title , translate , upper , zfill ). Each word was taken and got modified in the following ways: remove i-th character, replace i-th with an ASCII letters, swap i-th and j-th characters, insert at i-th position an ASCII letter. A hit is defined as a suggestion that yields the original word. average hits set Levenshtein Byte histogram Bit histogram git commands 99.64% 98.05% 96.14% str methods 98.84% 95.32% 90.02% Git commands word cases Levenshtein Byte histogram Bit histogram misses hits misses hits misses hits clone 301 0 100.00% 0 100.00% 0 100.00% init 244 0 100.00% 0 100.00% 0 100.00% add 188 0 100.00% 2 98.94% 2 100.00% mv 133 1 99.25% 4 96.99% 4 100.00% restore 418 0 100.00% 26 93.78% 26 100.00% rm 133 5 96.24% 33 75.19% 33 76.69% bisect 359 0 100.00% 0 100.00% 0 100.00% diff 244 0 100.00% 3 98.77% 3 100.00% grep 244 0 100.00% 3 98.77% 3 97.95% log 188 0 100.00% 4 97.87% 4 97.87% show 244 0 100.00% 0 100.00% 0 100.00% status 359 0 100.00% 2 99.44% 2 100.00% branch 359 0 100.00% 0 100.00% 0 100.00% commit 359 0 100.00% 2 99.44% 2 100.00% merge 301 1 99.67% 62 79.40% 62 99.00% rebase 359 0 100.00% 4 98.89% 4 99.44% reset 301 1 99.67% 24 92.03% 24 94.35% switch 359 0 100.00% 9 97.49% 9 97.49% tag 188 3 98.40% 12 93.62% 12 96.81% fetch 301 0 100.00% 0 100.00% 0 100.00% pull 244 0 100.00% 4 98.36% 4 100.00% push 244 3 98.77% 10 95.90% 10 97.54% average: 99.64% average: 98.05% average: 96.14% Python str methods word cases Levenshtein Byte histogram Bit histogram misses hits misses hits misses hits capitalize 601 0 100.00% 0 100.00% 0 100.00% casefold 478 0 100.00% 0 100.00% 0 100.00% center 359 0 100.00% 0 100.00% 0 100.00% count 301 0 100.00% 4 98.67% 4 100.00% encode 359 0 100.00% 3 99.16% 3 99.44% endswith 478 0 100.00% 0 100.00% 0 100.00% expandtabs 601 0 100.00% 0 100.00% 0 100.00% find 244 0 100.00% 3 98.77% 3 98.77% format 359 0 100.00% 0 100.00% 0 100.00% format_map 601 0 100.00% 53 91.18% 53 100.00% index 301 0 100.00% 6 98.01% 6 99.34% isalnum 418 0 100.00% 0 100.00% 0 100.00% isalpha 418 0 100.00% 1 99.76% 1 100.00% isascii 418 0 100.00% 3 99.28% 3 100.00% isdecimal 539 0 100.00% 2 99.63% 2 100.00% isdigit 418 0 100.00% 0 100.00% 0 100.00% isidentifier 728 0 100.00% 4 99.45% 4 100.00% islower 418 0 100.00% 0 100.00% 0 100.00% isnumeric 539 0 100.00% 0 100.00% 0 100.00% isprintable 664 0 100.00% 0 100.00% 0 100.00% isspace 418 0 100.00% 54 87.08% 54 99.04% istitle 418 0 100.00% 31 92.58% 31 100.00% isupper 418 0 100.00% 6 98.56% 6 100.00% join 244 0 100.00% 4 98.36% 4 98.36% ljust 301 0 100.00% 6 98.01% 6 100.00% lower 301 2 99.34% 22 92.69% 22 92.69% lstrip 359 3 99.16% 60 83.29% 60 85.24% maketrans 539 0 100.00% 2 99.63% 2 100.00% partition 539 0 100.00% 0 100.00% 0 100.00% removeprefix 728 0 100.00% 2 99.73% 2 100.00% removesuffix 728 0 100.00% 2 99.73% 2 100.00% replace 418 0 100.00% 6 98.56% 6 100.00% rfind 301 33 89.04% 30 90.03% 30 90.03% rindex 359 34 90.53% 31 91.36% 31 91.92% rjust 301 33 89.04% 37 87.71% 37 87.71% rpartition 601 37 93.84% 601 0.00% 601 91.01% rsplit 359 4 98.89% 359 0.00% 359 0.00% rstrip 359 34 90.53% 27 92.48% 27 81.89% split 301 29 90.37% 74 75.42% 74 96.68% splitlines 601 0 100.00% 77 87.19% 77 100.00% startswith 601 0 100.00% 3 99.50% 3 100.00% strip 301 31 89.70% 301 0.00% 301 85.05% swapcase 478 0 100.00% 42 91.21% 42 99.37% title 301 3 99.00% 12 96.01% 12 92.03% translate 539 0 100.00% 7 98.70% 7 98.89% upper 301 2 99.34% 25 91.69% 25 92.69% zfill 301 0 100.00% 8 97.34% 8 100.00% average: 98.84% average: 95.32% average: 90.02% Source All programs are available on Github .'],
["notesen/2024-11-09-riscv-vector-extension.html", 'RISC-V Vector Extension overview', 'RISC-V Vector Extension overview Wojciech Mua Added on 2024-11-09 Contents Introduction The big picture Specification Data types Instruction encoding Register grouping (LMUL) Vector fractions (LMUL < 1) Stripmining (or dynamic vector length) Vstart register Masks Tail/mask agnostic/undisturbed policies Vector register size Vector instruction arguments Memory operations ABI Intrinsic functions ISA highlights Upcasting/downcasting vectors Reduction or horizontal instructions Mask instructions Vector iota Integer division Multi-word arithmetic Binary operations Integer multiply-add Vector slide Introduction The goal of this text is to provide an overview of RISC-V Vector extension ( RVV ), and compare --- when applicable --- with widespread SIMD vector instruction sets: SSE , AVX , AVX-512 , ARM Neon and SVE . The RISC-V architecture defines four basic modes (32-bit, 32-bit for embedded systems, 64-bit, 128-bit) and several extensions . For instance, the support for single precision floating-point numbers is added by the F extension. The vector extension is quite a huge addition. It adds 302 instructions plus four highly configurable load & store operations. The RVV instructions can be split into three groups: related to masks, integer operations, and floating-point operations. When a CPU does not support floating-point instructions, it still may provide the integer subset. RVV introduces 32 vector registers v0 , ..., v31 , a concept of mask (similar to AVX-512), and nine control registers. Unlike other SIMD ISAs, RVV does not explicitly define size of vector register. It is an implementation parameter (called VLEN ): the size has to be a power of two, but not greater than [...] an implementation parameter (called ELEN , also a power of two and not less than 8 bits). For example, a 32-bit CPU might not support vectors of 64-bit values. But generally, we may expect that a decent 64-bit CPU would support elements having 8, 16, 32 or 64-bit, interpreted as integers or floats. The big picture In this section we are discussing generic concepts of RVV. Specification The specification is given three-fold: There\'s a plain English document , describing RVV fundamentals as well as instructions. The document is sparse , and the instruction description is not very detailed, but... But the RISC-V ISA --- not only RVV! --- is described in SAIL, the language designed for ISAs specification. Its syntax resembles Rust, it is rather friendly. Yes, there is The Formal Specification . No more psuedo-code meaning whatever an author had in mind at the moment of writing. The RISC-V project provides also Spike , an ISA-level emulator. One can compile code with the favourite compiler and run the binary! The emulator is written in C++, and most instructions are defined with some helper macros. Although, it\'s quite easy to understand what the given opcode does, if it is needed. Spike is actively maintained and constantly gains support for more and more ISA extensions. Data types In the RVV integer operations accept 8-, 16-, 32- and 64-bit numbers, both signed and unsigned. This makes the ISA very regular --- the given operation is supported for all possible vector element types. A bright example are bit shifts, that in other SIMD ISAs usually exist for a limited sub-set of integer types. In particular, SSE, AVX and AVX-512 have no support for 8-bit shifts. Likewise, floating-point operations can be done on single precision (32 bits), double precision (64 bits), as well as half-precision numbers (16 bits). While integer instructions are mandatory, floating point support depends on core ISA extensions present in the given core (the F for single precision, D for double precision, and Zfh for half-precision). Instruction encoding A unique trait of RVV is encoding of instructions. An operation opcode does not encode the bit-width of a vector element. The element width is a global state . It is called selected element width (SEW), and the term SEW is used throughout the RVV specification. The SEW is set by the dedicated instruction vsetvl . The setting is applied to all subsequent instructions, until another vsetvl . (Fast forward: vsetvl sets also other aspects of vector processing.) Let\'s look at the dissasembled section of a simple program. The third parameter of vsetvli is SEW: e8 means 8 bits, e16 --- 16 bits, e32 --- 32 bits, and e64 --- 64 bits. The integer add operation ( vadd.vv ) is encoded exactly in the same way, as 0x02110057. This is completely different from the existing ISAs, that use separate encoding for each supported vector element width. However, in cases when we need to operate on different elements widths within a single procedure, we need to switch modes, which makes things a little more complex. It forces a compiler to track the current vector settings; the reality is that compilers targeting RVV have a separate pass inserting vsetvli . Register grouping (LMUL) The vector engine can be setup (using the mentioned vsetvl instruction) to use a group of registers instead of a single register. A similar solution exists in ARM SIMD ISAs. A group may contain 2, 4 or 8 registers; the group size is called LMUL . The combination of LMUL and VLEN yields the parameter VLENMAX . When LMUL > 1, then a program is allowed to use vector register having index of multiply of LMUL. For instance, if we use LMUL = 8 , then the allowed registers are only v0 , v8 , v16 and v24 , using anything else results in a trap (AKA exception). Without digging much into assembly details, this code: can be compacted into: Vector fractions (LMUL < 1) It is also possible to limit instructions to operate only on a fraction of register --- LMUL can be 1/2, 1/4 or 1/8. Similar solution is used for floating-point operations in SSE & AVX: an instruction operates either on the whole vector register (like ADDPS ) or only on the first element (like ADDSS ). It\'s important to note that not all fractions are valid. For example, when VLEN = 128 and SEW = 64 , then a single register can hold only two elements. Thus, it\'s impossible to use its 1/4 or 1/8. When the instruction vsetvli sets something which is not sane in the given implementation, then the bit vill of the control register vtype is set; then any subsequent vector operation results in a trap (AKA exception). Stripmining (or dynamic vector length) Let\'s start with the problem we have with current SIMD ISAs. The majority of (auto)vectorization of code is done on loops. When we have a loop like that: and we know that the target\'s ISA registers can hold K elements, the loop can be rewritten as: Because K is fixed, we have to add an extra processing of \"a tail\" to handle cases when n is not a multiple of K . This requires duplication of the body\'s loop. In our example the body is just a simple addition, but often things are way more complex. With AVX512 it might be solved in a more elegant way, by using the explicit mask applied for all operations . For the main loop the mask is full, just for the last iteration we limit the mask to the tail elements. While it\'s nicer, we still have some kind of tail processing, but present at a different layer of user code. The RVV solves that particular problem at the architecture level, allowing to tell the vector engine how many elements we\'re going to process. This number is called application vector length (AVL), and in our example it\'s the n parameter. A programmer feeds vsetvli with that number. The RVV implementation responses with the actual number of elements it will process. The response is called vector length ( VL ), it\'s a value from 0 to VLMAX . The VLMAX is the total number of elements , which is calculated as: register width ( VLEN ) times register multiplier ( LMUL ) divided by the element width ( SEW ). For example VLEN = 128 bits , LMUL = 4 and SEW = 32 bits , then the maximum length is VLMAX = 128 * 4 / 32 = 16 elements. Let\'s see how the above loop can coded in plain assembler. It\'s not complicated, don\'t worry. Taking this from another angle, the vector length acts as an implicit mask . The vector length is applied for almost all instructions. Only a few vector instructions do not obey this settings, but it\'s for purpose (for example, loading & storing whole registers). Vstart register A quite obvious complement to setting vector length would be setting the first element of vector. Thus our code would process any subvector! And indeed, there is the vstart control register which is... weird. Although it is exposed to the user code, it\'s indented to use in exception handlers. A CPU has to set vstart to the index of the faulting element, for instance when accessing unmapped memory while loading multiple elements. A user code may set the vstart , but the outcome is implementation-defined : the vector instructions work, but are expected to be slow; the CPU reports invalid instruction trap if vstart has value that \"would never be set by the hardware\". Let\'s take into account a simple vector addition --- this instruction never fails, thus vstart is always 0. And setting the register to anything else before addition results in a trap. For the sake of completeness: some instructions --- mostly related to masks --- explicitly disallow vstart other than zero. Masks Similarly to AVX-512, RVV uses a concept of mask --- a mask is a bit vector that determines which elements of vector are being processed. Most vector instructions can be masked. A mask is also a result of comparisons, and multi-word arithmetic instructions. However, unlike AVX-512, the RVV does not have a separate register file for masks. A mask is interpreted as the VL lowest bits of a vector register. In practice it means that we have to sacrifice some vector registers solely for masks. Another caveat is that only the register v0 can be used for masking instruction. (It\'s important when we write in plain assembler, compilers for ages been dealing with architecturally fixed registers.) A natural consequence of having masks is providing a subset of instructions that operate on mask. That are logical instructions (and, or, xor), but also an instruction that returns the index of the first set element and an instruction that yields number of set bits (population count). AVX-512 supports only logical instructions, a mask register has to be moved to a generic purpose register in order to do something more advanced with mask bits. Tail/mask agnostic/undisturbed policies Before we move forward, we need to formalize a little how a vector is interpreted: prestart are elements before vstart ; tail are elements after vl ; body are elements in range [ vstart , vl ); When an instruction is not masked, all its body elements are active . When an instruction is masked, then the elements of body can be either active or inactive , depending on the mask bits. We can decide how prestart / tail & inactive elements are being updated in the destination register. There are two policies: undisturbed and agnostic. The policy undistrubed keeps the previous value. This is generally slower, because a CPU has to read the destination register and then do an implicit merge operation . The policy agnostic may not keep the previous values, filling elements with bit 1. Not all elements have be filled in that way --- it\'s perfectly valid to get a non-deterministic outcome. With the agnostic policy we cannot assume anything about non-active elements, thus we choose that policy iff we really don\'t care about the non-active elements. These policies are set independently for prestart / tail and inactive elements. In most cases we\'ll have tail agnostic policy, and undistrubed masked elements. Side note: setting all ones instead of zeroing non-active elements looks odd. The specification justifies this choice: The agnostic policy was added to accommodate machines with vector register renaming. With an undisturbed policy, all elements would have to be read from the old physical destination vector register to be copied into the new physical destination vector register. I\'m not buying it. Both AVX-512 and SVE fill with zeros the inactive elements and there\'s no performance penalty because of that. Vector register size As it was said, RVV does not define the size of vector register. The vector register size can be read from control register vlenb , which is the width given in bytes . A portable program should not assume anything about vlenb , in particular it\'s minimum value. Caveat: in-register gathers, known as shuffle or permutation on other architectures, are not fully portable. Vector instruction arguments Most RVV instructions have three arguments: destination ( vd ), source #1 ( vs1 ), source #2 ( vs2 ). The majority of instructions update vd with the result of some binary operation on sources (like addition, multiplication): Only multiply-add instructions additionally read vd : A useful feature of RVV is that for many instructions the source #1 can be also: a scalar register (integer or floating point one), a 5-bit immediate (signed or unsigned integer). Conceptually, the scalar argument is splat ( broadcast ) before applying a vector operation. For example following code adds 3 to each element of vector v7 : The intrinsics functions do not expose immediate variants, their scalar argument will be properly interpreted by a compiler. For the sake of completeness the above assembler code with C intrinisic function. Memory operations RVV offers several load/store operations. First of all, we can load/store whole registers, regardless of the vector length. These instructions are meant more for bare data movement, like registers spilling or saving registers on a stack. There are load/stores the operate on vector length elements. There are gathers/scatter, that load indices from another vector register. There are specialised gather/scatter, that load elements with given spacing. Note that the for regular load/stores, mentioned earlier, multiplier = 1 . It\'s possible to set multiplier to zero --- then effectively such instruction perform broadcast of a single element from memory into a vector register. It\'s also possible to set negative multiplier, if somebody really wants. There are load/stores that performs transposition , loading elements at the given offset into separate registers. This is something ARM Neon supports. A classical example is splitting RGB images (3 x 8 bit) into separate channels, something like that: There are loads that allow to mask accessing unmapped memory . This feature is also present in SVE. ABI The ABI for RVV is simple: all registers may be freely clobbered. Taking this from the perspective of shared libs, it\'s not ideal. Functions are accessed via bare calls, without inlining. Any utility-level function has to preserve the modified RVV registers, thus RVV-intensive code should be rather huge (called less often). Forget about short helper functions. Intrinsic functions Intrinsics functions are well-defined by a separate spec . That\'s really good, kudos for that! There is a nice online viewer ISA highlights This section is not meant to enumerate all instructions, it lists things the author found interesting. Upcasting/downcasting vectors In one of the previous sections we mentioned that when a procedure uses different element widths, we\'re forced to switch the mode using vsetvl instruction. That\'s quite often in integer-intensitive code. For example, if we\'re summing vectors of bytes, we need to cast uint8 into uint16 to avoid overflow. The RVV comes with many variants of instructions that implicitly do widening (upcasting) and narrowing (downcasting), without changing the mode . Widening means that we operate on vectors with SEW , but the result is written as 2*SEW . In the case of narrowing, we\'re usually have SEW inputs and 1/n*SEW outputs. For example instruction vwaddu.vv adds two vectors of width SEW , and then casts the addition results into 2*SEW unsigned numbers. The instruction vaddu.wv adds a vector of 2*SEW and a vector of SEW : it first casts SEW vector into 2*SEW , and then performs additions of 2*SEW unsigneds, yielding a vector of 2*SEW numbers. The other SIMD ISAs do not provide anything similar, they have dedicated instructions to upcast or downcast explicitly. Reduction or horizontal instructions The Intel documentation coined terms \"vertical\" and \"horizontal\" to distinguish between vector instructions that process corresponding elements of arguments (vertical) and instructions that process adjacent elements of arguments (horizontal). The keyword here is adjacent: Intel ISAs provides way to process pairs of adjacent elements, a good instance is PMADDWD instruction. The RVV made a leap: it\'s possible to apply the given operation to a vector and get a scalar result . It\'s called reduction ; reduction is defined for floats or integers. For floats we have three operations: sum, min and max. Summing may be ordered or not --- the latter means that a CPU is free to add elements in any order, but presumably faster. For integers we have: sum, min (signed/unsigned), max (signed/unsigned) as well as binary operations: or, and, xor. In the case of summing elements, there are also variants that widen the result, so there\'s no wrapping on overflow. Mask instructions Masks are used in the same way, regardless if they are applied to integer or floating-point instructions. Mask can be build from other masks using several boolean functions, like and , or , xor ; there are also unusual nand , nor and xnor . It\'s possible to construct a new mask from the existing one, that takes into account the first bit set: vmsof.m --- set-only-first, vmsbf.m --- set-before-first, vmsif.m --- set-including-first. They work in the following way: We can query the mask, getting result in a generic-purpose register: get the index of the first bit set, or -1 if the mask is zero, the number of set bits in the mask. Vector iota The instruction viota is quite unusual, and its main purpose is implementation of vector decompress operation. The instruction takes a mask and produces a vector, where each element of vector is the number of bits in mask that are set before the i-th position. The following C-like code shows the idea. Integer division The most striking difference with other SIMD ISAs is that RVV supports integer division as well as reminder. There is support for both signed and unsigned numbers. Multi-word arithmetic It is possible to add or subtract multi-word numbers. A similar feature was present in AltiVec . Addition/Subtract accepts three arguments: two numbers and carry/borrow from the previous addition. There\'s a separate instruction for producing carry/borrow bits. Binary operations There are only three operations available: and , or and xor . It cannot be compared with AVX-512 with its ternary logic instruction . But not having \"and-not\" operation or \"bit-merge\" ( (x and c) or (y and not c) ) seems an obvious omission. Integer multiply-add Mulitply-add/subtract are well known in the world of floating-point numbers. Having similar operations for integers is a nice addition, saving a few instructions. Vector slide It\'s possible to slide vector elements by the given offset (in elements). For single-element slides it\'s possible to shift-in a scalar register content. It\'s similar to vector alignments from SSE/AVX, but more generic.'],
["notesen/2024-11-11-myriad-riscv-sequence.html", 'Myriad sequences of RISC-V code', 'Myriad sequences of RISC-V code Wojciech Mua Added on 2024-11-11 Contents Myriad sequences 32-bit unsigned numbers Example 1 Example 2 Example 3 64-bit unsigned numbers Example 1 Example 2 Example 3 Tool versions Myriad sequences The RISC-V assembler defines the pseudo-instruction li that load an immediate into a register. Unlike other pseudo-instructions, having one or a few expansions, li explodes into --- as the spec says --- myriad sequences . RISC-V opcodes have 32 bits, it\'s impossible to encode 64-bit immediates. It\'s impossible to encode 32-bit immediates too, as we need to have some spare bits for the opcode itself (instruction + destination). Assemblers have to do quite complex job, as they can only use a single register --- the li argument; compilers have more freedom. RISC-V comes with two instructions that are used to fill registers with the given value: ADDI rd, rs1, imm12 --- that adds a sign-extended 12-bit immediate to register rs1 and stores result in rd ; ADDIW rd, rs1, imm12 --- likewise, but defined for RV64, i.e., the CPUs with 64-bit registers; LUI rd, imm20 --- that stores a sign-extend 20-bit immediate shifted left by 12 positions in rd ; alternatively: 32-bit immediate with reset lowest 12 bits. For easy cases we can use pick a single instruction from the above list. But when a constant fall off any of the ranges, more instructions have to be used. 32-bit unsigned numbers Example 1 When an immediate has 31 bits, then a pair of LUI & ADDIW is enough. GNU as output: Example 2 However, when a number has 32 bits, then assembler emits more instructions. For example: GNU as output: Both GCC and Clang synthesize a bit better sequence: Example 3 GNU as output: Again, GCC and Clang yield shorter sequence: 64-bit unsigned numbers Example 1 64-bit immediates are more heavy. For this sample constant: The GNU assembler produces eight instructions: While GCC takes advantage of using multiple registers, the outcome is not much shorter, we saved only one instruction: Clang gives up, and loads the constant from memory. Example 2 GNU as output: GCC output (Clang also decided to load the value from memory): Example 3 GNU as output: GCC output: Clang output is better: Tool versions riscv64-unknown-elf-as : GNU assembler (2.43.1-5+7) 2.43.1 GCC: riscv64-unknown-linux-gnu-g++ (crosstool-NG UNKNOWN) 15.0.0 20241111 (experimental) Clang: clang version 20.0.0git ( https://github.com/llvm/llvm-project.git 3006dddfe091bcb95924d72dddbb84f73186a344)'],
["notesen/2024-12-21-uint8-division.html", 'Dividing unsigned 8-bit numbers', 'Dividing unsigned 8-bit numbers Wojciech Mua Added on 2024-12-21 Updated on 2024-12-22 (fixed a typo, thanks John Rinehart , clarify introduction based on HN comments, add more AVX-512 variants); 2024-12-28 (add see also section) Contents Introduction Floating-point point operations Division with rounding Division without rounding Using approximate reciprocal Long division Vectorization SSE & AVX2 Step 1: Updating remainder Step 2: Comparison Step 3: Conditional operations Implementation (SSE) AVX-512 Step 1: Updating remainder Step 2: Comparison Step 3: Conditional operations Implementation Experiment results Ryzen 7 Skylake-X IceLake See also Source code Introduction Division is quite an expensive operation. For instance, latency of the 32-bit division varies between 10 and 15 cycles on the Cannon Lake CPU, and for Zen4 this range is from 9 to 14 cycles. The latency of 32-bit multiplication is 3 or 4 cycles on both CPU models. None of commonly used SIMD ISAs (SSE, AVX, AVX-512, ARM Neon, ARM SVE) provides the integer division, only RISC-V Vector Extension does. However, all these ISAs have floating point division. In this text we present two approaches to achieve a SIMD-ized division of 8-bit unsigned numbers: using floating point division, using the long division algorithm. We try to vectorize the following C++ procedure. The procedure cannot assume anything about dividends, especially if they are all equal. Thus, it is not possible to employ division by a constant . Compilers cannot vectorize it. For example GCC 14.1.0 produces the following assembly (stripped from code alignment junk): Floating-point point operations An 8-bit number can be converted into single precision floating point number without any precision loss. The generic outline of division consist the following steps: cast 8-bit dividend and divisor into 32-bit integers, convert unsigned integers into floating-point numbers, perform floating-point division, convert floating-point result into 32-bit integers, cast back 32-bit integer into 8-bit final result. Division with rounding Here is the actual implementation of SSE procedure. Note that we need to explicitly truncate the floating point number before converting back into integer. By default that conversion rounds the argument, so we would get wrong results (off by 1). Load four 8-bit dividends. And four 8-bit divisors. Transfer them to SSE register and cast to 32-bit numbers. Cast 32-bit integers into floats. Perform division and then truncation. Convert floats back into integers. Cast 32-bit into 8-bit numbers: gather lowest 8-bit numbers into single 32-bit word and save this word to the output array. Division without rounding Rounding instruction ROUNDPS has quite big latency, at least on Intel CPUs. On IceLake it is 8 cycles, while Zen4 has only 3 cycles. We can avoid floating point rounding by multiplying the dividend 256 (shift left by 8 bits) and shifting right by 8 the final result. The shift right can be done at no cost, because we anyway use shuffling to gather individual bytes, so it\'s only matter of a constant. Shifting left by 8 is suitable only for SSE code --- we can use byte shuffle to shift-and-extend integers. In the case of AVX2 code, byte shuffling is done on 128-bit lanes, thus we would need more work to prepare input for that operation. The SSE procedure is almost the same as in the previous section: Load four dividends. Convert dividend << 8 into 32-bit numbers. Load four divisors and convert them to 32-bit numbers. Cast all 32-bit integers into floats. Perform division. Convert quotient into 32-bit integers. Cast quotient >> 8 into 8-bit numbers: gather bit #1 of each 32-bit word. Using approximate reciprocal SSE comes with instruction RCPPS that calculates the approximate inversion of its argument: [...] [...] The specification says relative error does not exceed [...] However, by trial-and-error search, we found that after multiplying the dividend by value 1.00025 , the result of RCPPS can be used. To be precise, any multiplier between 1.00024 and 1.00199 works. x 1 / x approx 1 / x error float hex float hex 1 1.000000 3f800000 0.999756 3f7ff000 0.000244 2 0.500000 3f000000 0.499878 3efff000 0.000122 3 0.333333 3eaaaaab 0.333313 3eaaa800 0.000020 4 0.250000 3e800000 0.249939 3e7ff000 0.000061 5 0.200000 3e4ccccd 0.199951 3e4cc000 0.000049 6 0.166667 3e2aaaab 0.166656 3e2aa800 0.000010 7 0.142857 3e124925 0.142822 3e124000 0.000035 8 0.125000 3e000000 0.124969 3dfff000 0.000031 9 0.111111 3de38e39 0.111084 3de38000 0.000027 10 0.100000 3dcccccd 0.099976 3dccc000 0.000024 11 0.090909 3dba2e8c 0.090897 3dba2800 0.000012 12 0.083333 3daaaaab 0.083328 3daaa800 0.000005 13 0.076923 3d9d89d9 0.076920 3d9d8800 0.000004 14 0.071429 3d924925 0.071411 3d924000 0.000017 15 0.066667 3d888889 0.066650 3d888000 0.000016 16 0.062500 3d800000 0.062485 3d7ff000 0.000015 17 0.058824 3d70f0f1 0.058807 3d70e000 0.000016 18 0.055556 3d638e39 0.055542 3d638000 0.000014 19 0.052632 3d579436 0.052620 3d578800 0.000012 20 0.050000 3d4ccccd 0.049988 3d4cc000 0.000012 ... 255 0.003922 3b808081 0.003922 3b808000 0.000000 Long division The long division algorithm is the one we know from school. We start with the remainder and quotient equals zero. Then, in each step, we extend the remainder with the next digit of the dividend, starting from most significant digits. If the remainder becomes bigger than the divisor, we calculate [...] a digit , is in range [0, 9] for decimal division, or is either 0 or 1 for binary division. We decrement remainder by [...] We prepend the digit [...] If there are still digits in dividend, go to point #2. A nice property of the algorithm is calculating both the quotient and remainder. The cons of algorithm are: Each step depends on the predecessor, it makes hard to utilize out-of-order CPUs. The number of iterations equal the number of significant digits in dividend minus # of digits in divisor plus 1. In the worst case, it equals # of digits in dividend. Since we\'re going to divide 8-bit numbers, it means that the basic step of algorithm has to be repeated eight times. Below is a reference implementation. The long division can be also applied to signed integers. We need to calculate the absolute values of dividend & divisor and perform the algorithm. Then quotient has to be negated if the operands have different signs. Since 8-bit signed integers have range [...] [...] Vectorization The algorithm consist the following operations: extract i-th bit from the divisor and shift it into the remainder: compare the remainder and divisor; conditionally set i-th bit in the quotient and adjust the remainder: SSE & AVX2 Step 1: Updating remainder In SSE & AVX2 it\'s easy to copy the most significant bit to the least significant bit #0. We compare the number interpreted as a signed one with zero. It yields either 0x00 or 0xff ( [...] We can rewrite the main loop to shift the dividend left by 1, thus we\'ll be able to copy all its bits using that technique. Shifting left by 1 is simple addition, which is a really fast operation. Step 2: Comparison There\'s no unsigned comparison in SSE nor AVX2, only signed one. It is possible to compare two unsigned numbers with a signed comparison: we need to negate their most significant bits. This is done by XOR-ing with 0x80. Note that we need to perform xor once for the divisor, and eight times for the remainder. Step 3: Conditional operations Once we get a mask from the comparison, we can easily compute masked operations. In fact we need unconditionally shift the quotient by 1 and then conditionally set the i-th bit. Implementation (SSE) The following C code shows all the implementation details. The actual SSE implementation. AVX-512 Step 1: Updating remainder Unlike SSE/AVX2 code it\'s easier to actually perform shift right to place i-th bit at position zero. Then isolating the least significant bit and merging it with quotient can be expressed as a single ternary operation . Step 2: Comparison AVX512 supports unsigned byte comparison, and returns a mask. Step 3: Conditional operations This is straightforward use of masked operations. Implementation The actual AVX512 implementation is shown below. Unlike SSE code, the inner loop is manually unrolled. Also, there\'s no explicitly use of the ternary logic intrinsic function --- but examining the assembly code reveals that a compiler nicely fuses binary operation. Experiment results Short summary: AVX-512 implementation of long division is the fastests on all Intel CPUs. AVX2 using approximate reciprocal is the fastests on Ryzen. It\'s worth noting that GCC autovectorized better or comparable code to hand-written AVX2 variants. All benchmark programs were compiled with -O3 -march=native options on each machine separately. Tested procedures Procedure Comments scalar plain 8-bit division scalar (unrolled x 4) division unrolled manually 4 times scalar (long division) scalar implementation of long division , with disabled autovectorization scalar (long div, autovect) scalar implementation of long division, with autovectorization SSE division with rounding SSE (no rounding) division without rounding (dividend multiplied by 256) SSE (cvtt) division followed by casting with truncation ( CVTTPS2DQ ) SSE (rcp) multiplication by approximate reciprocal SSE long div long division implemented with SSE instructions AVX2 division with rounding AVX2 (cvtt) division followed by casting with truncation (CVTTPS2DQ) AVX2 (rcp) multiplication by approximate reciprocal AVX2 long div long division implemented with AVX2 instructions AVX512 (cvtt) division followed by casting with truncation (CVTTPS2DQ) AVX512 (rcp) multiplication by approximate reciprocal AVX512 long div long division implemented with AVX-512 instructions Ryzen 7 Compiler: gcc (Debian 14.1.0-5) 14.1.0 CPU: AMD Ryzen 7 7730U with Radeon Graphics procedure time in cycles per byte speed-up average best scalar 1.776 1.759 1.0 scalar (unrolled x 4) 1.894 1.869 0.9 scalar (long div) 5.715 5.520 0.3 scalar (long div, autovect) 0.427 0.417 4.2 SSE 0.374 0.368 4.8 SSE (no rounding) 0.356 0.332 5.3 SSE (cvtt) 0.338 0.331 5.3 SSE (rcp) 0.348 0.328 5.4 SSE long div 0.753 0.738 2.4 AVX2 0.223 0.218 8.1 AVX2 (cvtt) 0.232 0.222 7.9 AVX2 (rcp) 0.220 0.216 8.1 AVX2 (4x rcp) 0.162 0.159 11.1 AVX2 long div 0.390 0.376 4.7 Skylake-X CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz Compiler: gcc (GCC) 11.2.0 procedure time in cycles per byte speed-up average best scalar 8.032 8.018 1.0 scalar (unrolled x 4) 6.518 6.513 1.2 scalar (long div) 18.882 18.784 0.4 scalar (long div, autovect) 1.008 1.003 8.0 SSE 1.209 1.195 6.7 SSE (no rounding) 0.871 0.864 9.3 SSE (cvtt) 0.912 0.905 8.9 SSE (rcp) 1.026 1.022 7.8 SSE long div 2.100 2.094 3.8 AVX2 1.059 1.055 7.6 AVX2 (cvtt) 0.834 0.823 9.7 AVX2 (rcp) 0.976 0.973 8.2 AVX2 (4x rcp) 0.589 0.584 13.7 AVX2 long div 1.077 1.070 7.5 AVX512 (cvtt) 1.473 1.465 5.5 AVX512 (rcp) 1.194 1.187 6.8 AVX512 (4x rcp) 0.687 0.682 11.8 AVX512 long div 0.707 0.699 11.5 IceLake Compiler: gcc (GCC) 13.3.1 20240611 (Red Hat 13.3.1-2) CPU: Intel(R) Xeon(R) Gold 6338 CPU @ 2.00GHz procedure time in cycles per byte speed-up average best scalar 6.069 6.011 1.0 scalar (unrolled x 4) 6.016 6.013 1.0 scalar (long div) 9.031 8.407 0.7 scalar (long div, autovect) 0.584 0.580 10.4 SSE 0.587 0.579 10.4 SSE (no rounding) 0.482 0.477 12.6 SSE (cvtt) 0.476 0.474 12.7 SSE (rcp) 0.497 0.490 12.3 SSE long div 1.246 1.238 4.9 AVX2 0.524 0.520 11.6 AVX2 (cvtt) 0.437 0.432 13.9 AVX2 (rcp) 0.435 0.432 13.9 AVX2 (4x rcp) 0.288 0.286 21.0 AVX2 long div 0.640 0.634 9.5 AVX512 (cvtt) 0.833 0.830 7.2 AVX512 (rcp) 0.504 0.500 12.0 AVX512 (4x rcp) 0.263 0.261 23.0 AVX512 long div 0.403 0.400 15.0 See also Dividing 8-bit Uints with AVX-512VBMI A practical impelementation in CQBN project. Formally verified 32- and 64-bit integer division using double-precision floating-point arithmetic by David Monniaux, Alice Pain Source code Sample implementation is available at GitHub .'],
["notesen/2025-01-03-uint16-division.html", 'Dividing unsigned 16-bit numbers', 'Dividing unsigned 16-bit numbers Wojciech Mua Added on 2025-01-03 Contents Introduction Experiment results Ryzen 7 AlderLake Icelake Skylake-X Source code Introduction This is a follow-up text for %%%ref:2024-12-21-uint8-division.rst%%%. We checked if dividing 16-bit unsigned numbers is also feasible for SIMD instructions. Apart from obvious path, where we use floating-point division ( DIVPS ), 8-bit numbers could also utilize the approximate reciprocal instruction RCPPS . Unfortunately, for 16-bit numbers the latter instruction cannot be used directly. To properly divide 16-bit integers we need to perform a single step of the Newton-Raphson algorithm , which kills performance. Experiment results Summary: Suprisingly, AVX-512 implementations are not faster than AVX2 ones. Unrolling doesn\'t help. All benchmark programs were compiled with -O3 -march=native options on each machine separately. Tested procedures Procedure Comments scalar plain 16-bit division AVX2 division followed by integer casting with truncation ( CVTTPS2DQ ) AVX2 (x2) the base AVX2 procedure unrolled twice AVX2 (x4) the base AVX2 procedure unrolled fourfold AVX2 (rcp) multiplication by approximate reciprocal followed by a single step of the Newton-Raphson algorithm AVX512 division followed by integer casting with truncation ( CVTTPS2DQ ) AVX512 (x2) the base AVX-512 procedure unrolled twice AVX512 (x4) the base AVX-512 procedure unrolled fourfold Ryzen 7 Compiler: gcc (Debian 14.1.0-5) 14.1.0 CPU: AMD Ryzen 7 7730U with Radeon Graphics procedure time in cycles per byte speed-up average best scalar 1.783 1.759 1.0 AVX2 0.208 0.182 9.7 AVX2 (x2) 0.201 0.185 9.5 AVX2 (x4) 0.215 0.188 9.4 AVX2 (rcp) 0.323 0.302 5.8 AlderLake Compiler: gcc (Debian 13.2.0-25) 13.2.0 CPU: 12th Gen Intel(R) Core(TM) i7-1255U procedure time in cycles per byte speed-up average best scalar 3.714 3.368 1.0 AVX2 0.507 0.389 8.7 AVX2 (x2) 0.477 0.384 8.8 AVX2 (x4) 0.518 0.376 9.0 AVX2 (rcp) 0.531 0.440 7.7 Icelake Compiler: gcc (GCC) 13.3.1 20240611 (Red Hat 13.3.1-2) CPU: Intel(R) Xeon(R) Gold 6338 CPU @ 2.00GHz procedure time in cycles per byte speed-up average best scalar 6.032 6.014 1.0 AVX2 0.630 0.628 9.6 AVX2 (x2) 0.628 0.626 9.6 AVX2 (x4) 0.404 0.401 15.0 AVX2 (rcp) 0.501 0.491 12.2 AVX512 0.431 0.428 14.1 AVX512 (x4) 0.407 0.405 14.8 AVX512 (x2) 0.415 0.413 14.6 Skylake-X CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz Compiler: gcc (GCC) 11.2.0 procedure time in cycles per byte speed-up average best scalar 8.116 8.092 1.0 AVX2 1.235 1.212 6.7 AVX2 (x2) 1.236 1.219 6.6 AVX2 (x4) 1.234 1.210 6.7 AVX2 (rcp) 1.394 1.368 5.9 AVX512 1.197 1.183 6.8 AVX512 (x4) 1.196 1.181 6.9 AVX512 (x2) 1.185 1.164 7.0 Source code Sample implementation is available at GitHub .'],
["notesen/2025-01-05-simd-pdep-pext.html", 'SIMD parallel bits deposit/extract', 'SIMD parallel bits deposit/extract Wojciech Mua Added on 2025-01-05 Contents Introduction PEXT Specification Software implementation AVX2 implementation AVX-512 implementation PDEP Specification Software implementation AVX2 implementation AVX-512 implementation Experiments Ryzen 7 Alder Lake Ice Lake Skylake-X Source code Introduction The BMI2 extension introduced two complementary instructions: parallel bits deposit ( PDEP ) and parallel bits extract ( PEXT ). The PDEP scatters continuous set of bits to positions denoted by the mask. The PEXT does the opposite: gathers/compresses selected bits into a continuous word. SIMD instruction sets do not directly support this kind of operations. There is GF2P8AFFINEQB in AVX-512, that allows arbitrary bit shuffling at the byte level (see %%%ref:2020-01-19-avx512-galois-field-for-bit-shuffling.rst%%%). In this text we show approaches suitable for implementing PEXT and PDEP for wider element widths on any SIMD ISA. PEXT Specification Pseudocode for PEXT : Software implementation The most basic operation we need is copying the m-th bit from data to k-th position in the result word. An important property is that the source index m is greater or equals the destination index k . We can avoid any explicit shifting of bits. We mask the m-th bit of data: this yields either 1 << m or 0 . We have the mask for destination bit, having value 1 << k . Calculating the minimum of these two values yields either 1 << k or 0 . Finally, we merge that value with the result word. The following pseudocode shows the idea: To isolate the first bit, we\'ll use a well known trick of resetting such bit: And this is how this works for sample values: AVX2 implementation The following C++ template generates an implementation. The most generic one would scan all mask bits ( MAX_MASK_BITS=32 ), but when we know the maximum number of bits set in masks, we may limit the number of iterations accordingly. The parameter EARLY_EXIT decides whether to check in every iteration if all mask bits were scanned on not. It adds runtime overhead, and in the case we don\'t know how diverse masks are, this check won\'t help. If we know that the number of bits in different masks are similar, this check may be a win. AVX-512 implementation Solution for AVX-512 can use the above trick, but it is simpler to directly use mask registers. There is instruction VPTESTMD that sets a register mask based on bit-and of two operands. This allows us to produce element-wise masks from m-th bits. Then conditional VPORD can be used to update the resulting word. The following fragment from AVX-512 implementation shows these steps. PDEP Specification Pseudocode for PDEP : Example of PDEP invoked with a 4-bit mask and sample data. Software implementation In the case of PDEP we need to copy the k-th from data to the m-th bit of destination. Similarly to PEXT , in this case relation [...] It is also possible to avoid any bit shifting, but the method is not as elegant as for PEXT . We start from isolating m-th bit from the mask In the word mask - 1 we have a series of ones before the m . Since [...] k-th bit from data. If that bit it one, it will cause the series of ones to carry up the bit again to m-th position. Than we need isolate the m-th bit, mask that bit in sum and use it to update the resulting word. AVX2 implementation While the shift-less method is feasible, we found an easier way to update the result word. We use VPCMPEQD that fills a 32-bit word with zeros or ones, depending on comparison result. We isolate the k-th bit of data and compare it with zero. This yield a negated mask , which we use to filter out m-th bits. The following snippet from AVX2 implementation shows the order of operations. AVX-512 implementation AVX-512 code uses the same approach as PEXT implementation. We transfer k-th bits from data word to a mask register and then use masked VPTERNLOGD to conditionally bit-or the m-th bits into the result words. Experiments The baseline code uses PDEP or PEXT invoked in a simple loop. It\'s a bit unrealistic solution, but can be seen it as a theoretical limit. More realistic scenario is when we have some computations done on vector registers and we have to switch to scalar code to perform PDEP or PEXT . Summary: The vectorized approaches have complexity proportional to the number of 1 bits in mask values. AVX2 code is never faster than scalar code. AVX-512 code is faster only on IceLake, when the mask values have a few bits (6 or 8 in tests). All test programs were compiled with options -O3 -march=native on each machine running tests. Tested PEXT procedures Procedure Comments pext scalar PEXT baseline pext AVX2 AVX2 implementation for 32-bit masks pext AVX2 (early exit) AVX2 implementation for 32-bit masks, with breaking the inner loop when all masks become zero pext AVX2 (6 bit) AVX2 implementation for 6-bit masks pext AVX2 (6-bit, early exit) AVX2 implementation for 6-bit masks, with breaking the inner loop when all masks become zero pext AVX2 (8 bit) AVX2 implementation for 8-bit masks pext AVX2 (8-bit, early exit) AVX2 implementation for 8-bit masks, with breaking the inner loop when all masks become zero pext AVX2 (16 bit) AVX2 implementation for 16-bit masks pext AVX2 (16-bit, early exit) AVX2 implementation for 16-bit masks, with breaking the inner loop when all masks become zero pext AVX2 (24 bit) AVX2 implementation for 24-bit masks pext AVX2 (24-bit, early exit) AVX2 implementation for 24-bit masks, with breaking the inner loop when all masks become zero pext AVX-512 AVX-512 implementation for 32-bit masks pext AVX-512 (early exit) AVX-512 implementation for 32-bit masks, with breaking the inner loop when all masks become zero pext AVX-512 (6 bit) AVX-512 implementation for 6-bit masks pext AVX-512 (6-bit, early exit) AVX-512 implementation for 6-bit masks, with breaking the inner loop when all masks become zero pext AVX-512 (8 bit) AVX-512 implementation for 8-bit masks pext AVX-512 (8-bit, early exit) AVX-512 implementation for 8-bit masks, with breaking the inner loop when all masks become zero pext AVX-512 (16 bit) AVX-512 implementation for 16-bit masks pext AVX-512 (16-bit, early exit) AVX-512 implementation for 16-bit masks, with breaking the inner loop when all masks become zero pext AVX-512 (24 bit) AVX-512 implementation for 24-bit masks pext AVX-512 (24-bit, early exit) AVX-512 implementation for 24-bit masks, with breaking the inner loop when all masks become zero Tested PDEP procedures Procedure Comments pdep scalar PDEP baseline pdep AVX2 AVX2 implementation for 32-bit masks pdep AVX2 (early exit) AVX2 implementation for 32-bit masks, with breaking the inner loop when all masks become zero pdep AVX2 (6 bit) AVX2 implementation for 6-bit masks pdep AVX2 (6-bit, early exit) AVX2 implementation for 6-bit masks, with breaking the inner loop when all masks become zero pdep AVX2 (8 bit) AVX2 implementation for 8-bit masks pdep AVX2 (8-bit, early exit) AVX2 implementation for 8-bit masks, with breaking the inner loop when all masks become zero pdep AVX2 (16 bit) AVX2 implementation for 16-bit masks pdep AVX2 (16-bit, early exit) AVX2 implementation for 16-bit masks, with breaking the inner loop when all masks become zero pdep AVX2 (24 bit) AVX2 implementation for 24-bit masks pdep AVX2 (24-bit, early exit) AVX2 implementation for 24-bit masks, with breaking the inner loop when all masks become zero pdep AVX-512 AVX-512 implementation for 32-bit masks pdep AVX-512 (early exit) AVX-512 implementation for 32-bit masks, with breaking the inner loop when all masks become zero pdep AVX-512 (6 bit) AVX-512 implementation for 6-bit masks pdep AVX-512 (6-bit, early exit) AVX-512 implementation for 6-bit masks, with breaking the inner loop when all masks become zero pdep AVX-512 (8 bit) AVX-512 implementation for 8-bit masks pdep AVX-512 (8-bit, early exit) AVX-512 implementation for 8-bit masks, with breaking the inner loop when all masks become zero pdep AVX-512 (16 bit) AVX-512 implementation for 16-bit masks pdep AVX-512 (16-bit, early exit) AVX-512 implementation for 16-bit masks, with breaking the inner loop when all masks become zero pdep AVX-512 (24 bit) AVX-512 implementation for 24-bit masks pdep AVX-512 (24-bit, early exit) AVX-512 implementation for 24-bit masks, with breaking the inner loop when all masks become zero Ryzen 7 Compiler: gcc (Debian 14.1.0-5) 14.1.0 CPU: AMD Ryzen 7 7730U with Radeon Graphics procedure time in cycles per byte speed-up average best any 32-bit mask pext scalar 1.012 0.915 1.0 pext AVX2 4.549 4.536 0.2 pext AVX2 (early exit) 6.174 6.133 0.1 mask has no more than 6 bits pext scalar 0.957 0.918 1.0 pext AVX2 (6 bit) 0.862 0.834 1.1 pext AVX2 (6 bit, early exit) 0.923 0.896 1.0 mask has no more than 8 bits pext scalar 0.938 0.909 1.0 pext AVX2 (8 bit) 0.914 0.896 1.0 pext AVX2 (8 bit, early exit) 1.207 1.195 0.8 mask has no more than 16 bits pext scalar 0.938 0.909 1.0 pext AVX2 (16 bit) 2.022 2.005 0.5 pext AVX2 (16 bit, early exit) 4.169 4.160 0.2 mask has no more than 24 bits pext scalar 0.939 0.911 1.0 pext AVX2 (24 bit) 3.314 3.297 0.3 pext AVX2 (24 bit, early exit) 5.322 5.310 0.2 procedure time in cycles per byte speed-up average best any 32-bit mask pdep scalar 0.924 0.881 1.0 pdep AVX2 4.409 4.398 0.2 pdep AVX2 (early exit) 6.230 6.206 0.1 mask has no more than 6 bits pdep scalar 0.906 0.878 1.0 pdep AVX2 (6 bit) 0.813 0.798 1.1 pdep AVX2 (6 bit, early exit) 0.931 0.918 1.0 mask has no more than 8 bits pdep scalar 0.905 0.876 1.0 pdep AVX2 (8 bit) 0.940 0.928 0.9 pdep AVX2 (8 bit, early exit) 1.251 1.240 0.7 mask has no more than 16 bits pdep scalar 0.897 0.878 1.0 pdep AVX2 (16 bit) 2.070 2.055 0.4 pdep AVX2 (16 bit, early exit) 4.254 4.242 0.2 mask has no more than 24 bits pdep scalar 0.902 0.876 1.0 pdep AVX2 (24 bit) 3.260 3.244 0.3 pdep AVX2 (24 bit, early exit) 5.397 5.385 0.2 Alder Lake Compiler: gcc (Debian 13.2.0-25) 13.2.0 CPU: 12th Gen Intel(R) Core(TM) i7-1255U procedure time in cycles per byte speed-up average best any 32-bit mask pext scalar 1.527 1.286 1.0 pext AVX2 7.556 6.846 0.2 pext AVX2 (early exit) 8.778 8.001 0.2 mask has no more than 6 bits pext scalar 1.471 1.264 1.0 pext AVX2 (6 bit) 1.482 1.289 1.0 pext AVX2 (6 bit, early exit) 1.673 1.477 0.9 mask has no more than 8 bits pext scalar 1.480 1.273 1.0 pext AVX2 (8 bit) 1.654 1.446 0.9 pext AVX2 (8 bit, early exit) 2.233 2.006 0.6 mask has no more than 16 bits pext scalar 1.464 1.268 1.0 pext AVX2 (16 bit) 3.428 3.042 0.4 pext AVX2 (16 bit, early exit) 6.045 5.461 0.2 mask has no more than 24 bits pext scalar 1.491 1.257 1.0 pext AVX2 (24 bit) 5.622 5.025 0.3 pext AVX2 (24 bit, early exit) 7.925 7.078 0.2 procedure time in cycles per byte speed-up average best any 32-bit mask pdep scalar 1.512 1.276 1.0 pdep AVX2 7.857 7.091 0.2 pdep AVX2 (early exit) 8.317 7.452 0.2 mask has no more than 6 bits pdep scalar 1.479 1.246 1.0 pdep AVX2 (6 bit) 1.472 1.318 0.9 pdep AVX2 (6 bit, early exit) 1.699 1.498 0.8 mask has no more than 8 bits pdep scalar 1.441 1.250 1.0 pdep AVX2 (8 bit) 1.768 1.517 0.8 pdep AVX2 (8 bit, early exit) 2.282 2.038 0.6 mask has no more than 16 bits pdep scalar 1.476 1.270 1.0 pdep AVX2 (16 bit) 3.472 3.130 0.4 pdep AVX2 (16 bit, early exit) 6.062 5.497 0.2 mask has no more than 24 bits pdep scalar 1.484 1.282 1.0 pdep AVX2 (24 bit) 5.795 5.244 0.2 pdep AVX2 (24 bit, early exit) 7.715 6.835 0.2 Ice Lake Compiler: gcc (GCC) 13.3.1 20240611 (Red Hat 13.3.1-2) CPU: Intel(R) Xeon(R) Gold 6338 CPU @ 2.00GHz procedure time in cycles per byte speed-up average best any 32-bit mask pext scalar 3.105 2.968 1.0 pext AVX2 18.473 14.244 0.2 pext AVX2 (early exit) 13.330 12.203 0.2 pext AVX512 9.780 9.657 0.3 pext AVX512 (early exit) 9.098 8.885 0.3 pext AVX512 v2 9.735 9.610 0.3 pext AVX512 v2 (early exit) 8.421 8.171 0.4 mask has no more than 6 bits pext scalar 3.160 3.050 1.0 pext AVX2 (6 bit) 2.079 1.972 1.5 pext AVX2 (6 bit, early exit) 2.832 2.700 1.1 pext AVX512 (6 bit) 1.360 1.259 2.4 pext AVX512 (6 bit, early exit) 1.755 1.600 1.9 pext AVX512 v2 (6 bit) 1.282 1.191 2.6 pext AVX512 v2 (6 bit, early exit) 1.647 1.510 2.0 mask has no more than 8 bits pext scalar 3.146 3.022 1.0 pext AVX2 (8 bit) 2.740 2.610 1.2 pext AVX2 (8 bit, early exit) 3.742 3.552 0.9 pext AVX512 (8 bit) 1.695 1.541 2.0 pext AVX512 (8 bit, early exit) 2.294 2.132 1.4 pext AVX512 v2 (8 bit) 1.559 1.433 2.1 pext AVX512 v2 (8 bit, early exit) 2.201 2.026 1.5 mask has no more than 16 bits pext scalar 3.084 2.983 1.0 pext AVX2 (16 bit) 5.406 5.146 0.6 pext AVX2 (16 bit, early exit) 8.798 8.562 0.3 pext AVX512 (16 bit) 3.192 2.936 1.0 pext AVX512 (16 bit, early exit) 5.321 5.113 0.6 pext AVX512 v2 (16 bit) 2.983 2.746 1.1 pext AVX512 v2 (16 bit, early exit) 4.665 4.575 0.7 mask has no more than 24 bits pext scalar 3.082 2.992 1.0 pext AVX2 (24 bit) 12.732 11.147 0.3 pext AVX2 (24 bit, early exit) 13.043 12.588 0.2 pext AVX512 (24 bit) 7.410 7.290 0.4 pext AVX512 (24 bit, early exit) 8.349 8.149 0.4 pext AVX512 v2 (24 bit) 7.384 7.269 0.4 pext AVX512 v2 (24 bit, early exit) 7.397 7.121 0.4 procedure time in cycles per byte speed-up average best any 32-bit mask pdep scalar 3.117 2.969 1.0 pdep AVX2 19.314 19.046 0.2 pdep AVX2 (early exit) 16.449 16.272 0.2 pdep AVX512 10.165 9.934 0.3 pdep AVX512 (early exit) 8.663 8.252 0.4 pdep AVX512 v2 9.401 8.432 0.4 pdep AVX512 v2 (early exit) 8.040 7.691 0.4 mask has no more than 6 bits pdep scalar 2.839 2.705 1.0 pdep AVX2 (6 bit) 2.153 2.006 1.3 pdep AVX2 (6 bit, early exit) 2.860 2.678 1.0 pdep AVX512 (6 bit) 1.620 1.388 1.9 pdep AVX512 (6 bit, early exit) 1.852 1.720 1.6 pdep AVX512 v2 (6 bit) 1.189 1.132 2.4 pdep AVX512 v2 (6 bit, early exit) 1.510 1.422 1.9 mask has no more than 8 bits pdep scalar 3.128 3.035 1.0 pdep AVX2 (8 bit) 3.115 2.948 1.0 pdep AVX2 (8 bit, early exit) 4.122 3.870 0.8 pdep AVX512 (8 bit) 1.769 1.678 1.8 pdep AVX512 (8 bit, early exit) 2.220 2.159 1.4 pdep AVX512 v2 (8 bit) 1.295 1.254 2.4 pdep AVX512 v2 (8 bit, early exit) 1.822 1.695 1.8 mask has no more than 16 bits pdep scalar 3.157 3.042 1.0 pdep AVX2 (16 bit) 6.010 5.802 0.5 pdep AVX2 (16 bit, early exit) 9.223 8.982 0.3 pdep AVX512 (16 bit) 3.616 3.364 0.9 pdep AVX512 (16 bit, early exit) 5.407 5.180 0.6 pdep AVX512 v2 (16 bit) 2.452 2.343 1.3 pdep AVX512 v2 (16 bit, early exit) 4.449 4.290 0.7 mask has no more than 24 bits pdep scalar 3.131 3.042 1.0 pdep AVX2 (24 bit) 13.123 10.766 0.3 pdep AVX2 (24 bit, early exit) 15.508 12.937 0.2 pdep AVX512 (24 bit) 7.661 7.438 0.4 pdep AVX512 (24 bit, early exit) 8.637 8.416 0.4 pdep AVX512 v2 (24 bit) 7.110 6.954 0.4 pdep AVX512 v2 (24 bit, early exit) 6.173 5.914 0.5 Skylake-X Compiler: gcc (GCC) 11.2.0 CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz procedure time in cycles per byte speed-up average best any 32-bit mask pext scalar 2.943 2.894 1.0 pext AVX2 13.043 13.019 0.2 pext AVX2 (early exit) 12.986 12.952 0.2 pext AVX512 10.296 10.267 0.3 pext AVX512 (early exit) 11.788 11.756 0.2 pext AVX512 v2 10.263 10.232 0.3 pext AVX512 v2 (early exit) 10.896 10.853 0.3 mask has no more than 6 bits pext scalar 2.986 2.958 1.0 pext AVX2 (6 bit) 2.910 2.894 1.0 pext AVX2 (6 bit, early exit) 3.143 3.103 1.0 pext AVX512 (6 bit) 3.009 2.979 1.0 pext AVX512 (6 bit, early exit) 3.339 3.223 0.9 pext AVX512 v2 (6 bit) 3.109 2.963 1.0 pext AVX512 v2 (6 bit, early exit) 3.172 3.124 0.9 mask has no more than 8 bits pext scalar 2.980 2.957 1.0 pext AVX2 (8 bit) 3.254 3.224 0.9 pext AVX2 (8 bit, early exit) 3.821 3.791 0.8 pext AVX512 (8 bit) 3.311 3.234 0.9 pext AVX512 (8 bit, early exit) 3.852 3.799 0.8 pext AVX512 v2 (8 bit) 3.159 3.122 0.9 pext AVX512 v2 (8 bit, early exit) 3.644 3.616 0.8 mask has no more than 16 bits pext scalar 2.974 2.948 1.0 pext AVX2 (16 bit) 5.719 5.697 0.5 pext AVX2 (16 bit, early exit) 9.145 9.118 0.3 pext AVX512 (16 bit) 4.774 4.747 0.6 pext AVX512 (16 bit, early exit) 7.565 7.541 0.4 pext AVX512 v2 (16 bit) 4.572 4.548 0.6 pext AVX512 v2 (16 bit, early exit) 7.293 7.262 0.4 mask has no more than 24 bits pext scalar 3.037 2.963 1.0 pext AVX2 (24 bit) 9.721 9.704 0.3 pext AVX2 (24 bit, early exit) 12.069 12.038 0.2 pext AVX512 (24 bit) 7.816 7.790 0.4 pext AVX512 (24 bit, early exit) 10.960 10.934 0.3 pext AVX512 v2 (24 bit) 7.752 7.722 0.4 pext AVX512 v2 (24 bit, early exit) 9.947 9.915 0.3 procedure time in cycles per byte speed-up average best any 32-bit mask pdep scalar 3.051 2.878 1.0 pdep AVX2 12.760 12.741 0.2 pdep AVX2 (early exit) 16.604 16.584 0.2 pdep AVX512 10.707 10.686 0.3 pdep AVX512 (early exit) 11.476 11.448 0.3 pdep AVX512 v2 8.677 8.636 0.3 pdep AVX512 v2 (early exit) 10.570 10.543 0.3 mask has no more than 6 bits pdep scalar 3.012 2.983 1.0 pdep AVX2 (6 bit) 3.012 2.990 1.0 pdep AVX2 (6 bit, early exit) 3.280 3.240 0.9 pdep AVX512 (6 bit) 3.162 3.110 1.0 pdep AVX512 (6 bit, early exit) 3.419 3.399 0.9 pdep AVX512 v2 (6 bit) 2.863 2.841 1.0 pdep AVX512 v2 (6 bit, early exit) 3.106 3.075 1.0 mask has no more than 8 bits pdep scalar 2.961 2.937 1.0 pdep AVX2 (8 bit) 3.332 3.295 0.9 pdep AVX2 (8 bit, early exit) 4.052 4.020 0.7 pdep AVX512 (8 bit) 3.431 3.394 0.9 pdep AVX512 (8 bit, early exit) 3.940 3.915 0.8 pdep AVX512 v2 (8 bit) 2.976 2.958 1.0 pdep AVX512 v2 (8 bit, early exit) 3.497 3.408 0.9 mask has no more than 16 bits pdep scalar 3.019 2.981 1.0 pdep AVX2 (16 bit) 5.505 5.481 0.5 pdep AVX2 (16 bit, early exit) 8.897 8.870 0.3 pdep AVX512 (16 bit) 4.782 4.758 0.6 pdep AVX512 (16 bit, early exit) 7.411 7.381 0.4 pdep AVX512 v2 (16 bit) 3.978 3.952 0.8 pdep AVX512 v2 (16 bit, early exit) 6.199 6.180 0.5 mask has no more than 24 bits pdep scalar 2.956 2.935 1.0 pdep AVX2 (24 bit) 9.169 9.155 0.3 pdep AVX2 (24 bit, early exit) 13.622 13.597 0.2 pdep AVX512 (24 bit) 8.199 8.159 0.4 pdep AVX512 (24 bit, early exit) 11.098 11.069 0.3 pdep AVX512 v2 (24 bit) 6.560 6.515 0.5 pdep AVX512 v2 (24 bit, early exit) 9.406 9.383 0.3 Source code Sample implementation is available at GitHub .'],
["notesen/2025-01-07-js-search.html", 'Building full-text search in Javascript', 'Building full-text search in Javascript Wojciech Mua Added on 2025-01-07 Contents Introduction Full-text search Indexing Searching Closing words Source code Introduction I dedicated the last few days of 2024 on refreshing my website. The project started around 2002, when the Internet was not widespread, there was no GitHub, Wikipedia or anything we know right now. Thus the website served also as a hosting platform for my open-source software. I created custom python software to maintain both the articles and software. In the meantime things evolved. I started to write my texts in English, and publish them more in a blog style (although, I\'m not a fan of the term \"blog\"), also GitHub allowed to easily distribute software. At some point of time my fancy system for static website become more cumbersome than helpful. The decision was simple: drop the old build system, create a new one, uncomplicated and tailored to my current needs --- focus only on publishing articles. A wise decision I made 20 years ago was picking reStructuedText to write texts. I prefer it over markdown. Not to mention that ReST allows to easily extend itself, which I found extremely handy . Long story short, the new system allowed me to introduce tags, to maintain texts in draft mode and, last but not least, to let make perform all boring tasks. But with the new build system, a new idea appeared: \"how about searching?\". Full-text search Text algorithms is something I enjoy, and had some experience with them . The first objective was obvious: no server-side programs! The website lives on my friend\'s servers, and I don\'t want to cause any troubles. (From time to time I grep the logs and keep seeing people trying to open wp-admin panel, or similar URLs.) Thus I needed a client-side solution. Quick googling for existing projects yield nothing that caught my attention. I decided to write from scratch everything, not use WASM (it was tempting, TBH) and not even use jQuery. The workflow I designed is quite simple (and fully automated, of course): The reStructuedText comes with tool converting .rst files into XML. Plain text is extracted from XML files using a python script. Then texts are indexed, and the index along the plain text is exported into JavaScript structures --- something what I called \"a database\". The website loads that prepared dataset plus some vanilla JavaScript code doing processing of user queries and displaying results. Indexing Indexing is solely based on trigrams. A trigram is a sequence of three letters; for instance the word \"letter\" contains the following trigrams: \"let\", \"ett\", \"tte\" and \"ter\". The trigrams approach is language agnostic, and also allow to catch partial matching. For example query \"conve\" would yield \"convex\" and \"convert\" matches. The process of indexing builds a map: trigram => set of document IDs having this trigram. Trigrams are always in lowercase and never contain spaces. Searching When we\'re searching, a query string is first split into words. Then each word is expanded into trigrams and the set trigrams is used to query the index. For each trigram we get the set of document IDs and calculate intersection with the current set of IDs. If some trigram does not exist at all, we have instantly zero hits. If the final set of IDs is not null, we search words in (lowercase) text of articles and also in their titles. Searching results are weighed using three factors: whether all words were found in given document or not; whether there\'s hit in the title; how many hits are there in text. It seems to quite a good solution, although for sure is not perfect. Closing words First of all, I\'m really surprised how pleasant was writing in JavaScript. Maybe it is a matter of maturity, but I didn\'t find anything blocking my progress. There\'s plenty of documentation, and the latests JavaScript versions offer a lot of nice features (like sets and maps). Probably I bumped into some JS odds, but... I used to be a professional C++ developer, JS is normal to me. Trigram searching is simple to implement and yields good results. I was trying to compress the text, but it appeared that the server already sends gzipped JS files. This removed more complexity from the flow. Source code Not on GitHub yet, but you can view it . And try it live'],
["notesen/2025-01-12-drawing-trees.html", 'Drawing trees', 'Drawing trees Wojciech Mua Added on 2025-01-12 Problem We have a tree of any degree and depth. Each node has assigned a bounding box of its graphical representation. We want to draw such data structure, taking into account geometry of nodes. Algorithm The algorithm to draw trees runs in two phases. In the first phase we group nodes by their depths . For each depth we calculate the maximum height and assign nodes at y coordinate. The y value is the sum of height of previous depths plus some horizontal spacing between each level. The second phase places horizontally the nodes at the given depth. We scan nodes by their depths, starting from the deepest level, up to the root; nodes are scanned left-to-right. The current node is moved to the right border of its predecessor, with some horizontal space, like node.x = prev.x + prev.width + x_space . Then, we calculate the x coordinate of node center: [...] If the node has children, we calculate the desired x coordinate [...] When [...] [...] undefined ). When [...] all subtress rooted on children nodes of: 1) the current node and 2) all its siblings to the right. We cannot move the deeper nodes to the left, as we assume these nodes are already correctly placed. On the other hand, there are not constraints to the right. Live demo Try algorithm on-line .'],
["notesen/2025-01-18-avx512-print-bin.html", 'AVX512: printing u64 as binary', 'AVX512: printing u64 as binary Wojciech Mua Added on 2025-01-18 Problem Printing 64-bit numbers in binary format can be done nicely with AVX-512 instructions. First, we populate each byte from the number into a separate 64-bit word of an AVX-512 register: Then, in each byte of 64-bit words we isolate i-th bit, where i is the byte position within a 64-bit word. Finally, we convert non-zero bytes into ASCII \'1\' (0x31) and zero bytes into ASCII \'0\' (0x30). This particular operation can be done in two different ways: converting non-zero bytes to value 1 using min operation and performing a non-masked addition: byte[i] = min(byte[i], 1) + 0x30 . building a bitmask in k-register and performing standard masked instructions, like: byte[i] = mask[i] ? 0x31 : 0x30 . These two methods do not differ in performance, just the first one does not use mask registers. Variant 1 Assembly output from GCC 14.1: Variant 2 Assembly output from GCC 14.1: Source code Sample implementation is available at GitHub .'],
["notesen/2025-01-18-simd-heap.html", 'SIMD binary heap operations', 'SIMD binary heap operations Wojciech Mua Added on 2025-01-18 Contents Introduction is_heap Experiments Ryzen 7 Skylake-X Ice Lake push_heap See also Source code Introduction Binary heap is a binary tree data structure having some interesting properties. One of them is an array-friendly memory layout, achieved by building (almost) complete binary tree. A binary heap keeps at index 0 the maximum value, or the minimum one depending on convention --- let\'s stick to maximum heaps . There is exactly one invariant: a child node, if exist, keep a value less than the parent node. For comparison, in the case of binary search trees, we have more strict rules: the left child keeps a smaller value than the parent\'s value, and the right child keeps a bigger value. A non-root node stored at index i have the parent node at index [...] [...] [...] In this text we cover two procedures related to heaps: is_heap --- checks if an array is proper heap, push_heap --- adds a new element to the heap, The procedure is_heap is vectorizable and using SIMD instructions brings profit. We also show that it is possible to define this function using forward iterators rather random iterators, as the C++ standard imposes. The procedure push_heap can be expressed with gather and scatter , but performance is terrible. For the sake of completeness, we show the AVX-512 implementation. There is also one more crucial method for heaps: removing the maximum value, pop_heap . However, it is difficult to vectorize, and benefits from vectorization would likely be worse than in the case of push_heap . is_heap The easiest approach to check if the given array is a proper heap is scanning the array from beginning, calculate the left and right children indices and then compare their values according to the invariant. We stop scanning, when both children indices are out of the array bounds. However, this algorithm is not suitable for vectorization. What we need is sequential scan over array. We need two pointers: one pointing parents and another pointing children nodes. The \"parent\" pointer start at index 0, and is incremented by 1. The \"children\" pointer nodes start at index 1, and is incremented by 2. Below is C++ template using the modified algorithm. What the typename argument suggests, this is suitable for forward iterators, while the standard C++ functions from <algorithm> expect random iterators. Below is a memory layout of a heap. We need to check if parents are greater than their children, that is: [...] [...] [...] [...] [...] [...] We can observe that a single parent node is used twice, thus our vectorized approach would work in the following manner: Load vector of parent nodes; let\'s assume vectors hold 8 elements. Load two vectors of child nodes. Double the parent nodes: each item appears them twice. Now both pairs p0 / c0 and p1 / c1 contain corresponding parent-child pairs, thus a plain vector comparison yield whether all pairs hold the relation parent-child. The vectorized AVX2 code follows this algorithm. The only downside of AVX2 is lack of comparison of unsigned 32-bit integers. Although it is possible to express relation less-or-equals with the min and equality: [...] Experiments The benchmark utility was compiled with -O3 -march=native and invoked with parameters ./benchmarks 1024 4096 8192 , where the parameters are input sizes. Benchmarked procedures Procedure Comments std standatd C++ std::is_heap with random access iterators fwd scalar scalar implementation of the approach using forward iterators rnd scalar reimplementation of std::is_heap with random access iterators fwd SSE SSE implementation of the approach using forward iterators fwd AVX2 AVX2 implementation of the approach using forward iterators fwd AVX-512 AVX-512 implementation of the approach using forward iterators Ryzen 7 Compiler: gcc (Debian 14.1.0-5) 14.1.0 CPU: AMD Ryzen 7 7730U with Radeon Graphics procedure time in cycles per byte speed-up average best Input size 1024 std 1.024 1.016 1.0 fwd scalar 0.454 0.449 2.3 rnd scalar 0.646 0.645 1.6 fwd SSE 0.229 0.215 4.7 fwd AVX2 0.142 0.137 7.4 Input size 4096 std 0.886 0.879 1.0 fwd scalar 0.451 0.439 2.0 rnd scalar 0.443 0.439 2.0 fwd SSE 0.169 0.166 5.3 fwd AVX2 0.103 0.098 9.0 Input size 8192 std 0.892 0.881 1.0 fwd scalar 0.452 0.439 2.0 rnd scalar 0.446 0.444 2.0 fwd SSE 0.168 0.166 5.3 fwd AVX2 0.101 0.098 9.0 Skylake-X Compiler: gcc (GCC) 11.2.0 CPU: Intel(R) Xeon(R) W-2104 CPU @ 3.20GHz procedure time in cycles per byte speed-up average best Input size 1024 std 2.529 2.509 1.0 fwd scalar 2.021 2.013 1.2 rnd scalar 1.033 1.026 2.4 fwd SSE 0.584 0.574 4.4 fwd AVX2 0.350 0.328 7.6 fwd AVX-512 0.286 0.276 9.1 Input size 4096 std 2.567 2.498 1.0 fwd scalar 2.008 2.000 1.2 rnd scalar 1.021 1.005 2.5 fwd SSE 0.547 0.541 4.6 fwd AVX2 0.289 0.280 8.9 fwd AVX-512 0.190 0.184 13.6 Input size 8192 std 2.566 2.497 1.0 fwd scalar 2.006 1.998 1.2 rnd scalar 1.011 1.001 2.5 fwd SSE 0.539 0.536 4.7 fwd AVX2 0.289 0.280 8.9 fwd AVX-512 0.175 0.164 15.2 Ice Lake Compiler: gcc (GCC) 13.3.1 20240611 (Red Hat 13.3.1-2) CPU: Intel(R) Xeon(R) Gold 6338 CPU @ 2.00GHz procedure time in cycles per byte speed-up average best Input size 1024 std 4.499 2.584 1.0 fwd scalar 1.576 1.096 2.4 rnd scalar 1.528 0.875 3.0 fwd SSE 0.976 0.543 4.8 fwd AVX2 0.551 0.297 8.7 fwd AVX-512 0.356 0.236 10.9 Input size 4096 std 4.497 2.725 1.0 fwd scalar 1.630 1.196 2.3 rnd scalar 1.531 1.123 2.4 fwd SSE 0.954 0.563 4.8 fwd AVX2 0.496 0.286 9.5 fwd AVX-512 0.228 0.143 19.1 Input size 8192 std 4.516 2.900 1.0 fwd scalar 1.555 1.211 2.4 rnd scalar 1.507 1.083 2.7 fwd SSE 0.965 0.620 4.7 fwd AVX2 0.475 0.355 8.2 fwd AVX-512 0.220 0.187 15.5 push_heap The procedure push_heap adds a new element to heap. We append the new value to the and of the array. We start from this index, and check whether the parent is greater. If it is, the heap invariant is hold, so no more work is needed. Otherwise, we swap the new item with the parent and recheck the swapped element with its new parent. In each iteration we go up, until we reach the root. The vectorized approach is based on the following observation: when we build a list of values from the new node one up to the root, then --- for a proper heap --- this list is sorted. Otherwise, we need to find position where to put this new value. Taking this form another angle, push_heap performs insertion sort on that list. For example, when we\'re adding 11-th element of value X to the heap show below, then its parents are at indices: 5, 2, and 0. Thus, we\'re considering a list [...] [...] [...] [...] [...] [...] Vectorized approach consists the following steps. Prepare list of indices. We start at index n : Perform gather using this list. Locate position where to insert the new value. Vector mask is converted into a bitmask ( 0b0011_1110 ) and the number of leading zeroes uniquely identifies the shuffle pattern. We load a precomputed shuffle pattern and perform shuffling. Finally we scatter the vector to initial positions in the heap. Repeat when the new item was placed on the last position after shuffle. First of all, this algorithm is not suitable for AVX2, as AVX2 does not support scatters. The AVX-512 implementation is shown below. This cannot be faster than a scalar implementation. In the worst case a scalar code execute [...] The vectorized code needs to construct vector of indices, than at least one gather and scatter which are slow. My experiments on quite decent Ice Lake machine showed 10x slowdowns, which makes this approach unpractical (although it is nice). See also %%%ref:2018-04-11-simd-is-sorted.rst%%% Source code Sample implementation is available at GitHub .'],
["notesen/2025-01-21-loongarch64-highlights.html", 'LoongArch64 subjective higlights', 'LoongArch64 subjective higlights Wojciech Mua Added on 2025-01-19 Introduction I get back to work on simdutf recently, and noticed that the library gained support for LoongArch64 . This is a custom design and custom ISA by Loongson from China. They provide documentation for scalar ISA, but not for the vector extension. Despite that, GCC, binutils, QEMU and other tools already support the ISA. To our luck, Jiajie Chen did an impressive work of reverse engineering the vector stuff and published results online as The Unofficial LoongArch Intrinsics Guide . LoongArch comes with two vector extensions: LSX, having 128-bit vector registers, LSAX, having 256-bit vector registers. These extensions are similar, especially most instructions present in LSX exist in LSAX. According to the Wikipedia entry, the ISA is mixture of RISC-V and MIPS. ISA supports both integer and floating point instructions. There\'s support for 8-bit, 16-bit, 32-bit, 64-bit and also 128-bit integers. Floating point instructions cover single precision, double precision and half precision numbers. Comparisons yield byte-masks, similarly to SSE. Integer instructions are defined for most integer types, this makes the ISA regular. My impression is that the ISA is well designed, but have not vectorized any code for that architecture. Below is the list of features I found interesting while browsing the intrinsics guide. Personal highlights Conditional branches It\'s possible to control the program flow based on two predicates: if any element of a vector is zero, if all elements of a vector are non-zero. Similar solution exists in SSE ( PTEST ), but it works on the whole vector, not vector elements. Bit operations There are vector instructions that allow to alter individual bits of a word: set a bit, reset a bit, toggle a bit. That\'s just cool (easily doable in SIMD ISAs having variable shifts). Counting bits The following counting ops are defined: counting leading zeros, counting leading ones, population count (counting ones). Counting leading zeros and population count are present only in AVX-512. 128-bit arithmetic There are addition and subtraction for 128-bit numbers. Very nice! There is a selection of any 64-bit subword from a 128-bit word. Integer absolute values There are two instructions related to absolute values. calculate absolute value of difference: the sum of absolute values: Widening addition Add even (or odd) element of given width and produce vector of wider elements. For instance we may add two vectors of 32-bit elements and get a vector of 64-bit sums. Integer division There are an integer division & modulo of 8-, 16-, 32- and 64-bit integers. Logical operations There is no ternary logic, but the set of binary operations is rich: and or xor and-not ( a and not b ) not-or ( not (a or b) ) or-not ( a or not b) ) There is also a bit-select operation: (a and c) or (b and not c) . Accessing individual elements of vector The following operations related to elements of vectors are possible: Store into memory the selected element; element index is given as an immediate . Copy i-th element from source vector to j-th element of destination; again, indices i & j are encoded as an immediate . Broadcast selected element; in this case index is read from generic purpose register. Integer clamping It\'s possible to clamp integer values, both signed and unsigned, to the given range. The range is given as power of two: in the case of unsigned number the range is given as [...] [...] n is given as an immediate . Shuffling In-register shuffling reads data from two registers , it\'s something we know from AMD XOP extension. 4-byte-lanes shuffling There\'s an instruction that allows to set arbitrary permutation of bytes within 4-byte lanes. The permutation is given as an immediate . Horizontal integer scanning The instruction finds the first negative number and stores its index to the selected lane of destination. That is a pretty complex one. Integer copy sign The instruction performs the following operation: If arguments a and b are the same vector, this instruction calculate the absolute value of the vector elemnets. Broadcast immediate to vector There is a powerful instruction that allows to initialize a vector from an immediate: broadcast an 8-bit immediate to all bytes; broadcast a sign-extended 10-bit immediate as 16-, 32- or 64-bit elements; broadcast an 8-bit immediate to 16-bit elements, broadcast an 8-bit immediate shifted left by 8 bits to 16-bit elements; broadcast an 8-bit immediate to 32-bit elements, broadcast an 8-bit immediate shifted left by 8 bits to 32-bit elements; broadcast an 8-bit immediate shifted left by 16 bits to 32-bit elements; broadcast an 8-bit immediate shifted left by 24 bits to 32-bit elements; broadcast an 8-bit immediate shifted left by 8 bits and or-ed with 0xff to 32-bit elements ( (imm << 8) | 0xff ); broadcast an 8-bit immediate shifted left by 16 bits and or-ed with 0xffff to 32-bit elements ( (imm << 16) | 0xffff ); convert an 8-bit value into a byte mask (64-bit value) and broadcast that value; convert an 8-bit immediate into a floating-point number (single or double precision) in range [...] See also %%%ref:2024-11-09-riscv-vector-extension.rst%%%'],
["notesen/2025-01-26-utf32-change-case.html", 'Change case of UTF-32-encoded strings', 'Change case of UTF-32-encoded strings Wojciech Mua Added on 2025-01-25 Contents Introduction Vectorization How to speed-up case conversion? Solution 1 --- huge lookup table Solution 2 --- compressed lookup table Introduction Changing letter case is something that appear handy in many situations, for instance input normalization, parsing, and other text-related tasks. Is changing case of Unicode-encoded string a simple task? In theory it is not difficult. If we need to describe this process using simple English, we need to determine whether given character has a upper- or lowercase variant and simply use that variant. Unlike plain ASCII, where we have only a single range of character codes that can be upper/lowercase (\'a\'..\'z\' or \'A\'..\'Z\'), Unicode comes with way more such ranges or even single characters randomly placed in the code space. Additionally, there are cases where uppercase or lowercase version of the given character is not a single character, but some string (two or three Unicode points). For example uppercase \"Latin small ligature ffi\" (  ) is a three-character string \"FFI\". How many characters are subject of case change 1 code point 2 code points 3 code points total uppercase 1423 86 16 1525 lowercase 1432 1 0 1433 While the Unicode codes span the range 0..0x10ffff , we can check that only characters up to 0x1ffff may have different codes due to change case. Additionaly, as the table shows, the density of characters that are sensitive to case is rather low. They make only ~2% of the limited range. Vectorization At Sneller we have a fully vecorized query engine, where each lane of an AVX-512 register get a single portion of record. We processed in parallel 16 or 8 records. Vectorization of case changing was straitforward, we couldn\'t assume anything about record contents. The only optimization was checking whether the characters in a register was ASCII, so we skip complex part. However, in the case of scalar interfaces, where we have to process a single string, things are bit different. We still process the string, but in chunks of a vector register width. An obvious optimization, which is present almost everywhere in vectorized code of simdutf , is checking whether the register contains only ASCII characters. If it\'s true, we have a fast-path --- in the case of changing case, that\'s a very simple, conditional xor. However, when at least one character is outside the ASCII range, we\'re getting back to slow path. How to speed-up case conversion? A common fast-path is special handling runs of ASCII characters. Whenever we detect that a group of adjacent characters (that fit in a GPR or SIMD register) are ASCII ones, we use simple ASCII rule to change character. Otherwise, we have a difficult problem. As we can see, the density of characters that can be altered is not big. However, there is no a cheap way to determine if all characters in a group can be simply copied, without changing case. We may think about Solution 1 --- huge lookup table That means, a table of size 131072 entries can handle single conversion. If an entry of the lookup table has 4 bytes, that table spans 512kB of data. That\'s a huge amount of memory, way bigger than usual L1 cache sizes. Solution 2 --- compressed lookup table'],
["notesen/2025-02-02-utf32-change-case.html", 'Change case of UTF-32-encoded strings', 'Change case of UTF-32-encoded strings Wojciech Mua Added on 2025-02-02 Contents Introduction Solutions overview Rely on a compiler Perfect hashing function Use lookup tables Multi-character conversions results Vectorization Possible improvement? Implementations Solution 1 --- huge lookup tables Solution 2 --- compressed lookup table (variant #1) Solution 3 --- compressed lookup tables (variant #2) Solution 4 --- compressed lookup tables with diffs (variant #3) Vectorization of variant #3 Experiments Ryzen 7 Ice Lake Conclusions Source code Appendixes A --- Codepoints of letters having different cases B --- Lowercase letters placement C --- Uppercase letters placement D --- Compressed tables --- variant 1 Introduction Changing letters case is something that appear handy in many situations, for instance input normalization, parsing, and other text-related tasks. When we are dealing with ASCII, such conversion is straightforward. We check if a character code lies in the range \'a\' .. \'z\' (or \'A\' .. \'Z\') and when its true, we toggle the 5th bit (0x20). But in the case of Unicode-encoded strings it is not that simple. There are many code points having upper- or lowercase counterparts, and they are not placed in any regular way in the Unicode code space. Although we may identify shorter or longer ranges of such codes, similarly to Latin letters in ASCII, this does not help much. See appendixes A , B and C , where we visualize how these characters are located. Additionally, there are cases where an uppercase or lowercase version of the given character is not a single character, but a string. These strings are short, have two or three Unicode points. For example the uppercase of \"Latin small ligature ffi\" () is a three-character string \"FFI\". How many characters are subject of case change (Unicode 15.0.0) 1 code point 2 code points 3 code points total uppercase 1423 86 16 1525 lowercase 1432 1 0 1433 How many characters are subject of case change (Unicode 13.0.0) 1 code point 2 code points 3 code points total uppercase 1383 86 16 1485 lowercase 1392 1 0 1393 There is one thing that makes our task easier: while the Unicode codes span the range 0..0x10ffff , we can check that only characters up to 0x1ffff may have different codes due to case change. The outline of case change algorithm for UTF-32 encoded strings can be written as follows. Solutions overview There are different ways to implement this algorithm, we list a selection of them. Rely on a compiler We may auto-generate a huge switch statement and let the compiler do all the hard job. It\'s not naive approach, as compilers are getting better and better. Refer to a great presentation Hans Wennborg: C++ switch statements under the hood in LLVM . Perfect hashing function Perfect hashing functions are really great (see %%%ref:2023-04-30-lookup-in-strings.rst%%%), although they do not fit well to this particular problem. Lookup in a hash table requires two steps: Calculate the value of our perfect hash function --- this yields the index to the hash table, Fetch the entry from the table --- the entry contains the key (a character code) and a value (an upper- or lowercase code). We need to check if the input value equals to the key and only then there\'s a hit. The first problem is finding a cheap perfect hash function, as we have to evaluate it for every character. We tried to find something like ((character code * M) >> N) & mask , where M , N and mask are compile time constants. The best hash function returned value ~8100. This means hash table size would be approx 126kB, while we can reduce auxiliary table sizes to ~26kB using simpler techniques. The second problem is related to vectorization --- fetching table entries require using VPGATHERDD . Our input are vectors of 4-byte character codes, but the size of hash table entry is 8 bytes. Thus we would need to issue gather instruction twice: either to fetch separately two halves of entries, or fetch 8-byte entries for characters at odd/even indices of the input. Use lookup tables Lookup tables addressed directly by the character code seems to be the best option. An obvious solution is to have tables of size 0x1ffff, that is 131\'072 entries. Than the lookup costs us only check the range and a single memory fetch. The drawback is size of a single table: 131\'072 * 4 bytes = 524\'288 bytes. 512kB exceeds usual sizes of L1 cache and cache misses may kill performance. Of course, we can come up with scenarios where this is not a problem. For example, if we\'re dealing with texts written in one language, we effectively will use only a small portion of the tables. But when we cannot assume anything about the text source, having 1MB of auxiliary tables does not seem to be a right solution. Also, when case changing is only a part of bigger system, huge lookup tables might be a problem. It is possible to compress lookup tables. We know that only a small fraction of codes are being altered during case changing, thus we can rule out a huge number of character codes. We split a character code into higher and lower parts. The higher order bits are used to distinguish between ranges of codes having none or some characters to change. If the characters from the given range are not changed, we simply do not save that range. The lower part of character code is used as a local offset within the selected range. A simplified algorithm is shown below. This solution also requires two lookups, so we are having exactly the same problem as in the case of perfect hashing function --- two gathers. Not ideally, but compression allows us to shave significant portions of lookup tables when compared to the naive solution. We said that a lookup table (single or compressed) is addressed by character codes, but what is stored in the table? We may store there UTF-32 uppercase or lowercase codes directly. However, we may also store there already encoded UTF-8 characters, when the UTF-8 is desired encoding. Another option is storing symmetrical differences (xor) between the source and destination codes. For uppercase we have 139 distinct differences, for lowercase 124. That is significantly fewer than the actual number of codes (1525 and 1433, respectively). The conversion that uses differences requires just additional xor operation. And as we learn later on, this allows some nice tricks, including replacing one of memory gathers with an in-register shuffle (yes, PSHUFB !). Multi-character conversions results We completely skip the problem of multi-character conversion results, assuming that tables would store either 4-byte values (for plain and compressed lookup tables) or 8-byte entries (for hash tables). Since these multi-character strings appear relative rare, we propose to handle them separately. For these cases we store code 0x8000_0000 --- that is: a negative value , easy to detect. If a negative number is the result of conversion, we are switching to the slowest path. The slowest path may be done in different ways. When the lookup step yields a character code (not differences) then we may encode in the negative number more information. We need a separate auxiliary table that keep all resulting strings; just for remind, strings have two or three characters. Our negative number keeps also the length and the exact offset to the auxiliary table, as follows: 0x8000_0000 + offset for 2-byte strings, 0xc000_0000 + offset for 3-byte strings. The expression code >> 30 yields the length, and code & 0xff the offset. A single byte for offset is enough, as the total length of the auxiliary table is [...] A scalar conversion can be written as: Vectorization If we go for lookup tables or perfectly-hashed tables, we need to use the gather instruction. This instruction is available only in AVX and AVX-512 extensions of the Intel ISAs. The AVX2 version of gather fetches data for all vector elements. The AVX-512 version of gather uses mask, and it does not issue memory fetches for inactive elements, so presumably might be faster in certain scenarios. A common optimization, which is present almost everywhere in vectorized code of simdutf project , is checking whether a SIMD register contains only ASCII characters. This check is inexpensive, we need to test if all character codes are less than 128. When it is true, we choose a fast path --- the fast path for changing case requires only two comparisons and conditional xor. However, when at least one character is outside the ASCII range, we are forced to use a slower path. Possible improvement? When we hit the slow path, we might want to check whether any of the characters from SIMD registers would change. When nothing would change, we simply could copy the register contents to the output. As the pictures in Appendix B and C suggest, there are many ranges of characters that are not altered during case changing. We may use higher order bits of code points to identify these ranges and avoid the slow path. Unfortunately, it doesn\'t work well in real world scenarios. We used exactly the same datasets as the simdutf project: the Wikipedia article about the Mars in various languages. The languages are: Arabic, Chinese, Czech, English, Esperanto, French, German, Greek, Hebrew, Hindi, Japanese, Korean, Persian, Portuguese, Russian, Thai, Turkish and Vietnamese. In our evaluation we process 8-character blocks of the input (eight UTF-32 characters fit in an AVX2 register). A block is first checked for ASCII characters. If there are some non-ASCII characters, we perform either uppercase of lowercase transformation on the block. The following table summarizes the experiment. The column \"ASCII\" says what fraction of the input blocks went through the fast path. The last two columns: \"changed case\" and \"not changed\" show the slow path outcome --- the fraction of blocks that were changed or not. As we can observe, in the case of European languages the majority of blocks is getting changed, while in Asian languages almost nothing got modified. This results make the discussed optimization pointless. dataset block size blocks ASCII changed case not changed arabic 8 28774 50.5% 3.1% 96.9% chinese 8 9101 58.1% 11.2% 88.8% czech 8 11363 63.3% 96.4% 3.6% english 8 22422 98.0% 63.0% 37.0% esperanto 8 7180 89.7% 92.0% 8.0% french 8 32883 79.4% 92.7% 7.3% german 8 16907 88.7% 86.7% 13.3% greek 8 9364 40.6% 98.1% 1.9% hebrew 8 8747 29.0% 5.1% 94.9% hindi 8 13881 39.0% 6.0% 94.0% japanese 8 6257 52.3% 11.9% 88.1% korean 8 5032 57.6% 13.6% 86.4% persan 8 7397 50.4% 7.8% 92.2% portuguese 8 19966 82.9% 91.7% 8.3% russian 8 24145 30.2% 95.0% 5.0% thai 8 20747 44.0% 5.9% 94.1% turkish 8 14747 66.9% 98.4% 1.6% vietnamese 8 20975 44.6% 98.3% 1.7% Implementations Solution 1 --- huge lookup tables This is the first approach --- use single, 512kB tables. To handle multi-character strings we used auxiliary lookup table, as discussed in the previous section . The scalar code performing lookup is shown below. The input is UTF-32-encoded string, n is its length. The output should be big enough ( n*3 is the safest & simplest to obtain size). The code is rather straightforward, the only unusual thing is marking branches with likely / unlikely (wrappers for __builtin_expect ). This moved the handling of multi-character replacements out of the main loop. In the case of lowercase operation, there is only one multi-character replacement, it can be handled directly. But it might not be a good solution, and better use table-based one. In the introduction we showed that the characters having different cases are added to the Unicode standard. Solution 2 --- compressed lookup table (variant #1) This section describes the solution we used at Sneller . We purposely omitted the mutli-character replacements as too complex for our needs at the moment of creating the product. The values in range 0 .. 0x1_ffff can be saved on 17 bits. We split the 17-bit character code into two parts: higher 9-bit ( row ), and lower 8-bit ( column ). For each of 512 possible higher order bit combinations, we collect all 256 lower- or uppercase character codes; we are collecting codes for range 0x000_00 .. 0x000_ff , then 0x001_00 .. 0x001_ff , up to the range 0x1ff_00 .. 0x1ff_ff . Then, for each group of 256 character codes ( rows ), we find the first and the last column where character codes got changed. We save only this range of characters, alongside the first and last index. Note that not all characters within a range are subject of case change --- this is an additional storage cost we pay for simplicity. Thus, the first level lookup contains 512 records with: offset to the second-level lookup table, 8 bits for first index, 8 bits for last index, These three fields fit in a single 4-byte word. For unused entries we set an invalid range, having [...] appendix D . The second level lookup contains arrays of 4-byte elements. At Sneller we stored UTF-8 encoded strings, as internally we used that encoding. In the experiments for this article, we store UTF-32 characters. Auxiliary table sizes table entry size [bytes] # entries total [bytes] first level table for uppercase 4 2875 11500 second level table for uppercase 4 490 1960 first level table for lowercase 4 2749 10996 second level table for lowercase 4 490 1960 auxiliary table for multi-character replacements (uppercase only) 4 220 880 total 27296 (~27kB) Below is shown the implementation. Solution 3 --- compressed lookup tables (variant #2) A simplification to the above method is storing the whole row, without dealing with the first & last index and logic required to handle them: a condition and more complex offset calculation. The following table shows the analysis of lookup table size depending on high/low bits split. We will get the smallest tables for 11 higher/6 lower bits, or 10 higher/7 lower bits. They are approx ~50kB, which is ~2 times more than in the compressed table. We may store the first level lookup on 16-bit values, that would save 2-3kB, but it\'s negligible amount of memory. # higher bits lower bits row size [bytes] uppercase 1st level entries uppercase 2nd level entries uppercase total size [bytes] lowercase 1st level entries lowercase 2nd level entries lowercase total size [bytes] total size [bytes] 1 16 1 8 62,625 1,067 259,036 62,608 1,011 258,520 517,556 2 15 2 16 31,312 569 134,352 31,304 530 133,696 268,048 3 14 3 32 15,656 305 72,384 15,652 279 71,536 143,920 4 13 4 64 7,828 168 42,064 7,826 154 41,160 83,224 5 12 5 128 3,914 98 28,200 3,913 86 26,660 54,860 6 11 6 256 1,957 60 23,188 1,956 55 21,904 45,092 7 10 7 512 978 42 25,416 978 35 21,832 47,248 8 9 8 1024 489 27 29,604 489 23 25,508 55,112 9 8 9 2048 244 19 39,888 244 17 35,792 75,680 10 7 10 4096 122 16 66,024 122 14 57,832 123,856 11 6 11 8192 61 13 106,740 61 12 98,548 205,288 12 5 12 16384 30 9 147,576 30 9 147,576 295,152 13 4 13 32768 15 7 229,436 15 7 229,436 458,872 14 3 14 65536 7 6 393,244 7 6 393,244 786,488 15 2 15 131072 3 4 524,300 3 4 524,300 1,048,600 16 1 16 262144 1 2 524,292 1 2 524,292 1,048,584 Solution 4 --- compressed lookup tables with diffs (variant #3) Another variant of compressed table, but stores character differences (xor) rather than raw code points. As we have already seen, the number of distinct difference values is significantly lower than character codes. And it appeared that many rows repeat, they allows even better compression. The table below also shows that we never get more than 255 distinct rows, thus the 1st level lookup table can be an array of bytes. And for the best character code split we are getting comparable table sizes to the first, more sophisticated variant #1 . # higher bits lower bits uppercase 1st level entries uppercase 2nd level entries uppercase total size [bytes] lowercase 1st level entries lowercase 2nd level entries lowercase total size [bytes] total size [bytes] 1 16 1 65,536 151 66,744 65,536 134 66,608 133,352 2 15 2 32,768 141 35,024 32,768 120 34,688 69,712 3 14 3 16,384 127 20,448 16,384 105 19,744 40,192 4 13 4 8,192 102 14,720 8,192 87 13,760 28,480 5 12 5 4,096 82 14,592 4,096 69 12,928 27,520 6 11 6 2,048 58 16,896 2,048 53 15,616 32,512 7 10 7 1,024 43 23,040 1,024 36 19,456 42,496 8 9 8 512 28 29,184 512 24 25,088 54,272 9 8 9 256 20 41,216 256 18 37,120 78,336 10 7 10 128 17 69,760 128 15 61,568 131,328 11 6 11 64 14 114,752 64 13 106,560 221,312 12 5 12 32 10 163,872 32 10 163,872 327,744 13 4 13 16 8 262,160 16 8 262,160 524,320 14 3 14 8 7 458,760 8 7 458,760 917,520 15 2 15 4 4 524,292 4 4 524,292 1,048,584 16 1 16 2 2 524,290 2 2 524,290 1,048,580 Below is shown the actual implementation of AVX2 procedure, using 10 higher and 7 lower bits of character code. There\'s also shown the fast path for ASCII conversion, which is basically the same in all vectorized procedures. Vectorization of variant #3 All compressed variants have to use two memory gather instructions. But in the variant #3 we limited the range of offsets to bytes. Thus we can use VPSHUFB (AVX2) or VPERMI2B (AVX-512) to implement the first level lookup. AVX2 variant #4 Use 5 higher bits (row #12 in the above table): this requires two VPSHUFB invocations plus some merging. Auxiliary tables size is 320kB. The lookup code is shown below. AVX2 variant #5 Use 6 higher bits (row #11 in the above table): this requires four VPSHUFB invocations plus merging. Auxiliary tables size is 216kB. The lookup code is shown below. These four VPSHUFB are not that expansive, but the whole merging and masking make the whole procedure complex. AVX-512 variant #6 Use 7 higher bits (row #10 in the above table): this requires a single invocation of VPERMI2B . Auxiliary tables size is 128kB. Experiments The benchmark utility was compiled with -O3 -march=native . We tested only uppercase conversion, as lowercase code is almost the same. Benchmarked procedures Procedure Comments C++ switch Compiler-generated switch scalar single lookup use a single lookup table AVX2 single lookup as above, but vectorized AVX2 compressed lookup (variant #3) variant #3 AVX2 compressed lookup (variant #4) variant #4 AVX2 compressed lookup (variant #5) variant #5 AVX-512 compressed lookup (variant #6) variant #6 Ryzen 7 Compiler: gcc (Debian 14.1.0-5) 14.1.0 CPU: AMD Ryzen 7 7730U with Radeon Graphics procedure time in cycles per char speed-up average best dataset arabic C++ switch 6.212 6.138 0.1 scalar single lookup 0.903 0.897 1.0 AVX2 single lookup 0.522 0.511 1.8 AVX2 compressed lookup (variant #2) 0.949 0.942 1.0 AVX2 compressed lookup (variant #3) 1.007 0.990 0.9 AVX2 compressed lookup (variant #4) 0.654 0.636 1.4 AVX2 compressed lookup (variant #5) 0.789 0.783 1.1 dataset chinese C++ switch 5.755 5.668 0.2 scalar single lookup 0.901 0.892 1.0 AVX2 single lookup 0.502 0.470 1.9 AVX2 compressed lookup (variant #2) 0.821 0.807 1.1 AVX2 compressed lookup (variant #3) 0.870 0.859 1.0 AVX2 compressed lookup (variant #4) 0.598 0.575 1.6 AVX2 compressed lookup (variant #5) 0.696 0.686 1.3 dataset czech C++ switch 9.509 9.367 0.1 scalar single lookup 0.891 0.885 1.0 AVX2 single lookup 0.468 0.437 2.0 AVX2 compressed lookup (variant #2) 0.808 0.790 1.1 AVX2 compressed lookup (variant #3) 0.860 0.840 1.1 AVX2 compressed lookup (variant #4) 0.581 0.558 1.6 AVX2 compressed lookup (variant #5) 0.683 0.665 1.3 dataset english C++ switch 9.114 9.016 0.1 scalar single lookup 0.889 0.883 1.0 AVX2 single lookup 0.268 0.205 4.3 AVX2 compressed lookup (variant #2) 0.326 0.323 2.7 AVX2 compressed lookup (variant #3) 0.328 0.325 2.7 AVX2 compressed lookup (variant #4) 0.263 0.261 3.4 AVX2 compressed lookup (variant #5) 0.321 0.319 2.8 dataset esperanto C++ switch 9.649 9.532 0.1 scalar single lookup 0.890 0.883 1.0 AVX2 single lookup 0.280 0.260 3.4 AVX2 compressed lookup (variant #2) 0.449 0.440 2.0 AVX2 compressed lookup (variant #3) 0.456 0.447 2.0 AVX2 compressed lookup (variant #4) 0.350 0.343 2.6 AVX2 compressed lookup (variant #5) 0.419 0.411 2.1 dataset french C++ switch 9.592 9.478 0.1 scalar single lookup 0.890 0.883 1.0 AVX2 single lookup 0.625 0.600 1.5 AVX2 compressed lookup (variant #2) 0.864 0.851 1.0 AVX2 compressed lookup (variant #3) 0.791 0.767 1.2 AVX2 compressed lookup (variant #4) 0.673 0.650 1.4 AVX2 compressed lookup (variant #5) 0.746 0.726 1.2 dataset german C++ switch 10.109 10.017 0.1 scalar single lookup 0.899 0.895 1.0 AVX2 single lookup 0.309 0.290 3.1 AVX2 compressed lookup (variant #2) 0.499 0.488 1.8 AVX2 compressed lookup (variant #3) 0.495 0.487 1.8 AVX2 compressed lookup (variant #4) 0.384 0.372 2.4 AVX2 compressed lookup (variant #5) 0.450 0.439 2.0 dataset greek C++ switch 9.680 9.591 0.1 scalar single lookup 0.892 0.884 1.0 AVX2 single lookup 0.565 0.550 1.6 AVX2 compressed lookup (variant #2) 1.027 1.016 0.9 AVX2 compressed lookup (variant #3) 1.091 1.078 0.8 AVX2 compressed lookup (variant #4) 0.708 0.689 1.3 AVX2 compressed lookup (variant #5) 0.858 0.845 1.0 dataset hebrew C++ switch 5.685 5.644 0.2 scalar single lookup 0.891 0.884 1.0 AVX2 single lookup 0.619 0.600 1.5 AVX2 compressed lookup (variant #2) 1.171 1.160 0.8 AVX2 compressed lookup (variant #3) 1.265 1.252 0.7 AVX2 compressed lookup (variant #4) 0.780 0.770 1.1 AVX2 compressed lookup (variant #5) 0.954 0.944 0.9 dataset hindi C++ switch 6.262 6.211 0.1 scalar single lookup 0.889 0.884 1.0 AVX2 single lookup 0.550 0.534 1.7 AVX2 compressed lookup (variant #2) 1.033 1.023 0.9 AVX2 compressed lookup (variant #3) 1.116 1.105 0.8 AVX2 compressed lookup (variant #4) 0.686 0.678 1.3 AVX2 compressed lookup (variant #5) 0.865 0.856 1.0 dataset japanese C++ switch 5.423 5.305 0.2 scalar single lookup 0.894 0.887 1.0 AVX2 single lookup 0.521 0.488 1.8 AVX2 compressed lookup (variant #2) 0.877 0.868 1.0 AVX2 compressed lookup (variant #3) 0.950 0.937 0.9 AVX2 compressed lookup (variant #4) 0.635 0.618 1.4 AVX2 compressed lookup (variant #5) 0.754 0.746 1.2 dataset korean C++ switch 6.466 6.404 0.1 scalar single lookup 0.887 0.883 1.0 AVX2 single lookup 0.478 0.456 1.9 AVX2 compressed lookup (variant #2) 0.821 0.807 1.1 AVX2 compressed lookup (variant #3) 0.883 0.868 1.0 AVX2 compressed lookup (variant #4) 0.614 0.597 1.5 AVX2 compressed lookup (variant #5) 0.711 0.700 1.3 dataset persan C++ switch 6.121 6.063 0.1 scalar single lookup 0.887 0.883 1.0 AVX2 single lookup 0.468 0.458 1.9 AVX2 compressed lookup (variant #2) 0.889 0.878 1.0 AVX2 compressed lookup (variant #3) 0.946 0.941 0.9 AVX2 compressed lookup (variant #4) 0.607 0.597 1.5 AVX2 compressed lookup (variant #5) 0.751 0.745 1.2 dataset portuguese C++ switch 9.663 9.550 0.1 scalar single lookup 0.889 0.883 1.0 AVX2 single lookup 0.372 0.349 2.5 AVX2 compressed lookup (variant #2) 0.693 0.674 1.3 AVX2 compressed lookup (variant #3) 0.582 0.565 1.6 AVX2 compressed lookup (variant #4) 0.439 0.416 2.1 AVX2 compressed lookup (variant #5) 0.524 0.501 1.8 dataset russian C++ switch 9.452 9.389 0.1 scalar single lookup 0.888 0.884 1.0 AVX2 single lookup 0.607 0.589 1.5 AVX2 compressed lookup (variant #2) 1.158 1.143 0.8 AVX2 compressed lookup (variant #3) 1.246 1.233 0.7 AVX2 compressed lookup (variant #4) 0.766 0.755 1.2 AVX2 compressed lookup (variant #5) 0.936 0.924 1.0 dataset thai C++ switch 5.738 5.682 0.2 scalar single lookup 0.886 0.883 1.0 AVX2 single lookup 0.535 0.518 1.7 AVX2 compressed lookup (variant #2) 1.019 1.007 0.9 AVX2 compressed lookup (variant #3) 1.055 1.045 0.8 AVX2 compressed lookup (variant #4) 0.687 0.676 1.3 AVX2 compressed lookup (variant #5) 0.831 0.820 1.1 dataset turkish C++ switch 9.544 9.419 0.1 scalar single lookup 0.892 0.885 1.0 AVX2 single lookup 0.433 0.406 2.2 AVX2 compressed lookup (variant #2) 0.866 0.825 1.1 AVX2 compressed lookup (variant #3) 0.794 0.768 1.2 AVX2 compressed lookup (variant #4) 0.538 0.519 1.7 AVX2 compressed lookup (variant #5) 0.641 0.618 1.4 dataset vietnamese C++ switch 8.915 8.839 0.1 scalar single lookup 0.898 0.893 1.0 AVX2 single lookup 0.542 0.520 1.7 AVX2 compressed lookup (variant #2) 0.973 0.958 0.9 AVX2 compressed lookup (variant #3) 1.062 1.047 0.9 AVX2 compressed lookup (variant #4) 0.654 0.640 1.4 AVX2 compressed lookup (variant #5) 0.841 0.817 1.1 Ice Lake Compiler: gcc (GCC) 13.3.1 20240611 (Red Hat 13.3.1-2) CPU: Intel(R) Xeon(R) Gold 6338 CPU @ 2.00GHz procedure time in cycles per char speed-up average best dataset arabic C++ switch 8.124 8.006 0.2 scalar single lookup 1.412 1.408 1.0 AVX2 single lookup 1.295 1.284 1.1 AVX2 compressed lookup (variant #2) 2.902 2.893 0.5 AVX2 compressed lookup (variant #3) 3.051 3.042 0.5 AVX2 compressed lookup (variant #4) 1.349 1.340 1.1 AVX2 compressed lookup (variant #5) 1.433 1.422 1.0 AVX-512 compressed lookup (variant #6) 0.822 0.815 1.7 dataset chinese C++ switch 7.618 7.426 0.2 scalar single lookup 1.414 1.406 1.0 AVX2 single lookup 1.102 1.074 1.3 AVX2 compressed lookup (variant #2) 2.462 2.449 0.6 AVX2 compressed lookup (variant #3) 2.591 2.580 0.5 AVX2 compressed lookup (variant #4) 1.164 1.150 1.2 AVX2 compressed lookup (variant #5) 1.233 1.215 1.2 AVX-512 compressed lookup (variant #6) 0.771 0.756 1.9 dataset czech C++ switch 12.857 12.738 0.1 scalar single lookup 1.406 1.400 1.0 AVX2 single lookup 1.344 1.301 1.1 AVX2 compressed lookup (variant #2) 2.161 2.147 0.7 AVX2 compressed lookup (variant #3) 2.317 2.290 0.6 AVX2 compressed lookup (variant #4) 1.559 1.493 0.9 AVX2 compressed lookup (variant #5) 1.712 1.457 1.0 AVX-512 compressed lookup (variant #6) 0.677 0.661 2.1 dataset english C++ switch 19.209 18.990 0.1 scalar single lookup 2.276 2.263 1.0 AVX2 single lookup 0.895 0.873 2.6 AVX2 compressed lookup (variant #2) 0.971 0.935 2.4 AVX2 compressed lookup (variant #3) 0.994 0.982 2.3 AVX2 compressed lookup (variant #4) 0.920 0.904 2.5 AVX2 compressed lookup (variant #5) 0.934 0.918 2.5 AVX-512 compressed lookup (variant #6) 1.946 1.934 1.2 dataset esperanto C++ switch 12.732 12.528 0.1 scalar single lookup 1.407 1.400 1.0 AVX2 single lookup 0.501 0.479 2.9 AVX2 compressed lookup (variant #2) 0.807 0.799 1.8 AVX2 compressed lookup (variant #3) 0.874 0.866 1.6 AVX2 compressed lookup (variant #4) 0.579 0.570 2.5 AVX2 compressed lookup (variant #5) 0.608 0.590 2.4 AVX-512 compressed lookup (variant #6) 1.090 1.075 1.3 dataset french C++ switch 12.895 12.731 0.1 scalar single lookup 1.422 1.414 1.0 AVX2 single lookup 1.877 1.825 0.8 AVX2 compressed lookup (variant #2) 2.326 2.273 0.6 AVX2 compressed lookup (variant #3) 2.376 1.594 0.9 AVX2 compressed lookup (variant #4) 1.338 1.286 1.1 AVX2 compressed lookup (variant #5) 1.431 1.405 1.0 AVX-512 compressed lookup (variant #6) 1.109 1.086 1.3 dataset german C++ switch 13.709 13.554 0.1 scalar single lookup 1.429 1.424 1.0 AVX2 single lookup 0.526 0.503 2.8 AVX2 compressed lookup (variant #2) 0.887 0.877 1.6 AVX2 compressed lookup (variant #3) 0.952 0.938 1.5 AVX2 compressed lookup (variant #4) 0.631 0.618 2.3 AVX2 compressed lookup (variant #5) 0.711 0.647 2.2 AVX-512 compressed lookup (variant #6) 1.056 1.047 1.4 dataset greek C++ switch 12.674 12.444 0.1 scalar single lookup 1.409 1.401 1.0 AVX2 single lookup 1.417 1.399 1.0 AVX2 compressed lookup (variant #2) 3.357 3.342 0.4 AVX2 compressed lookup (variant #3) 3.521 3.508 0.4 AVX2 compressed lookup (variant #4) 1.478 1.468 1.0 AVX2 compressed lookup (variant #5) 1.572 1.557 0.9 AVX-512 compressed lookup (variant #6) 0.606 0.593 2.4 dataset hebrew C++ switch 7.511 7.372 0.2 scalar single lookup 1.407 1.401 1.0 AVX2 single lookup 1.617 1.599 0.9 AVX2 compressed lookup (variant #2) 3.944 3.933 0.4 AVX2 compressed lookup (variant #3) 4.137 4.128 0.3 AVX2 compressed lookup (variant #4) 1.685 1.678 0.8 AVX2 compressed lookup (variant #5) 1.795 1.788 0.8 AVX-512 compressed lookup (variant #6) 0.509 0.497 2.8 dataset hindi C++ switch 8.567 8.410 0.2 scalar single lookup 1.408 1.401 1.0 AVX2 single lookup 1.421 1.405 1.0 AVX2 compressed lookup (variant #2) 3.432 3.423 0.4 AVX2 compressed lookup (variant #3) 3.608 3.600 0.4 AVX2 compressed lookup (variant #4) 1.492 1.482 0.9 AVX2 compressed lookup (variant #5) 1.607 1.580 0.9 AVX-512 compressed lookup (variant #6) 0.580 0.570 2.5 dataset japanese C++ switch 6.879 6.635 0.2 scalar single lookup 1.412 1.404 1.0 AVX2 single lookup 1.209 1.183 1.2 AVX2 compressed lookup (variant #2) 2.751 2.738 0.5 AVX2 compressed lookup (variant #3) 2.894 2.881 0.5 AVX2 compressed lookup (variant #4) 1.261 1.246 1.1 AVX2 compressed lookup (variant #5) 1.333 1.322 1.1 AVX-512 compressed lookup (variant #6) 0.722 0.705 2.0 dataset korean C++ switch 8.328 8.102 0.2 scalar single lookup 1.409 1.402 1.0 AVX2 single lookup 1.093 1.069 1.3 AVX2 compressed lookup (variant #2) 2.451 2.443 0.6 AVX2 compressed lookup (variant #3) 2.580 2.573 0.5 AVX2 compressed lookup (variant #4) 1.150 1.138 1.2 AVX2 compressed lookup (variant #5) 1.213 1.204 1.2 AVX-512 compressed lookup (variant #6) 0.800 0.777 1.8 dataset persan C++ switch 12.663 12.325 0.2 scalar single lookup 2.260 2.240 1.0 AVX2 single lookup 1.979 1.947 1.2 AVX2 compressed lookup (variant #2) 4.619 4.588 0.5 AVX2 compressed lookup (variant #3) 4.856 4.828 0.5 AVX2 compressed lookup (variant #4) 2.097 2.074 1.1 AVX2 compressed lookup (variant #5) 2.226 2.200 1.0 AVX-512 compressed lookup (variant #6) 1.108 1.090 2.1 dataset portuguese C++ switch 12.958 12.837 0.1 scalar single lookup 1.412 1.407 1.0 AVX2 single lookup 0.861 0.836 1.7 AVX2 compressed lookup (variant #2) 1.146 1.132 1.2 AVX2 compressed lookup (variant #3) 1.223 1.208 1.2 AVX2 compressed lookup (variant #4) 0.801 0.735 1.9 AVX2 compressed lookup (variant #5) 0.851 0.830 1.7 AVX-512 compressed lookup (variant #6) 0.988 0.969 1.5 dataset russian C++ switch 12.919 12.721 0.1 scalar single lookup 1.413 1.407 1.0 AVX2 single lookup 1.623 1.597 0.9 AVX2 compressed lookup (variant #2) 3.890 3.878 0.4 AVX2 compressed lookup (variant #3) 4.095 4.079 0.3 AVX2 compressed lookup (variant #4) 1.697 1.674 0.8 AVX2 compressed lookup (variant #5) 1.810 1.787 0.8 AVX-512 compressed lookup (variant #6) 0.551 0.542 2.6 dataset thai C++ switch 6.950 6.770 0.2 scalar single lookup 1.411 1.405 1.0 AVX2 single lookup 1.344 1.327 1.1 AVX2 compressed lookup (variant #2) 3.184 3.159 0.4 AVX2 compressed lookup (variant #3) 3.338 3.327 0.4 AVX2 compressed lookup (variant #4) 1.422 1.406 1.0 AVX2 compressed lookup (variant #5) 1.514 1.499 0.9 AVX-512 compressed lookup (variant #6) 0.652 0.643 2.2 dataset turkish C++ switch 12.836 12.653 0.1 scalar single lookup 1.438 1.432 1.0 AVX2 single lookup 1.458 1.348 1.1 AVX2 compressed lookup (variant #2) 2.148 2.106 0.7 AVX2 compressed lookup (variant #3) 2.257 2.222 0.6 AVX2 compressed lookup (variant #4) 1.738 1.677 0.9 AVX2 compressed lookup (variant #5) 1.991 1.948 0.7 AVX-512 compressed lookup (variant #6) 0.810 0.795 1.8 dataset vietnamese C++ switch 11.983 11.764 0.1 scalar single lookup 1.411 1.405 1.0 AVX2 single lookup 1.386 1.332 1.1 AVX2 compressed lookup (variant #2) 3.156 3.147 0.4 AVX2 compressed lookup (variant #3) 3.311 3.301 0.4 AVX2 compressed lookup (variant #4) 1.445 1.413 1.0 AVX2 compressed lookup (variant #5) 1.562 1.521 0.9 AVX-512 compressed lookup (variant #6) 0.616 0.607 2.3 Conclusions Changing case is not easy to vectorized. SIMD code requires also memory gather instructions, which is not widespread. On Ryzen 7 (AVX2 code) only variant 4 is fast, but it brings significantly bigger lookup tables (320kB, instead of ~30kB from the best case). On IceLake (AVX-512 code) the variant 6 is really fast, but also requires bigger tables (~130kB). We are fully aware that benchmarks hide cost of memory misses, as the same conversion is repeated many times. This is why the sizes of lookups are always given, because this may be an important factor in real-world applications. What about UTF-8 inputs? At Sneller we internally used UTF-8, and there was always conversion to UTF-32 code when we had to deal with individual characters. However, it not impossible that for UTF-8 we might have nice solution, especially in scalar code (precomputed tries , for instance). Source code Sample implementation is available at GitHub . Appendixes A --- Codepoints of letters having different cases codepoinst with uppercase variants count in set/range codepoinst with lowercase variants count in set/range [ 0x41 ... 0x5a ] 26 [ 0x61 ... 0x7a ] 26 [ 0xc0 ... 0xd6 ] 23 0xb5 1 [ 0xd8 ... 0xde ] 7 [ 0xf8 ... 0xff ] 8 { 0x100 , 0x102 , 0x104 , 0x106 , 0x108 , 0x10a , 0x10c , 0x10e , 0x110 , 0x112 , 0x114 , 0x116 , 0x118 , 0x11a , 0x11c , 0x11e , 0x120 , 0x122 , 0x124 , 0x126 , 0x128 , 0x12a , 0x12c , 0x12e , 0x130 , 0x132 , 0x134 , 0x136 , 0x139 , 0x13b , 0x13d , 0x13f , 0x141 , 0x143 , 0x145 , 0x147 , 0x14a , 0x14c , 0x14e , 0x150 , 0x152 , 0x154 , 0x156 , 0x158 , 0x15a , 0x15c , 0x15e , 0x160 , 0x162 , 0x164 , 0x166 , 0x168 , 0x16a , 0x16c , 0x16e , 0x170 , 0x172 , 0x174 , 0x176 } 59 { 0x101 , 0x103 , 0x105 , 0x107 , 0x109 , 0x10b , 0x10d , 0x10f , 0x111 , 0x113 , 0x115 , 0x117 , 0x119 , 0x11b , 0x11d , 0x11f , 0x121 , 0x123 , 0x125 , 0x127 , 0x129 , 0x12b , 0x12d , 0x12f , 0x131 , 0x133 , 0x135 , 0x137 , 0x13a , 0x13c , 0x13e , 0x140 , 0x142 , 0x144 , 0x146 } 35 { 0x17b , 0x17d } 2 { 0x14b , 0x14d , 0x14f , 0x151 , 0x153 , 0x155 , 0x157 , 0x159 , 0x15b , 0x15d , 0x15f , 0x161 , 0x163 , 0x165 , 0x167 , 0x169 , 0x16b , 0x16d , 0x16f , 0x171 , 0x173 , 0x175 , 0x177 , 0x17a , 0x17c } 25 0x184 1 { 0x183 , 0x185 , 0x188 , 0x18c , 0x192 , 0x195 } 6 [ 0x189 ... 0x18b ] 3 { 0x1a1 , 0x1a3 , 0x1a5 , 0x1a8 , 0x1ad , 0x1b0 , 0x1b4 , 0x1b6 , 0x1b9 , 0x1bd , 0x19e , 0x1bf } 12 [ 0x18e ... 0x191 ] 4 [ 0x1c8 ... 0x1c9 ] 2 [ 0x193 ... 0x194 ] 2 [ 0x1cb ... 0x1cc ] 2 [ 0x196 ... 0x198 ] 3 { 0x1ce , 0x1d0 , 0x1d2 , 0x1d4 , 0x1d6 , 0x1d8 , 0x1da } 7 [ 0x19c ... 0x19d ] 2 { 0x1e1 , 0x1e3 , 0x1e5 , 0x1e7 , 0x1e9 , 0x1eb , 0x1ed , 0x1df } 8 [ 0x19f ... 0x1a0 ] 2 [ 0x1f2 ... 0x1f3 ] 2 { 0x1a2 , 0x1a4 } 2 { 0x201 , 0x203 , 0x205 , 0x207 , 0x209 , 0x20b , 0x20d , 0x20f , 0x211 , 0x213 , 0x215 , 0x217 , 0x219 , 0x21b , 0x21d , 0x21f , 0x223 , 0x225 , 0x227 , 0x229 , 0x22b , 0x22d , 0x22f , 0x231 , 0x233 , 0x23c , 0x1f5 , 0x1f9 , 0x1fb , 0x1fd , 0x1ff } 31 { 0x1a9 , 0x1ac } 2 { 0x242 , 0x247 , 0x249 , 0x24b , 0x24d } 5 [ 0x1b1 ... 0x1b3 ] 3 [ 0x256 ... 0x257 ] 2 0x1b5 1 0x259 1 0x1bc 1 [ 0x260 ... 0x261 ] 2 [ 0x1c7 ... 0x1c8 ] 2 0x263 1 [ 0x1ca ... 0x1cb ] 2 [ 0x268 ... 0x26c ] 5 { 0x1e0 , 0x1e2 , 0x1e4 , 0x1e6 , 0x1e8 , 0x1ea , 0x1ec , 0x1cd , 0x1ee , 0x1cf , 0x1d1 , 0x1d3 , 0x1d5 , 0x1d7 , 0x1d9 , 0x1db , 0x1de } 17 0x26f 1 0x1f4 1 { 0x280 , 0x27d , 0x275 } 3 { 0x200 , 0x202 , 0x204 , 0x206 , 0x208 , 0x20a , 0x20c , 0x20e , 0x210 , 0x212 , 0x214 , 0x216 , 0x218 , 0x21a , 0x21c , 0x21e , 0x220 , 0x222 , 0x224 , 0x226 , 0x228 , 0x22a , 0x22c , 0x22e , 0x230 , 0x232 , 0x1fa , 0x1fc , 0x1fe } 29 [ 0x287 ... 0x28c ] 6 [ 0x23d ... 0x23e ] 2 0x292 1 0x241 1 { 0x371 , 0x373 , 0x345 , 0x377 } 4 { 0x386 , 0x248 , 0x24a , 0x24c , 0x24e , 0x370 , 0x372 , 0x376 , 0x37f } 9 0x390 1 0x38c 1 [ 0x3d0 ... 0x3d1 ] 2 [ 0x391 ... 0x3a1 ] 17 [ 0x3d5 ... 0x3d7 ] 3 [ 0x3a3 ... 0x3ab ] 9 { 0x3e1 , 0x3e3 , 0x3e5 , 0x3e7 , 0x3e9 , 0x3eb , 0x3ed , 0x3d9 , 0x3db , 0x3dd , 0x3df } 11 { 0x3e0 , 0x3e2 , 0x3e4 , 0x3e6 , 0x3e8 , 0x3ea , 0x3ec , 0x3ee , 0x3cf , 0x3f4 , 0x3f7 , 0x3d8 , 0x3da , 0x3dc , 0x3de } 15 { 0x3f8 , 0x3fb , 0x3f5 } 3 [ 0x3fd ... 0x42f ] 51 { 0x481 , 0x48b , 0x48d , 0x48f , 0x491 , 0x493 , 0x495 , 0x497 , 0x499 , 0x49b , 0x49d , 0x49f , 0x4a1 , 0x4a3 , 0x4a5 , 0x4a7 , 0x4a9 , 0x4ab , 0x4ad , 0x4af , 0x4b1 , 0x4b3 , 0x4b5 , 0x4b7 , 0x4b9 , 0x4bb , 0x4bd , 0x4bf , 0x4c2 , 0x4c4 , 0x4c6 , 0x4c8 , 0x4ca , 0x4cc , 0x461 , 0x463 , 0x465 , 0x467 , 0x469 , 0x46b , 0x46d , 0x46f , 0x471 , 0x473 , 0x475 , 0x477 , 0x479 , 0x47b , 0x47d , 0x47f } 50 { 0x480 , 0x48a , 0x48c , 0x48e , 0x490 , 0x492 , 0x494 , 0x496 , 0x498 , 0x49a , 0x49c , 0x49e , 0x4a0 , 0x4a2 , 0x4a4 , 0x4a6 , 0x4a8 , 0x4aa , 0x4ac , 0x4ae , 0x4b0 , 0x4b2 , 0x4b4 , 0x4b6 , 0x4b8 , 0x4ba , 0x4bc , 0x4be , 0x460 , 0x462 , 0x464 , 0x466 , 0x468 , 0x46a , 0x46c , 0x46e , 0x470 , 0x472 , 0x474 , 0x476 , 0x478 , 0x47a , 0x47c , 0x47e } 44 { 0x501 , 0x503 , 0x505 , 0x507 , 0x509 , 0x50b , 0x50d , 0x50f , 0x511 , 0x513 , 0x515 , 0x517 , 0x519 , 0x51b , 0x51d , 0x51f , 0x521 , 0x523 , 0x525 , 0x527 , 0x529 , 0x52b , 0x52d , 0x52f , 0x4d1 , 0x4d3 , 0x4d5 , 0x4d7 , 0x4d9 , 0x4db , 0x4dd , 0x4df , 0x4e1 , 0x4e3 , 0x4e5 , 0x4e7 , 0x4e9 , 0x4eb , 0x4ed , 0x4ef , 0x4f1 , 0x4f3 , 0x4f5 , 0x4f7 , 0x4f9 , 0x4fb , 0x4fd , 0x4ff } 48 { 0x500 , 0x502 , 0x504 , 0x506 , 0x508 , 0x50a , 0x50c , 0x50e , 0x510 , 0x512 , 0x514 , 0x516 , 0x518 , 0x51a , 0x51c , 0x51e , 0x520 , 0x522 , 0x524 , 0x526 , 0x528 , 0x52a , 0x52c , 0x52e , 0x4c3 , 0x4c5 , 0x4c7 , 0x4c9 , 0x4cb , 0x4cd , 0x4d0 , 0x4d2 , 0x4d4 , 0x4d6 , 0x4d8 , 0x4da , 0x4dc , 0x4de , 0x4e0 , 0x4e2 , 0x4e4 , 0x4e6 , 0x4e8 , 0x4ea , 0x4ec , 0x4ee , 0x4f0 , 0x4f2 , 0x4f4 , 0x4f6 , 0x4f8 , 0x4fa , 0x4fc , 0x4fe } 54 [ 0x10d0 ... 0x10fa ] 43 [ 0x10a0 ... 0x10c5 ] 38 [ 0x10fd ... 0x10ff ] 3 { 0x10cd , 0x10c7 } 2 [ 0x13f8 ... 0x13fd ] 6 [ 0x1c90 ... 0x1cba ] 43 [ 0x1c80 ... 0x1c88 ] 9 [ 0x1cbd ... 0x1cbf ] 3 { 0x1e01 , 0x1e03 , 0x1e05 , 0x1e07 , 0x1e09 , 0x1e0b , 0x1e0d , 0x1e0f , 0x1e11 , 0x1e13 , 0x1e15 , 0x1e17 , 0x1e19 , 0x1e1b , 0x1e1d , 0x1e1f , 0x1e21 , 0x1e23 , 0x1e25 , 0x1e27 , 0x1e29 , 0x1e2b , 0x1e2d , 0x1e2f , 0x1e31 , 0x1e33 , 0x1e35 , 0x1e37 , 0x1e39 , 0x1e3b , 0x1e3d , 0x1e3f , 0x1e41 , 0x1e43 , 0x1e45 , 0x1e47 , 0x1e49 , 0x1e4b , 0x1e4d , 0x1e4f , 0x1e51 , 0x1e53 , 0x1e55 , 0x1e57 , 0x1e59 , 0x1e5b , 0x1e5d , 0x1e5f , 0x1e61 , 0x1e63 , 0x1e65 , 0x1e67 , 0x1e69 , 0x1e6b , 0x1e6d , 0x1e6f , 0x1e71 , 0x1e73 , 0x1e75 , 0x1e77 , 0x1e79 , 0x1e7b , 0x1e7d , 0x1e7f , 0x1e81 , 0x1e83 , 0x1e85 , 0x1e87 , 0x1e89 , 0x1e8b , 0x1e8d , 0x1e8f , 0x1e91 , 0x1e93 , 0x1d79 , 0x1d7d , 0x1d8e } 77 { 0x1e00 , 0x1e02 , 0x1e04 , 0x1e06 , 0x1e08 , 0x1e0a , 0x1e0c , 0x1e0e , 0x1e10 , 0x1e12 , 0x1e14 , 0x1e16 , 0x1e18 , 0x1e1a , 0x1e1c , 0x1e1e , 0x1e20 , 0x1e22 , 0x1e24 , 0x1e26 , 0x1e28 , 0x1e2a , 0x1e2c , 0x1e2e , 0x1e30 , 0x1e32 , 0x1e34 , 0x1e36 , 0x1e38 , 0x1e3a , 0x1e3c , 0x1e3e , 0x1e40 , 0x1e42 , 0x1e44 , 0x1e46 , 0x1e48 , 0x1e4a , 0x1e4c , 0x1e4e , 0x1e50 , 0x1e52 , 0x1e54 , 0x1e56 , 0x1e58 , 0x1e5a , 0x1e5c , 0x1e5e , 0x1e60 , 0x1e62 , 0x1e64 , 0x1e66 , 0x1e68 , 0x1e6a , 0x1e6c , 0x1e6e , 0x1e70 , 0x1e72 , 0x1e74 , 0x1e76 , 0x1e78 , 0x1e7a , 0x1e7c , 0x1e7e , 0x1e80 , 0x1e82 , 0x1e84 , 0x1e86 , 0x1e88 , 0x1e8a , 0x1e8c , 0x1e8e , 0x1e90 , 0x1e92 , 0x1e94 , 0x1e9e , 0x1ea0 , 0x1ea2 , 0x1ea4 , 0x1ea6 , 0x1ea8 , 0x1eaa , 0x1eac , 0x1eae , 0x1eb0 , 0x1eb2 , 0x1eb4 , 0x1eb6 , 0x1eb8 , 0x1eba , 0x1ebc , 0x1ebe , 0x1ec0 , 0x1ec2 , 0x1ec4 , 0x1ec6 , 0x1ec8 , 0x1eca , 0x1ecc , 0x1ece , 0x1ed0 , 0x1ed2 , 0x1ed4 , 0x1ed6 , 0x1ed8 , 0x1eda , 0x1edc , 0x1ede , 0x1ee0 , 0x1ee2 , 0x1ee4 , 0x1ee6 , 0x1ee8 , 0x1eea , 0x1eec , 0x1eee , 0x1ef0 , 0x1ef2 , 0x1ef4 , 0x1ef6 , 0x1ef8 , 0x1efa , 0x1efc , 0x1efe } 124 { 0x1ea1 , 0x1ea3 , 0x1ea5 , 0x1ea7 , 0x1ea9 , 0x1eab , 0x1ead , 0x1eaf , 0x1eb1 , 0x1eb3 , 0x1eb5 , 0x1eb7 , 0x1eb9 , 0x1ebb , 0x1ebd , 0x1ebf , 0x1ec1 , 0x1ec3 , 0x1ec5 , 0x1ec7 , 0x1ec9 , 0x1ecb , 0x1ecd , 0x1ecf , 0x1ed1 , 0x1ed3 , 0x1ed5 , 0x1ed7 , 0x1ed9 , 0x1edb , 0x1edd , 0x1edf , 0x1ee1 , 0x1ee3 , 0x1ee5 , 0x1ee7 , 0x1ee9 , 0x1eeb , 0x1eed , 0x1eef , 0x1ef1 , 0x1ef3 , 0x1ef5 , 0x1ef7 , 0x1ef9 , 0x1efb , 0x1efd } 47 [ 0x1f18 ... 0x1f1d ] 6 [ 0x1f10 ... 0x1f15 ] 6 [ 0x1f28 ... 0x1f2f ] 8 [ 0x1f20 ... 0x1f27 ] 8 [ 0x1f38 ... 0x1f3f ] 8 [ 0x1f30 ... 0x1f37 ] 8 [ 0x1f48 ... 0x1f4d ] 6 [ 0x1f40 ... 0x1f45 ] 6 { 0x1f59 , 0x1f5b , 0x1f5d , 0x1f5f } 4 [ 0x1f50 ... 0x1f57 ] 8 [ 0x1f88 ... 0x1f8f ] 8 [ 0x1f60 ... 0x1f67 ] 8 [ 0x1f98 ... 0x1f9f ] 8 [ 0x1f70 ... 0x1f7d ] 14 [ 0x1fa8 ... 0x1faf ] 8 [ 0x1f80 ... 0x1fb4 ] 53 [ 0x1fb8 ... 0x1fbc ] 5 [ 0x1fb6 ... 0x1fb7 ] 2 [ 0x1fc8 ... 0x1fcc ] 5 { 0x1fbc , 0x1fbe } 2 [ 0x1fd8 ... 0x1fdb ] 4 [ 0x1fc6 ... 0x1fc7 ] 2 [ 0x1fe8 ... 0x1fec ] 5 0x1fcc 1 [ 0x1ff8 ... 0x1ffc ] 5 [ 0x1fd6 ... 0x1fd7 ] 2 0x2126 1 [ 0x1fe0 ... 0x1fe7 ] 8 0x2132 1 [ 0x1ff2 ... 0x1ff4 ] 3 0x2183 1 [ 0x1ff6 ... 0x1ff7 ] 2 [ 0x2c00 ... 0x2c2f ] 48 { 0x1ffc , 0x214e } 2 0x2c60 1 0x2184 1 { 0x2c69 , 0x2c6b , 0x2c67 } 3 [ 0x2c30 ... 0x2c5f ] 48 { 0x2c72 , 0x2c75 } 2 0x2c61 1 { 0xa640 , 0xa642 , 0xa644 , 0xa646 , 0xa648 , 0xa64a , 0xa64c , 0xa64e , 0xa650 , 0xa652 , 0xa654 , 0xa656 , 0xa658 , 0xa65a , 0xa65c , 0xa65e , 0xa660 , 0xa662 , 0xa664 , 0xa666 , 0xa668 , 0xa66a , 0xa66c , 0xa680 , 0x2c82 , 0xa682 , 0x2c84 , 0xa684 , 0x2c86 , 0xa686 , 0x2c88 , 0xa688 , 0x2c8a , 0xa68a , 0x2c8c , 0xa68c , 0x2c8e , 0xa68e , 0x2c90 , 0xa690 , 0x2c92 , 0xa692 , 0x2c94 , 0xa694 , 0x2c96 , 0xa696 , 0x2c98 , 0xa698 , 0x2c9a , 0xa69a , 0x2c9c , 0x2c9e , 0x2ca0 , 0x2ca2 , 0x2ca4 , 0x2ca6 , 0x2ca8 , 0x2caa , 0x2cac , 0x2cae , 0x2cb0 , 0x2cb2 , 0x2cb4 , 0x2cb6 , 0x2cb8 , 0x2cba , 0x2cbc , 0x2cbe , 0x2cc0 , 0x2cc2 , 0x2cc4 , 0x2cc6 , 0x2cc8 , 0x2cca , 0x2ccc , 0x2cce , 0x2cd0 , 0x2cd2 , 0x2cd4 , 0x2cd6 , 0x2cd8 , 0x2cda , 0x2cdc , 0x2cde , 0x2ce0 , 0x2ce2 , 0x2ceb , 0x2ced , 0x2cf2 , 0xa722 , 0xa724 , 0xa726 , 0xa728 , 0xa72a , 0xa72c , 0xa72e , 0xa732 , 0xa734 , 0xa736 , 0xa738 , 0xa73a , 0xa73c , 0xa73e , 0xa740 , 0xa742 , 0xa744 , 0xa746 , 0xa748 , 0xa74a , 0xa74c , 0xa74e , 0xa750 , 0xa752 , 0xa754 , 0xa756 , 0xa758 , 0xa75a , 0xa75c , 0xa75e , 0xa760 , 0xa762 , 0xa764 , 0xa766 , 0xa768 , 0xa76a , 0xa76c , 0xa76e , 0xa779 , 0xa77b } 129 { 0x2c81 , 0x2c83 , 0x2c85 , 0x2c87 , 0x2c89 , 0x2c8b , 0x2c8d , 0x2c8f , 0x2c91 , 0x2c93 , 0x2c95 , 0x2c97 , 0x2c99 , 0x2c9b , 0x2c9d , 0x2c9f , 0x2ca1 , 0x2ca3 , 0x2ca5 , 0x2ca7 , 0x2ca9 , 0x2cab , 0x2cad , 0x2caf , 0x2cb1 , 0x2cb3 , 0x2cb5 , 0x2cb7 , 0x2cb9 , 0x2cbb , 0x2cbd , 0x2cbf , 0x2cc1 , 0x2cc3 , 0x2cc5 , 0x2cc7 , 0x2cc9 , 0x2ccb , 0x2ccd , 0x2ccf , 0x2cd1 , 0x2cd3 , 0x2cd5 , 0x2cd7 , 0x2cd9 , 0x2cdb , 0x2cdd , 0x2cdf , 0x2ce1 , 0x2ce3 , 0x2c68 , 0x2c6a , 0x2c6c , 0x2cec , 0x2cee , 0x2c73 , 0x2cf3 , 0x2c76 } 58 { 0xa780 , 0xa7a0 , 0xa782 , 0xa7a2 , 0xa784 , 0xa7a4 , 0xa786 , 0xa7a6 , 0xa7a8 , 0xa78b , 0xa78d , 0xa790 , 0xa792 , 0xa796 , 0xa798 , 0xa79a , 0xa79c , 0xa79e } 18 { 0xa641 , 0xa643 , 0xa645 , 0xa647 , 0xa649 , 0xa64b , 0xa64d , 0xa64f , 0xa651 , 0xa653 , 0xa655 , 0xa657 , 0xa659 , 0xa65b , 0xa65d , 0xa65f , 0xa661 , 0xa663 , 0xa665 , 0xa667 , 0xa669 , 0xa66b , 0xa66d , 0xa681 , 0xa683 , 0xa685 , 0xa687 , 0xa689 , 0xa68b , 0xa68d , 0xa68f , 0xa691 , 0xa693 , 0xa695 , 0xa697 , 0xa699 , 0xa69b , 0xa723 , 0xa725 , 0x2d27 , 0xa727 , 0xa729 , 0xa72b , 0x2d2d , 0xa72d , 0xa72f , 0xa733 , 0xa735 , 0xa737 , 0xa739 , 0xa73b , 0xa73d , 0xa73f , 0xa741 , 0xa743 , 0xa745 , 0xa747 , 0xa749 , 0xa74b , 0xa74d , 0xa74f , 0xa751 , 0xa753 , 0xa755 , 0xa757 , 0xa759 , 0xa75b , 0xa75d , 0xa75f , 0xa761 , 0xa763 , 0xa765 , 0xa767 , 0xa769 , 0xa76b , 0xa76d , 0xa76f , 0xa77a , 0xa77c , 0xa77f , 0xa781 , 0xa783 , 0xa785 , 0xa787 , 0xa78c , 0xa791 } 86 [ 0xa7b0 ... 0xa7b4 ] 5 { 0xa797 , 0xa799 , 0xa79b , 0xa79d , 0xa79f , 0xa7a1 , 0xa7a3 , 0xa7a5 , 0xa7a7 , 0xa7a9 , 0xa7b5 , 0xa7b7 , 0xa7b9 , 0xa7bb , 0xa7bd , 0xa7bf , 0xa7c1 , 0xa7c3 , 0xa7c8 , 0xa7ca , 0xa7d1 , 0xab53 , 0xa7d7 , 0xa7d9 , 0xa7f6 } 25 { 0xa7c0 , 0xa7c2 , 0xa7b6 , 0xa7b8 , 0xa7ba , 0xa7bc , 0xa7be } 7 [ 0xfb00 ... 0xfb06 ] 7 { 0xa7c9 , 0xa7d0 , 0xa7f5 , 0xa7d6 , 0xa7d8 } 5 [ 0xfb13 ... 0xfb17 ] 5 [ 0x10400 ... 0x10427 ] 40 [ 0xff41 ... 0xff5a ] 26 [ 0x104b0 ... 0x104d3 ] 36 [ 0x10428 ... 0x1044f ] 40 [ 0x10570 ... 0x1057a ] 11 [ 0x104d8 ... 0x104fb ] 36 [ 0x1057c ... 0x1058a ] 15 [ 0x10597 ... 0x105a1 ] 11 [ 0x1058c ... 0x10592 ] 7 [ 0x105a3 ... 0x105b1 ] 15 [ 0x10594 ... 0x10595 ] 2 [ 0x105b3 ... 0x105b9 ] 7 [ 0x10c80 ... 0x10cb2 ] 51 [ 0x105bb ... 0x105bc ] 2 [ 0x118a0 ... 0x118bf ] 32 [ 0x10cc0 ... 0x10cf2 ] 51 [ 0x16e40 ... 0x16e5f ] 32 [ 0x118c0 ... 0x118df ] 32 [ 0x1e900 ... 0x1e921 ] 34 [ 0x16e60 ... 0x16e7f ] 32 [ 0x1e922 ... 0x1e943 ] 34 B --- Lowercase letters placement The picture shows which characters in range 0..0x1ffff have lowercase variants: they are marked with blue, green or red. In gray are shown characters without lowercase variants. There are 512 rows (addressed by bits [16:8]) of 256 characters (addressed by bits [7:0] of character code). C --- Uppercase letters placement The picture shows which characters in range 0..0x1ffff have uppercase variants: they are marked with blue, green or red. In gray are shown characters without lowercase variants. There are 512 rows (addressed by bits [16:8]) of 256 characters (addressed by bits [7:0] of character code). D --- Compressed tables --- variant 1 The exact sizes of the 1st level lookup tables in variant #1 . First-level lookup metadata for uppercase # 9 highest bits minimum character code maximum character code chars in that range 0 0x000 0x0061 0x00ff 159 1 0x001 0x0101 0x01ff 255 2 0x002 0x0201 0x029e 158 3 0x003 0x0345 0x03fb 183 4 0x004 0x0430 0x04ff 208 5 0x005 0x0501 0x0587 135 6 0x010 0x10d0 0x10ff 48 7 0x013 0x13f8 0x13fd 6 8 0x01c 0x1c80 0x1c88 9 9 0x01d 0x1d79 0x1d8e 22 10 0x01e 0x1e01 0x1eff 255 11 0x01f 0x1f00 0x1ffc 253 12 0x021 0x214e 0x2184 55 13 0x024 0x24d0 0x24e9 26 14 0x02c 0x2c30 0x2cf3 196 15 0x02d 0x2d00 0x2d2d 46 16 0x0a6 0xa641 0xa69b 91 17 0x0a7 0xa723 0xa7f6 212 18 0x0ab 0xab53 0xabbf 109 19 0x0fb 0xfb00 0xfb17 24 20 0x0ff 0xff41 0xff5a 26 21 0x104 0x10428 0x104fb 212 22 0x105 0x10597 0x105bc 38 23 0x10c 0x10cc0 0x10cf2 51 24 0x118 0x118c0 0x118df 32 25 0x16e 0x16e60 0x16e7f 32 26 0x1e9 0x1e922 0x1e943 34 total 2875 First-level lookup metadata for lowercase # 9 highest bits minimum character code maximum character code chars in that range 0 0x000 0x0041 0x00de 158 1 0x001 0x0100 0x01fe 255 2 0x002 0x0200 0x024e 79 3 0x003 0x0370 0x03ff 144 4 0x004 0x0400 0x04fe 255 5 0x005 0x0500 0x0556 87 6 0x010 0x10a0 0x10cd 46 7 0x013 0x13a0 0x13f5 86 8 0x01c 0x1c90 0x1cbf 48 9 0x01e 0x1e00 0x1efe 255 10 0x01f 0x1f08 0x1ffc 245 11 0x021 0x2126 0x2183 94 12 0x024 0x24b6 0x24cf 26 13 0x02c 0x2c00 0x2cf2 243 14 0x0a6 0xa640 0xa69a 91 15 0x0a7 0xa722 0xa7f5 212 16 0x0ff 0xff21 0xff3a 26 17 0x104 0x10400 0x104d3 212 18 0x105 0x10570 0x10595 38 19 0x10c 0x10c80 0x10cb2 51 20 0x118 0x118a0 0x118bf 32 21 0x16e 0x16e40 0x16e5f 32 22 0x1e9 0x1e900 0x1e921 34 total 2749'],
];
