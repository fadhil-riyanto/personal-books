<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2018/covariance-and-contravariance-in-subtyping/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:14 GMT -->
<head>
    <title>Covariance and contravariance in subtyping - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Covariance and contravariance in subtyping">
                        Covariance and contravariance in subtyping
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> October 17, 2018 at 05:35</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/programming.html">Programming</a>
        ,
    <a href="../../tag/python.html">Python</a>
        ,
    <a href="../../tag/c-c.html">C & C++</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Many programming languages support <em>subtyping</em>, a kind of polymorphism that lets
us define hierarchical relations on types, with specific types being subtypes of
more generic types. For example, a Cat could be a subtype of Mammal, which
itself is a subtype of Vertebrate.</p>
<p>Intuitively, functions that accept any Mammal would accept a Cat too. More
formally, this is known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a>:</p>
<blockquote>
Let <object class="valign-m4" data="../../images/math/981767307c6c4e0961591f103d7a2afbd4310648.svg" style="height: 18px;" type="image/svg+xml">\phi (x)</object> be a property
provable about objects <tt class="docutils literal">x</tt> of type <tt class="docutils literal">T</tt>. Then <object class="valign-m4" data="../../images/math/870ca38dfa9cd9a0f364eadfd23b9ec3722953c2.svg" style="height: 18px;" type="image/svg+xml">\phi (y)</object>
should be true for objects <tt class="docutils literal">y</tt> of type <tt class="docutils literal">S</tt> where <tt class="docutils literal">S</tt> is a subtype
of <tt class="docutils literal">T</tt>.</blockquote>
<p>A shorter way to say <em>S is a subtype of T</em> is <tt class="docutils literal">S &lt;: T</tt>. The relation <tt class="docutils literal">&lt;:</tt>
is also sometimes expressed as <object class="valign-m3" data="../../images/math/60fd4c42f3956e697cf94397160a51086fbb6f5b.svg" style="height: 15px;" type="image/svg+xml">\le</object>, and can be thought of as &quot;is less
general than&quot;. So <tt class="docutils literal">Cat &lt;: Mammal</tt> and <tt class="docutils literal">Mammal &lt;: Vertebrate</tt>. Naturally,
<tt class="docutils literal">&lt;:</tt> is transitive, so <tt class="docutils literal">Cat &lt;: Vertebrate</tt>; it's also reflexive, as <tt class="docutils literal">T
&lt;: T</tt> for any type T <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>.</p>
<div class="section" id="kinds-of-variance-in-subtyping">
<h2>Kinds of variance in subtyping</h2>
<p>Variance refers to how subtyping between composite types (e.g. list of Cats
versus list of Mammals) relates to subtyping between their components (e.g. Cats
and Mammals). Let's use the general <tt class="docutils literal">Composite&lt;T&gt;</tt> to refer to some composite
type with components of type <tt class="docutils literal">T</tt>.</p>
<p>Given types <tt class="docutils literal">S</tt> and <tt class="docutils literal">T</tt> with the relation <tt class="docutils literal">S &lt;: T</tt>, <em>variance</em> is a way
to describe the relation between the composite types:</p>
<ul class="simple">
<li><em>Covariant</em> means the ordering of component types is preserved:
<tt class="docutils literal">Composite&lt;S&gt; &lt;: Composite&lt;T&gt;</tt>.</li>
<li><em>Contravariant</em> means the ordering is reversed: <tt class="docutils literal">Composite&lt;T&gt; &lt;:
Composite&lt;S&gt;</tt> <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>.</li>
<li><em>Bivariant</em> means both covariant and contravariant.</li>
<li><em>Invariant</em> means neither covariant nor contravariant.</li>
</ul>
<p>That's a lot of theory and rules right in the beginning; the
following examples should help clarify all of this.</p>
</div>
<div class="section" id="covariance-in-return-types-of-overriding-methods-in-c">
<h2>Covariance in return types of overriding methods in C++</h2>
<p>In C++, when a subclass method overrides a similarly named method in a
superclass, their signatures have to match. There is an important exception to
this rule, however. When the original return type is <tt class="docutils literal">B*</tt> or <tt class="docutils literal">B&amp;</tt>, the
return type of the overriding function is allowed to be <tt class="docutils literal">D*</tt> or <tt class="docutils literal">D&amp;</tt>
respectively, provided that <tt class="docutils literal">D</tt> is a public subclass of <tt class="docutils literal">B</tt>. This rule is
important to implement methods like <tt class="docutils literal">Clone</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Mammal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Mammal</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">Mammal</span><span class="o">*</span><span class="w"> </span><span class="nf">Clone</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Cat</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Mammal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Cat</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="n">Cat</span><span class="o">*</span><span class="w"> </span><span class="n">Clone</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Cat</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Mammal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="n">Dog</span><span class="o">*</span><span class="w"> </span><span class="n">Clone</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>And we can write functions like the following:</p>
<div class="highlight"><pre><span></span><span class="n">Mammal</span><span class="o">*</span><span class="w"> </span><span class="nf">DoSomething</span><span class="p">(</span><span class="n">Mammal</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Mammal</span><span class="o">*</span><span class="w"> </span><span class="n">cloned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">Clone</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Do something with cloned</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">cloned</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>No matter what the concrete run-time class of <tt class="docutils literal">m</tt> is, <tt class="docutils literal"><span class="pre">m-&gt;Clone()</span></tt> will
return the right kind of object.</p>
<p>Armed with our new terminology, we can say that the return type rule for
overriding methods is <em>covariant</em> for pointer and reference types. In other
words, given <tt class="docutils literal">Cat &lt;: Mammal</tt> we have <tt class="docutils literal">Cat* &lt;: Mammal*</tt>.</p>
<p>Being able to replace <tt class="docutils literal">Mammal*</tt> by <tt class="docutils literal">Cat*</tt> seems like a natural thing to
do in C++, but not all typing rules are covariant. Consider this code:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MammalClinic</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Accept</span><span class="p">(</span><span class="n">Mammal</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">CatClinic</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MammalClinic</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Accept</span><span class="p">(</span><span class="n">Cat</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Looks legit? We have general <tt class="docutils literal">MammalClinic</tt>s that accept all mammals, and
more specialized <tt class="docutils literal">CatClinic</tt>s that only accept cats. Given a
<tt class="docutils literal">MammalClinic*</tt>, we should be able to call <tt class="docutils literal">Accept</tt> and the right one will
be invoked at run-time, right? Wrong. <tt class="docutils literal"><span class="pre">CatClinic::Accept</span></tt> does not actually
override <tt class="docutils literal"><span class="pre">MammalClinic::Accept</span></tt>; it simply overloads it. If we try to add
the <tt class="docutils literal">override</tt> keyword (as we should always do starting with C++11):</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">CatClinic</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MammalClinic</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Accept</span><span class="p">(</span><span class="n">Cat</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>We'll get:</p>
<div class="highlight"><pre><span></span>error: ‘virtual void CatClinic::Accept(Cat*)’ marked ‘override’, but does not override
   virtual void Accept(Cat* c) override;
                ^
</pre></div>
<p>This is precisely what the <tt class="docutils literal">override</tt> keyword was created for - help us find
erroneous assumptions about methods overriding other methods. The reality is
that function overrides are not covariant for pointer types. They are
<em>invariant</em>. In fact, the vast majority of typing rules in C++ are invariant;
<tt class="docutils literal"><span class="pre">std::vector&lt;Cat&gt;</span></tt> is not a subclass of <tt class="docutils literal"><span class="pre">std::vector&lt;Mammal&gt;</span></tt>, even though
<tt class="docutils literal">Cat &lt;: Mammal</tt>. As the next section demonstrates, there's a good reason for
that.</p>
</div>
<div class="section" id="covariant-arrays-in-java">
<h2>Covariant arrays in Java</h2>
<p>Suppose we have <tt class="docutils literal">PersianCat &lt;: Cat</tt>, and some class representing a list of
cats. Does it make sense for lists to be covariant? On initial thought, yes. Say
we have this (pseudocode) function:</p>
<div class="highlight"><pre><span></span>MakeThemMeow(List&lt;Cat&gt; lst) {
    for each cat in lst {
        cat-&gt;Meow()
    }
}
</pre></div>
<p>Why shouldn't we be able to pass a <tt class="docutils literal">List&lt;PersianCat&gt;</tt> into it? After all,
all persian cats are cats, so they can all meow! As long as lists are immutable,
this is actually safe. The problem appears when lists can be modified. The
best example of this problem can be demonstrated with actual Java code, since
in Java array constructors are covariant:</p>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">strings</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;house&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;daisy&quot;</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">objects</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strings</span><span class="p">;</span><span class="w"> </span><span class="c1">// covariant</span><span class="w"></span>

<span class="w">    </span><span class="n">objects</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;cauliflower&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// works fine</span><span class="w"></span>
<span class="w">    </span><span class="n">objects</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">             </span><span class="c1">// throws exception</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>In Java, <tt class="docutils literal">String &lt;: Object</tt>, and since arrays are covariant, it means that
<tt class="docutils literal">String[] &lt;: Object[]</tt>, which makes the assignment on the line marked with
&quot;covariant&quot; type-check successfully. From that point on, <tt class="docutils literal">objects</tt> is an
array of <tt class="docutils literal">Object</tt> as far as the compiler is concerned, so assigning anything
that's a subclass of <tt class="docutils literal">Object</tt> to its elements is kosher, including integers
<a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>. Therefore the last line in <tt class="docutils literal">main</tt> throws an exception <em>at run-time</em>:</p>
<div class="highlight"><pre><span></span>Exception in thread &quot;main&quot; java.lang.ArrayStoreException: java.lang.Integer
    at Main.main(Main.java:7)
</pre></div>
<p>Assigning an integer fails because at run-time it's known that <tt class="docutils literal">objects</tt> is
actually an array of <em>strings</em>. Thus, covariance together with mutability makes
array types unsound. Note, however, that this is not just a mistake - it's a
deliberate historical decision made when Java didn't have generics and
polymorphism was still desired; the same problem exists in C# - <a class="reference external" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Covariant_arrays_in_Java_and_C.23">read this for
more details</a>.</p>
<p>Other languages have immutable containers, which can then be made covariant
without jeopardizing the soundness of the type system. For example in OCaml
lists are immutable and covariant.</p>
</div>
<div class="section" id="contravariance-for-function-types">
<h2>Contravariance for function types</h2>
<p>Covariance seems like a pretty intuitive concept, but what about contravariance?
When does it make sense to reverse the subtyping relation for composite types
to get <tt class="docutils literal">Composite&lt;T&gt; &lt;: Composite&lt;S&gt;</tt> for <tt class="docutils literal">S &lt;: T</tt>?</p>
<p>An important use case is <em>function types</em>. Consider a function that takes a
<tt class="docutils literal">Mammal</tt> and returns a <tt class="docutils literal">Mammal</tt>; in functional programming the type of this
function is commonly referred to as <tt class="docutils literal">Mammal <span class="pre">-&gt;</span> Mammal</tt>. Which function types
are valid subtypes of this type?</p>
<p>Here's a pseudo-code definition that makes it easier to discuss:</p>
<div class="highlight"><pre><span></span>func user(f : Mammal -&gt; Mammal) {
  // do stuff with &#39;f&#39;
}
</pre></div>
<p>Can we call <tt class="docutils literal">user</tt> providing it a function of type <tt class="docutils literal">Mammal <span class="pre">-&gt;</span> Cat</tt> as <tt class="docutils literal">f</tt>?
Inside its body, <tt class="docutils literal">user</tt> may invoke <tt class="docutils literal">f</tt> and expect its return value to be
a <tt class="docutils literal">Mammal</tt>. Since <tt class="docutils literal">Mammal <span class="pre">-&gt;</span> Cat</tt> returns cats, that's fine, so this usage
is safe. It aligns with our earlier intuition that covariance makes sense for
function return types.</p>
<p>Note that passing a <tt class="docutils literal">Mammal <span class="pre">-&gt;</span> Vertebrate</tt> function as <tt class="docutils literal">f</tt> doesn't work as
well, because <tt class="docutils literal">user</tt> expects <tt class="docutils literal">f</tt> to return <tt class="docutils literal">Mammal</tt>s, but our function
may return a <tt class="docutils literal">Vertebrate</tt> that's not a <tt class="docutils literal">Mammal</tt> (maybe a <tt class="docutils literal">Bird</tt>).
Therefore, function return types are not contravariant.</p>
<p>But what about function parameters? So far we've been looking at function types
that take <tt class="docutils literal">Mammal</tt> - an exact match for the expected signature of <tt class="docutils literal">f</tt>. Can
we call <tt class="docutils literal">user</tt> with a function of type <tt class="docutils literal">Cat <span class="pre">-&gt;</span> Mammal</tt>? No, because <tt class="docutils literal">user</tt>
expects to be able to pass any kind of <tt class="docutils literal">Mammal</tt> into <tt class="docutils literal">f</tt>, not just
<tt class="docutils literal">Cat</tt>s. So function parameters are not covariant. On the other hand, it
should be safe to pass a function of type <tt class="docutils literal">Vertebrate <span class="pre">-&gt;</span> Mammal</tt> as <tt class="docutils literal">f</tt>,
because it can take any <tt class="docutils literal">Mammal</tt>, and that's what <tt class="docutils literal">user</tt> is going to pass to
it. So contravariance makes sense for function parameters.</p>
<p>Most generally, we can say that <tt class="docutils literal">Vertebrate <span class="pre">-&gt;</span> Cat</tt> is a subtype of <tt class="docutils literal">Mammal
<span class="pre">-&gt;</span> Mammal</tt>, because parameters types are contravariant and return types are
covariant. A nice quote that can help remember these rules is: <em>be liberal in
what you accept and conservative in what you produce</em>.</p>
<p>This is not just theory; if we go back to C++, this is exactly how function
types with <tt class="docutils literal"><span class="pre">std::function</span></tt> behave:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="cp"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Vertebrate</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Mammal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Vertebrate</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Cat</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Mammal</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="n">Cat</span><span class="o">*</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="n">Vertebrate</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">Vertebrate</span><span class="o">*</span><span class="w"> </span><span class="nf">f2</span><span class="p">(</span><span class="n">Vertebrate</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">Cat</span><span class="o">*</span><span class="w"> </span><span class="nf">f3</span><span class="p">(</span><span class="n">Cat</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">User</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Mammal</span><span class="o">*</span><span class="p">(</span><span class="n">Mammal</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// do stuff with &#39;f&#39;</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">User</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span><span class="w">       </span><span class="c1">// works</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The invocation <tt class="docutils literal">User(f1)</tt> compiles, because <tt class="docutils literal">f1</tt> is convertible to the type
<tt class="docutils literal"><span class="pre">std::function&lt;Mammal*(Mammal*)&gt;</span></tt> <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>. Had we tried to invoke <tt class="docutils literal">User(f2)</tt> or
<tt class="docutils literal">User(f3)</tt>, they would fail because neither <tt class="docutils literal">f2</tt> nor <tt class="docutils literal">f3</tt> are proper
subtypes of <tt class="docutils literal"><span class="pre">std::function&lt;Mammal*(Mammal*)&gt;</span></tt>.</p>
</div>
<div class="section" id="bivariance">
<h2>Bivariance</h2>
<p>So far we've seen examples of invariance, covariance and contravariance. What
about bivariance? Recall, bivariance means that given <tt class="docutils literal">S &lt;: T</tt>, both
<tt class="docutils literal">Composite&lt;S&gt; &lt;: Composite&lt;T&gt;</tt> and <tt class="docutils literal">Composite&lt;T&gt; &lt;: Composite&lt;S&gt;</tt> are true.
When is this useful? Not often at all, it turns out.</p>
<p>In TypeScript, function parameters are bivariant. The following code compiles
correctly but fails at run-time:</p>
<div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">trainDog</span><span class="p">(</span><span class="nx">d</span><span class="o">:</span><span class="w"> </span><span class="nx">Dog</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kd">function</span><span class="w"> </span><span class="nx">cloneAnimal</span><span class="p">(</span><span class="nx">source</span><span class="o">:</span><span class="w"> </span><span class="nx">Animal</span><span class="p">,</span><span class="w"> </span><span class="nx">done</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">result</span><span class="o">:</span><span class="w"> </span><span class="nx">Animal</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Cat</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Runtime error here occurs because we end up invoking &#39;trainDog&#39; with a &#39;Cat&#39;</span><span class="w"></span>
<span class="nx">cloneAnimal</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">trainDog</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Once again, this is not because the TypeScript designers are incompetent. The
reason is fairly intricate and explained <a class="reference external" href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant">on this page</a>;
the summary is that it's needed to help the type-checker treat functions that
don't mutate their arguments as covariant for arrays.</p>
<p>That said, in <a class="reference external" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html">TypeScript 2.6 this is being changed</a>
with a new strictness flag that treats parameters only contravariantly.</p>
</div>
<div class="section" id="explicit-variance-specification-in-python-type-checking">
<h2>Explicit variance specification in Python type-checking</h2>
<p>If you had to guess which of the mainstream languages has the most advanced
support for variance in their type system, Python probably wouldn't be your
first guess, right? I admit it wasn't mine either, because Python is dynamically
(duck) typed. But the new type hinting support (described in <a class="reference external" href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> with more details in <a class="reference external" href="https://www.python.org/dev/peps/pep-0483/">PEP 483</a>) is actually fairly advanced.</p>
<p>Here's an example:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mammal</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Cat</span><span class="p">(</span><span class="n">Mammal</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">count_mammals_list</span><span class="p">(</span><span class="n">seq</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Mammal</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

<span class="n">mlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mammal</span><span class="p">(),</span> <span class="n">Mammal</span><span class="p">()]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">count_mammals_list</span><span class="p">(</span><span class="n">mlst</span><span class="p">))</span>
</pre></div>
<p>If we run <tt class="docutils literal">mypy</tt> type-checking on this code, it will succeed.
<tt class="docutils literal">count_mammals_list</tt> takes a list of <tt class="docutils literal">Mammal</tt>s, and this is what we passed
in; so far, so good. However, the following will fail:</p>
<div class="highlight"><pre><span></span><span class="n">clst</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cat</span><span class="p">(),</span> <span class="n">Cat</span><span class="p">()]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">count_mammals_list</span><span class="p">(</span><span class="n">clst</span><span class="p">))</span>
</pre></div>
<p>Because <tt class="docutils literal">List</tt> is not covariant. Python doesn't know whether
<tt class="docutils literal">count_mammals_list</tt> will modify the list, so allowing calls with a list of
<tt class="docutils literal">Cat</tt>s is potentially unsafe.</p>
<p>It turns out that the <tt class="docutils literal">typing</tt> module lets us express the variance of types
explicitly. Here's a very minimal &quot;immutable list&quot; implementation that only
supports counting elements:</p>
<div class="highlight"><pre><span></span><span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ImmutableList</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T_co</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lst</span><span class="p">)</span>
</pre></div>
<p>And now if we define:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_mammals_ilist</span><span class="p">(</span><span class="n">seq</span> <span class="p">:</span> <span class="n">ImmutableList</span><span class="p">[</span><span class="n">Mammal</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>We can actually invoke it with a <tt class="docutils literal">ImmutableList</tt> of <tt class="docutils literal">Cat</tt>s, and this will
pass type checking:</p>
<div class="highlight"><pre><span></span><span class="n">cimmlst</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="p">([</span><span class="n">Cat</span><span class="p">(),</span> <span class="n">Cat</span><span class="p">()])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">count_mammals_ilist</span><span class="p">(</span><span class="n">cimmlst</span><span class="p">))</span>
</pre></div>
<p>Similarly, we can support contravariant types, etc. The <tt class="docutils literal">typing</tt> module also
provides a number of useful built-ins; for example, it's not really necessary
to create an <tt class="docutils literal">ImmutableList</tt> type, as there's already a <tt class="docutils literal">Sequence</tt> type that
is covariant.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>In most cases <tt class="docutils literal">&lt;:</tt> is also antisymmetric, making it a
<a class="reference external" href="../partial-and-total-orders/index.html">partial order</a>,
but in some cases it isn't; for example, structs with permuted fields can
be considered subtypes of each other (in most languages they aren't!) but
such subtyping is not antisymmetric.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>These terms come from math, and a good
rule of thumb to remember how they apply is: <em>co</em> means together, while
<em>contra</em> means against. As long as the composite types vary together (in
the same direction) as their component types, they are <em>co</em>-variant. When
they vary against their component types (in the reverse direction), they
are <em>contra</em>-variant.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>Strictly speaking, integer literals like <tt class="docutils literal">5</tt> are primitives in Java
and not objects at all. However, due to <a class="reference external" href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">autoboxing</a>,
this is equivalent to wrapping the <tt class="docutils literal">5</tt> in <tt class="docutils literal">Integer</tt> prior to the
assignment.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>Note that we're using pointer types here. The same example would work
with <tt class="docutils literal"><span class="pre">std::function&lt;Mammal(Mammal)&gt;</span></tt> and corresponding <tt class="docutils literal">f1</tt> taking
and returning value types. It's just that in C++ value types are not
very useful for polymorphism, so pointer (or reference) values are much
more commonly used.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2018/covariance-and-contravariance-in-subtyping/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:14 GMT -->
</html>