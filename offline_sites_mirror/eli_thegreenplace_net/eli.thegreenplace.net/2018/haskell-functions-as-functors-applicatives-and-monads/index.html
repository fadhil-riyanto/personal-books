<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2018/haskell-functions-as-functors-applicatives-and-monads/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:44 GMT -->
<head>
    <title>Haskell functions as functors, applicatives and monads - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Haskell functions as functors, applicatives and monads">
                        Haskell functions as functors, applicatives and monads
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> January 22, 2018 at 05:19</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/haskell.html">Haskell</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This post explores how functions in Haskell can be seen as instances of the
<tt class="docutils literal">Functor</tt>, <tt class="docutils literal">Applicative</tt> and <tt class="docutils literal">Monad</tt> type classes, with some reflection on
the practical uses of this technique.</p>
<div class="section" id="function-as-an-instance-of-functor">
<h2>Function as an instance of Functor</h2>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
<p>Types parameterized by a single type can be instances of <tt class="docutils literal">Functor</tt> if they
implement <tt class="docutils literal">fmap</tt> in a way that follows the functor laws. The simplest example
is <tt class="docutils literal">Maybe</tt>; <tt class="docutils literal">Maybe</tt> is a type parameterized by a single type (also known
as <em>type constructor</em>):</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">Maybe</tt> is a <tt class="docutils literal">Functor</tt>:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>So what about functions? In general, a function <tt class="docutils literal"><span class="pre">(-&gt;)</span></tt> is parameterized by
<em>two</em> types: <tt class="docutils literal">a <span class="pre">-&gt;</span> b</tt> or alternatively <tt class="docutils literal"><span class="pre">(-&gt;)</span> a b</tt> - both <tt class="docutils literal">a</tt> (the function
argument) and <tt class="docutils literal">b</tt> (the function return value) can have arbitrary types for an
arbitrary function. So functions aren't a good fit for <tt class="docutils literal">Functor</tt>, unless we
tweak something.</p>
<p>The tweak is to fix the argument type, leaving only the return type arbitrary.
This is written as <tt class="docutils literal"><span class="pre">(-&gt;)</span> a</tt>, a type parameterized by a single type - the
return value (the argument type is fixed at <tt class="docutils literal">a</tt>). Haskell type constructors
can be partially applied, same as functions. As an example, consider <tt class="docutils literal">Either</tt>,
which is a type constructor parameterized by two types <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">kind</span><span class="w"> </span><span class="kt">Either</span><span class="w"></span>
<span class="kt">Either</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
</pre></div>
<p>If we partially apply the <tt class="docutils literal">Either</tt> type constructor we get another type
constructor, this time with a single type parameter:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">kind</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kt">Either</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
</pre></div>
<p>Similarly, we can check the kind of functions:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">kind</span><span class="w"> </span><span class="p">(</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
</pre></div>
<p>And of partially-applied functions:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">kind</span><span class="w"> </span><span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
</pre></div>
<p>Before showing how <tt class="docutils literal"><span class="pre">(-&gt;)</span> a</tt> is an instance of <tt class="docutils literal">Functor</tt>, let's reformulate
it in a slightly more explicit way. Let's use <tt class="docutils literal">FuncWithArgA</tt> to name the
concept of &quot;a function with argument of type <tt class="docutils literal">a</tt>&quot;. This type is parameterized
by a single type: <tt class="docutils literal">b</tt>, the return value type.</p>
<p>So if we had to make <tt class="docutils literal">FuncWithArgA</tt> an instance of <tt class="docutils literal">Functor</tt>, the type of
<tt class="docutils literal">fmap</tt> would be:</p>
<div class="highlight"><pre><span></span><span class="nf">fmap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">FuncWithArgA</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">FuncWithArgA</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
<p>That is, we map a function <tt class="docutils literal">b <span class="pre">-&gt;</span> c</tt> onto <tt class="docutils literal">FuncWithArgA b</tt> to produce
<tt class="docutils literal">FuncWithArgA c</tt>. Now if we go back to the actual type of functions
parameterized by the return type, we get:</p>
<div class="highlight"><pre><span></span>fmap :: (b -&gt; c) -&gt; ((-&gt;) a) b -&gt; ((-&gt;) a) c

... or

fmap :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</pre></div>
<p>So this should be the type of <tt class="docutils literal">fmap</tt> for functions. One way to make this work
would be <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="n">ff</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Let's follow the types: <tt class="docutils literal">ff</tt> is our functor - it's a function <tt class="docutils literal">a <span class="pre">-&gt;</span> b</tt>. The
mapped function <tt class="docutils literal">g</tt> is <tt class="docutils literal">b <span class="pre">-&gt;</span> c</tt>. Hence, the result of <tt class="docutils literal">fmap</tt> is a function
taking <tt class="docutils literal">a</tt> and returning <tt class="docutils literal">c</tt>, or <tt class="docutils literal">a <span class="pre">-&gt;</span> c</tt>, so this matches the expected
type.</p>
<p>Note that <tt class="docutils literal">\x <span class="pre">-&gt;</span> g (ff x)</tt> is precisely the composition of <tt class="docutils literal">g</tt> onto
<tt class="docutils literal">ff</tt>, or <tt class="docutils literal">g . ff</tt> in Haskell notation. So being extra clever, we can use
point-free notation to rewrite our <tt class="docutils literal">Functor</tt> instance as:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">.</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Now it's time for an example. Let's take the function <tt class="docutils literal">replicate</tt>:</p>
<div class="highlight"><pre><span></span><span class="nf">replicate</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
</pre></div>
<p>By itself, <tt class="docutils literal">replicate</tt> has two arguments, so it's not a good match for our
<tt class="docutils literal">Functor</tt>. But if we <em>partially apply</em> it, it will be. Say <tt class="docutils literal">replicate 4</tt>.
Its type is:</p>
<div class="highlight"><pre><span></span>&gt; :t replicate 4
replicate 4 :: b -&gt; [b]
</pre></div>
<p><tt class="docutils literal">replicate 4</tt> is a function a single parameter - a perfect fit for
<tt class="docutils literal">Functor</tt>. So we can use <tt class="docutils literal">fmap</tt> on it! Let's <tt class="docutils literal">fmap</tt> the function <tt class="docutils literal">show</tt>
on it. <tt class="docutils literal">show</tt> takes any &quot;showable&quot; type and produces <tt class="docutils literal">String</tt>. Therefore:</p>
<div class="highlight"><pre><span></span>&gt; :t fmap show (replicate 4)
fmap show (replicate 4) :: Show a =&gt; a -&gt; String
</pre></div>
<p>Let's check the type of <tt class="docutils literal">fmap</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">replicate 4</tt> is <tt class="docutils literal">b <span class="pre">-&gt;</span> [b]</tt></li>
<li><tt class="docutils literal">show</tt> is <tt class="docutils literal">Show a =&gt; a <span class="pre">-&gt;</span> String</tt>; in this case <tt class="docutils literal">[b] <span class="pre">-&gt;</span> String</tt></li>
<li>So <tt class="docutils literal">fmap show (replicate 4)</tt> is <tt class="docutils literal">b <span class="pre">-&gt;</span> String</tt>, via function composition</li>
</ul>
<p>We can try it on different types:</p>
<div class="highlight"><pre><span></span>&gt; fmap show (replicate 4) 5
&quot;[5,5,5,5]&quot;
&gt; fmap show (replicate 4) (Just 6)
&quot;[Just 6,Just 6,Just 6,Just 6]&quot;
</pre></div>
</div>
<div class="section" id="functor-laws-for-functions">
<h2>Functor laws for functions</h2>
<p>To be a proper <tt class="docutils literal">Functor</tt> in Haskell, it isn't sufficient to define a
<tt class="docutils literal">Functor</tt> instance that type-checks. In addition, the definition has to
satisfy the <em>functor laws</em>:</p>
<div class="highlight"><pre><span></span>fmap id = id
fmap (g . h) = fmap g . fmap h
</pre></div>
<p>Explaining how the <tt class="docutils literal">Functor</tt> instance for functions shown above satisfies
these laws is a great exercise in mind-bending Haskell notation, and really
stresses our grasp of types and type constructors. Let's get to it.</p>
<p>Two factors that make such derivations difficult to follow for beginners in
Haskell are <a class="reference external" href="https://wiki.haskell.org/Pointfree">point-free style</a> and
currying. As an example, what does <tt class="docutils literal">fmap id</tt> mean <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>?</p>
<p>We know that <tt class="docutils literal">fmap</tt> takes two arguments: a mapped function and the functor.
<tt class="docutils literal">fmap id</tt> is partially applied, or <em>curried</em> - it's another function that
already accounts for the mapped function so it only takes a single argument -
the functor. All Haskell functions are curried by default, so any multi-argument
function can be expressed as a single-argument function returning a function. In
the case of <tt class="docutils literal">fmap</tt>:</p>
<div class="highlight"><pre><span></span>fmap g ff = \x -&gt; g (ff x)

... can be written as

fmap g = \ff -&gt; \x -&gt; g (ff x)
</pre></div>
<p>This helps, because now we can write down what <tt class="docutils literal">fmap id</tt> is:</p>
<div class="highlight"><pre><span></span>fmap id = \ff -&gt; \x -&gt; id (ff x)

... or

fmap id = \ff -&gt; \x -&gt; ff x
</pre></div>
<p>And this is exactly <tt class="docutils literal">id</tt>, because it takes <tt class="docutils literal">ff</tt> and returns a function that
takes an argument and applies <tt class="docutils literal">ff</tt> to it - which is just <tt class="docutils literal">ff</tt> itself. So the
first functor law holds. Let's take a look at the second one:</p>
<div class="highlight"><pre><span></span>fmap (g . h) = fmap g . fmap h
</pre></div>
<p>As before, <tt class="docutils literal">fmap (g . h)</tt> can be written more explicitly as:</p>
<div class="highlight"><pre><span></span>fmap (g . h) ff = \x -&gt; (g . h) (ff x)
                = \x -&gt; g (h (ff x))
</pre></div>
<p>On the other hand:</p>
<div class="highlight"><pre><span></span>(fmap g . fmap h) ff
  = fmap g (fmap h ff)

  ... by definition of &quot;fmap h ff&quot;

  = fmap g (\x -&gt; h (ff x))

  ... by definition of &quot;fmap g ff&quot; for ff now being (fmap h ff)

  = \y -&gt; g ((\x -&gt; h (ff x)) y)
  = \y -&gt; g (h (ff y))
</pre></div>
<p>So the second law holds as well, meaning that our <tt class="docutils literal">Functor</tt> instance for
functions is legitimate.</p>
</div>
<div class="section" id="function-as-an-instance-of-applicative">
<h2>Function as an instance of Applicative</h2>
<p>Let's now move on to how functions are defined to be instances of
<tt class="docutils literal">Applicative</tt>. A reminder:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">pure</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
<p>Let's start by figuring out the types of these methods in a function instance,
using the helper <tt class="docutils literal">FuncWithArgA</tt> substitute.</p>
<div class="highlight"><pre><span></span>pure :: b -&gt; FuncWithArgA b
</pre></div>
<p>Replacing <tt class="docutils literal">FuncWithArgA</tt> by <tt class="docutils literal"><span class="pre">(-&gt;)</span> a</tt>, we get:</p>
<div class="highlight"><pre><span></span>pure :: b -&gt; (a -&gt; b)
</pre></div>
<p>A function that satisfies this type is:</p>
<div class="highlight"><pre><span></span>pure = \x -&gt; (\y -&gt; x)
</pre></div>
<p>This is a very peculiar function, you'll notice. It takes two arguments and
returns the first, completely ignoring the second. Haskell already has such a
function in the standard library, it's called
<tt class="docutils literal">const</tt>:</p>
<div class="highlight"><pre><span></span>&gt; :t const
const :: a -&gt; b -&gt; a
&gt; :t const 10
const 10 :: Num a =&gt; b -&gt; a
&gt; (const 10) &quot;foo&quot;
10
&gt; (const 10) (Just 20)
10
</pre></div>
<p>Using point-free style, <tt class="docutils literal">pure</tt> is defined as:</p>
<div class="highlight"><pre><span></span>pure = const
</pre></div>
<p>Now let's turn our attention to the <tt class="docutils literal">&lt;*&gt;</tt> operator. Once again, we'll be using
<tt class="docutils literal">FuncWithArgA</tt>; to make it more readable I'll rename the types in the
declaration of <tt class="docutils literal">&lt;*&gt;</tt>, since <tt class="docutils literal">a</tt> is already implied in <tt class="docutils literal">FuncWithArgA</tt>:</p>
<div class="highlight"><pre><span></span>(&lt;*&gt;) :: FuncWithArgA (b -&gt; c) -&gt; FuncWithArgA b -&gt; FuncWithArgA c

.. replacing FuncWithArgA by ((-&gt;) a)

(&lt;*&gt;) :: (a -&gt; (b -&gt; c)) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</pre></div>
<p>A definition that satisfies this type is:</p>
<div class="highlight"><pre><span></span><span class="nf">g</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>The type of <tt class="docutils literal">g</tt> is <tt class="docutils literal">a <span class="pre">-&gt;</span> b <span class="pre">-&gt;</span> c</tt> and the type of <tt class="docutils literal">h</tt> is <tt class="docutils literal">a <span class="pre">-&gt;</span> b</tt>; hence,
for a parameter of type <tt class="docutils literal">a</tt>, the type of the expression is indeed <tt class="docutils literal">a <span class="pre">-&gt;</span> c</tt>.</p>
<p>To conclude, the <tt class="docutils literal">Applicative</tt> instance for functions looks like this:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">pure</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">const</span><span class="w"></span>
<span class="w">  </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="applicative-laws-for-functions">
<h2>Applicative laws for functions</h2>
<p>Let's see how the instance defined satisfies the applicative laws:</p>
<div class="highlight"><pre><span></span>pure id &lt;*&gt; x = x
pure (g x) = pure g &lt;*&gt; pure x
x &lt;*&gt; pure y = pure (\g -&gt; g y) &lt;*&gt; x
x &lt;*&gt; (y &lt;*&gt; z) = (pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z
</pre></div>
<p>Starting with the <strong>first law</strong> <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>:</p>
<div class="highlight"><pre><span></span>pure id &lt;*&gt; x

.. by definition of pure

(\x -&gt; (\y -&gt; x)) id &lt;*&gt; x
(\y -&gt; id) &lt;*&gt; x

.. by definition of &lt;*&gt;, with (\y -&gt; id) for g and x for h

\z -&gt; (\y -&gt; id) z (x z)

.. using partial function application

\z -&gt; id (x z)
\z -&gt; x z
</pre></div>
<p>Which is just another way of saying <tt class="docutils literal">x</tt> - a function taking a single parameter
and applying <tt class="docutils literal">x</tt> to it. The first law holds! For the <strong>second law</strong>:</p>
<div class="highlight"><pre><span></span>pure (g x)

.. by definition of pure

\y -&gt; g x
</pre></div>
<p>Right-hand side:</p>
<div class="highlight"><pre><span></span>pure g &lt;*&gt; pure x

.. by definition of pure

\y -&gt; g &lt;*&gt; \z -&gt; x

.. by definition of &lt;*&gt;

\t -&gt; (\y -&gt; g) t ((\z -&gt; x) t)
\t -&gt; (\y -&gt; g) t x
\t -&gt; g x
</pre></div>
<p>The <strong>third law</strong>, left-hand side:</p>
<div class="highlight"><pre><span></span>x &lt;*&gt; pure y
x &lt;*&gt; \z -&gt; y

.. by definition of &lt;*&gt;

\t -&gt; x t ((\z -&gt; y) t)
\t -&gt; x t y
</pre></div>
<p>Right-hand side:</p>
<div class="highlight"><pre><span></span>pure (\g -&gt; g y) &lt;*&gt; x
\z -&gt; (\g -&gt; g y) &lt;*&gt; x

.. by definition of &lt;*&gt;

\t -&gt; (\z -&gt; (\g -&gt; g y)) t (x t)
\t -&gt; (\g -&gt; g y) (x t)
\t -&gt; x t y
</pre></div>
<p>The <strong>fourth law</strong>, left-hand side:</p>
<div class="highlight"><pre><span></span>x &lt;*&gt; (y &lt;*&gt; z)
x &lt;*&gt; (\t -&gt; y t (z t))
\g -&gt; x g ((\t-&gt; y t (z t)) g)
\g -&gt; x g (y g (z g))
</pre></div>
<p>Right-hand side:</p>
<div class="highlight"><pre><span></span>(pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z
((\t -&gt; (.) (x t)) &lt;*&gt; y) &lt;*&gt; z
(\g -&gt; ((.) (x g)) (y g)) &lt;*&gt; z
\v -&gt; x v ((y v) (z v))
</pre></div>
</div>
<div class="section" id="function-as-an-instance-of-monad">
<h2>Function as an instance of Monad</h2>
<p>Finally, let's see how functions are instances of <tt class="docutils literal">Monad</tt>, which is defined
as:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
<p>For functions, starting with the <tt class="docutils literal">FuncWithArgA</tt> helper:</p>
<div class="highlight"><pre><span></span>return :: b -&gt; FuncWithArgA b
</pre></div>
<p>Which, as for <tt class="docutils literal">Applicative</tt> has the type:</p>
<div class="highlight"><pre><span></span>b -&gt; a -&gt; b
</pre></div>
<p>Which is satisfied by the same function, <tt class="docutils literal">const</tt>:</p>
<div class="highlight"><pre><span></span>return = const
</pre></div>
<p>Now, on to <tt class="docutils literal">&gt;&gt;=</tt>:</p>
<div class="highlight"><pre><span></span>&gt;&gt;= :: FuncWithArgA b -&gt; (b -&gt; FuncWithArgA c) -&gt; FuncWithArgA c

.. Unpacking the ``FuncWithArgA`` helper:

&gt;&gt;= :: (a -&gt; b) -&gt; (b -&gt; (a -&gt; c)) -&gt; (a -&gt; c)
&gt;&gt;= :: (a -&gt; b) -&gt; (b -&gt; a -&gt; c) -&gt; (a -&gt; c)
</pre></div>
<p>A definition that satisfies this type is:</p>
<div class="highlight"><pre><span></span><span class="nf">g</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="monad-laws-for-functions">
<h2>Monad laws for functions</h2>
<p>The monad laws are:</p>
<div class="highlight"><pre><span></span>return x &gt;&gt;= f = f x
mx &gt;&gt;= return = mx
(mx &gt;&gt;= f) &gt;&gt;= g = mx &gt;&gt;= (\x -&gt; (f x &gt;&gt;= g))
</pre></div>
<p>Let's start with the <strong>first law</strong>. Left-hand side:</p>
<div class="highlight"><pre><span></span>return x = \y -&gt; x
return x &gt;&gt;= f = \t -&gt; f ((\y -&gt; x) t) t
               = \t -&gt; f x t
</pre></div>
<p>This is equivalent to <tt class="docutils literal">f x</tt>, which is in point-free style. The left-hand
side for the <strong>second law</strong>:</p>
<div class="highlight"><pre><span></span>mx &gt;&gt;= return = \t -&gt; return (mx t) t

              .. by definition of return, returns the first argument whenever
                 applied.

              = \t -&gt; mx t
</pre></div>
<p>This can be written as just <tt class="docutils literal">mx</tt> in point-free style. Finally, the <strong>third
law</strong>. Left-hand side:</p>
<div class="highlight"><pre><span></span>(mx &gt;&gt; f) &gt;&gt;= g = (\x -&gt; f (mx x) x) &gt;&gt;= g
                = \t -&gt; g ((\x -&gt; f (mx x) x) t) t
                = \t -&gt; g (f (mx t) t) t
</pre></div>
<p>Right-hand side:</p>
<div class="highlight"><pre><span></span>mx &gt;&gt;= (\x -&gt; (f x &gt;&gt;= g)) = mx &gt;&gt;= (\x -&gt; (\t -&gt; g (f x t) t))
                           = \z -&gt; (\x -&gt; (\t -&gt; g (f x t) t)) (mx z) z
                           = \z -&gt; (\t -&gt; g (f (mx z) t) t) z
                           = \z -&gt; g (f (mx z) z) z
</pre></div>
<p>Which is equivalent, modulo the renamed bound variable.</p>
</div>
<div class="section" id="real-life-applicability">
<h2>Real-life applicability</h2>
<p>Now that we've persevered through the derivations, what practical uses does this
technique have? I was wondering the same, so I created a <a class="reference external" href="https://stackoverflow.com/questions/46631242/use-cases-for-functor-applicative-monad-instances-for-functions">Stack Overflow
question</a>
that got a couple of answers. The main idea is that it lets us compose functions
more succinctly, using more Haskell-y point-free style instead of explicitly
creating functions with named parameters.</p>
<p>Consider the following example, taken from the top answer in the linked
question. Here's a way to find whether a sequence is ascending:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">drop</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="kt">False</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">drop</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
</pre></div>
<p>Note that we create an explicit lambda for combining <tt class="docutils literal">zipWith</tt> with its
parameters in the right way. Using applicative style, we don't need it and can
write the code more succinctly <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="kt">False</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
</pre></div>
<p>Note how this achieves the same, but without the explicit lambda. <tt class="docutils literal">&lt;*&gt;</tt> does
the functional composition for us. As an exercise, follow the types of the
sub-expressions in the <tt class="docutils literal">&lt;*&gt;</tt> to see how this works.</p>
<p>Is this something you'd use in real programs? Maybe, maybe not. I think it
depends on personal and project style. The first (non-applicative) option
certainly looks more readable to me, but that's because I'm far from being a
Haskell pro. Seasoned Haskellers may find the latter more stylistically
appealing because it's more point-free, without naming parameters explicitly.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>These samples show <a class="reference external" href="https://en.wikipedia.org/wiki/Kind_(type_theory)">Haskell kinds</a>
using the <tt class="docutils literal">:kind</tt> query in <tt class="docutils literal">ghci</tt>. In <tt class="docutils literal">:kind</tt> output, <tt class="docutils literal">*</tt> denotes
concrete values (also known as <em>nullary type contructors</em>), <tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt>
denotes a single-parameter type constructor (for example the kind of
<tt class="docutils literal">Maybe</tt> is <tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt>), and so on.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>In fact, it's not just <em>one way</em> to make this work; it's <em>the only</em> way
to make this work. <tt class="docutils literal">Functor</tt> instances for any given type are unique
in Haskell, as long as the functor laws are satisfied. This can be proved
but is outside the scope of this article.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>Note that in the equation <tt class="docutils literal">fmap id = id</tt>, the types of <tt class="docutils literal">id</tt> are
different on the left and on the right. On the left, <tt class="docutils literal">fmap id</tt> takes
a functor and returns a functor, while <tt class="docutils literal">id</tt> takes and returns the
<em>type parameter of the functor</em>. In other words, for <tt class="docutils literal">Functor a</tt>,
<tt class="docutils literal">id</tt> on the left has type <tt class="docutils literal">a <span class="pre">-&gt;</span> a</tt> while <tt class="docutils literal">id</tt> on the right has type
<tt class="docutils literal">Functor a <span class="pre">-&gt;</span> Functor a</tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>In this derivation, and throughout the post I'm making liberal use of the
power of renaming bound variables in functions. For example I may have
a function <tt class="docutils literal">\x <span class="pre">-&gt;</span> foo x</tt> on one line, and refer to it as <tt class="docutils literal">\y <span class="pre">-&gt;</span> foo
y</tt> on another line - the two are equivalent, and this renaming helps
avoid name collisions. This is called <a class="reference external" href="https://wiki.haskell.org/Alpha_conversion">alpha conversion</a> in Lambda calculus.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>You'll need to import <tt class="docutils literal">Control.Applicative</tt> to get access to the
built-in applicative instance for functions.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2018/haskell-functions-as-functors-applicatives-and-monads/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:44 GMT -->
</html>