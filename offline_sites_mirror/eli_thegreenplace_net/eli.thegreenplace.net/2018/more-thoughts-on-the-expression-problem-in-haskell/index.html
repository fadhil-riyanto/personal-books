<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2018/more-thoughts-on-the-expression-problem-in-haskell/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:43 GMT -->
<head>
    <title>More thoughts on the Expression Problem in Haskell - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to More thoughts on the Expression Problem in Haskell">
                        More thoughts on the Expression Problem in Haskell
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> February 05, 2018 at 06:45</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/haskell.html">Haskell</a>
        ,
    <a href="../../tag/multiple-dispatch.html">Multiple dispatch</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>My <a class="reference external" href="../../2016/the-expression-problem-and-its-solutions/index.html">previous post</a>
discussed the Expression Problem and presented code in several languages to
demonstrate the issue and some solutions. Haskell was used as the poster boy for
functional languages which suffer from the problem in one of its dimensions
(particularly - it being easy to add new functions but not new types).</p>
<p>In comments to that post (and other comments made online) it was pointed out
that using typeclasses could help solve or alleviate the problem in Haskell, and
I want to fix any misconceptions by pursuing this approach right now. While
typeclasses can help work around some issues related to the Expression Problem,
they don't provide a complete solution - at least not in the way usually
presented in online tutorials. For a more complete solution, we'll going to dig
a bit deeper.</p>
<div class="section" id="a-quick-recap">
<h2>A quick recap</h2>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Expression_problem">Expression Problem</a> in
Haskell can be demonstrated with the following code:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Expr</span><span class="w"></span>

<span class="nf">stringify</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">stringify</span><span class="w"> </span><span class="n">lhs</span><span class="w"></span>
<span class="w">                                </span><span class="o">++</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"></span>
<span class="w">                                </span><span class="o">++</span><span class="w"> </span><span class="n">stringify</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>

<span class="nf">evaluate</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>
</pre></div>
<p>While it's easy to add new functions (for example <tt class="docutils literal">typecheck</tt>) without
modifying existing code, the same cannot be said of new expression types. If we
add a new type - say <tt class="docutils literal">BinaryMul</tt>, we'll have to modify a whole bunch of
existing code - the definitions of <tt class="docutils literal">stringify</tt> and <tt class="docutils literal">evaluate</tt> (and
<tt class="docutils literal">typecheck</tt> if we already had it).</p>
<img alt="FP expression problem matrix" class="align-center" src="../../images/2016/expr-problem-fp.png" />
</div>
<div class="section" id="typeclasses-to-the-rescue">
<h2>Typeclasses to the rescue</h2>
<p>The following shows how to &quot;solve&quot; the aforementioned issue with typeclasses.
The word &quot;solve&quot; is in quotes for a reason - this is not a complete solution, as
we shall soon see. And yet, this is the most common solution you will find
online, so I wanted to inspect it in detail before we go deeper.</p>
<p>We start by definiting the data types for different nodes:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Constant</span><span class="w">           </span><span class="ow">=</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>They are separate now, and not variants of the same <tt class="docutils literal">data</tt>. Having all nodes
under the same <tt class="docutils literal">data</tt> created the expression problem in the first place,
because we had to update the pattern matching rules in every function whenever a
new type is added.</p>
<p>We tie them together with an empty typeclass <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="n">e</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Constant</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Expr</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>So now, even though <tt class="docutils literal">Constant</tt> and <tt class="docutils literal">BinaryPlus</tt> are completely different
data types, they are both instances of <tt class="docutils literal">Expr</tt>, which provides a unification
point by letting functions and other classes require an <tt class="docutils literal">Expr</tt>-implementing
type in parameters, etc.</p>
<p>Let's implement evaluation for these expressions:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">Expr</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evaluate</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evaluate</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eval</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evaluate</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhsx</span><span class="w"> </span><span class="n">rhsx</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">lhsx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">rhsx</span><span class="w"></span>
</pre></div>
<p>Now we can do this from a terminal:</p>
<div class="highlight"><pre><span></span>&gt; let e = BinaryPlus (Constant 1.1) (Constant 2.2)
&gt; evaluate e
3.3000000000000003
</pre></div>
<p>Adding new functions is fairly easy:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">Expr</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringify</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Stringify</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhsx</span><span class="w"> </span><span class="n">rhsx</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">printf</span><span class="w"> </span><span class="s">&quot;(%s + %s)&quot;</span><span class="w"></span>
<span class="w">                                       </span><span class="p">(</span><span class="n">stringify</span><span class="w"> </span><span class="n">lhsx</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">stringify</span><span class="w"> </span><span class="n">rhsx</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>As before, we didn't have to modify any of the existing code to add this, so
that's good. What about new types though, will it be easier this time? Let's add
a <tt class="docutils literal">BinaryMul</tt> node:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Expr</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eval</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evaluate</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">lhsx</span><span class="w"> </span><span class="n">rhsx</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">lhsx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">rhsx</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Stringify</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">lhsx</span><span class="w"> </span><span class="n">rhsx</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">printf</span><span class="w"> </span><span class="s">&quot;(%s * %s)&quot;</span><span class="w"></span>
<span class="w">                                      </span><span class="p">(</span><span class="n">stringify</span><span class="w"> </span><span class="n">lhsx</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">stringify</span><span class="w"> </span><span class="n">rhsx</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Taking it for a ride:</p>
<div class="highlight"><pre><span></span>&gt; let d = BinaryMul (Constant 2.0) (BinaryPlus (Constant 2.0) (Constant 0.5))
&gt; evaluate d
5.0
&gt; stringify d
&quot;(2.0 * (2.0 + 0.5))&quot;
</pre></div>
<p>It works! And note that we didn't have to modify any existing code to add a new
type - <tt class="docutils literal">instance</tt> definitions live outside their original <tt class="docutils literal">class</tt>, so they
can be defined for new types without touching existing code (not unlike the
Clojure multimethods discussed in <a class="reference external" href="../../2016/the-expression-problem-and-its-solutions/index.html">the original post</a>).</p>
<p>So this is it! Problem solved, right? Well, no. It does seem like we've managed
to add both a new function and a new type without modifying existing code, but
if we think about it a bit deeper - there's a huge problem lurking here. Can you
figure it out?</p>
<p>Alright, a hint. Imagine you want to write a function that parses a string and
produces an expression. What would the type of this function be? Specifically,
what is its return type?</p>
<p>When we split up <tt class="docutils literal">Constant</tt> and <tt class="docutils literal">BinaryPlus</tt> to different <tt class="docutils literal">data</tt> types, we
gained the ability to sidestep the expression problem, but we lost something
valuable too - the ability to unify them under a single type. No, a parsing
function cannot return <tt class="docutils literal">Expr</tt> - <tt class="docutils literal">Expr</tt> is not a type, it's a type class.
Here's a slightly different demonstration:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">20</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">2.2</span><span class="p">)</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">5.5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">2.1</span><span class="p">))</span><span class="w"></span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">43</span><span class="kt">:</span><span class="mi">44</span><span class="kt">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">Couldn&#39;t</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="p">`</span><span class="kt">Constant&#39;</span><span class="w"></span>
<span class="w">                </span><span class="n">with</span><span class="w"> </span><span class="n">actual</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="p">`</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kt">Constant&#39;</span><span class="w"></span>
<span class="w">    </span><span class="kt">In</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">`</span><span class="kt">BinaryPlus&#39;</span><span class="w"></span>
<span class="w">    </span><span class="kt">In</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">expression</span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">5.5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">2.1</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kt">In</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">expression</span><span class="kt">:</span><span class="w"></span>
<span class="w">      </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">2.2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="kr">else</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">5.5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">2.1</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Haskell won't have it. The type of <tt class="docutils literal">k</tt> can be inferred to either <tt class="docutils literal">Constant</tt>
or <tt class="docutils literal">BinaryPlus</tt>, but this has to be done at compile-time. This expression
tries to flip the type based on a run-time value, and that just isn't possible
<a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>.</p>
<p>To make this work, we'll need to rethink our <tt class="docutils literal">data</tt> declarations again,
attempting to unify different expression in a way that a single type can be
returned from functions. This complicates the code considerably, so take a deep
breath before reading on.</p>
</div>
<div class="section" id="combining-type-constructors">
<h2>Combining type constructors</h2>
<blockquote>
<strong>Disclaimer</strong>: the following is my exposition of the first part of Wouter
Swierstra's paper <em>&quot;Data types a la carte&quot;</em>. I'm also indebted to <a class="reference external" href="https://bartoszmilewski.com/">Bartosz
Milewski</a> for discussing the problem mentioned
above with me and his kind suggestion to read this paper.</blockquote>
<p>The last section ended with a problem - how to combine the different expression
types in a way that we could use a single type to refer to them? One idea that
can come to mind is using something like <tt class="docutils literal">Either</tt>. Here's a conditional
assignment similar to the one shown before:</p>
<div class="highlight"><pre><span></span>&gt; let k = if x &gt; 4 then Left &quot;Foo&quot; else Right 20
&gt; :t k
k :: Either [Char] Integer
</pre></div>
<p>However, using <tt class="docutils literal">Either</tt> directly presents some immediate challenges:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">Either</tt> expects concrete types, not type constructors. Its <em>kind</em> is
<tt class="docutils literal">* <span class="pre">-&gt;</span> * <span class="pre">-&gt;</span> *</tt>. Our expression types, like <tt class="docutils literal">BinaryPlus</tt>, are type
constructors (they accept type arguments).</li>
<li><tt class="docutils literal">Either</tt> supports two types - but we may need many more (a realistic case
would have dozens of expression types).</li>
</ol>
<p>So we're not going to be using <tt class="docutils literal">Either</tt> itself, but rather are going to keep
it in mind as inspiration.</p>
<p>In fact, we're going to start with something similar, by defining this type:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">ET</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">El</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Er</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>It's a bit like <tt class="docutils literal">Either</tt>, just for type constructors. It takes three
parameters: <tt class="docutils literal">f</tt> and <tt class="docutils literal">g</tt> are type constructors, and <tt class="docutils literal">e</tt> is a type that can
be passed to these type constructors. <tt class="docutils literal">ET</tt> &quot;unifies&quot; them in a way similar to
<tt class="docutils literal">Either</tt>. In the paper, Swierstra refers to <tt class="docutils literal">ET</tt> as <em>the coproduct of the
signatures of f and g</em>.</p>
<p>But how do such type constructors look? Here comes the tricky part, so get some
paper and think this through:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">In</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Expr</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Yes, this is a recursive type declaration. Note that both <tt class="docutils literal">Expr</tt> and <tt class="docutils literal">f</tt> are
type constructors here; <tt class="docutils literal">f</tt> takes a type parameter corresponding to the
expressions that occur as the subtrees of constructors.</p>
<p>Let's get to the more concrete types. Here are some of the familiar expression
node types:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
</pre></div>
<p>Note that:</p>
<ol class="arabic simple">
<li>They are separate types, not under the same <tt class="docutils literal">data</tt> declaration. Recall that
this part is important for solving the expression problem. This led to
another problem in the previous section, but we'll soon see how the clever
<tt class="docutils literal">Expr</tt> shown here will help us overcome it.</li>
<li>They all accept a type parameter <tt class="docutils literal">e</tt>; this is in preparation for making
them more generic in the sense of <tt class="docutils literal">Expr f</tt>.</li>
</ol>
<p>These types can be made instances of <tt class="docutils literal">Functor</tt> so that we can map things over
them in a uniform way:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">e1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">e1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Importantly, the coproduct <tt class="docutils literal">ET</tt> is also a <tt class="docutils literal">Functor</tt>:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="p">(</span><span class="kt">ET</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">El</span><span class="w"> </span><span class="n">e1</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">El</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">e1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Er</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Er</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Another important piece of the puzzle is <tt class="docutils literal">foldExpr</tt>, which lets us perform
a fold on an expression:</p>
<div class="highlight"><pre><span></span><span class="nf">foldExpr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">foldExpr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">In</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="p">(</span><span class="n">foldExpr</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">foldExpr</tt> takes a function that extracts the value from inside a functor, and
an <tt class="docutils literal">Expr</tt>. It uses <tt class="docutils literal">fmap</tt> to recursively extract a value from the contained
type. This is getting a bit complicated - an example will soon help clarify
things.</p>
<p>Finally, we're ready to define some operations on these expressions. Let's start
with <tt class="docutils literal">evaluate</tt>:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evalFunctor</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evalFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evalFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evalFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eval</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="p">(</span><span class="kt">ET</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">evalFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">El</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">evalFunctor</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="n">evalFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">Er</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">evalFunctor</span><span class="w"> </span><span class="n">y</span><span class="w"></span>

<span class="nf">evaluate</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eval</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="nf">evaluate</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldExpr</span><span class="w"> </span><span class="n">evalFunctor</span><span class="w"> </span><span class="n">expr</span><span class="w"></span>
</pre></div>
<p>First, <tt class="docutils literal">Eval</tt> is a typeclass that supports the <tt class="docutils literal">evalFunctor</tt> function which
produces a <tt class="docutils literal">Double</tt> from an expression. Instances for our data types are
trivial, and the instance for <tt class="docutils literal">ET</tt> simply propagates left or right based on
the combinator's contents.</p>
<p>We're ready for an example. Let's start by defining a type that unifies all our
three existing expression types:</p>
<div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">GeneralExpr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="p">(</span><span class="kt">ET</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="p">(</span><span class="kt">ET</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>This simply builds a binary tree of types; think of <tt class="docutils literal">Either</tt> again - this is
like the variable-length version of <tt class="docutils literal">Either</tt>, just for types. Here's how it
looks:</p>
<div class="highlight"><pre><span></span>        ET
       /  \
      /    \
     /      \
Constant    ET
           /  \
          /    \
         /   BinaryMul
        /
  BinaryPlus
</pre></div>
<p>As an example, we can define a simple constant and evaluate it as follows:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">In</span><span class="p">(</span><span class="kt">El</span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="mf">7.0</span><span class="p">))</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GeneralExpr</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="mf">7.0</span><span class="w"></span>
</pre></div>
<p>Do you see why <tt class="docutils literal">x</tt> is defined the way it is? We just follow the tree; one step
left (<tt class="docutils literal">El</tt>) and we get to <tt class="docutils literal">Constant</tt>; then wrap it in <tt class="docutils literal">In</tt> to make it an
<tt class="docutils literal">Expr</tt>, done. Now, what happens when <tt class="docutils literal">evaluate x</tt> is called? Let's trace it
through:</p>
<div class="highlight"><pre><span></span>-&gt; evaluate x

... x is of type GeneralExpr, so it&#39;s an Expr, and also satisfies Eval because
... there&#39;s an instance of Eval for ET

-&gt; foldExpr evalFunctor x
-&gt; evalFunctor (fmap (foldExpr evalFunctor) (El(Constant 7.0)))

... first, this fmap-s something on El(Constant 7.0); looking up the fmap
... definition for ET, this turns into El(fmap &lt;...&gt; (Constant 7.0))

-&gt; evalFunctor El(fmap (foldExpr evalFunctor) (Constant 7.0))

... but fmap-ing anything onto Constant just produces that Constant, so:

-&gt; evalFunctor El(Constant 7.0)

... looking up the instance of Eval for ET, we see that for (El x) we invoke
... evalFunctor x

-&gt; evalFunctor(Constant 7.0)

... and finally, for evalFunctor (Constant x) the answer is x

-&gt; 7.0
</pre></div>
<p>Now let's define a more complicated expression:</p>
<div class="highlight"><pre><span></span>&gt; let y = In(El(Constant 2.0)) :: GeneralExpr
&gt; let mulXY = In(Er(Er(BinaryMul x y))) :: GeneralExpr
&gt; let addXmulXY = In(Er(El(BinaryPlus x mulXY))) :: GeneralExpr
&gt; evaluate addXmulXY -- note: this does &quot;x + xy&quot;
21.0
</pre></div>
<p>It may take longer, but it should be fairly straightforward to trace through
this <tt class="docutils literal">evaluate</tt> similarly to the simpler case above. I recommend it as an
exercise! Pay special attention to how <tt class="docutils literal">BinaryPlus</tt> and <tt class="docutils literal">BinaryMul</tt> nodes
are created by picking the right path through the <tt class="docutils literal">ET</tt> tree defined for
<tt class="docutils literal">GeneralExpr</tt>.</p>
<p>It's time to see how to add new functions to this solution. Let's add
<tt class="docutils literal">stringify</tt>; it's very straightforward now that we know how <tt class="docutils literal">evaluate</tt> is
done:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="kt">BinaryMul</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryMul</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot; * &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Stringify</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">ET</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">El</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">Er</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="n">y</span><span class="w"></span>

<span class="nf">stringify</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Stringify</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">stringify</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldExpr</span><span class="w"> </span><span class="n">stringifyFunctor</span><span class="w"> </span><span class="n">expr</span><span class="w"></span>
</pre></div>
<p>It follows exactly the same pattern, and of course no modification of existing
code is required. Since our node types don't reside in a single <tt class="docutils literal">data</tt> type,
there's no pattern matching to update. The new functionality is provided by
instances of the <tt class="docutils literal">Stringify</tt> typeclass.</p>
<div class="highlight"><pre><span></span>&gt; stringify x
&quot;7.0&quot;
&gt; stringify addXmulXY
&quot;(7.0 + (7.0 * 2.0))&quot;
</pre></div>
</div>
<div class="section" id="reflecting-on-the-combinator-technique">
<h2>Reflecting on the combinator technique</h2>
<p>The technique presented in the previous section solves the expression problem.
It also doesn't suffer from the problem with the simpler typeclass approach,
because we now actually have <tt class="docutils literal">Expr</tt> as a unifying type. To go back to the
previous attempt to conditionally define a value of either type:</p>
<div class="highlight"><pre><span></span>&gt; let k = if p &gt; 4 then x else addXYmulX
&gt; :t k
k :: GeneralExpr
&gt; evaluate k
7.0
</pre></div>
<p>w00t, it works! So now we can actually write a parser that will return
<tt class="docutils literal">GeneralExpr</tt>, with the actual node type determined at run-time.</p>
<p>Not everything is perfect, though. There are a couple of problems with this
approach. First, it's really tedious to create expressions. Recall the sequence
of temporary <tt class="docutils literal">let</tt>s required to create the <tt class="docutils literal">addXmulXY</tt> node, and these
nestings of <tt class="docutils literal">El</tt> and <tt class="docutils literal">Er</tt> are quite tiresome.</p>
<p>Also, if we add more node types to our expression language, these
definitions will get even more complicated because the <tt class="docutils literal">ET</tt> tree will get
deeper; and finally, the worst problem of all, we'd have to rewrite the existing
code that creates expressions because the <tt class="docutils literal">El</tt> / <tt class="docutils literal">Er</tt> paths change. Note
that we won't have to modify the definitions of existing nodes; nor will we have
to modify the definitions of the existing functions like <tt class="docutils literal">evaluate</tt> and
<tt class="docutils literal">stringify</tt> (only add instances for new types), so the expression problem
isn't violated, strictly speaking.</p>
<p>There are a number of solutions possible for these problems, all of which make
the code even more complicated (FWIW I find the existing approach of the
recursive <tt class="docutils literal">Expr</tt> definition pretty obtuse already). If you keep reading
Swierstra's paper, section 4 discusses one mitigation by creating smarter
constructors; it even goes as far as to veer off the Haskell 98 standard,
requiring language extension support.</p>
<p>To be honest, I think this exploration went too far into the land of code
complexity already. How bad is the expression problem really? Why is it such a
taboo to modify existing code? Healthy code bases should be continously tended
to and refactored, in my view, and there's nothing wrong with modifying existing
code to generalize it. Sure, when the solution is as trivial as in Clojure, the
cost of maintaining these invariants is fairly small. But the approach presented
here for Haskell is so complex that I'd be careful about using it in real life.
There's a cost-benefit analysis to be made here, and I'm not sure which way it
would go.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>This typeclass is empty in the sense that it doesn't declare any methods
that need to be implemented by instances. Therefore any type can be made
an instance of this class just by declaring it as such.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>Incidentally, Clojure's dynamic nature is precisely what makes this
a non-problem in the Clojure multiple dispatch solution. Unlike Haskell,
Clojure doesn't attempt to infer a compile-time type for every expression
and values can hold different types at different times during execution.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>By <em>type constructor</em> I mean a
<a class="reference external" href="https://wiki.haskell.org/Constructor#Type_constructor">non-nullary type constructor</a>.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2018/more-thoughts-on-the-expression-problem-in-haskell/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:43 GMT -->
</html>