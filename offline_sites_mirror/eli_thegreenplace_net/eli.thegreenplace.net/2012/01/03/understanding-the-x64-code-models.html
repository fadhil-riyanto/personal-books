<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2012/01/03/understanding-the-x64-code-models by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:03:32 GMT -->
<head>
    <title>Understanding the x64 code models - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../theme/css/style.css" type="text/css"/>

        <link href="../../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../../index.html" class="navbar-brand">
                <img src="../../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="understanding-the-x64-code-models.html"
                       rel="bookmark"
                       title="Permalink to Understanding the x64 code models">
                        Understanding the x64 code models
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> January 03, 2012 at 05:46</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../../tag/assembly.html">Assembly</a>
        ,
    <a href="../../../tag/c-c.html">C & C++</a>
        ,
    <a href="../../../tag/linux.html">Linux</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                
        <p>An interesting issue that comes up when writing code for the x64 architecture is which code model to use. This probably isn't a very well-known topic, but if one wants to understand the x64 machine code generated by compilers, it's  educational to be familiar with code models. There are also implications for optimization, for those who really care about performance down to the smallest instruction.</p>

<p>There's very little information on this topic online or anywhere. By far the
most important resource is the official x64 ABI, which you can obtain from the
<a class="reference external" href="https://uclibc.org/specs.html">uclibc page</a>
(from now on I'm going to refer to it simply as &quot;the ABI&quot;). There's
also a bit of information in the <tt class="docutils literal">gcc</tt>
man-pages. The aim of this article is to provide an approachable reference, with
some discussion of the topic and concrete examples to demonstrate the concepts
in real-life code.</p>

<p>An important disclaimer: this is not a tutorial for beginners. The prerequisites are a solid understanding of C and assembly language, plus a basic familiarity with the x64 architecture.</p>
<div class="section" id="code-models-motivation">
<h3>Code models - motivation</h3>
<p>References to both code and data on x64 are done with instruction-relative (RIP-relative in x64 parlance) addressing modes. The offset from RIP in these instructions is limited to 32 bits. So what do we do when 32 bits are not enough? What if the program is larger than 2 GB? Then, a case can arise when an instruction attempting to address some piece of code (or data) just can't do it with its 32-bit offset from RIP.</p>
<p>One solution to this problem is to give up the RIP-relative addressing modes, and use absolute 64-bit offsets for all code and data references. But this has a high cost - more instructions are required to perform the simplest operations. It's a high cost to pay in <em>all code</em> just for the sake of the (very rare) case of extremely huge programs or libraries.</p>
<p>So, the compromise is code models <a class="footnote-reference" href="#id8" id="id1">[1]</a>. A code model is a formal agreement between the programmer and the compiler, in which the programmer states his intentions for the size of the eventual program(s) the object file that's being currently compiled will get into <a class="footnote-reference" href="#id9" id="id2">[2]</a>.</p>
<p>Code models exist for the programmer to be able to tell the compiler: don't worry, this object will only get into non-huge programs, so you can use the fast RIP-relative addressing modes. Conversely, he can tell the compiler: this object is expected to be linked into huge programs, so please use the slow but safe absolute addressing modes with full 64-bit offsets.</p>
</div>
<div class="section" id="what-will-be-covered-here">
<h3>What will be covered here</h3>
<p>The two scenarios described above have names: the <em>small code model</em> promises to the compiler that 32-bit relative offsets should be enough for all code and data references in the compiled object. The <em>large code model</em>, on the other hand, tells it not to make any assumptions and use absolute 64-bit addressing modes for code and data references. To make things more interesting, there's also a middle road, called the <em>medium code model</em>.</p>
<p>These code models exist separately for non-PIC and PIC code. The article is going to discuss all 6 variations.</p>
</div>
<div class="section" id="example-c-source">
<h3>Example C source</h3>
<p>I'll be using the following C program compiled with different code models to demonstrate the concepts discussed in the article. In this code, the <tt class="docutils literal">main</tt> function accesses 4 different global arrays and one global function. The arrays differ by two parameters: size and visibility. The size is important to explain the medium code model and won't be used for the small and large models. Visibility is either static (visible only in this source file) or completely global (visible by all other objects linked into the program). This distinction is important for the PIC code models.</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">int</span> global_arr[<span style="color: #007f7f">100</span>] = {<span style="color: #007f7f">2</span>, <span style="color: #007f7f">3</span>};
<span style="color: #00007f; font-weight: bold">static</span> <span style="color: #00007f; font-weight: bold">int</span> static_arr[<span style="color: #007f7f">100</span>] = {<span style="color: #007f7f">9</span>, <span style="color: #007f7f">7</span>};
<span style="color: #00007f; font-weight: bold">int</span> global_arr_big[<span style="color: #007f7f">50000</span>] = {<span style="color: #007f7f">5</span>, <span style="color: #007f7f">6</span>};
<span style="color: #00007f; font-weight: bold">static</span> <span style="color: #00007f; font-weight: bold">int</span> static_arr_big[<span style="color: #007f7f">50000</span>] = {<span style="color: #007f7f">10</span>, <span style="color: #007f7f">20</span>};

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">global_func</span>(<span style="color: #00007f; font-weight: bold">int</span> param)
{
    <span style="color: #00007f; font-weight: bold">return</span> param * <span style="color: #007f7f">10</span>;
}

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">main</span>(<span style="color: #00007f; font-weight: bold">int</span> argc, <span style="color: #00007f; font-weight: bold">const</span> <span style="color: #00007f; font-weight: bold">char</span>* argv[])
{
    <span style="color: #00007f; font-weight: bold">int</span> t = global_func(argc);
    t += global_arr[<span style="color: #007f7f">7</span>];
    t += static_arr[<span style="color: #007f7f">7</span>];
    t += global_arr_big[<span style="color: #007f7f">7</span>];
    t += static_arr_big[<span style="color: #007f7f">7</span>];
    <span style="color: #00007f; font-weight: bold">return</span> t;
}
</pre></div>
<p><tt class="docutils literal">gcc</tt> takes the code model as the value of the <tt class="docutils literal"><span class="pre">-mcmodel</span></tt> option. Additionally, PIC compilation can be specified with the <tt class="docutils literal"><span class="pre">-fpic</span></tt> flag.</p>
<p>For example, compiling it into an object file with the large code model and PIC enabled:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; gcc -g -O0 -c codemodel1.c -fpic -mcmodel=large -o codemodel1_large_pic.o
</pre></div>
</div>
<div class="section" id="small-code-model">
<h3>Small code model</h3>
<p>Here's what <tt class="docutils literal">man gcc</tt> has to say about the small code model:</p>
<blockquote>
<p><strong>-mcmodel=small</strong></p>
<p>Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space.  Pointers are 64 bits.  Programs can be statically or dynamically linked.  This is the default code model.</p>
</blockquote>
<p>In other words, the compiler is free to assume that all code and data can be accessed with 32-bit RIP-relative offsets from any instruction in the code. Let's see the disassembly of the example C program compiled in non-PIC small code model:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; objdump -dS codemodel1_small.o
[...]
int main(int argc, const char* argv[])
{
  15: 55                      push   %rbp
  16: 48 89 e5                mov    %rsp,%rbp
  19: 48 83 ec 20             sub    $0x20,%rsp
  1d: 89 7d ec                mov    %edi,-0x14(%rbp)
  20: 48 89 75 e0             mov    %rsi,-0x20(%rbp)
    int t = global_func(argc);
  24: 8b 45 ec                mov    -0x14(%rbp),%eax
  27: 89 c7                   mov    %eax,%edi
  29: b8 00 00 00 00          mov    $0x0,%eax
  2e: e8 00 00 00 00          callq  33 &lt;main+0x1e&gt;
  33: 89 45 fc                mov    %eax,-0x4(%rbp)
    t += global_arr[7];
  36: 8b 05 00 00 00 00       mov    0x0(%rip),%eax
  3c: 01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr[7];
  3f: 8b 05 00 00 00 00       mov    0x0(%rip),%eax
  45: 01 45 fc                add    %eax,-0x4(%rbp)
    t += global_arr_big[7];
  48: 8b 05 00 00 00 00       mov    0x0(%rip),%eax
  4e: 01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr_big[7];
  51: 8b 05 00 00 00 00       mov    0x0(%rip),%eax
  57: 01 45 fc                add    %eax,-0x4(%rbp)
    return t;
  5a: 8b 45 fc                mov    -0x4(%rbp),%eax
}
  5d: c9                      leaveq
  5e: c3                      retq
</pre></div>
<p>As we can see, all arrays are accessed in exactly the same manner - by using a simple RIP-relative offset. However, the offset in the code is 0, because the compiler doesn't know where the data section will be placed. So it also creates a relocation for each such access:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; readelf -r codemodel1_small.o

Relocation section &#39;.rela.text&#39; at offset 0x62bd8 contains 5 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000002f  001500000002 R_X86_64_PC32     0000000000000000 global_func - 4
000000000038  001100000002 R_X86_64_PC32     0000000000000000 global_arr + 18
000000000041  000300000002 R_X86_64_PC32     0000000000000000 .data + 1b8
00000000004a  001200000002 R_X86_64_PC32     0000000000000340 global_arr_big + 18
000000000053  000300000002 R_X86_64_PC32     0000000000000000 .data + 31098
</pre></div>
<p>Let's fully decode the access to <tt class="docutils literal">global_arr</tt> as an example. Here's the relevant part of the disassembly again:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  t += global_arr[7];
36:       8b 05 00 00 00 00       mov    0x0(%rip),%eax
3c:       01 45 fc                add    %eax,-0x4(%rbp)
</pre></div>
<p>RIP-relative addressing is relative to the next instruction. So the offset that should be patched into the <tt class="docutils literal">mov</tt> instruction should be relative to 0x3c. The relevant relocation is the second one, pointing to the operand of <tt class="docutils literal">mov</tt> at 0x38. It's <tt class="docutils literal">R_X86_64_PC32</tt>, which means: take the symbol value, add the addend and subtract the offset this relocation points to. If you do the math you see this ends up placing the relative offset between the next instruction and <tt class="docutils literal">global_arr</tt>, plus 0x1c. This relative offset is just what we need, since 0x1c simply means &quot;the 7th <tt class="docutils literal">int</tt> in the array&quot; (each <tt class="docutils literal">int</tt> is 4 bytes long on x64). So the instruction correctly references <tt class="docutils literal">global_arr[7]</tt> using RIP relative addressing.</p>
<p>Another interesting thing to note here is that although the instructions for accessing <tt class="docutils literal">static_arr</tt> are similar, its relocation has a different symbol, pointing to the <tt class="docutils literal">.data</tt> section instead of the specific symbol. This is because the static array is placed by the linker in the <tt class="docutils literal">.data</tt> section in a known location - it can't be shared with other shared libraries. This relocation will eventually get fully resolved by the linker. On the other hand, the reference to <tt class="docutils literal">global_arr</tt> will be left to the dynamic loader to resolve, since <tt class="docutils literal">global_arr</tt> can actually be used (or overridden by) a different shared library <a class="footnote-reference" href="#id10" id="id3">[3]</a>.</p>
<p>Finally, let's look at the reference to <tt class="docutils literal">global_func</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  int t = global_func(argc);
24:       8b 45 ec                mov    -0x14(%rbp),%eax
27:       89 c7                   mov    %eax,%edi
29:       b8 00 00 00 00          mov    $0x0,%eax
2e:       e8 00 00 00 00          callq  33 &lt;main+0x1e&gt;
33:       89 45 fc                mov    %eax,-0x4(%rbp)
</pre></div>
<p>The operand of a <tt class="docutils literal">callq</tt> is also RIP-relative, so the <tt class="docutils literal">R_X86_64_PC32</tt> relocation here works similarly to place the actual relative offset to <tt class="docutils literal">global_func</tt> into the operand.</p>
<p>To conclude, since the small code model promises the compiler that all code and data in the eventual program can be accessible with 32-bit RIP-relative offsets, the compiler can generate simple and efficient code for accessing all kinds of objects.</p>
</div>
<div class="section" id="large-code-model">
<h3>Large code model</h3>
<p>From <tt class="docutils literal">man gcc</tt>:</p>
<blockquote>
<p><strong>-mcmodel=large</strong></p>
<p>Generate code for the large model: This model makes no assumptions about addresses and sizes of sections.</p>
</blockquote>
<p>Here's the disassembled code of <tt class="docutils literal">main</tt> when compiled with the non-PIC large code model:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">int main(int argc, const char* argv[])
{
  15: 55                      push   %rbp
  16: 48 89 e5                mov    %rsp,%rbp
  19: 48 83 ec 20             sub    $0x20,%rsp
  1d: 89 7d ec                mov    %edi,-0x14(%rbp)
  20: 48 89 75 e0             mov    %rsi,-0x20(%rbp)
    int t = global_func(argc);
  24: 8b 45 ec                mov    -0x14(%rbp),%eax
  27: 89 c7                   mov    %eax,%edi
  29: b8 00 00 00 00          mov    $0x0,%eax
  2e: 48 ba 00 00 00 00 00    movabs $0x0,%rdx
  35: 00 00 00
  38: ff d2                   callq  *%rdx
  3a: 89 45 fc                mov    %eax,-0x4(%rbp)
    t += global_arr[7];
  3d: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  44: 00 00 00
  47: 8b 40 1c                mov    0x1c(%rax),%eax
  4a: 01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr[7];
  4d: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  54: 00 00 00
  57: 8b 40 1c                mov    0x1c(%rax),%eax
  5a: 01 45 fc                add    %eax,-0x4(%rbp)
    t += global_arr_big[7];
  5d: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  64: 00 00 00
  67: 8b 40 1c                mov    0x1c(%rax),%eax
  6a: 01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr_big[7];
  6d: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  74: 00 00 00
  77: 8b 40 1c                mov    0x1c(%rax),%eax
  7a: 01 45 fc                add    %eax,-0x4(%rbp)
    return t;
  7d: 8b 45 fc                mov    -0x4(%rbp),%eax
}
  80: c9                      leaveq
  81: c3                      retq
</pre></div>
<p>Again, looking at the relocations will be useful:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">Relocation section &#39;.rela.text&#39; at offset 0x62c18 contains 5 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000030  001500000001 R_X86_64_64       0000000000000000 global_func + 0
00000000003f  001100000001 R_X86_64_64       0000000000000000 global_arr + 0
00000000004f  000300000001 R_X86_64_64       0000000000000000 .data + 1a0
00000000005f  001200000001 R_X86_64_64       0000000000000340 global_arr_big + 0
00000000006f  000300000001 R_X86_64_64       0000000000000000 .data + 31080
</pre></div>
<p>The large code model is also quite uniform - no assumptions can be made about the size of the code and data sections, so all data is accessed similarly. Let's pick <tt class="docutils literal">global_arr</tt> once again:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  t += global_arr[7];
3d:       48 b8 00 00 00 00 00    movabs $0x0,%rax
44:       00 00 00
47:       8b 40 1c                mov    0x1c(%rax),%eax
4a:       01 45 fc                add    %eax,-0x4(%rbp)
</pre></div>
<p>Here two instructions are needed to pull the desired value from the array. The first places an absolute 64-bit address into <tt class="docutils literal">rax</tt>. This is the address of <tt class="docutils literal">global_arr</tt>, as we shall soon see. The second loads the word at <tt class="docutils literal">(rax) + 0x1c</tt> into <tt class="docutils literal">eax</tt>.</p>
<p>So, let's focus on the instruction at 0x3d. It's a <tt class="docutils literal">movabs</tt> - the absolute 64-bit version of <tt class="docutils literal">mov</tt> on x64. It can swing a full 64-bit immediate into a register. The value of this immediate in the disassembled code is 0, so we have to turn to the relocation table for the answer. It has a <tt class="docutils literal">R_X86_64_64</tt> relocation for the operand at 0x3f. This is an absolute relocation, which simply means - place the symbol value + addend back into the offset. In other words, <tt class="docutils literal">rax</tt> will hold the absolute address of <tt class="docutils literal">global_arr</tt>.</p>
<p>What about the function call?</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  int t = global_func(argc);
24:       8b 45 ec                mov    -0x14(%rbp),%eax
27:       89 c7                   mov    %eax,%edi
29:       b8 00 00 00 00          mov    $0x0,%eax
2e:       48 ba 00 00 00 00 00    movabs $0x0,%rdx
35:       00 00 00
38:       ff d2                   callq  *%rdx
3a:       89 45 fc                mov    %eax,-0x4(%rbp)
</pre></div>
<p>After a famililar <tt class="docutils literal">movabs</tt>, we have a <tt class="docutils literal">call</tt> instruction that calls a function whose address is in <tt class="docutils literal">rdx</tt>. From a glance at the relevant relocation it's obvious that this is very similar to the data access.</p>
<p>Evidently, the large code model makes absolutely no assumptions about the sizes of code and data sections, or where symbols might end up. It just takes the &quot;safe road&quot; everywhere, using absolute 64-bit moves to refer to symbols. This has a cost, of course. Notice that it now takes one extra instruction to access any symbol, when compared to the small model.</p>
<p>So, we've just witnessed two extremes. The small model happily assumes everything fits into the lower 2GB of memory, and the large model assumes everything is possible and any symbol can reside anywhere in the full 64-bit address space. The medium code model is a compromise.</p>
</div>
<div class="section" id="medium-code-model">
<h3>Medium code model</h3>
<p>As before, let's start with a quote from <tt class="docutils literal">man gcc</tt>:</p>
<blockquote>
<p><strong>-mcmodel=medium</strong></p>
<p>Generate code for the medium model: The program is linked in the lower 2 GB of the address space. Small symbols are also placed there. Symbols with sizes larger than -mlarge-data-threshold are put into large data or bss sections and can be located above 2GB. Programs can be statically or dynamically linked.</p>
</blockquote>
<p>Similarly to the small code model, the medium code model assumes all code is linked into the low 2GB. Data, on the other hand, is divided into &quot;large data&quot; and &quot;small data&quot;. Small data is also assumed to be linked into the low 2GB. Large data, on the other hand, is not restricted in its memory placement. Data is considered large when it's larger than a given threshold option, which is 64KB by default.</p>
<p>It is also interesting to note that in the medium code model, special sections will be created for the large data - <tt class="docutils literal">.ldata</tt> and <tt class="docutils literal">.lbss</tt> (parallel to <tt class="docutils literal">.data</tt> and <tt class="docutils literal">.bss</tt>). It's not really important for the sake of this article, however, so I'm going to sidestep the topic. Read the ABI for more details.</p>
<p>Now it should be clear why the sample C code has those <tt class="docutils literal">_big</tt> arrays. These are meant for the medium code model to be considered as &quot;large data&quot; (which they certainly are, at 200KB each). Here's the disassembly:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">int main(int argc, const char* argv[])
{
  15: 55                      push   %rbp
  16: 48 89 e5                mov    %rsp,%rbp
  19: 48 83 ec 20             sub    $0x20,%rsp
  1d: 89 7d ec                mov    %edi,-0x14(%rbp)
  20: 48 89 75 e0             mov    %rsi,-0x20(%rbp)
    int t = global_func(argc);
  24: 8b 45 ec                mov    -0x14(%rbp),%eax
  27: 89 c7                   mov    %eax,%edi
  29: b8 00 00 00 00          mov    $0x0,%eax
  2e: e8 00 00 00 00          callq  33 &lt;main+0x1e&gt;
  33: 89 45 fc                mov    %eax,-0x4(%rbp)
    t += global_arr[7];
  36: 8b 05 00 00 00 00       mov    0x0(%rip),%eax
  3c: 01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr[7];
  3f: 8b 05 00 00 00 00       mov    0x0(%rip),%eax
  45: 01 45 fc                add    %eax,-0x4(%rbp)
    t += global_arr_big[7];
  48: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  4f: 00 00 00
  52: 8b 40 1c                mov    0x1c(%rax),%eax
  55: 01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr_big[7];
  58: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  5f: 00 00 00
  62: 8b 40 1c                mov    0x1c(%rax),%eax
  65: 01 45 fc                add    %eax,-0x4(%rbp)
    return t;
  68: 8b 45 fc                mov    -0x4(%rbp),%eax
}
  6b: c9                      leaveq
  6c: c3                      retq
</pre></div>
<p>Note that the <tt class="docutils literal">_big</tt> arrays are accessed as in the large model, and the other arrays are accessed as in the small model. The function is also accessed as in the small model. I won't even show the relocations since there's nothing new in them either.</p>
<p>The medium model is a clever compromise between the small and large models. The program's code is unlikely to be terribly big <a class="footnote-reference" href="#id11" id="id4">[4]</a>, so what might push it over the 2GB threshold is large pieces of data statically linked into it (perhaps for some sort of big lookup tables). The medium code model separates these large chunks of data from the rest and handles them specially. All code just calling functions and accessing the other, smaller symbols will be as efficient as in the small code model. Only the code actually accessing the large symbols will have to go the whole 64-bit way similarly to the large code model.</p>
</div>
<div class="section" id="small-pic-code-model">
<h3>Small PIC code model</h3>
<p>Let us now turn to the code models for PIC, starting once again with the small model <a class="footnote-reference" href="#id12" id="id5">[5]</a>. Here's the sample code, compiled with PIC and the small code model:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">int main(int argc, const char* argv[])
{
  15:   55                      push   %rbp
  16:   48 89 e5                mov    %rsp,%rbp
  19:   48 83 ec 20             sub    $0x20,%rsp
  1d:   89 7d ec                mov    %edi,-0x14(%rbp)
  20:   48 89 75 e0             mov    %rsi,-0x20(%rbp)
    int t = global_func(argc);
  24:   8b 45 ec                mov    -0x14(%rbp),%eax
  27:   89 c7                   mov    %eax,%edi
  29:   b8 00 00 00 00          mov    $0x0,%eax
  2e:   e8 00 00 00 00          callq  33 &lt;main+0x1e&gt;
  33:   89 45 fc                mov    %eax,-0x4(%rbp)
    t += global_arr[7];
  36:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax
  3d:   8b 40 1c                mov    0x1c(%rax),%eax
  40:   01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr[7];
  43:   8b 05 00 00 00 00       mov    0x0(%rip),%eax
  49:   01 45 fc                add    %eax,-0x4(%rbp)
    t += global_arr_big[7];
  4c:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax
  53:   8b 40 1c                mov    0x1c(%rax),%eax
  56:   01 45 fc                add    %eax,-0x4(%rbp)
    t += static_arr_big[7];
  59:   8b 05 00 00 00 00       mov    0x0(%rip),%eax
  5f:   01 45 fc                add    %eax,-0x4(%rbp)
    return t;
  62:   8b 45 fc                mov    -0x4(%rbp),%eax
}
  65:   c9                      leaveq
  66:   c3                      retq
</pre></div>
<p>And the relocations:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">Relocation section &#39;.rela.text&#39; at offset 0x62ce8 contains 5 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000002f  001600000004 R_X86_64_PLT32    0000000000000000 global_func - 4
000000000039  001100000009 R_X86_64_GOTPCREL 0000000000000000 global_arr - 4
000000000045  000300000002 R_X86_64_PC32     0000000000000000 .data + 1b8
00000000004f  001200000009 R_X86_64_GOTPCREL 0000000000000340 global_arr_big - 4
00000000005b  000300000002 R_X86_64_PC32     0000000000000000 .data + 31098
</pre></div>
<p>Since the small vs. big data distinction plays no role in the small model, we're going to focus on the difference between local (static) and global symbols, which <em>does</em> play a role when PIC is generated.</p>
<p>As you can see, the code generated for the static arrays is exactly equivalent to the code generated in the non-PIC case. This is one of the boons of the x64 architecture - unless symbols have to be accessed externally, you get PIC for free because of the RIP-relative addressing for data. The instructions and relocations used are the same, so we won't go over them again.</p>
<p>The interesting case here is the global arrays. Recall that in PIC, global data has to go through GOT, because it may be eventually found or used in other shared libraries <a class="footnote-reference" href="#id15" id="id6">[6]</a>. Here's the code generated for accessing <tt class="docutils literal">global_arr</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  t += global_arr[7];
36:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax
3d:   8b 40 1c                mov    0x1c(%rax),%eax
40:   01 45 fc                add    %eax,-0x4(%rbp)
</pre></div>
<p>And the relevant relocation is a <tt class="docutils literal">R_X86_64_GOTPCREL</tt>, which means: the location of the entry for the symbol in the GOT + addend, minus the offset for applying the relocation. In other words, the relative offset between RIP (of the next instruction) and the slot reserved for <tt class="docutils literal">global_arr</tt> in GOT is patched into the instruction. So what's put into <tt class="docutils literal">rax</tt> in the instruction at 0x36 is the actual address of <tt class="docutils literal">global_arr</tt>. This is followed by dereferncing the address of <tt class="docutils literal">global_arr</tt> plus an offset to its 7th element into <tt class="docutils literal">eax</tt>.</p>
<p>Now let's examine the function call:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  int t = global_func(argc);
24:   8b 45 ec                mov    -0x14(%rbp),%eax
27:   89 c7                   mov    %eax,%edi
29:   b8 00 00 00 00          mov    $0x0,%eax
2e:   e8 00 00 00 00          callq  33 &lt;main+0x1e&gt;
33:   89 45 fc                mov    %eax,-0x4(%rbp)
</pre></div>
<p>There's a <tt class="docutils literal">R_X86_64_PLT32</tt> relocation for the operand of <tt class="docutils literal">callq</tt> at 0x2e. This relocation means: the address of the PLT entry for the symbol + addend, minus the offset for applying the relocation. In other words, the <tt class="docutils literal">callq</tt> should correctly call the PLT trampoline for <tt class="docutils literal">global_func</tt>.</p>
<p>Note the implicit assumptions made by the compiler - that the GOT and PLT could be accessed with RIP-relative addresing. This will be important when comparing this model to the other PIC code models.</p>
</div>
<div class="section" id="large-pic-code-model">
<h3>Large PIC code model</h3>
<p>Here's the disassembly:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">int main(int argc, const char* argv[])
{
  15: 55                      push   %rbp
  16: 48 89 e5                mov    %rsp,%rbp
  19: 53                      push   %rbx
  1a: 48 83 ec 28             sub    $0x28,%rsp
  1e: 48 8d 1d f9 ff ff ff    lea    -0x7(%rip),%rbx
  25: 49 bb 00 00 00 00 00    movabs $0x0,%r11
  2c: 00 00 00
  2f: 4c 01 db                add    %r11,%rbx
  32: 89 7d dc                mov    %edi,-0x24(%rbp)
  35: 48 89 75 d0             mov    %rsi,-0x30(%rbp)
    int t = global_func(argc);
  39: 8b 45 dc                mov    -0x24(%rbp),%eax
  3c: 89 c7                   mov    %eax,%edi
  3e: b8 00 00 00 00          mov    $0x0,%eax
  43: 48 ba 00 00 00 00 00    movabs $0x0,%rdx
  4a: 00 00 00
  4d: 48 01 da                add    %rbx,%rdx
  50: ff d2                   callq  *%rdx
  52: 89 45 ec                mov    %eax,-0x14(%rbp)
    t += global_arr[7];
  55: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  5c: 00 00 00
  5f: 48 8b 04 03             mov    (%rbx,%rax,1),%rax
  63: 8b 40 1c                mov    0x1c(%rax),%eax
  66: 01 45 ec                add    %eax,-0x14(%rbp)
    t += static_arr[7];
  69: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  70: 00 00 00
  73: 8b 44 03 1c             mov    0x1c(%rbx,%rax,1),%eax
  77: 01 45 ec                add    %eax,-0x14(%rbp)
    t += global_arr_big[7];
  7a: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  81: 00 00 00
  84: 48 8b 04 03             mov    (%rbx,%rax,1),%rax
  88: 8b 40 1c                mov    0x1c(%rax),%eax
  8b: 01 45 ec                add    %eax,-0x14(%rbp)
    t += static_arr_big[7];
  8e: 48 b8 00 00 00 00 00    movabs $0x0,%rax
  95: 00 00 00
  98: 8b 44 03 1c             mov    0x1c(%rbx,%rax,1),%eax
  9c: 01 45 ec                add    %eax,-0x14(%rbp)
    return t;
  9f: 8b 45 ec                mov    -0x14(%rbp),%eax
}
  a2: 48 83 c4 28             add    $0x28,%rsp
  a6: 5b                      pop    %rbx
  a7: c9                      leaveq
  a8: c3                      retq
</pre></div>
<p>And the relocations:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">Relocation section &#39;.rela.text&#39; at offset 0x62c70 contains 6 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000027  00150000001d R_X86_64_GOTPC64  0000000000000000 _GLOBAL_OFFSET_TABLE_ + 9
000000000045  00160000001f R_X86_64_PLTOFF64 0000000000000000 global_func + 0
000000000057  00110000001b R_X86_64_GOT64    0000000000000000 global_arr + 0
00000000006b  000800000019 R_X86_64_GOTOFF64 00000000000001a0 static_arr + 0
00000000007c  00120000001b R_X86_64_GOT64    0000000000000340 global_arr_big + 0
000000000090  000900000019 R_X86_64_GOTOFF64 0000000000031080 static_arr_big + 0
</pre></div>
<p>Again, the small vs. big data distinction isn't important here, so we'll focus on <tt class="docutils literal">static_arr</tt> and <tt class="docutils literal">global_arr</tt>. But first, there's a new prologue in this code which we didn't encounter earlier:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">1e: 48 8d 1d f9 ff ff ff    lea    -0x7(%rip),%rbx
25: 49 bb 00 00 00 00 00    movabs $0x0,%r11
2c: 00 00 00
2f: 4c 01 db                add    %r11,%rbx
</pre></div>
<p>Here's a relevant quote from the ABI:</p>
<blockquote>
In the small code model all addresses (including GOT entries) are accessible via
the IP-relative addressing provided by the AMD64 architecture. Hence there is no
need for an explicit GOT pointer and therefore no function prologue for setting it
up is necessary.
In the medium and large code models a register has to be allocated to hold
the address of the GOT in position-independent objects, because the AMD64 ISA
does not support an immediate displacement larger than 32 bits.</blockquote>
<p>Let's see how the prologue displayed above computes the address of GOT. First, the instruction at 0x1e loads its own address into <tt class="docutils literal">rbx</tt>. Then, an absolute 64-bit move is done into <tt class="docutils literal">r11</tt>, with a <tt class="docutils literal">R_X86_64_GOTPC64</tt> relocation. This relocation means: take the GOT address, subtract the relocated offset and add the addend. Finally, the instruction at 0x2f adds the two together. The result is the absolute address of GOT in <tt class="docutils literal">rbx</tt> <a class="footnote-reference" href="#id16" id="id7">[7]</a>.</p>
<p>Why go through all this trouble to compute the address of GOT? Well, for one thing, as the quote says, in the large model we can't assume that the 32-bit RIP relative offset will suffice to access GOT, so we need a full 64-bit address. On the other hand, we still want PIC, so we can't just place an absolute address into the register. Rather, the address has to be computed relative to RIP. This is what the prologue does. It's just a 64-bit RIP-relative computation.</p>
<p>Anyway, now we have the address of GOT firmly in our <tt class="docutils literal">rbx</tt>, let's see how <tt class="docutils literal">static_arr</tt> is accessed:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  t += static_arr[7];
69:       48 b8 00 00 00 00 00    movabs $0x0,%rax
70:       00 00 00
73:       8b 44 03 1c             mov    0x1c(%rbx,%rax,1),%eax
77:       01 45 ec                add    %eax,-0x14(%rbp)
</pre></div>
<p>The relocation for the first instruction is <tt class="docutils literal">R_X86_64_GOTOFF64</tt>, which means: symbol + addend - GOT. In our case: the relative offset between the address of <tt class="docutils literal">static_arr</tt> and the address of GOT. The next instruction adds that to <tt class="docutils literal">rbx</tt> (the absolute GOT address), and dereferences with a 0x1c offset. Here's some pseudo-C to make this computation easier to visualize:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">// char* static_arr
// char* GOT
rax = static_arr + 0 - GOT;  // rax now contains an offset
eax = *(rbx + rax + 0x1c);   // rbx == GOT, so eax now contains
                             // *(GOT + static_arr - GOT + 0x1c) or
                             // *(static_arr + 0x1c)
</pre></div>
<p>Note an interesting thing here: the GOT address is just used as an anchor to reach <tt class="docutils literal">static_arr</tt>. This is unlike the normal usage of GOT to actually contain the address of a symbol within it. Since <tt class="docutils literal">static_arr</tt> is not an external symbol, there's no point keeping it <em>inside</em> the GOT. But still, GOT is used here as an anchor in the data section, relative to which the address of the symbol can be found with a full 64-bit offset, which is at the same time position independent (the linker will be able to resolve this relocation, leaving no need to modify the code section during loading).</p>
<p>How about <tt class="docutils literal">global_arr</tt>?</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  t += global_arr[7];
55:       48 b8 00 00 00 00 00    movabs $0x0,%rax
5c:       00 00 00
5f:       48 8b 04 03             mov    (%rbx,%rax,1),%rax
63:       8b 40 1c                mov    0x1c(%rax),%eax
66:       01 45 ec                add    %eax,-0x14(%rbp)
</pre></div>
<p>The code is a bit longer, and the relocation is also different. This is actually a more traditional use of GOT. The <tt class="docutils literal">R_X86_64_GOT64</tt> relocation for the <tt class="docutils literal">movabs</tt> just tells it to place the offset into the GOT where the address of <tt class="docutils literal">global_arr</tt> resides into <tt class="docutils literal">rax</tt>. The instruction at 0x5f extracts the address of <tt class="docutils literal">global_arr</tt> from the GOT and places it into <tt class="docutils literal">rax</tt>. The next instruction dereferences <tt class="docutils literal">global_arr[7]</tt>, placing the value into <tt class="docutils literal">eax</tt>.</p>
<p>Now let's look at the code reference for <tt class="docutils literal">global_func</tt>. Recall that in the large code model we can't make any assumptions regarding the size of the code section, so we should assume that even to reach the PLT we need an absolute 64-bit address:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  int t = global_func(argc);
39: 8b 45 dc                mov    -0x24(%rbp),%eax
3c: 89 c7                   mov    %eax,%edi
3e: b8 00 00 00 00          mov    $0x0,%eax
43: 48 ba 00 00 00 00 00    movabs $0x0,%rdx
4a: 00 00 00
4d: 48 01 da                add    %rbx,%rdx
50: ff d2                   callq  *%rdx
52: 89 45 ec                mov    %eax,-0x14(%rbp)
</pre></div>
<p>The relevant relocation is a <tt class="docutils literal">R_X86_64_PLTOFF64</tt>, which means: PLT entry address for <tt class="docutils literal">global_func</tt>, minus GOT address. This is placed into <tt class="docutils literal">rdx</tt>, into which <tt class="docutils literal">rbx</tt> (the absolute address of GOT) is later added. The result is the PLT entry address for <tt class="docutils literal">global_func</tt> in <tt class="docutils literal">rdx</tt>.</p>
<p>Again, note the use of GOT as an &quot;anchor&quot; to enable position-independent reference to the PLT entry offset.</p>
</div>
<div class="section" id="medium-pic-code-model">
<h3>Medium PIC code model</h3>
<p>Finally, we'll examine the code generated for the medium PIC code model:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">int main(int argc, const char* argv[])
{
  15:   55                      push   %rbp
  16:   48 89 e5                mov    %rsp,%rbp
  19:   53                      push   %rbx
  1a:   48 83 ec 28             sub    $0x28,%rsp
  1e:   48 8d 1d 00 00 00 00    lea    0x0(%rip),%rbx
  25:   89 7d dc                mov    %edi,-0x24(%rbp)
  28:   48 89 75 d0             mov    %rsi,-0x30(%rbp)
    int t = global_func(argc);
  2c:   8b 45 dc                mov    -0x24(%rbp),%eax
  2f:   89 c7                   mov    %eax,%edi
  31:   b8 00 00 00 00          mov    $0x0,%eax
  36:   e8 00 00 00 00          callq  3b &lt;main+0x26&gt;
  3b:   89 45 ec                mov    %eax,-0x14(%rbp)
    t += global_arr[7];
  3e:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax
  45:   8b 40 1c                mov    0x1c(%rax),%eax
  48:   01 45 ec                add    %eax,-0x14(%rbp)
    t += static_arr[7];
  4b:   8b 05 00 00 00 00       mov    0x0(%rip),%eax
  51:   01 45 ec                add    %eax,-0x14(%rbp)
    t += global_arr_big[7];
  54:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax
  5b:   8b 40 1c                mov    0x1c(%rax),%eax
  5e:   01 45 ec                add    %eax,-0x14(%rbp)
    t += static_arr_big[7];
  61:   48 b8 00 00 00 00 00    movabs $0x0,%rax
  68:   00 00 00
  6b:   8b 44 03 1c             mov    0x1c(%rbx,%rax,1),%eax
  6f:   01 45 ec                add    %eax,-0x14(%rbp)
    return t;
  72:   8b 45 ec                mov    -0x14(%rbp),%eax
}
  75:   48 83 c4 28             add    $0x28,%rsp
  79:   5b                      pop    %rbx
  7a:   c9                      leaveq
  7b:   c3                      retq
</pre></div>
<p>And the relocations:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">Relocation section &#39;.rela.text&#39; at offset 0x62d60 contains 6 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000021  00160000001a R_X86_64_GOTPC32  0000000000000000 _GLOBAL_OFFSET_TABLE_ - 4
000000000037  001700000004 R_X86_64_PLT32    0000000000000000 global_func - 4
000000000041  001200000009 R_X86_64_GOTPCREL 0000000000000000 global_arr - 4
00000000004d  000300000002 R_X86_64_PC32     0000000000000000 .data + 1b8
000000000057  001300000009 R_X86_64_GOTPCREL 0000000000000000 global_arr_big - 4
000000000063  000a00000019 R_X86_64_GOTOFF64 0000000000030d40 static_arr_big + 0
</pre></div>
<p>First, let's clear the function call out of the way. Similarly to the small model, in the medium model we assume that code references are within the bounds of a 32-bit offset from RIP. Therefore, the code to call <tt class="docutils literal">global_func</tt> is exactly similar to the small PIC model. The same goes for the small data arrays <tt class="docutils literal">static_arr</tt> and <tt class="docutils literal">global_arr</tt>. So we'll focus on the big data arrays, but first let's discuss the prologue, which is different from the large model:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">1e:   48 8d 1d 00 00 00 00    lea    0x0(%rip),%rbx
</pre></div>
<p>That's it, a single instruction (instead of the 3 it took in the large model) to get the address of GOT into <tt class="docutils literal">rbx</tt> (with the help of a <tt class="docutils literal">R_X86_64_GOTPC32</tt> relocation). Why the difference? Because in the medium code model, we assume the GOT itself is reachable with a 32-bit offset, because it's not part of the &quot;big data sections&quot;. In the large code model we couldn't make this assumption and had to use a full 64-bit offset to access the GOT.</p>
<p>Interestingly, we notice that the code to access <tt class="docutils literal">global_arr_big</tt> is also similar to the small PIC model. Why? For the same reason the prologue is shorter than in the large model. In the medium model, we assume the GOT itself is reachable with 32-bit RIP-relative addressing. True, <tt class="docutils literal">global_arr_big</tt> itself is not, but this is covered by the GOT anyway, since the address of <tt class="docutils literal">global_arr_big</tt> actually resides in the GOT, and it's a full 64-bit address there.</p>
<p>For <tt class="docutils literal">static_arr_big</tt>, the situation is different, however:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">  t += static_arr_big[7];
61:   48 b8 00 00 00 00 00    movabs $0x0,%rax
68:   00 00 00
6b:   8b 44 03 1c             mov    0x1c(%rbx,%rax,1),%eax
6f:   01 45 ec                add    %eax,-0x14(%rbp)
</pre></div>
<p>This is actually similar to the large PIC code model, because here we do obtain an absolute address for the symbol, which doesn't reside in the GOT itself. Since this is a large symbol that can't be assumed to reside in the low 2 GB, we need the 64-bit PIC offset here, similarly to the large model.</p>
<img class="align-center" src="../../../images/hline.jpg" style="width: 320px; height: 5px;" />
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Code models are not to be confused with <a class="reference external" href="http://en.wikipedia.org/wiki/64-bit#64-bit_data_models">64-bit data models</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/Intel_Memory_Model">Intel memory models</a>, both of which are different topics.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>An important thing to keep in mind here: the actual instructions are created by the <em>compiler</em>, and the addressing modes are &quot;cemented&quot; at that stage. The compiler has no way to know into which programs or shared libs the object it's compiling will eventually get into. Some may be small, but some may be large. The linker does know the size of the resulting program, but it's too late at that point, since the linker can't actually change the instructions, just patch offsets within them with relocations. Therefore, the code model &quot;contract&quot; has to be &quot;signed&quot; by the programmer at the compilation stage.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>If this isn't clear, read <a class="reference external" href="../../../2011/08/25/load-time-relocation-of-shared-libraries/index.html">this article</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Although it's getting there. Last time I checked, the Debug+Asserts build of Clang was almost half a GB in size (thanks to quite a bit of auto-generated code).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Unless
    you already know how PIC works (both in general and for x64 in particular),
    this would be a good time to go over my earlier articles on this subject -
    <a class="reference external" href="../../../2011/11/03/position-independent-code-pic-in-shared-libraries/index.html">#1</a>
    and <a class="reference external" href="../../../2011/11/11/position-independent-code-pic-in-shared-libraries-on-x64/index.html">#2</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>So the linker can't fully resolve the references on its own, and has to leave GOT handling to the dynamic loader.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>0x25 - 0x7 + GOT - 0x27 + 0x9 = GOT</td></tr>
</tbody>
</table>
</div>

    
            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2012/01/03/understanding-the-x64-code-models by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:03:32 GMT -->
</html>