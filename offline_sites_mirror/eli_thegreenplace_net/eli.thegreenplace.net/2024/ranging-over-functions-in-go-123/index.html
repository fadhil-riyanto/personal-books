<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2024/ranging-over-functions-in-go-123/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:39:06 GMT -->
<head>
    <title>Ranging over functions in Go 1.23 - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Ranging over functions in Go 1.23">
                        Ranging over functions in Go 1.23
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> November 02, 2024 at 06:35</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/go.html">Go</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Go 1.23 shipped with a new major feature: ranging over functions (also known
as &quot;iterators&quot;), per <a class="reference external" href="https://github.com/golang/go/issues/61405">this proposal</a>.
This feature is nicely covered in the official <a class="reference external" href="https://go.dev/blog/range-functions">Go blog post from August</a>.</p>
<p>This article is a rewrite of <a class="reference external" href="../../2023/preview-ranging-over-functions-in-go/index.html">my older post</a>
that described this feature when it was still in preview. The feature was
slightly different then, and I want a post that reflects the accepted and final
state of affairs. The full code for this article is available in the
<a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2023/for-range-proposal/final-shipped-1.23">accompanying repository</a>.</p>
<div class="section" id="background-original-for-range-statements">
<h2>Background - original <tt class="docutils literal"><span class="pre">for-range</span></tt> statements</h2>
<p>All Go programmers know and love the venerable <tt class="docutils literal">for ... := range</tt> loop;
whether it's ranging over elements of a slice, runes of a string, or key/value
pairs of a map - it's a versatile tool, and few programs do without it.</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">elem</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">mySlice</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// use index i or element elem somehow</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>However, so far <tt class="docutils literal"><span class="pre">for-range</span></tt> statements have been limited to a relatively
small number of Go constructs: arrays, slices, strings, maps and channels.</p>
</div>
<div class="section" id="ranging-over-int">
<h2>Ranging over <tt class="docutils literal">int</tt></h2>
<p>The first addition made in <a class="reference external" href="https://github.com/golang/go/issues/61405">the proposal</a> is <tt class="docutils literal">range</tt> over
integers. Here's a basic example of how it looks:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This code is exactly equivalent to:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And will do the same thing: print out the numbers 0,1,2,3,4 - each on a separate
line. Obviously, the ranged integer does not have to be a constant and
assigning the range to a per-iteration value is optional:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// do something</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Will <em>do something</em> exactly <tt class="docutils literal">n</tt> times. That's really all there is to it!
This is just a clean shortcut for a very common loop (<tt class="docutils literal">i := 0; i &lt; n; i++</tt>).
In the proposal, Russ mentioned that approximately half of the 3-clause <tt class="docutils literal">for</tt>
loops he observed in the wild can be converted to this &quot;range over int&quot; form.
This includes Go benchmarks, where the main loop can be converted to:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// run the benchmarked code</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Ranging over integers is simple and clear, so I won't spend more time on it.
Let's move on to the more significant change - ranging over functions.</p>
</div>
<div class="section" id="range-over-functions-motivation">
<h2>Range over functions - motivation</h2>
<p>Since Go's addition of generics <a class="reference external" href="https://go.dev/blog/go1.18">in version 1.18</a>,
people started writing generic <em>containers</em> or Abstract Data Structures;
generics make it possible for programmers to decouple the data structure from
the types it stores in an efficient and convenient way (compared to the older
way of using empty interfaces).</p>
<p>However, one nagging issue for custom containers remained: how do you iterate
over their elements? While Go supports iteration over built-in containers like
slices and maps very naturally with a <tt class="docutils literal"><span class="pre">for-range</span></tt> loop, this utility was
not available for custom containers, so programmers had to come up with ad-hoc
iteration methods... until now.</p>
<p>For a concrete motivating example, let's assume that Lisp programmers were right
all along and <a class="reference external" href="https://en.wikipedia.org/wiki/Association_list">association lists</a> are the best data structure
(TM). Using generics, we can implement a simple assoc list in Go, built
on top of a slice <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="w"> </span><span class="kt">comparable</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">lst</span><span class="w"> </span><span class="p">[]</span><span class="nx">pair</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">type</span><span class="w"> </span><span class="nx">pair</span><span class="p">[</span><span class="nx">K</span><span class="w"> </span><span class="kt">comparable</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">key</span><span class="w">   </span><span class="nx">K</span><span class="w"></span>
<span class="w">  </span><span class="nx">value</span><span class="w"> </span><span class="nx">V</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">al</span><span class="w"> </span><span class="o">*</span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">])</span><span class="w"> </span><span class="nx">Add</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="p">,</span><span class="w"> </span><span class="nx">pair</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">]{</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>I'll leave the &quot;lookup&quot; method as an exercise for motivated readers. We can
create an association list and populate it:</p>
<div class="highlight"><pre><span></span><span class="nx">al</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">AssocList</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">]{}</span><span class="w"></span>
<span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ten&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;twenty&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;five&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>With this data structure in hand, an obvious question arises - how do I iterate
over all its elements? We could cheat and <tt class="docutils literal">range</tt> over the underlying slice,
but this requires exposing an implementation detail -- what if we want to
re-implement assoc lists without slices later?</p>
<p>We're left with devising a custom iteration API; something like a <tt class="docutils literal">Next()</tt>
method. This is what Go programmers have been doing so far, and you can find
many examples of custom iteration APIs across the standard library and
elsewhere. As you would expect, many different approaches emerged.
Starting with Go 1.23, we can finally settle on a single, idiomatic approach.</p>
<p>I'm going to show how to use the Go 1.23 range-over-functions feature
to write an iterator for <tt class="docutils literal">AssocList</tt>; the next section will discuss the
mechanics of how it works. We start by adding a method to <tt class="docutils literal">AssocList</tt> with a
special signature; it can also be a free-standing function, but for a container
like <tt class="docutils literal">AssocList</tt>, a method is natural:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">al</span><span class="w"> </span><span class="o">*</span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">])</span><span class="w"> </span><span class="nx">All</span><span class="p">()</span><span class="w"> </span><span class="nx">iter</span><span class="p">.</span><span class="nx">Seq2</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Where <tt class="docutils literal">Seq2</tt> is a helper type defined in the new <a class="reference external" href="https://pkg.go.dev/iter">iter</a> package
in the standard library:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Seq</span><span class="p">[</span><span class="nx">V</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="kd">type</span><span class="w"> </span><span class="nx">Seq2</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>We can use the new <tt class="docutils literal">All</tt> method as follows:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">AssocList</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">]{}</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ten&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;twenty&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;five&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">All</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;key=%v, value=%v\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Prints:</span><span class="w"></span>
<span class="c1">//</span><span class="w"></span>
<span class="c1">// key=10, value=ten</span><span class="w"></span>
<span class="c1">// key=20, value=twenty</span><span class="w"></span>
<span class="c1">// key=5, value=five</span><span class="w"></span>
</pre></div>
<p>Magic! We just iterate over our container with a standard <tt class="docutils literal"><span class="pre">for-range</span></tt> loop;
how does it work?</p>
</div>
<div class="section" id="range-over-functions-the-mechanics">
<h2>Range over functions - the mechanics</h2>
<p>First, note that <tt class="docutils literal">All</tt> is a method that returns a function. To be eligible
for <tt class="docutils literal"><span class="pre">for-range</span></tt> iteration, a value has to be a function with one of these
signatures:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Each is a function that takes another function as parameter. The function
parameter is named <tt class="docutils literal">yield</tt> <em>by convention</em> - the name itself has no
significance. <tt class="docutils literal">yield</tt> can have 0, 1, or 2 parameters and returns a <tt class="docutils literal">bool</tt>.</p>
<p>The number of <tt class="docutils literal">yield</tt>'s parameters is directly mapped to the left-hand side
of the <tt class="docutils literal"><span class="pre">for-range</span></tt> loop w.r.t maximal number of returned values, e.g. <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<div class="highlight"><pre><span></span>for x, y := range ...   // two parameters
for x := range ...      // one parameter
for range ...           // no parameters
</pre></div>
<p>With the new iteration functionality, the <tt class="docutils literal"><span class="pre">for-range</span></tt> loop over functions will
be automatically transformed by the compiler. Quoting from the proposal:</p>
<blockquote>
For a function <tt class="docutils literal">f</tt>, the iteration proceeds by calling <tt class="docutils literal">f</tt> with a
synthesized <tt class="docutils literal">yield</tt> function that invokes the body of the loop. The
values produced correspond to the arguments in successive calls to <tt class="docutils literal">yield</tt>.
As with range over other types, it is permitted to declare fewer iteration
variables than there are iteration values. The return value from the
<tt class="docutils literal">yield</tt> function reports whether <tt class="docutils literal">f</tt> should continue iterating. For
example, if the loop body executes a <tt class="docutils literal">break</tt> statement, the corresponding
call to <tt class="docutils literal">yield</tt> returns <tt class="docutils literal">false</tt>.</blockquote>
<p>Letâ€™s unpack this, using our <tt class="docutils literal">AssocList</tt> iterator as an example. Here's
the transformation:</p>
<img alt="transformation of for-range code" class="align-center" src="../../images/2024/for-range-code-transform-123.png" />
<p>Now looking into the definition of <tt class="docutils literal">AssocList.All</tt>, it's clear how the
iteration works. The loop in this method iterates over the items in the data
structure, passing each into the supplied <tt class="docutils literal">yield</tt> function, which the compiler
substitutes for the body of the original <tt class="docutils literal">range</tt> loop.</p>
<p>This is the simplest example, because it doesn't change the control flow in any
way. In more complex cases the compiler applies more sophisticated
transformations; for example, a <tt class="docutils literal">break</tt> in the <tt class="docutils literal"><span class="pre">for-range</span></tt> loop body is
transformed into a <tt class="docutils literal">return false</tt> from the <tt class="docutils literal">yield</tt> function, directing
iteration to stop. A <tt class="docutils literal">continue</tt> is transformed into an early <tt class="docutils literal">return true</tt>;
more work is needed for <tt class="docutils literal">goto</tt> statements, early returns, panics, <tt class="docutils literal">defer</tt>s
and so on. For the gory details, take a look at the <a class="reference external" href="https://github.com/golang/go/blob/release-branch.go1.23/src/cmd/compile/internal/rangefunc/rewrite.go">transformation
implementing the proposal</a>.</p>
</div>
<div class="section" id="stopping-iteration-early">
<h2>Stopping iteration early</h2>
<p>Early stops are an essential feature of the range over functions proposal.
Recall our <tt class="docutils literal">AssocList.All</tt> method:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">al</span><span class="w"> </span><span class="o">*</span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">])</span><span class="w"> </span><span class="nx">All</span><span class="p">()</span><span class="w"> </span><span class="nx">iter</span><span class="p">.</span><span class="nx">Seq2</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Checking for a false return from <tt class="docutils literal">yield</tt> and using that to return early is
important, because this is the invoking <tt class="docutils literal"><span class="pre">for-range</span></tt> loop telling us to
stop. Consider this loop:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">All</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fi&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;found bad value, aborting!&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;key=%v, value=%v\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>As mentioned earlier, the <tt class="docutils literal">break</tt> is transformed into <tt class="docutils literal">return false</tt> when
the body of this loop is transformed into the <tt class="docutils literal">yield</tt> function. Once we've
encountered a &quot;bad value&quot;, we don't want to continue iterating, and therefore
the iterator function has to exit early, too.</p>
<p>This is very important because iteration may be costly, have side effects (it
could be reading I/O devices, for example), or because the iterator isn't even
finite.</p>
</div>
<div class="section" id="iterating-over-all-fibonacci-numbers">
<h2>Iterating over &quot;all&quot; Fibonacci numbers</h2>
<p>As an example of an infinite iterator, let's write one for Fibonacci numbers:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">genFib</span><span class="p">()</span><span class="w"> </span><span class="nx">iter</span><span class="p">.</span><span class="nx">Seq</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This function returns <tt class="docutils literal">iter.Seq</tt> because the iteration happens over single
values (unlike the pairs passed to <tt class="docutils literal">yield</tt> by our assoc list iterator).
This means the associated <tt class="docutils literal"><span class="pre">for-range</span></tt> loop will yield at most a single value.
Here's how we can use it:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">genFib</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This will print Fibonacci numbers until (and including) the first one over 1000.
Clearly, there is no &quot;end&quot; to such an iterator; there are infinitely many
Fibonacci numbers. In fact, the <tt class="docutils literal">for</tt> loop in the function returned by
<tt class="docutils literal">genFib</tt> doesn't even have an end condition; it only exits when <tt class="docutils literal">yield</tt>
returns false. This happens when the <tt class="docutils literal">break</tt> statement from the <tt class="docutils literal">if p &gt;
1000</tt> condition is triggered.</p>
</div>
<div class="section" id="recursive-iterators">
<h2>Recursive iterators</h2>
<p>So far the iterator examples have all been <em>linear</em>: the iterator had a single
loop that yields all the values one by one. Some iteration patterns are not
linear, however; for example, consider iterating over a binary tree:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Tree</span><span class="p">[</span><span class="nx">E</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">val</span><span class="w">         </span><span class="nx">E</span><span class="w"></span>
<span class="w">  </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">E</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">E</span><span class="p">])</span><span class="w"> </span><span class="nx">Inorder</span><span class="p">()</span><span class="w"> </span><span class="nx">iter</span><span class="p">.</span><span class="nx">Seq</span><span class="p">[</span><span class="nx">E</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">t</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">yield</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">E</span><span class="p">])</span><span class="w"> </span><span class="nx">push</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">yield</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">yield</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">yield</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note that there's no loop here - the iteration is done by means of recursion
instead. This code uses a recursive helper method -- <tt class="docutils literal">push</tt>. We need a helper
method here because we want <tt class="docutils literal">push</tt> to return a boolean; this boolean indicates
whether iteration should stop and propagates it up the recursion stack.
It only stops if <tt class="docutils literal">yield</tt> returns <tt class="docutils literal">false</tt> on some value.</p>
<p>Here's the in-order tree iterator in action:</p>
<div class="highlight"><pre><span></span><span class="c1">// Create a sample tree:</span><span class="w"></span>
<span class="c1">//</span><span class="w"></span>
<span class="c1">//       10</span><span class="w"></span>
<span class="c1">//      /  \</span><span class="w"></span>
<span class="c1">//     20  40</span><span class="w"></span>
<span class="c1">//    /  \</span><span class="w"></span>
<span class="c1">//   30  39</span><span class="w"></span>
<span class="nx">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="w"></span>
<span class="w">  </span><span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="w"></span>
<span class="w">    </span><span class="mi">20</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="mi">39</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">}},</span><span class="w"></span>
<span class="w">  </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">tt</span><span class="p">.</span><span class="nx">Inorder</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Prints:</span><span class="w"></span>
<span class="c1">// 30</span><span class="w"></span>
<span class="c1">// 20</span><span class="w"></span>
<span class="c1">// 39</span><span class="w"></span>
<span class="c1">// 10</span><span class="w"></span>
<span class="c1">// 40</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="additional-iteration-examples">
<h2>Additional iteration examples</h2>
<p><a class="reference external" href="https://pkg.go.dev/bufio#Scanner">bufio.Scanner</a> is a useful type for
iterating over lines in text; it can also be used to work with other separators,
but let's just talk about newline-separated lines for simplicity.</p>
<p>The canonical way of iterating over all lines in the input is:</p>
<div class="highlight"><pre><span></span><span class="nx">scanner</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Text</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;reading standard input:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This is a great example of an ad-hoc iteration method the designers of Go came
up with, before the language had real iterator support. There's nothing wrong
with this approach - it's clear and it works well. However, without a standard
for iteration, multiple approaches emerge and one always has to consult the
documentation for the right way to do this.</p>
<p>With the new range-over-functions feature, we can write an iterator that works
in a <tt class="docutils literal"><span class="pre">for-range</span></tt> loop. I'll wrap <tt class="docutils literal">Scanner</tt> to demonstrate this without
modifying the standard library:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">myScanner</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Scanner</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">newScanner</span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">myScanner</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">myScanner</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">s</span><span class="p">:</span><span class="w"> </span><span class="nx">s</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ms</span><span class="w"> </span><span class="o">*</span><span class="nx">myScanner</span><span class="p">)</span><span class="w"> </span><span class="nx">All</span><span class="p">()</span><span class="w"> </span><span class="nx">iter</span><span class="p">.</span><span class="nx">Seq</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">ms</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">ms</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">Text</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ms</span><span class="w"> </span><span class="o">*</span><span class="nx">myScanner</span><span class="p">)</span><span class="w"> </span><span class="nx">Err</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">ms</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">Err</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And we can use it as follows:</p>
<div class="highlight"><pre><span></span><span class="nx">scanner</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">newScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nx">line</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">All</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;got line:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">line</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;reading stdin: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>One could envision an <tt class="docutils literal">All</tt> method being added to the actual <tt class="docutils literal">Scanner</tt>
type at some point in the future.</p>
<p>Another example that I like is the <tt class="docutils literal">Backward</tt> function for slices. It shows
that a free-standing function can also return an iterator, and that it can
use a parameter to define the iteration:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Backward</span><span class="p">[</span><span class="nx">E</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">x</span><span class="w"> </span><span class="p">[]</span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="nx">iter</span><span class="p">.</span><span class="nx">Seq2</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">E</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">yield</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">i</span><span class="o">--</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Usage:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">Backward</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Prints:</span><span class="w"></span>
<span class="c1">// 22</span><span class="w"></span>
<span class="c1">// 11</span><span class="w"></span>
<span class="c1">// 8</span><span class="w"></span>
<span class="c1">// 7</span><span class="w"></span>
<span class="c1">// 6</span><span class="w"></span>
<span class="c1">// 5</span><span class="w"></span>
</pre></div>
<p>You don't have to write your own <tt class="docutils literal">Backward</tt> function though - it's already
been added to the standard <a class="reference external" href="https://pkg.go.dev/slices">slices package</a>,
along with some other useful iterator functions (search the documentation
for <tt class="docutils literal">iter.Seq</tt>).</p>
</div>
<div class="section" id="final-words-push-vs-pull-iterators">
<h2>Final words - push vs. pull iterators</h2>
<p>I like this new feature - it improves the ergonomics of Go
programming with only minimal added complexity <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>. I started putting
together a <a class="reference external" href="https://github.com/eliben/gogl">small collection of generic Go data structures</a>,
and most of the packages there now implement iterators.</p>
<p>Finally, if you read the proposal and other documents related to it, you'll
quickly run into &quot;push&quot; vs. &quot;pull&quot; iterators; what do these terms mean?</p>
<p>Simply put, &quot;push&quot; iterators push their values into a function given to them;
the iterators in this proposal and the examples in this post are therefore
all push iterators - they take a <tt class="docutils literal">yield</tt> function and generate values by
invoking it; <tt class="docutils literal">yield</tt>'s return value is then used to determine whether the
iterator should continue generating values, or else stop.</p>
<p>&quot;Pull&quot; iterators work somewhat differently; a pull iterator is a function
you can invoke multiple times and its signature is something like:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">cont</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Where <tt class="docutils literal">value</tt> is the generated value and <tt class="docutils literal">cont</tt> says if the iterator is
ready to produce more values, or else is done.</p>
<p>The control flow around push vs. pull iterators is very different. Push
iterators &quot;drive&quot; the iteration process, feeding values into a function until
they're done or explicitly asked to stop. Pull iterators, on the other hand,
are driven from elsewhere and have to retain state between calls. Both kinds of
iterators are useful for different patterns.</p>
<p>The <a class="reference external" href="https://go.dev/blog/range-functions">Go blog post</a> has an example
of pull-based iteration, and <a class="reference external" href="https://research.swtch.com/coro">Russ's coro blog post</a>
goes into more details.</p>
<p>An <a class="reference external" href="https://pkg.go.dev/iter#Pull">iter.Pull</a> function for converting from
push to pull iterators has also been added to the standard library. I may
write more about pull iterators separately.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>As an exercise, if you want to feel like a real Lisp hacker, feel free
to implement it using a proper linked list.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>Note that I'm saying <em>maximal</em> number of returned values. Even if our
<tt class="docutils literal">yield</tt> takes two values, we can still iterate with <tt class="docutils literal">for x := range</tt>
and only the <em>first</em> value fed to <tt class="docutils literal">yield</tt> will be assigned to <tt class="docutils literal">x</tt>.
This is just like iterating over regular maps, where the
<tt class="docutils literal">for k, v := range</tt> form obtains both keys and values, but the
<tt class="docutils literal">for k := range</tt> form is valid as well - for iterating just over keys.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>At least user-observable complexity. The implementation of the proposal
is rather involved in order to handle all forms of control flow properly.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2024/ranging-over-functions-in-go-123/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:39:06 GMT -->
</html>