<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - Recursive descent parsing</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/recursive-descent-parsing.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2024-05-04T19:46:23-07:00</updated><entry><title>Ungrammar in Go and resilient parsing</title><link href="https://eli.thegreenplace.net/2023/ungrammar-in-go-and-resilient-parsing/" rel="alternate"></link><published>2023-07-08T06:12:00-07:00</published><updated>2023-07-08T13:12:59-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2023-07-08:/2023/ungrammar-in-go-and-resilient-parsing/</id><summary type="html">&lt;p&gt;It won't be news to the readers of this blog that I have &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;some interest&lt;/a&gt; in
&lt;a class="reference external" href="https://eli.thegreenplace.net/tag/compilation"&gt;compiler&lt;/a&gt;
&lt;a class="reference external" href="https://eli.thegreenplace.net/tag/recursive-descent-parsing"&gt;front-ends&lt;/a&gt;.
So when I heard about a new(-ish) DSL for
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Parse_tree"&gt;concrete syntax trees&lt;/a&gt; (CST), I
couldn't resist playing with it a bit.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/rust-analyzer/ungrammar/tree/master"&gt;Ungrammar&lt;/a&gt; is used
in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rust-analyzer&lt;/span&gt;&lt;/tt&gt; to define and access a â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;It won't be news to the readers of this blog that I have &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;some interest&lt;/a&gt; in
&lt;a class="reference external" href="https://eli.thegreenplace.net/tag/compilation"&gt;compiler&lt;/a&gt;
&lt;a class="reference external" href="https://eli.thegreenplace.net/tag/recursive-descent-parsing"&gt;front-ends&lt;/a&gt;.
So when I heard about a new(-ish) DSL for
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Parse_tree"&gt;concrete syntax trees&lt;/a&gt; (CST), I
couldn't resist playing with it a bit.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/rust-analyzer/ungrammar/tree/master"&gt;Ungrammar&lt;/a&gt; is used
in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rust-analyzer&lt;/span&gt;&lt;/tt&gt; to define and access a CST for Rust.
&lt;a class="reference external" href="https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html"&gt;This blog post&lt;/a&gt;
by its creator provides much more details. According to the author, Ungrammar
is &amp;quot;the ASDL for concrete syntax trees&amp;quot;. This sounded interesting,
since I've been &lt;a class="reference external" href="https://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers"&gt;dabbling in ASDL in the past&lt;/a&gt;,
and also have experience with similar techniques for defining
&lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser ASTs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The result is &lt;a class="reference external" href="https://github.com/eliben/go-ungrammar"&gt;go-ungrammar&lt;/a&gt;,
a re-implementation of Ungrammar in Go. The input is an Ungrammar file defining
some CST; for example, here's a simple calculator language:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Program = Stmt*

Stmt = AssignStmt | Expr

AssignStmt = &amp;#39;set&amp;#39; &amp;#39;ident&amp;#39; &amp;#39;=&amp;#39; Expr

Expr =
    Literal
  | UnaryExpr
  | ParenExpr
  | BinExpr

UnaryExpr = op:(&amp;#39;+&amp;#39; | &amp;#39;-&amp;#39;) Expr

ParenExpr = &amp;#39;(&amp;#39; Expr &amp;#39;)&amp;#39;

BinExpr = lhs:Expr op:(&amp;#39;+&amp;#39; | &amp;#39;-&amp;#39; | &amp;#39;*&amp;#39; | &amp;#39;/&amp;#39; | &amp;#39;%&amp;#39;) rhs:Expr

Literal = &amp;#39;int_literal&amp;#39; | &amp;#39;ident&amp;#39;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ungrammar looks a bit like EBNF, but not &lt;em&gt;quite&lt;/em&gt; (hence the name &amp;quot;ungrammar&amp;quot;).
It's much simpler because it doesn't need to concern itself with precedence,
ambiguities and so on, also leaving all the (often complex) lexical rules to the
lexer. It simply defines a &lt;em&gt;tree&lt;/em&gt; that can be used to represent parsed language.
It's also different from ASTs in that it preserves all tokens, including
delimiters and other syntax elements. This is useful for tools like language
servers that need a full-fidelity representation of the source code.&lt;/p&gt;
&lt;div class="section" id="implementation-notes"&gt;
&lt;h2&gt;Implementation notes&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-ungrammar&lt;/span&gt;&lt;/tt&gt; uses a classical &lt;a class="reference external" href="https://github.com/eliben/go-ungrammar/blob/main/lexer.go"&gt;hand-written lexical analyzer&lt;/a&gt;
and a &lt;a class="reference external" href="https://github.com/eliben/go-ungrammar/blob/main/parser.go"&gt;recursive
descent parser&lt;/a&gt;.
Just for fun, I spent more time on error recovery than strictly necessary for
such a simple input language. The lexer &lt;a class="reference external" href="https://www.youtube.com/watch?v=dQw4w9WgXcQ"&gt;never gives up&lt;/a&gt; when encountering non-sensical
input; it simply emits an &lt;tt class="docutils literal"&gt;ERROR&lt;/tt&gt; token and keeps going. The parser doesn't
quit on the first error either; instead, it collects all the errors it
encounters and tries to recover from each one (the &lt;tt class="docutils literal"&gt;synchronize()&lt;/tt&gt; method in
the parser code). As an example of this in action, consider this faulty
Ungrammar input:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo = @
bar = ( joe
x = y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At first glance, there are at least a couple of issues here:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&amp;#64;&lt;/tt&gt; is not a valid Ungrammar token&lt;/li&gt;
&lt;li&gt;The &lt;tt class="docutils literal"&gt;(&lt;/tt&gt; in the second rule is unterminated; as all programmers know,
unterminated grouping elements spell trouble because the compiler can get
easily confused until it finds a valid terminator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-ungrammar&lt;/span&gt;&lt;/tt&gt; runs it will report an error that looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1:7: unknown token starting with &amp;#39;@&amp;#39; (and 2 more errors)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/eliben/go-ungrammar/blob/main/errorlist.go"&gt;concrete error type&lt;/a&gt; returned by
the parser collects all the errors, so we can iterate over them and display them
all:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1:7: unknown token starting with &amp;#39;@&amp;#39;
2:1: expected rule, got bar
3:1: expected &amp;#39;)&amp;#39;, got x
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The parser recovers after the first error expecting to see the RHS
(right-hand-side) for the &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; rule, but doesn't find any. This is a good
place to discuss parser recovery. The Ungrammar language has a significant
ambiguity:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo = bar baz = barn
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Are &lt;tt class="docutils literal"&gt;bar baz&lt;/tt&gt; the RHS sequence for rule &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;, or is &lt;tt class="docutils literal"&gt;baz =&lt;/tt&gt; the beginning
of a new rule? Note that the language is whitespace-insensitive, so this really
does come up; just look at the example calculator Ungrammar above - this is
encountered on pretty much any new rule.&lt;/p&gt;
&lt;p&gt;The way &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-ungrammar&lt;/span&gt;&lt;/tt&gt; resolves the ambiguity is by using an &lt;tt class="docutils literal"&gt;NODE =&lt;/tt&gt;
lookahead, deciding it's the beginning of a new rule (&lt;tt class="docutils literal"&gt;NODE&lt;/tt&gt; is an Ungrammar
term for &amp;quot;plain identifier&amp;quot;).&lt;/p&gt;
&lt;p&gt;Back to our recovery example: the second error is the parser complaining that
it expected some rule after &lt;tt class="docutils literal"&gt;foo =&lt;/tt&gt; but found none; an empty RHS is invalid
in Ungrammar and the &lt;tt class="docutils literal"&gt;&amp;#64;&lt;/tt&gt; was reported and skipped. So the parser complains
that it found a new rule definition instead of the RHS for an existing rule.
At this point it re-synchronizes and parses the &lt;tt class="docutils literal"&gt;bar =&lt;/tt&gt; rule. Then it runs into
the third error - the &lt;tt class="docutils literal"&gt;(&lt;/tt&gt; is unterminated. Still, the parser recovers and
keeps going.&lt;/p&gt;
&lt;p&gt;Even with all these errors, the parser will produce a partial result - a tree
equivalent to this input:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bar = joe
x = y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; there was simply nothing to parse. For &lt;tt class="docutils literal"&gt;bar&lt;/tt&gt;, the parser reported
the missing &lt;tt class="docutils literal"&gt;)&lt;/tt&gt; but parsed the contents anyway. It then fully recovered and
was able to parse &lt;tt class="docutils literal"&gt;x = y&lt;/tt&gt; properly. Being able to parse incomplete input and
produce partial trees is very important for error recovery, and especially for
tools like language servers that need to be resilient in the presence of partial
input the user is busy typing in.&lt;/p&gt;
&lt;p&gt;I enjoyed coding this resilient parser; while it's probably an overkill for
a language as simple as Ungrammar, it's a good kata for frontend construction.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Go"></category><category term="Compilation"></category><category term="Recursive descent parsing"></category></entry><entry><title>Deciphering Haskell's applicative and monadic parsers</title><link href="https://eli.thegreenplace.net/2017/deciphering-haskells-applicative-and-monadic-parsers/" rel="alternate"></link><published>2017-11-27T05:28:00-08:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-11-27:/2017/deciphering-haskells-applicative-and-monadic-parsers/</id><summary type="html">&lt;p&gt;This post follows the construction of parsers described in &lt;a class="reference external" href="http://www.cs.nott.ac.uk/~pszgmh/pih.html"&gt;Graham Hutton's
&amp;quot;Programming in Haskell&amp;quot; (2nd edition)&lt;/a&gt;. It's my attempt to work through
chapter 13 in this book and understand the details of applicative and monadic
combination of parsers presented therein.&lt;/p&gt;
&lt;div class="section" id="basic-definitions-for-the-parser-type"&gt;
&lt;h2&gt;Basic definitions for the Parser type&lt;/h2&gt;
&lt;p&gt;A parser parameterized on â€¦&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;This post follows the construction of parsers described in &lt;a class="reference external" href="http://www.cs.nott.ac.uk/~pszgmh/pih.html"&gt;Graham Hutton's
&amp;quot;Programming in Haskell&amp;quot; (2nd edition)&lt;/a&gt;. It's my attempt to work through
chapter 13 in this book and understand the details of applicative and monadic
combination of parsers presented therein.&lt;/p&gt;
&lt;div class="section" id="basic-definitions-for-the-parser-type"&gt;
&lt;h2&gt;Basic definitions for the Parser type&lt;/h2&gt;
&lt;p&gt;A parser parameterized on some type &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;P&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's a function taking a &lt;tt class="docutils literal"&gt;String&lt;/tt&gt; and returning a list of &lt;tt class="docutils literal"&gt;(a,String)&lt;/tt&gt;
pairs, where &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; is a value of the parameterized type and &lt;tt class="docutils literal"&gt;String&lt;/tt&gt; is (by
convention) the unparsed remainder of the input. The returned list is
potentially empty, which signals a failure in parsing &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. It might have made
more sense to define &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt; as a &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; alias for the function, but
&lt;tt class="docutils literal"&gt;type&lt;/tt&gt;s can't be made into instances of typeclasses; therefore, we use
&lt;tt class="docutils literal"&gt;netwype&lt;/tt&gt; with a dummy constructor named &lt;tt class="docutils literal"&gt;P&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;With this &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt; type, the act of actually parsing a string is expressed
with the following helper function. It's not strictly necessary, but it helps
make code cleaner by hiding &lt;tt class="docutils literal"&gt;P&lt;/tt&gt; from users of the parser.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;P&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most basic parsing primitive plucks off the first character from a given
string:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;item&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;item&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;P&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;of&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's how it works in practice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; parse item &amp;quot;foo&amp;quot;
[(&amp;#39;f&amp;#39;,&amp;quot;oo&amp;quot;)]
&amp;gt; parse item &amp;quot;f&amp;quot;
[(&amp;#39;f&amp;#39;,&amp;quot;&amp;quot;)]
&amp;gt; parse item &amp;quot;&amp;quot;
[]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="parser-as-a-functor"&gt;
&lt;h2&gt;Parser as a Functor&lt;/h2&gt;
&lt;p&gt;We'll start by making &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt; an instance of &lt;tt class="docutils literal"&gt;Functor&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;-- fmap :: (a -&amp;gt; b) -&amp;gt; Parser a -&amp;gt; Parser b&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;fmap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;P&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;of&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;fmap&lt;/tt&gt; we can create a new parser from an existing parser, with a
function applied to the parser's output. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; parse (fmap toUpper item) &amp;quot;foo&amp;quot;
[(&amp;#39;F&amp;#39;,&amp;quot;oo&amp;quot;)]
&amp;gt; parse (fmap toUpper item) &amp;quot;&amp;quot;
[]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's check that the functor laws work for this definition. The first law:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fmap id = id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is fairly obvious when we substitute &lt;tt class="docutils literal"&gt;id&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;g&lt;/tt&gt; in the definition of
&lt;tt class="docutils literal"&gt;fmap&lt;/tt&gt;. We get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fmap id p = P (\inp -&amp;gt; case parse p inp of
                        []        -&amp;gt; []
                        [(v,out)] -&amp;gt; [(id v,out)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which takes the parse result of &lt;tt class="docutils literal"&gt;p&lt;/tt&gt; and passes it through without
modification. In other words, it's equivalent to &lt;tt class="docutils literal"&gt;p&lt;/tt&gt; itself, and hence the
first law holds.&lt;/p&gt;
&lt;p&gt;Verifying the second law:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fmap (g . h) = fmap g . fmap h
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;... is similarly straightforward and is left as an exercise to the reader.&lt;/p&gt;
&lt;p&gt;While it's not obvious why a &lt;tt class="docutils literal"&gt;Functor&lt;/tt&gt; instance for &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt; is useful in
its own right, it's actually required to make &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt; into an
&lt;tt class="docutils literal"&gt;Applicative&lt;/tt&gt;, and also when combining parsers using applicative style.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="parser-as-an-applicative"&gt;
&lt;h2&gt;Parser as an Applicative&lt;/h2&gt;
&lt;p&gt;Consider parsing conditional expressions in a fictional language:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if &amp;lt;expr&amp;gt; then &amp;lt;expr&amp;gt; else &amp;lt;expr&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To parse such expressions we'd like to say:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Parse the token &lt;tt class="docutils literal"&gt;if&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Parse an &amp;lt;expr&amp;gt;&lt;/li&gt;
&lt;li&gt;Parse the token &lt;tt class="docutils literal"&gt;then&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Parse an &amp;lt;expr&amp;gt;&lt;/li&gt;
&lt;li&gt;Parse the token &lt;tt class="docutils literal"&gt;else&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Parse an &amp;lt;expr&amp;gt;&lt;/li&gt;
&lt;li&gt;If all of this was successful, combine all the parsed expressions into some
sort of result, like an AST node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such sequences, along with alternation (an expression is either &lt;em&gt;this&lt;/em&gt; or
&lt;em&gt;that&lt;/em&gt;) are two of the critical basic blocks of constructing non-trivial
parsers. Let's see a popular way to accomplish this in Haskell (for a complete
example demonstrating how to construct a parser for this particular conditional
expression, see the last section in this post).&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Parser_combinator"&gt;Parser combinators&lt;/a&gt; is a
popular technique for constructing complex parsers from simpler parsers, by
means of higher-order functions. In Haskell, one of the ways in which parsers
can be elegantly combined is using applicative style. Here's the &lt;tt class="docutils literal"&gt;Applicative&lt;/tt&gt;
instance for &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;-- pure :: a -&amp;gt; Parser a&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;P&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;-- &amp;lt;*&amp;gt; :: Parser (a -&amp;gt; b) -&amp;gt; Parser a -&amp;gt; Parser b&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;pg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;px&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;P&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;of&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;px&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall how we created a parser that applied &lt;tt class="docutils literal"&gt;toUpper&lt;/tt&gt; to its result using
&lt;tt class="docutils literal"&gt;fmap&lt;/tt&gt;? We can now do the same in applicative style:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; parse (pure toUpper &amp;lt;*&amp;gt; item) &amp;quot;foo&amp;quot;
[(&amp;#39;F&amp;#39;,&amp;quot;oo&amp;quot;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's see why this works. While not too exciting on its own, this application of
a single-argument function is a good segue to more complicated use cases.&lt;/p&gt;
&lt;p&gt;Looking at the &lt;tt class="docutils literal"&gt;Applicative&lt;/tt&gt; instance, &lt;tt class="docutils literal"&gt;pure toUpper&lt;/tt&gt; translates to
&lt;tt class="docutils literal"&gt;P (\inp &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; [(toUpper,inp)]&lt;/tt&gt; - a parser that passes its input through
unchanged, returning &lt;tt class="docutils literal"&gt;toUpper&lt;/tt&gt; as a result. Now, substituting &lt;tt class="docutils literal"&gt;item&lt;/tt&gt; into
the definition of &lt;tt class="docutils literal"&gt;&amp;lt;*&amp;gt;&lt;/tt&gt; we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pg &amp;lt;*&amp;gt; item = P (\inp -&amp;gt; case parse pg inp of
                            []        -&amp;gt; []
                            [(g,out)] -&amp;gt; parse (fmap g item) out)

... pg is (pure toUpper), the parsing of which always succeeds, returning
    [(toUpper,inp)]

pg &amp;lt;*&amp;gt; item = P (\inp -&amp;gt; parse (fmap toUpper item) inp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, this is exactly the example we had for &lt;tt class="docutils literal"&gt;Functor&lt;/tt&gt; by
&lt;tt class="docutils literal"&gt;fmap&lt;/tt&gt;-ing &lt;tt class="docutils literal"&gt;toUpper&lt;/tt&gt; onto &lt;tt class="docutils literal"&gt;item&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The more interesting case is applying functions with multiple parameters. Here's
how we define a parser that parses three items from the input, dropping the
middle result:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;dropMiddle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;dropMiddle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Following the application of nested &lt;tt class="docutils literal"&gt;&amp;lt;*&amp;gt;&lt;/tt&gt; operators is tricky because it
builds a run-time chain of functions referring to other functions. This chain
is only collapsed when the parser is used to actually &lt;tt class="docutils literal"&gt;parse&lt;/tt&gt; some input, so
it is necessary to keep a lot of context &amp;quot;on the fly&amp;quot;. To better understand how
this works, we can break the definition of &lt;tt class="docutils literal"&gt;dropMiddle&lt;/tt&gt; into parts as follows
(since &lt;tt class="docutils literal"&gt;&amp;lt;*&amp;gt;&lt;/tt&gt; is left-associative):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;dropMiddle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Applying the first &lt;tt class="docutils literal"&gt;&amp;lt;*&amp;gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pg &amp;lt;*&amp;gt; item = P (\inp -&amp;gt; case parse pg inp of
                            []        -&amp;gt; []
                            [(g,out)] -&amp;gt; parse (fmap g item) out)

... pg is (pure selector), the parsing of which always succeeds, returning
    [(selector,inp)]

pg &amp;lt;*&amp;gt; item = P (\inp -&amp;gt; parse (fmap selector item) inp)  --= app1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's call this parser &lt;tt class="docutils literal"&gt;app1&lt;/tt&gt; and apply the second &lt;tt class="docutils literal"&gt;&amp;lt;*&amp;gt;&lt;/tt&gt; in the sequence.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;app1 &amp;lt;*&amp;gt; item = P (\inp -&amp;gt; case parse app1 inp of
                            []        -&amp;gt; []
                            [(g,out)] -&amp;gt; parse (fmap g item) out)  --= app2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We'll call this &lt;tt class="docutils literal"&gt;app2&lt;/tt&gt; and move on. Similarly, applying the third &lt;tt class="docutils literal"&gt;&amp;lt;*&amp;gt;&lt;/tt&gt; in
the sequence produces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;app2 &amp;lt;*&amp;gt; item = P (\inp -&amp;gt; case parse app2 inp of
                            []        -&amp;gt; []
                            [(g,out)] -&amp;gt; parse (fmap g item) out)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is &lt;tt class="docutils literal"&gt;dropMiddle&lt;/tt&gt;. It's a chain of parsers expressed as a compbination of
higher-order functions (closures, actually).&lt;/p&gt;
&lt;p&gt;To see how this combined parser actually parses input, let's trace through the
execution of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; parse dropMiddle &amp;quot;pumpkin&amp;quot;
[((&amp;#39;p&amp;#39;,&amp;#39;m&amp;#39;),&amp;quot;pkin&amp;quot;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;dropMiddle&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;app2 &amp;lt;*&amp;gt; item&lt;/tt&gt;, so we have:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-- parse dropMiddle

parse P (\inp -&amp;gt; case parse app2 inp of
                   []         -&amp;gt; []
                   [(g,out)]  -&amp;gt; parse (fmap g item) out)
      &amp;quot;pumpkin&amp;quot;

.. substituting &amp;quot;pumpkin&amp;quot; into inp

case parse app2 &amp;quot;pumpkin&amp;quot; of
 []         -&amp;gt; []
 [(g,out)]  -&amp;gt; parse (fmap g item) out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now &lt;tt class="docutils literal"&gt;parse app2 &amp;quot;pumpkin&amp;quot;&lt;/tt&gt; is going to be invoked; &lt;tt class="docutils literal"&gt;app2&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;app1 &amp;lt;*&amp;gt;
item&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-- parse app2

case parse app1 &amp;quot;pumpkin&amp;quot; of
 []         -&amp;gt; []
 [(g,out)]  -&amp;gt; parse (fmap g item) out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Similarly, we get to &lt;tt class="docutils literal"&gt;parse app1 &amp;quot;pumpkin&amp;quot;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-- parse app1

parse (fmap selector item) &amp;quot;pumpkin&amp;quot;

.. following the definition of fmap

parse P (\inp -&amp;gt; case parse item inp of
                  []        -&amp;gt; []
                  [(v,out)] -&amp;gt; [(selector v,out)])
      &amp;quot;pumpkin&amp;quot;

.. Since (parse item &amp;quot;pumpkin&amp;quot;) returns [(&amp;#39;p&amp;#39;,&amp;quot;umpkin&amp;quot;)], we get:

[(selector &amp;#39;p&amp;#39;,&amp;quot;umpkin&amp;quot;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now going back to &lt;tt class="docutils literal"&gt;parse app2&lt;/tt&gt;, knowing what &lt;tt class="docutils literal"&gt;parse app1 &amp;quot;pumpkin&amp;quot;&lt;/tt&gt; returns:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;parse (fmap (selector &amp;#39;p&amp;#39;) item) &amp;quot;umpkin&amp;quot;

.. following the definition of fmap

parse P (\inp -&amp;gt; case parse item inp of
                  []        -&amp;gt; []
                  [(v,out)] -&amp;gt; [(selector &amp;#39;p&amp;#39; v,out)])
      &amp;quot;umpkin&amp;quot;

[(selector &amp;#39;p&amp;#39; &amp;#39;u&amp;#39;,&amp;quot;mpkin&amp;quot;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, &lt;tt class="docutils literal"&gt;dropMiddle&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;app2 &amp;lt;*&amp;gt; item = P (\inp -&amp;gt; case parse app2 inp of
                            []        -&amp;gt; []
                            [(g,out)] -&amp;gt; parse (fmap g item) out)

.. Since (parse app2 &amp;quot;pumpkin&amp;quot;) returns [(selector &amp;#39;p&amp;#39; &amp;#39;u&amp;#39;,&amp;quot;mpkin&amp;quot;)]

parse (fmap (selector &amp;#39;p&amp;#39; &amp;quot;u&amp;quot;) item) &amp;quot;mpkin&amp;quot;

.. If we follow the definition of fmap again, we&amp;#39;ll get:

[(selector &amp;#39;p&amp;#39; &amp;#39;u&amp;#39; &amp;#39;m&amp;#39;,&amp;quot;pkin&amp;quot;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the final result of applying &lt;tt class="docutils literal"&gt;dropMiddle&lt;/tt&gt; to &amp;quot;pumpkin&amp;quot;, and when
&lt;tt class="docutils literal"&gt;selector&lt;/tt&gt; is invoked we get &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;[(('p','m'),&amp;quot;pkin&amp;quot;)]&lt;/span&gt;&lt;/tt&gt;, as expected.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="parser-as-a-monad"&gt;
&lt;h2&gt;Parser as a Monad&lt;/h2&gt;
&lt;p&gt;Parsers can also be expressed and combined using monadic style. Here's the
&lt;tt class="docutils literal"&gt;Monad&lt;/tt&gt; instance for &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;-- return :: a -&amp;gt; Parser a&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;-- (&amp;gt;&amp;gt;=) :: Parser a -&amp;gt; (a -&amp;gt; Parser b) -&amp;gt; Parser b&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;P&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;of&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's take the simple example of applying &lt;tt class="docutils literal"&gt;toUpper&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;item&lt;/tt&gt; again, this
time using monadic operators:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; parse (item &amp;gt;&amp;gt;= (\x -&amp;gt; return $ toUpper x)) &amp;quot;foo&amp;quot;
[(&amp;#39;F&amp;#39;,&amp;quot;oo&amp;quot;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Substituting in the definition of &lt;tt class="docutils literal"&gt;&amp;gt;&amp;gt;=&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;item &amp;gt;&amp;gt;= (\x -&amp;gt; return $ toUpper x) =
  P (\inp -&amp;gt; case parse item inp of
                []        -&amp;gt; []
                [(v,out)] -&amp;gt; parse (return $ toUpper v) out)

... if item succeeds, this is a parser that will always succeed with
    the upper-cased result of item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When writing in monadic style, however, we won't typically be using the &lt;tt class="docutils literal"&gt;&amp;gt;&amp;gt;=&lt;/tt&gt;
operator explicitly; instead, we'll use the &lt;tt class="docutils literal"&gt;do&lt;/tt&gt; notation. Recall that in the
general multi-parameter case, this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;m1 &amp;gt;&amp;gt;= \x1 -&amp;gt;
  m2 &amp;gt;&amp;gt;= \x2 -&amp;gt;
    ...
      mn &amp;gt;&amp;gt;= \xn -&amp;gt; f x1 x2 ... xn
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is equivalent to this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;do x1 &amp;lt;- m1
   x2 &amp;lt;- m2
   ...
   xn &amp;lt;- mn
   f x1 x2 ... xn
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we can also rewrite our example as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; parse (do x &amp;lt;- item; return $ toUpper x) &amp;quot;foo&amp;quot;
[(&amp;#39;F&amp;#39;,&amp;quot;oo&amp;quot;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;do&lt;/tt&gt; notation starts looking much more attractive for multiple parameters,
however. Here's &lt;tt class="docutils literal"&gt;dropMiddle&lt;/tt&gt; in monadic style written directly &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dropMiddleM :: Parser (Char,Char)
dropMiddleM = item &amp;gt;&amp;gt;= \x -&amp;gt;
                item &amp;gt;&amp;gt;= \_ -&amp;gt;
                  item &amp;gt;&amp;gt;= \z -&amp;gt; return (x,z)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now rewritten using &lt;tt class="docutils literal"&gt;do&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dropMiddleM&amp;#39; :: Parser (Char,Char)
dropMiddleM&amp;#39; =
  do  x &amp;lt;- item
      item
      z &amp;lt;- item
      return (x,z)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's do a detailed breakdown of what's happening here to better understand the
monadic sequencing mechanics. I'll be using the direct style (&lt;tt class="docutils literal"&gt;dropMiddleM&lt;/tt&gt;)
to unravel the applications of &lt;tt class="docutils literal"&gt;&amp;gt;&amp;gt;=&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;item &amp;gt;&amp;gt;= \x -&amp;gt;
  item &amp;gt;&amp;gt;= \_ -&amp;gt;
    item &amp;gt;&amp;gt;= \z -&amp;gt; return (x,z)

.. applying the first &amp;gt;&amp;gt;=, calling the right-hand side rhsX

P (\inp -&amp;gt; case parse item inp of
              []        -&amp;gt; []
              [(v,out)] -&amp;gt; parse (rhsX v) out)

.. the result of parsing the first item is passed in as the argument to rhsX,
   which then returns the next application of &amp;gt;&amp;gt;=; As usual, we acknowledge
   the error propagation and ignore it for simplicity.

P (\inp -&amp;gt; case parse item inp of
              []        -&amp;gt; []
              [(v,out)] -&amp;gt; parse (rhsY v) out)

... and similarly for rhsZ; the final result is invoking &amp;quot;parse return (x,z)&amp;quot;
    where x is the result of parsing the first item and z the result of
    parsing the third.
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="a-complete-example"&gt;
&lt;h2&gt;A complete example&lt;/h2&gt;
&lt;p&gt;As a complete example, I've expanded the parser grammar found in the book to
support conditional expressions. The full example is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/haskell-parsers/exprparser.hs"&gt;available here&lt;/a&gt;.
Recall that wa want to parse expressions of the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if &amp;lt;expr&amp;gt; then &amp;lt;expr&amp;gt; else &amp;lt;expr&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the monadic parser &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ifexpr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;ifexpr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;if&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;then&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;thenExpr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;else&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;elseExpr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;then&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;elseExpr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thenExpr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this is the equivalent applicative version (&lt;tt class="docutils literal"&gt;&amp;lt;$&amp;gt;&lt;/tt&gt; is just an infix
synonym for &lt;tt class="docutils literal"&gt;fmap&lt;/tt&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ifexpr&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Parser&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;ifexpr&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;if&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;then&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;else&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;then&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which one is better? It's really a matter of personal taste. Since both the
monadic and applicative styles deal in &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt;s, they can be freely mixed
and combined.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Failures could also be signaled by using &lt;tt class="docutils literal"&gt;Maybe&lt;/tt&gt;, but a list lets us
express multiple results (for example a string that can be parsed in
multiple ways). We're not going to be using multiple results in this
article, but it's good to keep this option open.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;We could also use the monadic operator &lt;tt class="docutils literal"&gt;&amp;gt;&amp;gt;&lt;/tt&gt; for statements that
don't create a new assignment, but using &lt;tt class="docutils literal"&gt;&amp;gt;&amp;gt;=&lt;/tt&gt; everywhere for
consistency makes it a bit easier to understand.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The return value of this parser is &lt;tt class="docutils literal"&gt;Int&lt;/tt&gt;, because it evaluates the
parsed expression on the fly - this technique is called &lt;em&gt;Syntax Directed
Translation&lt;/em&gt; in the Dragon book. Note also that the conditional clauses
are evaluated eagerly, which is valid only when no side effects are
present.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Haskell"></category><category term="Recursive descent parsing"></category></entry><entry><title>Parsing expressions by precedence climbing</title><link href="https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing" rel="alternate"></link><published>2012-08-02T05:48:43-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-08-02:/2012/08/02/parsing-expressions-by-precedence-climbing</id><summary type="html">
        &lt;p&gt;I've written &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/"&gt;previously&lt;/a&gt; about the problem recursive descent parsers have with expressions, especially when the language has multiple levels of operator precedence.&lt;/p&gt;
&lt;p&gt;There are several ways to attack this problem. The Wikipedia article on &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser"&gt;operator-precedence parsers&lt;/a&gt; mentions three algorithms: Shunting Yard, top-down operator precedence (TDOP) and precedence climbing. I have â€¦&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;I've written &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/"&gt;previously&lt;/a&gt; about the problem recursive descent parsers have with expressions, especially when the language has multiple levels of operator precedence.&lt;/p&gt;
&lt;p&gt;There are several ways to attack this problem. The Wikipedia article on &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser"&gt;operator-precedence parsers&lt;/a&gt; mentions three algorithms: Shunting Yard, top-down operator precedence (TDOP) and precedence climbing. I have already covered &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/"&gt;Shunting Yard&lt;/a&gt; and &lt;a class="reference external" href="https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/"&gt;TDOP&lt;/a&gt; in this blog. Here I aim to present the third method (and the one that actually ends up being used a lot in practice) - precedence climbing.&lt;/p&gt;
&lt;div class="section" id="precedence-climbing-what-it-aims-to-achieve"&gt;
&lt;h3&gt;Precedence climbing - what it aims to achieve&lt;/h3&gt;
&lt;p&gt;It's not necessary to be familiar with the other algorithms for expression parsing in order to understand precedence climbing. In fact, I think that precedence climbing is the simplest of them all. To explain it, I want to first present what the algorithm is trying to achieve. After this, I will explain how it does this, and finally will present a fully functional implementation in Python.&lt;/p&gt;
&lt;p&gt;So the basic goal of the algorithm is the following: treat an expression as a bunch of nested sub-expressions, where each sub-expression has in common the lowest precedence level of the the operators it contains.&lt;/p&gt;
&lt;p&gt;Here's a simple example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 + 3 * 4 * 5 - 6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Assuming that the precedence of &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; (and &lt;tt class="docutils literal"&gt;-&lt;/tt&gt;) is 1 and the precedence of &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; (and &lt;tt class="docutils literal"&gt;/&lt;/tt&gt;) is 2, we have:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 + 3 * 4 * 5 - 6

|---------------|   : prec 1
    |-------|       : prec 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The sub-expression multiplying the three numbers has a minimal precedence of 2. The sub-expression spanning the whole original expression has a minimal precedence of 1.&lt;/p&gt;
&lt;p&gt;Here's a more complex example, adding a power operator &lt;tt class="docutils literal"&gt;^&lt;/tt&gt; with precedence 3:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 + 3 ^ 2 * 3 + 4

|---------------|   : prec 1
    |-------|       : prec 2
    |---|           : prec 3
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="associativity"&gt;
&lt;h4&gt;Associativity&lt;/h4&gt;
&lt;p&gt;Binary operators, in addition to precedence, also have the concept of &lt;em&gt;associativity&lt;/em&gt;. Simply put, &lt;em&gt;left associative&lt;/em&gt; operators stick to the left stronger than to the right; &lt;em&gt;right associative&lt;/em&gt; operators vice versa.&lt;/p&gt;
&lt;p&gt;Some examples. Since addition is left associative, this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 + 3 + 4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is equivalent to this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;(2 + 3) + 4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On the other hand, power (exponentiation) is right associative. This:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 ^ 3 ^ 4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is equivalent to this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 ^ (3 ^ 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The precedence climbing algorithm also needs to handle associativity correctly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nested-parenthesized-sub-expressions"&gt;
&lt;h4&gt;Nested parenthesized sub-expressions&lt;/h4&gt;
&lt;p&gt;Finally, we all know that parentheses can be used to explicitly group sub-expressions, beating operator precedence. So the following expression computes the addition &lt;em&gt;before&lt;/em&gt; the multiplication:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 * (3 + 5) * 7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we'll see, the algorithm has a special provision to cleverly handle nested sub-expressions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="precedence-climbing-how-it-actually-works"&gt;
&lt;h3&gt;Precedence climbing - how it actually works&lt;/h3&gt;
&lt;p&gt;First let's define some terms. &lt;em&gt;Atoms&lt;/em&gt; are either numbers or parenthesized expressions. &lt;em&gt;Expressions&lt;/em&gt; consist of atoms connected by binary operators &lt;a class="footnote-reference" href="#id4" id="id1"&gt;[1]&lt;/a&gt;. Note how these two terms are mutually dependent. This is normal in the land of grammars and parsers.&lt;/p&gt;
&lt;p&gt;The algorithm is &lt;em&gt;operator-guided&lt;/em&gt;. Its fundamental step is to consume the next atom and look at the operator following it. If the operator has precedence lower than the lowest acceptable for the current step, the algorithm returns. Otherwise, it calls itself in a loop to handle the sub-expression. In pseudo-code, it looks like this &lt;a class="footnote-reference" href="#id5" id="id2"&gt;[2]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;compute_expr(min_prec):
  result = compute_atom()

  while cur token is a binary operator with precedence &amp;gt;= min_prec:
    prec, assoc = precedence and associativity of current token
    if assoc is left:
      next_min_prec = prec + 1
    else:
      next_min_prec = prec
    rhs = compute_expr(next_min_prec)
    result = compute operator(result, rhs)

  return result
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each recursive call here handles a sequence of operator-connected atoms sharing the same minimal precedence.&lt;/p&gt;
&lt;div class="section" id="an-example"&gt;
&lt;h4&gt;An example&lt;/h4&gt;
&lt;p&gt;To get a feel for how the algorithm works, let's start with an example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2 + 3 ^ 2 * 3 + 4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's recommended to follow the execution of the algorithm through this expression with, on paper. The computation is kicked off by calling &lt;tt class="docutils literal"&gt;compute_expr(1)&lt;/tt&gt;, because 1 is the minimal operator precedence among all operators we've defined. Here is the &amp;quot;call tree&amp;quot; the algorithm produces for this expression:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;* compute_expr(1)                # Initial call on the whole expression
  * compute_atom() --&amp;gt; 2
  * compute_expr(2)              # Loop entered, operator &amp;#39;+&amp;#39;
    * compute_atom() --&amp;gt; 3
    * compute_expr(3)
      * compute_atom() --&amp;gt; 2
      * result --&amp;gt; 2             # Loop not entered for &amp;#39;*&amp;#39; (prec &amp;lt; &amp;#39;^&amp;#39;)
    * result = 3 ^ 2 --&amp;gt; 9
    * compute_expr(3)
      * compute_atom() --&amp;gt; 3
      * result --&amp;gt; 3             # Loop not entered for &amp;#39;+&amp;#39; (prec &amp;lt; &amp;#39;*&amp;#39;)
    * result = 9 * 3 --&amp;gt; 27
  * result = 2 + 27 --&amp;gt; 29
  * compute_expr(2)              # Loop entered, operator &amp;#39;+&amp;#39;
    * compute_atom() --&amp;gt; 4
    * result --&amp;gt; 4               # Loop not entered - end of expression
  * result = 29 + 4 --&amp;gt; 33
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="handling-precedence"&gt;
&lt;h4&gt;Handling precedence&lt;/h4&gt;
&lt;p&gt;Note that the algorithm makes one recursive call per binary operator. Some of these calls are short lived - they will only consume an atom and return it because the &lt;tt class="docutils literal"&gt;while&lt;/tt&gt; loop is not entered (this happens on the second 2, as well as on the second 3 in the example expression above). Some are longer lived. The initial call to &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt; will compute the whole expression.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;while&lt;/tt&gt; loop is the essential ingredient here. It's the thing that makes sure that the current &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt; call handles all consecutive operators with the given minimal precedence before exiting.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="handling-associativity"&gt;
&lt;h4&gt;Handling associativity&lt;/h4&gt;
&lt;p&gt;In my opinion, one of the coolest aspects of this algorithm is the simple and elegant way it handles associativity. It's all in that condition that either sets the minimal precedence for the next call to the current one, or current one plus one.&lt;/p&gt;
&lt;p&gt;Here's how this works. Assume we have this sub-expression somewhere:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;8 * 9 * 10

  ^
  |
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The arrow marks where the &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt; call is, having entered the &lt;tt class="docutils literal"&gt;while&lt;/tt&gt; loop. &lt;tt class="docutils literal"&gt;prec&lt;/tt&gt; is 2. Since the associativity of &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; is left, &lt;tt class="docutils literal"&gt;next_min_prec&lt;/tt&gt; is set to 3. The recursive call to &lt;tt class="docutils literal"&gt;compute_expr(3)&lt;/tt&gt;, after consuming an atom, sees the next &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; token:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;8 * 9 * 10

      ^
      |
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the precedence of &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; is 2, while &lt;tt class="docutils literal"&gt;min_prec&lt;/tt&gt; is 3, the &lt;tt class="docutils literal"&gt;while&lt;/tt&gt; loop never runs and the call returns. So the original &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt; will get to handle the second multiplication, not the internal call. Essentially, this means that the expression is grouped as follows:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;(8 * 9) * 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is exactly what we want from left associativity.&lt;/p&gt;
&lt;p&gt;In contrast, for this expression:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;8 ^ 9 ^ 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The precedence of &lt;tt class="docutils literal"&gt;^&lt;/tt&gt; is 3, and since it's right associative, the &lt;tt class="docutils literal"&gt;min_prec&lt;/tt&gt; for the recursive call stays 3. This will mean that the recursive call &lt;em&gt;will&lt;/em&gt; consume the next &lt;tt class="docutils literal"&gt;^&lt;/tt&gt; operator before returning to the original &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt;, grouping the expression as follows:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;8 ^ (9 ^ 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="handling-sub-expressions"&gt;
&lt;h4&gt;Handling sub-expressions&lt;/h4&gt;
&lt;p&gt;The algorithm pseudo-code presented above doesn't explain how parenthesized sub-expressions are handled. Consider this expression:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2000 * (4 - 3) / 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's not clear how the &lt;tt class="docutils literal"&gt;while&lt;/tt&gt; loop can handle this. The answer is &lt;tt class="docutils literal"&gt;compute_atom&lt;/tt&gt;. When it sees a left paren, it knows that a sub-expression will follow, so it calls &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt; on the sub expression (which lasts until the matching right paren), and returns its result as the result of the atom. So &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt; is oblivious to the existence of sub-expressions.&lt;/p&gt;
&lt;p&gt;Finally, in order to stay short the pseudo-code leaves some interesting details out. What follows is a full implementation of the algorithm that fills all the gaps.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="a-python-implementation"&gt;
&lt;h3&gt;A Python implementation&lt;/h3&gt;
&lt;p&gt;Here is a Python implementation of expression parsing by precedence climbing. It's kept short for simplicity, but can be be easily expanded to cover a more real-world language of expressions. The following sections present the code in small chunks. The whole code is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2012/rd_infix_precedence.py"&gt;available here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I'll start with a small tokenizer class that breaks text into tokens and keeps a state. The grammar is very simple: numeric expressions, the basic arithmetic operators &lt;tt class="docutils literal"&gt;+, &lt;span class="pre"&gt;-,&lt;/span&gt; *, /, ^&lt;/tt&gt; and parens - &lt;tt class="docutils literal"&gt;(, )&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Tok = namedtuple(&lt;span style="color: #7f007f"&gt;&amp;#39;Tok&amp;#39;&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;name value&amp;#39;&lt;/span&gt;)


&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Tokenizer&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Simple tokenizer object. The cur_token attribute holds the current&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        token (Tok). Call get_next_token() to advance to the&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        next token. cur_token is None before the first token is&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        taken and after the source ends.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    TOKPATTERN = re.compile(&lt;span style="color: #7f007f"&gt;&amp;quot;\s*(?:(\d+)|(.))&amp;quot;&lt;/span&gt;)

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, source):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._tokgen = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._gen_tokens(source)
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token = &lt;span style="color: #00007f"&gt;None&lt;/span&gt;

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;get_next_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Advance to the next token, and return it.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;try&lt;/span&gt;:
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._tokgen.next()
        &lt;span style="color: #00007f; font-weight: bold"&gt;except&lt;/span&gt; StopIteration:
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token = &lt;span style="color: #00007f"&gt;None&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;_gen_tokens&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, source):
        &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; number, operator &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.TOKPATTERN.findall(source):
            &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; number:
                &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; Tok(&lt;span style="color: #7f007f"&gt;&amp;#39;NUMBER&amp;#39;&lt;/span&gt;, number)
            &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;:
                &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; Tok(&lt;span style="color: #7f007f"&gt;&amp;#39;LEFTPAREN&amp;#39;&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;)
            &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;:
                &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; Tok(&lt;span style="color: #7f007f"&gt;&amp;#39;RIGHTPAREN&amp;#39;&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;)
            &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
                &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; Tok(&lt;span style="color: #7f007f"&gt;&amp;#39;BINOP&amp;#39;&lt;/span&gt;, operator)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, &lt;tt class="docutils literal"&gt;compute_atom&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;compute_atom&lt;/span&gt;(tokenizer):
    tok = tokenizer.cur_token
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; tok.name == &lt;span style="color: #7f007f"&gt;&amp;#39;LEFTPAREN&amp;#39;&lt;/span&gt;:
        tokenizer.get_next_token()
        val = compute_expr(tokenizer, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; tokenizer.cur_token.name != &lt;span style="color: #7f007f"&gt;&amp;#39;RIGHTPAREN&amp;#39;&lt;/span&gt;:
            parse_error(&lt;span style="color: #7f007f"&gt;&amp;#39;unmatched &amp;quot;(&amp;quot;&amp;#39;&lt;/span&gt;)
        tokenizer.get_next_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; val
    &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; tok &lt;span style="color: #0000aa"&gt;is&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt;:
            parse_error(&lt;span style="color: #7f007f"&gt;&amp;#39;source ended unexpectedly&amp;#39;&lt;/span&gt;)
    &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; tok.name == &lt;span style="color: #7f007f"&gt;&amp;#39;BINOP&amp;#39;&lt;/span&gt;:
        parse_error(&lt;span style="color: #7f007f"&gt;&amp;#39;expected an atom, not an operator &amp;quot;%s&amp;quot;&amp;#39;&lt;/span&gt; % tok.value)
    &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
        &lt;span style="color: #00007f; font-weight: bold"&gt;assert&lt;/span&gt; tok.name == &lt;span style="color: #7f007f"&gt;&amp;#39;NUMBER&amp;#39;&lt;/span&gt;
        tokenizer.get_next_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;int&lt;/span&gt;(tok.value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It handles true atoms (numbers in our case), as well as parenthesized sub-expressions.&lt;/p&gt;
&lt;p&gt;Here is &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt; itself, which is very close to the pseudo-code shown above:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;# For each operator, a (precedence, associativity) pair.&lt;/span&gt;
OpInfo = namedtuple(&lt;span style="color: #7f007f"&gt;&amp;#39;OpInfo&amp;#39;&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;prec assoc&amp;#39;&lt;/span&gt;)

OPINFO_MAP = {
    &lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;:    OpInfo(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;LEFT&amp;#39;&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;:    OpInfo(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;LEFT&amp;#39;&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;:    OpInfo(&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;LEFT&amp;#39;&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;:    OpInfo(&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;LEFT&amp;#39;&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;:    OpInfo(&lt;span style="color: #007f7f"&gt;3&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;RIGHT&amp;#39;&lt;/span&gt;),
}

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;compute_expr&lt;/span&gt;(tokenizer, min_prec):
    atom_lhs = compute_atom(tokenizer)

    &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; &lt;span style="color: #00007f"&gt;True&lt;/span&gt;:
        cur = tokenizer.cur_token
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (cur &lt;span style="color: #0000aa"&gt;is&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt; &lt;span style="color: #0000aa"&gt;or&lt;/span&gt; cur.name != &lt;span style="color: #7f007f"&gt;&amp;#39;BINOP&amp;#39;&lt;/span&gt;
                        &lt;span style="color: #0000aa"&gt;or&lt;/span&gt; OPINFO_MAP[cur.value].prec &amp;lt; min_prec):
            &lt;span style="color: #00007f; font-weight: bold"&gt;break&lt;/span&gt;

        &lt;span style="color: #007f00"&gt;# Inside this loop the current token is a binary operator&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;assert&lt;/span&gt; cur.name == &lt;span style="color: #7f007f"&gt;&amp;#39;BINOP&amp;#39;&lt;/span&gt;

        &lt;span style="color: #007f00"&gt;# Get the operator&amp;#39;s precedence and associativity, and compute a&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;# minimal precedence for the recursive call&lt;/span&gt;
        op = cur.value
        prec, assoc = OPINFO_MAP[op]
        next_min_prec = prec + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; assoc == &lt;span style="color: #7f007f"&gt;&amp;#39;LEFT&amp;#39;&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; prec

        &lt;span style="color: #007f00"&gt;# Consume the current token and prepare the next one for the&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;# recursive call&lt;/span&gt;
        tokenizer.get_next_token()
        atom_rhs = compute_expr(tokenizer, next_min_prec)

        &lt;span style="color: #007f00"&gt;# Update lhs with the new value&lt;/span&gt;
        atom_lhs = compute_op(op, atom_lhs, atom_rhs)

    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; atom_lhs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only difference is that this code makes token handling more explicit. It basically follows the usual &amp;quot;recursive-descent protocol&amp;quot;. Each recursive call has the current token available in &lt;tt class="docutils literal"&gt;tokenizer.cur_tok&lt;/tt&gt;, and makes sure to consume all the tokens it has handled (by calling &lt;tt class="docutils literal"&gt;tokenizer.get_next_token()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;One additional small piece is missing. &lt;tt class="docutils literal"&gt;compute_op&lt;/tt&gt; simply performs the arithmetic computation for the supported binary operators:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;compute_op&lt;/span&gt;(op, lhs, rhs):
    lhs = &lt;span style="color: #00007f"&gt;int&lt;/span&gt;(lhs); rhs = &lt;span style="color: #00007f"&gt;int&lt;/span&gt;(rhs)
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; op == &lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;:   &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lhs + rhs
    &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; op == &lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;: &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lhs - rhs
    &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; op == &lt;span style="color: #7f007f"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;: &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lhs * rhs
    &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; op == &lt;span style="color: #7f007f"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;: &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lhs / rhs
    &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; op == &lt;span style="color: #7f007f"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;: &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lhs ** rhs
    &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
        parse_error(&lt;span style="color: #7f007f"&gt;&amp;#39;unknown operator &amp;quot;%s&amp;quot;&amp;#39;&lt;/span&gt; % op)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="in-the-real-world-clang"&gt;
&lt;h3&gt;In the real world - Clang&lt;/h3&gt;
&lt;p&gt;Precedence climbing is being used in real world tools. One example is &lt;a class="reference external" href="http://clang.llvm.org/"&gt;Clang&lt;/a&gt;, the C/C++/ObjC front-end. Clang's parser is hand-written recursive descent, and it uses precedence climbing for efficient parsing of expressions. If you're interested to see the code, it's &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Parser::ParseExpression&lt;/span&gt;&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;lib/Parse/ParseExpr.cpp&lt;/tt&gt; &lt;a class="footnote-reference" href="#id6" id="id3"&gt;[3]&lt;/a&gt;. This method plays the role of &lt;tt class="docutils literal"&gt;compute_expr&lt;/tt&gt;. The role of &lt;tt class="docutils literal"&gt;compute_atom&lt;/tt&gt; is played by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Parser::ParseCastExpression&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="other-resources"&gt;
&lt;h3&gt;Other resources&lt;/h3&gt;
&lt;p&gt;Here are some resources I found useful while writing this article:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The Wikipedia page for &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser"&gt;Operator-precedence parsing&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;a class="reference external" href="http://antlr.org/papers/Clarke-expr-parsing-1986.pdf"&gt;article by Keith Clarke&lt;/a&gt; (PDF), one of the early inventors of the technique.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm"&gt;This page&lt;/a&gt; by Theodore Norvell, about parsing expressions by recursive descent.&lt;/li&gt;
&lt;li&gt;The Clang source code (exact locations given in the previous section).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;i&gt;&lt;b&gt;Update (2016-11-02):&lt;/b&gt; Andy Chu &lt;a href="http://www.oilshell.org/blog/2016/11/01.html"&gt;notes&lt;/a&gt;
that precedence climbing and &lt;a href="https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing"&gt;TDOP&lt;/a&gt;
are pretty much the same algorithm, formulated a bit differently. I tend to agree,
and also note that &lt;a href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator"&gt;Shunting Yard&lt;/a&gt;
is again the same algorithm, except that the explicit recursion is replaced by
a stack.&lt;/i&gt;
&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There are a couple of simplifications made here on purpose. First, I assume only numeric expressions. Identifiers that represent variables can also be viewed as atoms. Second, I ignore unary operators. These are quite easy to incorporate into the algorithm by also treating them as atoms. I leave them out for succinctness.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In this article I present a parser that computes the result of a numeric expression on-the-fly. Modifying it for accumulating the result into some kind of a parse tree is trivial.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Clang's source code is constantly in flow. This information is correct at least for the date the article was written.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="Recursive descent parsing"></category></entry><entry><title>How Clang handles the type / variable name ambiguity of C/C++</title><link href="https://eli.thegreenplace.net/2012/07/05/how-clang-handles-the-type-variable-name-ambiguity-of-cc" rel="alternate"></link><published>2012-07-05T19:35:22-07:00</published><updated>2023-02-04T15:35:51-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-07-05:/2012/07/05/how-clang-handles-the-type-variable-name-ambiguity-of-cc</id><summary type="html">
        &lt;p&gt;My previous articles on the context sensitivity and ambiguity of the C/C++ grammar (&lt;a class="reference external" href="https://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/"&gt;one&lt;/a&gt;, &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;two&lt;/a&gt;, &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/06/28/the-type-variable-name-ambiguity-in-c/"&gt;three&lt;/a&gt;) can probably make me sound pessimistic about the prospect of correctly parsing C/C++, which couldn't be farther from the truth. My gripe is not with the grammar itself (although I admit it's â€¦&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;My previous articles on the context sensitivity and ambiguity of the C/C++ grammar (&lt;a class="reference external" href="https://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/"&gt;one&lt;/a&gt;, &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;two&lt;/a&gt;, &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/06/28/the-type-variable-name-ambiguity-in-c/"&gt;three&lt;/a&gt;) can probably make me sound pessimistic about the prospect of correctly parsing C/C++, which couldn't be farther from the truth. My gripe is not with the grammar itself (although I admit it's needlessly complex), it's with the inability of Yacc-generated LALR(1) parsers to parse it without considerable hacks. As I've mentioned numerous times before, industrial-strength compilers for C/C++ exist after all, so they do manage to somehow parse these languages.&lt;/p&gt;
&lt;p&gt;One of the newest, and in my eyes the most exciting of C/C++ compilers is &lt;a class="reference external" href="http://clang.llvm.org/"&gt;Clang&lt;/a&gt;. Originally developed by Apple as a front-end to LLVM, it's been a vibrant open-source project for the past couple of years with participation from many companies and individuals (although Apple remains the main driving force in the community). Clang, similarly to LLVM, features a modular library-based design and a very clean C++ code-base. Clang's parser is hand-written, based on a standard recursive-descent parsing algorithm.&lt;/p&gt;
&lt;p&gt;In this post I want to explain how Clang manages to overcome the ambiguities I mentioned in the previous articles.&lt;/p&gt;
&lt;div class="section" id="no-lexer-hack"&gt;
&lt;h3&gt;No lexer hack&lt;/h3&gt;
&lt;p&gt;There is no &amp;quot;lexer hack&amp;quot; in Clang. Information flows in a single direction - from the lexer to the parser, not back. How is this managed?&lt;/p&gt;
&lt;p&gt;The thing is that the Clang lexer doesn't distinguish between user-defined types and other identifiers. All are marked with the &lt;tt class="docutils literal"&gt;identifier&lt;/tt&gt; token.&lt;/p&gt;
&lt;p&gt;For this code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; mytype;
mytype bb;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Clang parser encounters the following tokens (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-dump-tokens&lt;/span&gt;&lt;/tt&gt;):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;typedef &amp;#39;typedef&amp;#39;   [StartOfLine]   Loc=&amp;lt;z.c:1:1&amp;gt;
int &amp;#39;int&amp;#39;           [LeadingSpace]  Loc=&amp;lt;z.c:1:9&amp;gt;
identifier &amp;#39;mytype&amp;#39; [LeadingSpace]  Loc=&amp;lt;z.c:1:13&amp;gt;
semi &amp;#39;;&amp;#39;                            Loc=&amp;lt;z.c:1:19&amp;gt;
identifier &amp;#39;mytype&amp;#39; [StartOfLine]   Loc=&amp;lt;z.c:2:1&amp;gt;
identifier &amp;#39;bb&amp;#39;     [LeadingSpace]  Loc=&amp;lt;z.c:2:8&amp;gt;
semi &amp;#39;;&amp;#39;                            Loc=&amp;lt;z.c:2:10&amp;gt;
eof &amp;#39;&amp;#39;                              Loc=&amp;lt;z.c:4:1&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how &lt;tt class="docutils literal"&gt;mytype&lt;/tt&gt; is always reported as an identifier, both before and after Clang figures out it's actually a user-defined type.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="figuring-out-what-s-a-type"&gt;
&lt;h3&gt;Figuring out what's a type&lt;/h3&gt;
&lt;p&gt;So if the Clang lexer always reports &lt;tt class="docutils literal"&gt;mytype&lt;/tt&gt; as an identifier, how does the parser figure out when it is actually a type? By keeping a symbol table.&lt;/p&gt;
&lt;p&gt;Well, actually it's not the parser that keeps the symbol table, it's &lt;tt class="docutils literal"&gt;Sema&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;Sema&lt;/tt&gt; is the Clang module responsible for semantic analysis and AST construction. It gets invoked from the parser through a generic &amp;quot;actions&amp;quot; interface, which in theory could serve a different client. Although conceptually the parser and &lt;tt class="docutils literal"&gt;Sema&lt;/tt&gt; are coupled, the actions interface provides a clean separation in the code. The parser is responsible for driving the parsing process, and &lt;tt class="docutils literal"&gt;Sema&lt;/tt&gt; is responsible for handling semantic information. In this particular case, the symbol table &lt;em&gt;is&lt;/em&gt; semantic information, so it's handled by &lt;tt class="docutils literal"&gt;Sema&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;To follow this process through, we'll start in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Parser::ParseDeclarationSpecifiers&lt;/span&gt;&lt;/tt&gt; &lt;a class="footnote-reference" href="#id5" id="id1"&gt;[1]&lt;/a&gt;. In the C/C++ grammar, type names are part of the &amp;quot;specifiers&amp;quot; in a declaration (that also include things like &lt;tt class="docutils literal"&gt;extern&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;inline&lt;/tt&gt;), and following the &amp;quot;recursive-descent protocol&amp;quot;, Clang will usually feature a parsing method per grammar rule. When this method encounters an identifier (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tok::identifier&lt;/span&gt;&lt;/tt&gt;), it asks &lt;tt class="docutils literal"&gt;Sema&lt;/tt&gt; whether it's actually a type by calling &lt;tt class="docutils literal"&gt;Actions.getTypeName&lt;/tt&gt; &lt;a class="footnote-reference" href="#id6" id="id2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Sema::getTypeName&lt;/span&gt;&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Sema::LookupName&lt;/span&gt;&lt;/tt&gt; to do the actual name lookup. For C, name lookup rules are relatively simple - you just climb the lexical scope stack the code belongs to, trying to find a scope that defines the name as a type. I've &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;mentioned before&lt;/a&gt; that all names in C (including type names) obey lexical scoping rules. With this mechanism, Clang implements the required nested symbol table. Note that this symbol table is queried by Clang in places where a type is actually expected and allowed, not only in declarations. For example, it's also done to disambiguate function calls from casts in some cases.&lt;/p&gt;
&lt;p&gt;How does a type actually get into this table, though?&lt;/p&gt;
&lt;p&gt;When the parser is done parsing a &lt;tt class="docutils literal"&gt;typedef&lt;/tt&gt; (and any declarator, for that matter), it calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Sema::ActOnDeclarator&lt;/span&gt;&lt;/tt&gt;. When the latter notices a new &lt;tt class="docutils literal"&gt;typedef&lt;/tt&gt; and makes sure everything about it is kosher (e.g. it does not re-define a name in the same scope), it adds the new name to the symbol table at the current scope.&lt;/p&gt;
&lt;p&gt;In Clang's code this whole process looks very clean and intuitive, but in a generated LALR(1) parser it would be utterly impossible, because leaving out the special token for type names and merging it with &lt;tt class="docutils literal"&gt;identifier&lt;/tt&gt; would create a tons of unresolvable reduce-reduce conflicts in the grammar. This is why Yacc-based parsers require a lexer hack to handle this issue.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="class-wide-declarations-in-c"&gt;
&lt;h3&gt;Class-wide declarations in C++&lt;/h3&gt;
&lt;p&gt;In the &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/06/28/the-type-variable-name-ambiguity-in-c/"&gt;previous post&lt;/a&gt; I mentioned how C++ makes this type lookup problem much more difficult by forcing declarations inside a class to be visible throughout the class, even in code that appears before them. Here's a short reminder:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; aa(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; arg) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; arg;
}

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;C&lt;/span&gt; {
    &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; foo(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; bb) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; (aa)(bb);
    }

    &lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; aa;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this code, even though the &lt;tt class="docutils literal"&gt;typedef&lt;/tt&gt; appears after &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;, the parser must figure out that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(aa)(bb)&lt;/span&gt;&lt;/tt&gt; is a cast of &lt;tt class="docutils literal"&gt;bb&lt;/tt&gt; to type &lt;tt class="docutils literal"&gt;aa&lt;/tt&gt;, and not the function call &lt;tt class="docutils literal"&gt;aa(bb)&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;We've seen how Clang can manage to figure out that &lt;tt class="docutils literal"&gt;aa&lt;/tt&gt; is a type. However, when it parses &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; it hasn't even &lt;em&gt;seen&lt;/em&gt; the &lt;tt class="docutils literal"&gt;typedef&lt;/tt&gt; yet, so how does that work?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="delayed-parsing-of-inline-method-bodies"&gt;
&lt;h3&gt;Delayed parsing of inline method bodies&lt;/h3&gt;
&lt;p&gt;To solve the problem described above, Clang employs a clever technique. When parsing an inline member function declaration/definition, it does full parsing and semantic analysis of the &lt;em&gt;declaration&lt;/em&gt;, leaving the &lt;em&gt;definition&lt;/em&gt; for later.&lt;/p&gt;
&lt;p&gt;Specifically, the body of an inline method definition is &lt;em&gt;lexed&lt;/em&gt; and the tokens are kept in a special buffer for later (this is done by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Parser::ParseCXXInlineMethodDef&lt;/span&gt;&lt;/tt&gt;). Once the parser has finished parsing the class, it calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Parser::ParseLexedMethodDefs&lt;/span&gt;&lt;/tt&gt; that does the actual parsing and semantic analysis of the saved method bodies. At this point, all the types declared inside the class are available, so the parser can correctly disambiguate wherever required.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="annotation-tokens"&gt;
&lt;h3&gt;Annotation tokens&lt;/h3&gt;
&lt;p&gt;Although the above is enough to understand how Clang approaches the problem, I want to mention another trick it uses to make parsing more efficient in some cases.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Sema::getTypeName&lt;/span&gt;&lt;/tt&gt; method mentioned earlier can be costly. It performs a lookup in a set of nested scopes, which may be expensive if the scopes are deeply nested and a name is &lt;em&gt;not&lt;/em&gt; actually a type (which is probably most often the case). It's alright (and inevitable!) to do this lookup once, but Clang would like to avoid repeating it for the same token when it &lt;em&gt;backtracks&lt;/em&gt; trying to parse a statement in a different way.&lt;/p&gt;
&lt;p&gt;A word on what &amp;quot;backtracks&amp;quot; means in this context. &lt;a class="reference external" href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/"&gt;Recursive descent parsers&lt;/a&gt; are naturally (by their very structure) backtracking. That is, they may try a number of different ways to parse a single grammatical production (be that a statement, an expression, a declaration, or whatever), before finding an approach that succeeds. In this process, the same token may need to be queried more than once.&lt;/p&gt;
&lt;p&gt;To avoid this, Clang has special &amp;quot;annotation tokens&amp;quot; it inserts into the token stream. The mechanism is used for other things as well, but in our case we're interested in the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tok::annot_typename&lt;/span&gt;&lt;/tt&gt; token. What happens is that the first time the parser encounters a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tok::identifier&lt;/span&gt;&lt;/tt&gt; and figures out it's a type, this token gets replaced by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tok::annot_typename&lt;/span&gt;&lt;/tt&gt;. The next time the parser encounters this token, it won't have to lookup whether it's a type once again, because it's no longer a generic &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tok::identifier&lt;/span&gt;&lt;/tt&gt; &lt;a class="footnote-reference" href="#id7" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="disclaimer-and-conclusion"&gt;
&lt;h3&gt;Disclaimer and conclusion&lt;/h3&gt;
&lt;p&gt;It's important to keep in mind that the cases examined in this post do not represent the full complexity of the C++ grammar. In C++, constructs like qualified names (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;foo::bar::baz&lt;/span&gt;&lt;/tt&gt;) and templates complicate matters considerably. However, I just wanted to focus on the cases I specifically discussed in previous posts, explaining how Clang addresses them.&lt;/p&gt;
&lt;p&gt;To conclude, we've seen how Clang's recursive descent parser manages some of the ambiguities of the C/C++ grammar. For a task that complex, it's inevitable for the code to become non-trivial &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[4]&lt;/a&gt;. That said, Clang has actually managed to keep its code-base relatively clean and logically structured, while at the same time sticking to its aggressive performance goals. Someone with a general understanding of how front-ends work shouldn't require more than a few hours of immersion in the Clang code-base to be able to answer questions about &amp;quot;how does it do &lt;em&gt;that&lt;/em&gt;&amp;quot;.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;As a rule, all &lt;tt class="docutils literal"&gt;Parser&lt;/tt&gt; code lives in &lt;tt class="docutils literal"&gt;lib/Parse&lt;/tt&gt; in the Clang source tree. &lt;tt class="docutils literal"&gt;Sema&lt;/tt&gt; code lives in &lt;tt class="docutils literal"&gt;lib/Sema&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Here and later I'll skip a lot of details and variations, focusing only on the path I want to use in the example.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;It's very important to note that only &lt;em&gt;this instance&lt;/em&gt; of the token in the token stream is replaced. The next instance may have already become a type (or we may have even changed the scope), so it wouldn't be semantically correct to reason about it.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;That Clang parses Objective-C and various extensions like CUDA or OpenCL in the same code-base doesn't help in this respect.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="C &amp; C++"></category><category term="Compilation"></category><category term="LLVM &amp; Clang"></category><category term="Recursive descent parsing"></category></entry><entry><title>Top-Down operator precedence (Pratt) parsing</title><link href="https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing" rel="alternate"></link><published>2010-01-02T17:08:12-08:00</published><updated>2024-04-01T12:46:43-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2010-01-02:/2010/01/02/top-down-operator-precedence-parsing</id><summary type="html">
        &lt;div class="section" id="introduction"&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Recursive-descent parsers have always interested me, and in the past year and a half I wrote a few articles on the topic. Here they are in chronological order:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/"&gt;Recursive descent, LL and predictive parsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/"&gt;Some problems of recursive descent parsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/"&gt;A recursive descent parser with an infix expression evaluator â€¦&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</summary><content type="html">
        &lt;div class="section" id="introduction"&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Recursive-descent parsers have always interested me, and in the past year and a half I wrote a few articles on the topic. Here they are in chronological order:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/"&gt;Recursive descent, LL and predictive parsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/"&gt;Some problems of recursive descent parsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/"&gt;A recursive descent parser with an infix expression evaluator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The third article describes a method that combines RD parsing with a different algorithm for parsing expressions to achieve better results. This method is actually used in the real-world, for example in GCC and Parrot (&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser"&gt;source&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;An alternative parsing algorithm was discovered by &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Vaughan_Pratt"&gt;Vaughan Pratt&lt;/a&gt; in 1973. Called &lt;em&gt;Top Down Operator Precedence&lt;/em&gt;, it shares some features with the modified RD parser, but promises to simplify the code, as well as provide better performance. Recently it was popularized again by Douglas Crockford in &lt;a class="reference external" href="http://javascript.crockford.com/tdop/tdop.html"&gt;his article&lt;/a&gt;, and employed by him in &lt;a class="reference external" href="http://www.jslint.com/"&gt;JSLint&lt;/a&gt; to parse Javascript.&lt;/p&gt;
&lt;p&gt;I encountered Crockford's article in the &lt;a class="reference external" href="https://eli.thegreenplace.net/2007/09/28/book-review-beautiful-code-edited-by-andy-oram-greg-wilson/"&gt;Beautiful Code&lt;/a&gt; book, but found it hard to understand. I could follow the code, but had a hard time grasping &lt;em&gt;why&lt;/em&gt; the thing works. Recently I became interested in the topic again, tried to read the article once more, and again was stumped. Finally, by reading Pratt's original paper and Fredrik Lundh's excellent &lt;a class="reference external" href="http://effbot.org/zone/simple-top-down-parsing.htm"&gt;Python-based piece&lt;/a&gt; &lt;a class="footnote-reference" href="#id7" id="id1"&gt;[1]&lt;/a&gt;, I understood the algorithm.&lt;/p&gt;
&lt;p&gt;So this article is my usual attempt to explain the topic to myself, making sure that when I forget how it works in a couple of months, I will have a simple way of remembering.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-fundamentals"&gt;
&lt;h3&gt;The fundamentals&lt;/h3&gt;
&lt;p&gt;Top down operator precedence parsing (TDOP from now on) is based on a few fundamental principles:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A &amp;quot;binding power&amp;quot; mechanism to handle precedence levels&lt;/li&gt;
&lt;li&gt;A means of implementing different functionality of tokens depending on their position relative to their neighbors - prefix or infix.&lt;/li&gt;
&lt;li&gt;As opposed to classic RD, where semantic actions are associated with grammar rules (BNF), TDOP associates them with tokens.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="binding-power"&gt;
&lt;h4&gt;Binding power&lt;/h4&gt;
&lt;p&gt;Operator precedence and associativity is a fundamental topic to be handled by parsing techniques. TDOP handles this issue by assigning a &amp;quot;binding power&amp;quot; to each token it parses.&lt;/p&gt;
&lt;p&gt;Consider a substring AEB where A takes a right argument, B a left, and E is an expression. Does E associate with A or with B? We define a numeric &lt;strong&gt;binding power&lt;/strong&gt; for each operator. &lt;strong&gt;The operator with the higher binding power &amp;quot;wins&amp;quot; - gets E associated with it&lt;/strong&gt;. Let's examine the expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;1 + 2 * 4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here it is once again with A, E, B identified:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;1 + 2 * 4
  ^ ^ ^
  A E B
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we want to express the convention of multiplication having a higher precedence than addition, let's define the binding power (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;bp&lt;/span&gt;&lt;/tt&gt;) of * to be 20 and that of + to be 10 (the numbers are arbitrary, what's important is that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;bp(*)&lt;/span&gt; &lt;span class="pre"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;bp(+)&lt;/span&gt;&lt;/tt&gt;). Thus, by the definition we've made above, the 2 will be associated with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;*&lt;/span&gt;&lt;/tt&gt;, since its binding power is higher than that of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="prefix-and-infix-operators"&gt;
&lt;h4&gt;Prefix and infix operators&lt;/h4&gt;
&lt;p&gt;To parse the traditional &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Infix_notation"&gt;infix-notation&lt;/a&gt; expression languages &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[2]&lt;/a&gt;, we have to differentiate between the prefix form and infix form of tokens. The best example is the minus operator (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&lt;/span&gt;&lt;/tt&gt;). In its infix form it is subtraction:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;a = b - c  &lt;span style="color: #007f00"&gt;# a is b minus c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In its prefix form, it is negation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;a = -b   &lt;span style="color: #007f00"&gt;# b has a&amp;#39;s magnitude but an opposite sign&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To accommodate this difference, TDOP allows for different treatment of tokens in prefix and infix contexts. In TDOP terminology the handler of a token as prefix is called &lt;strong&gt;nud&lt;/strong&gt; (for &amp;quot;null denotation&amp;quot;) and the handler of a token as infix is called &lt;strong&gt;led&lt;/strong&gt; (for &amp;quot;left denotation&amp;quot;).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-tdop-algorithm"&gt;
&lt;h3&gt;The TDOP algorithm&lt;/h3&gt;
&lt;p&gt;Here's a basic TDOP parser:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;expression&lt;/span&gt;(rbp=&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; token
    t = token
    token = next()
    left = t.nud()
    &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; rbp &amp;lt; token.lbp:
        t = token
        token = next()
        left = t.led(left)

    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;literal_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, value):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.value = &lt;span style="color: #00007f"&gt;int&lt;/span&gt;(value)
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;nud&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.value

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_add_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        right = expression(&lt;span style="color: #007f7f"&gt;10&lt;/span&gt;)
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left + right

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_mul_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left * expression(&lt;span style="color: #007f7f"&gt;20&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;end_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We only have to augment it with some support code consisting of a simple tokenizer &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[3]&lt;/a&gt; and the parser driver:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;re&lt;/span&gt;
token_pat = re.compile(&lt;span style="color: #7f007f"&gt;&amp;quot;\s*(?:(\d+)|(.))&amp;quot;&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;tokenize&lt;/span&gt;(program):
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; number, operator &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; token_pat.findall(program):
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; number:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; literal_token(number)
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_add_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_mul_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;raise&lt;/span&gt; SyntaxError(&lt;span style="color: #7f007f"&gt;&amp;#39;unknown operator: %s&amp;#39;&lt;/span&gt;, operator)
    &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; end_token()

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;parse&lt;/span&gt;(program):
    &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; token, next
    next = tokenize(program).next
    token = next()
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; expression()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we have a complete parser and evaluator for arithmetic expressions involving addition and multiplication.&lt;/p&gt;
&lt;p&gt;Now let's figure out how it actually works. Note that the token classes have several attributes (not all classes have all kinds of attributes):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lbp&lt;/span&gt;&lt;/tt&gt; - the left binding power of the operator. For an infix operator, it tells us how strongly the operator binds to the argument at its left.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nud&lt;/span&gt;&lt;/tt&gt; - this is the prefix handler we talked about. In this simple parser it exists only for the literals (the numbers)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;led&lt;/span&gt;&lt;/tt&gt; - the infix handler.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The key to enlightenment here is to notice how the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; function works, and how the operator handlers call it, passing in a binding power.&lt;/p&gt;
&lt;p&gt;When &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; is called, it is provided the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rbp&lt;/span&gt;&lt;/tt&gt;  - right binding power of the operator that called it. It consumes tokens until it meets a token whose left binding power is equal or lower than &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rbp&lt;/span&gt;&lt;/tt&gt;. Specifically, it means that it collects all tokens that bind together before returning to the operator that called it.&lt;/p&gt;
&lt;p&gt;Handlers of operators call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; to process their arguments, providing it with their binding power to make sure it gets just the right tokens from the input.&lt;/p&gt;
&lt;p&gt;Let's see, for example, how this parser handles the expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;3 + 1 * 2 * 4 + 5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's the call trace of the parser's functions when parsing this expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;&amp;lt;expression with rbp 0&amp;gt;&amp;gt;
    &amp;lt;&amp;lt;literal nud = 3&amp;gt;&amp;gt;
    &amp;lt;&amp;lt;led of &amp;quot;+&amp;quot;&amp;gt;&amp;gt;
    &amp;lt;&amp;lt;expression with rbp 10&amp;gt;&amp;gt;
       &amp;lt;&amp;lt;literal nud = 1&amp;gt;&amp;gt;
       &amp;lt;&amp;lt;led of &amp;quot;*&amp;quot;&amp;gt;&amp;gt;
       &amp;lt;&amp;lt;expression with rbp 20&amp;gt;&amp;gt;
          &amp;lt;&amp;lt;literal nud = 2&amp;gt;&amp;gt;
       &amp;lt;&amp;lt;led of &amp;quot;*&amp;quot;&amp;gt;&amp;gt;
       &amp;lt;&amp;lt;expression with rbp 20&amp;gt;&amp;gt;
          &amp;lt;&amp;lt;literal nud = 4&amp;gt;&amp;gt;
    &amp;lt;&amp;lt;led of &amp;quot;+&amp;quot;&amp;gt;&amp;gt;
    &amp;lt;&amp;lt;expression with rbp 10&amp;gt;&amp;gt;
       &amp;lt;&amp;lt;literal nud = 5&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The following diagram shows the calls made to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; on various recursion levels:&lt;/p&gt;
&lt;img src="https://eli.thegreenplace.net/images/2010/01/tdop_expr1.png" /&gt;
&lt;p&gt;The arrows show the tokens on which each execution of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; works, and the number above them is the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rbp&lt;/span&gt;&lt;/tt&gt; given to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; for this call.&lt;/p&gt;
&lt;p&gt;Apart from the initial call (with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rbp=0&lt;/span&gt;&lt;/tt&gt;) which spans the whole input, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; is called after each operator (by its &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;led&lt;/span&gt;&lt;/tt&gt; handler) to collect the right-side argument. As the diagram clearly shows, the binding power mechanism makes sure &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; doesn't go &amp;quot;too far&amp;quot; - only as far as the precedence of the invoking operator allows. The best place to see it is the long arrow after the first &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+&lt;/span&gt;&lt;/tt&gt;, that collects all the multiplication terms (they must be grouped together due to the higher precedence of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;*&lt;/span&gt;&lt;/tt&gt;) and returns before the second &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+&lt;/span&gt;&lt;/tt&gt; is encountered (when the precedence ceases being higher than its &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rbp&lt;/span&gt;&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;Another way to look at it: at any point in the execution of the parser, there's an instance of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; for each precedence level that is active at that moment. This instance awaits the results of the higher-precedence instance and keeps going, until it has to stop itself and return its result to its caller.&lt;/p&gt;
&lt;p&gt;If you understand this example, you understand TDOP parsing. All the rest is really just more of the same.&lt;/p&gt;
&lt;div class="section" id="enhancing-the-parser"&gt;
&lt;h4&gt;Enhancing the parser&lt;/h4&gt;
&lt;p&gt;The parser presented so far is very rudimentary, so let's enhance it to be more realistic. First of all, what about unary operators?&lt;/p&gt;
&lt;p&gt;As I've mentioned in the section on prefix and infix operators, TDOP makes an explicit distinction between the two, encoding it in the difference between the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nud&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;led&lt;/span&gt;&lt;/tt&gt; methods. Adding the subtraction operator handler &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[4]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_sub_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;nud&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; -expression(&lt;span style="color: #007f7f"&gt;100&lt;/span&gt;)
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left - expression(&lt;span style="color: #007f7f"&gt;10&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nud&lt;/span&gt;&lt;/tt&gt; handles the unary (prefix) form of minus. It has no &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;left&lt;/span&gt;&lt;/tt&gt; argument (since it's prefix), and it negates its right argument. The binding power passed into &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; is high, since unary minus has a high precedence (higher than multiplication). &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;led&lt;/span&gt;&lt;/tt&gt; handles the infix case similarly to the handlers of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;*&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Now we can handle expressions like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;3 - 2 + 4 * -5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And get a correct result (-19).&lt;/p&gt;
&lt;p&gt;How about right-associative operators? Let's implement exponentiation (using the caret sign &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;^&lt;/span&gt;&lt;/tt&gt;). To make the operation right-associative, we want the parser to treat subsequent exponentiation operators as sub-expressions of the first one. We can do that by calling &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; in the handler of exponentiation with a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rbp&lt;/span&gt;&lt;/tt&gt; lower than the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lbp&lt;/span&gt;&lt;/tt&gt; of exponentiation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_pow_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;30&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left ** expression(&lt;span style="color: #007f7f"&gt;30&lt;/span&gt; - &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; gets to the next &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;^&lt;/span&gt;&lt;/tt&gt; in its loop, it will find that still &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rbp&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;&lt;/span&gt; &lt;span class="pre"&gt;token.lbp&lt;/span&gt;&lt;/tt&gt; and won't return the result right away, but will collect the value of the sub-expression first.&lt;/p&gt;
&lt;p&gt;And how about grouping with parentheses? Since each token can execute actions in TDOP, this can be easily handled by adding actions to the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(&lt;/span&gt;&lt;/tt&gt; token.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_lparen_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;nud&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        expr = expression()
        match(operator_rparen_token)
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; expr

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_rparen_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;match&lt;/span&gt;&lt;/tt&gt; is the usual RD primitive:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;match&lt;/span&gt;(tok=&lt;span style="color: #00007f"&gt;None&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; token
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; tok &lt;span style="color: #0000aa"&gt;and&lt;/span&gt; tok != &lt;span style="color: #00007f"&gt;type&lt;/span&gt;(token):
        &lt;span style="color: #00007f; font-weight: bold"&gt;raise&lt;/span&gt; SyntaxError(&lt;span style="color: #7f007f"&gt;&amp;#39;Expected %s&amp;#39;&lt;/span&gt; % tok)
    token = next()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(&lt;/span&gt;&lt;/tt&gt; has &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lbp=0&lt;/span&gt;&lt;/tt&gt;, meaning that it doesn't bind to any token on its left. It is treated as a prefix, and its &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nud&lt;/span&gt;&lt;/tt&gt; collects an expression after the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(&lt;/span&gt;&lt;/tt&gt;, right until &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;)&lt;/span&gt;&lt;/tt&gt; is encountered (which stops the expression parser since it also has &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lbp=0&lt;/span&gt;&lt;/tt&gt;). Then it consumes the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;)&lt;/span&gt;&lt;/tt&gt; itself and returns the result of the expression &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[5]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's the code for the complete parser, handling addition, subtraction, multiplication, division, exponentiation and grouping by parentheses:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;re&lt;/span&gt;

token_pat = re.compile(&lt;span style="color: #7f007f"&gt;&amp;quot;\s*(?:(\d+)|(.))&amp;quot;&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;tokenize&lt;/span&gt;(program):
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; number, operator &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; token_pat.findall(program):
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; number:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; literal_token(number)
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_add_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_sub_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_mul_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_div_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;quot;^&amp;quot;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_pow_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_lparen_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; operator == &lt;span style="color: #7f007f"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; operator_rparen_token()
        &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;raise&lt;/span&gt; SyntaxError(&lt;span style="color: #7f007f"&gt;&amp;#39;unknown operator: %s&amp;#39;&lt;/span&gt;, operator)
    &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; end_token()


&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;match&lt;/span&gt;(tok=&lt;span style="color: #00007f"&gt;None&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; token
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; tok &lt;span style="color: #0000aa"&gt;and&lt;/span&gt; tok != &lt;span style="color: #00007f"&gt;type&lt;/span&gt;(token):
        &lt;span style="color: #00007f; font-weight: bold"&gt;raise&lt;/span&gt; SyntaxError(&lt;span style="color: #7f007f"&gt;&amp;#39;Expected %s&amp;#39;&lt;/span&gt; % tok)
    token = next()


&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;parse&lt;/span&gt;(program):
    &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; token, next
    next = tokenize(program).next
    token = next()
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; expression()


&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;expression&lt;/span&gt;(rbp=&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; token
    t = token
    token = next()
    left = t.nud()
    &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; rbp &amp;lt; token.lbp:
        t = token
        token = next()
        left = t.led(left)
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;literal_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, value):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.value = &lt;span style="color: #00007f"&gt;int&lt;/span&gt;(value)
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;nud&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.value

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_add_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;nud&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; expression(&lt;span style="color: #007f7f"&gt;100&lt;/span&gt;)
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        right = expression(&lt;span style="color: #007f7f"&gt;10&lt;/span&gt;)
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left + right

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_sub_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;nud&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; -expression(&lt;span style="color: #007f7f"&gt;100&lt;/span&gt;)
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left - expression(&lt;span style="color: #007f7f"&gt;10&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_mul_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left * expression(&lt;span style="color: #007f7f"&gt;20&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_div_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left / expression(&lt;span style="color: #007f7f"&gt;20&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_pow_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;30&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;led&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, left):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; left ** expression(&lt;span style="color: #007f7f"&gt;30&lt;/span&gt; - &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_lparen_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;nud&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        expr = expression()
        match(operator_rparen_token)
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; expr

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;operator_rparen_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;end_token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    lbp = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sample usage:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; parse(&lt;span style="color: #7f007f"&gt;&amp;#39;3 * (2 + -4) ^ 4&amp;#39;&lt;/span&gt;)
&lt;span style="color: #007f7f"&gt;48&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="closing-words"&gt;
&lt;h3&gt;Closing words&lt;/h3&gt;
&lt;p&gt;When people consider parsing methods to implement, the debate usually goes between hand-coded RD parsers, auto-generated &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(k)&lt;/span&gt;&lt;/tt&gt; parsers, or auto-generated &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LR&lt;/span&gt;&lt;/tt&gt; parsers. TDOP is another alternative &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[6]&lt;/a&gt;. It's an original and unusual parsing method that can handle complex grammars (not limited to expressions), relatively easy to code, and is quite fast.&lt;/p&gt;
&lt;p&gt;What makes TDOP fast is that it doesn't need deep recursive descents to parse expressions - only a couple of calls per token are required, no matter how the grammar looks. If you trace the token actions in the example parser I presented in this article, you'll notice that on average, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expression&lt;/span&gt;&lt;/tt&gt; and one &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nud&lt;/span&gt;&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;led&lt;/span&gt;&lt;/tt&gt; method are called per token, and that's about it. Fredrik Lundh compares the performance of TDOP with several other methods in his article, and gets very favorable results.&lt;/p&gt;
&lt;div align="center" class="align-center"&gt;&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Which is also the source for most of the code in this article - so the copyright is Fredrik Lundh's&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Like C, Java, Python. An example of a language that doesn't have infix notation is Lisp, which has prefix notation for expressions.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This tokenizer just recognizes numbers and single-character operators.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that to allow our parser actually recognize &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&lt;/span&gt;&lt;/tt&gt;, an appropriate dispatcher should be added to the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tokenize&lt;/span&gt;&lt;/tt&gt; function - this is left as an exercise to the reader.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Quiz: is it useful having a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;led&lt;/span&gt;&lt;/tt&gt; handler for a left paren as well? Hint: how would you implement function calls?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;By the way, I have no idea where to categorize it on the LL/LR scale? Any ideas?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="Recursive descent parsing"></category></entry><entry><title>A recursive descent parser with an infix expression evaluator</title><link href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator" rel="alternate"></link><published>2009-03-20T18:01:09-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2009-03-20:/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator</id><summary type="html">
        &lt;p&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/"&gt;Last week&lt;/a&gt; I wrote about some of the inherent problems of recursive-descent parsers. An elegant solution to the operator associativity problem was shown, but another problem remained - and that is of the unwieldy handling of expressions, mainly performance-wise.&lt;/p&gt;
&lt;p&gt;Here I want to present one alternative to the pure-RD approach, and â€¦&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/"&gt;Last week&lt;/a&gt; I wrote about some of the inherent problems of recursive-descent parsers. An elegant solution to the operator associativity problem was shown, but another problem remained - and that is of the unwieldy handling of expressions, mainly performance-wise.&lt;/p&gt;
&lt;p&gt;Here I want to present one alternative to the pure-RD approach, and that is intermixing RD with another parsing method.&lt;/p&gt;
&lt;div class="section" id="the-code"&gt;
&lt;h3&gt;The code&lt;/h3&gt;
&lt;p&gt;I'll begin by pointing to &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2009/py_rd_parser_example"&gt;the code for this article&lt;/a&gt;. It contains several Python files and a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;readme.txt&lt;/span&gt;&lt;/tt&gt; explaining what is what. Throughout the article I'll present short snippets from the code, but it's encouraged to run it on your own. The code is self-contained and only requires Python (version 2.5) to run.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="extending-the-grammar"&gt;
&lt;h3&gt;Extending the grammar&lt;/h3&gt;
&lt;p&gt;To illuminate some of the points I'm presenting better, I've greatly extended the EBNF grammar we'll be parsing. Here's the new grammar (taken from the top of the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rd_parser_ebnf.py&lt;/span&gt;&lt;/tt&gt; in the code .zip):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# EBNF:
#
# &amp;lt;stmt&amp;gt;        : &amp;lt;assign_stmt&amp;gt;
#               | &amp;lt;if_stmt&amp;gt;
#               | &amp;lt;cmp_expr&amp;gt;
#
# &amp;lt;assign_stmt&amp;gt; : set &amp;lt;id&amp;gt; = &amp;lt;cmp_expr&amp;gt;
#
## Note &amp;#39;else&amp;#39; binds to the innermost &amp;#39;if&amp;#39;, like in C
#
# &amp;lt;if_stmt&amp;gt;     : if &amp;lt;cmp_expr&amp;gt; then &amp;lt;stmt&amp;gt; [else &amp;lt;stmt&amp;gt;]
#
# &amp;lt;cmp_expr&amp;gt;    : &amp;lt;bitor_expr&amp;gt; [== &amp;lt;bitor_expr&amp;gt;]
#               | &amp;lt;bitor_expr&amp;gt; [!= &amp;lt;bitor_expr&amp;gt;]
#               | &amp;lt;bitor_expr&amp;gt; [&amp;gt; &amp;lt;bitor_expr&amp;gt;]
#               | &amp;lt;bitor_expr&amp;gt; [&amp;lt; &amp;lt;bitor_expr&amp;gt;]
#               | &amp;lt;bitor_expr&amp;gt; [&amp;gt;= &amp;lt;bitor_expr&amp;gt;]
#               | &amp;lt;bitor_expr&amp;gt; [&amp;lt;= &amp;lt;bitor_expr&amp;gt;]
#
# &amp;lt;bitor_expr&amp;gt;  | &amp;lt;bitxor_expr&amp;gt; {| &amp;lt;bitxor_expr&amp;gt;}
#
# &amp;lt;bitxor_expr&amp;gt; | &amp;lt;bitand_expr&amp;gt; {^ &amp;lt;bitand_expr&amp;gt;}
#
# &amp;lt;bitand_expr&amp;gt; | &amp;lt;shift_expr&amp;gt; {&amp;amp; &amp;lt;shift_expr&amp;gt;}
#
# &amp;lt;shift_expr&amp;gt;  | &amp;lt;arith_expr&amp;gt; {&amp;lt;&amp;lt; &amp;lt;arith_expr&amp;gt;}
#               : &amp;lt;arith_expr&amp;gt; {&amp;gt;&amp;gt; &amp;lt;arith_expr&amp;gt;}
#
# &amp;lt;arith_expr&amp;gt;  : &amp;lt;term&amp;gt; {+ &amp;lt;term&amp;gt;}
#               | &amp;lt;term&amp;gt; {- &amp;lt;term&amp;gt;}
#
# &amp;lt;term&amp;gt;        : &amp;lt;power&amp;gt; {* &amp;lt;power&amp;gt;}
#               | &amp;lt;power&amp;gt; {/ &amp;lt;power&amp;gt;}
#
# &amp;lt;power&amp;gt;       : &amp;lt;power&amp;gt; ** &amp;lt;factor&amp;gt;
#               | &amp;lt;factor&amp;gt;
#
# &amp;lt;factor&amp;gt;      : &amp;lt;id&amp;gt;
#               | &amp;lt;number&amp;gt;
#               | - &amp;lt;factor&amp;gt;
#               | ( &amp;lt;cmp_expr&amp;gt; )
#
# &amp;lt;id&amp;gt;          : [a-zA-Z_]\w+
# &amp;lt;number&amp;gt;      : \d+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, this simple calculator is starting to approach a real programming language, as it supports a plethora of mathematical and logical expressions, as well as conditional statements (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;if&lt;/span&gt; &lt;span class="pre"&gt;...&lt;/span&gt; &lt;span class="pre"&gt;then&lt;/span&gt; &lt;span class="pre"&gt;...&lt;/span&gt; &lt;span class="pre"&gt;else&lt;/span&gt;&lt;/tt&gt;) and assignments. I've added a simplistic &amp;quot;prompt&amp;quot; so you can experiment with the calculator from the command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;D:\zzz\rd_parser_calc&amp;gt;rd_parser_ebnf.py -p
Welcome to the calculator. Press Ctrl+C to exit.
--&amp;gt; set x = 2 + 2 * 3
8
--&amp;gt; set y = (x - 1) * (x - 2)
42
--&amp;gt; if y &amp;gt; x then set y = x else set x = y
8
--&amp;gt; x
8
--&amp;gt; y
8
--&amp;gt; x ** ((y - 10) * -3)
262144
--&amp;gt; ... Thanks for using the calculator.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that since a separate expression &amp;quot;level&amp;quot; is required for each precedence, the resulting code is somewhat repetitive. I'll get back to this point later on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="evaluating-infix-expressions"&gt;
&lt;h3&gt;Evaluating infix expressions&lt;/h3&gt;
&lt;p&gt;An alternative method of evaluating expressions is required, then. Luckily, such a need arose early enough (in the 1950s and 60s, when first compilers and interpreters were constructed) and some luminaries examined this problem in detail. In particular, &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Edsger_Dijkstra"&gt;Edsger W. Dijkstra&lt;/a&gt; proposed an efficient and intuitive algorithm for converting from &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Infix_notation"&gt;infix notation&lt;/a&gt; to &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation"&gt;RPN&lt;/a&gt;, called the &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Shunting_yard_algorithm"&gt;Shunting Yard algorithm&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I will not describe the algorithm here, as it's been done several times already. If the Wikipedia article is not enough, &lt;a class="reference external" href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm"&gt;here's another good source&lt;/a&gt; (which I've actually used as the basis for my implementation).&lt;/p&gt;
&lt;p&gt;The algorithm employs two stacks to resolve the precedence dilemmas of infix notation. One stack is for storing operators of relatively low precedence that await results from computations with higher precedence. The other stack keeps the result accumulated so far. The result can either be a RPN expression, an AST or just the computed result (a number) of the computation.&lt;/p&gt;
&lt;p&gt;In my code, the file &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rd_parser_infix_exper.py&lt;/span&gt;&lt;/tt&gt; implements a hybrid parser, using Shunting Yard to evaluate expressions and a top-level RD parser for statements and combining everything together. It's instructive to examine the implementation and see how things fit together.&lt;/p&gt;
&lt;p&gt;The grammar this parser accepts is exactly the same as the pure RD EBNF parser presented eariler. The statements (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;assign_stmt&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;if_stmt&lt;/span&gt;&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;stmt&lt;/span&gt;&lt;/tt&gt;) are evaluated by traditional RD, but getting deeper into expressions is done with an &amp;quot;infix evaluator&amp;quot;, the gateway to which is the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_infix_eval&lt;/span&gt;&lt;/tt&gt; method &lt;a class="footnote-reference" href="#id4" id="id1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;_infix_eval&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
    &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Run the infix evaluator and return the result.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.op_stack = []
    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.res_stack = []

    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.op_stack.append(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;._sentinel)
    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._infix_eval_expr()
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.res_stack[-&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This method prepares the Shunting Yard stacks and begins evaluating the expression, terminating with returning its results.&lt;/p&gt;
&lt;p&gt;Note that the connection to the RD parser is seamless. When &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_infix_eval&lt;/span&gt;&lt;/tt&gt; is called, it assumes that the current token is the beginning of an expression (just like any RD rule), and consumes as much tokens as required to parse the full expression before returning the result.&lt;/p&gt;
&lt;p&gt;The rest of the implementation (the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_infix_eval_expr&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_infix_eval_atom&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_push_op&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_pop_op&lt;/span&gt;&lt;/tt&gt; methods) is pretty much a word by word translation of the algorithm described in &lt;a class="reference external" href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm"&gt;this article&lt;/a&gt; into Python.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="adding-expressions"&gt;
&lt;h3&gt;Adding expressions&lt;/h3&gt;
&lt;p&gt;Here's a big advantage of this hybrid parser: adding new expressions and/or changing precedence levels is much simpler and requires far less code. In the pure RD parser, the operators and their precedences are determined by the structure of recursive calls between methods. Adding a new operator requires a new method, as well as modifying some of the other methods &lt;a class="footnote-reference" href="#id5" id="id2"&gt;[2]&lt;/a&gt;. Changing the precedence of some operator is also troublesome and requires moving around lots of code.&lt;/p&gt;
&lt;p&gt;Not so in the infix expression parser. Once the Shunting Yard machinery is in place, all we have to do to add new operators or modify existing ones is update the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_ops&lt;/span&gt;&lt;/tt&gt; table:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;_ops = {
    &lt;span style="color: #7f007f"&gt;&amp;#39;u-&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;unary -&amp;#39;&lt;/span&gt;, operator.neg, &lt;span style="color: #007f7f"&gt;90&lt;/span&gt;, unary=&lt;span style="color: #00007f"&gt;True&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;**&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;**&amp;#39;&lt;/span&gt;, operator.pow, &lt;span style="color: #007f7f"&gt;70&lt;/span&gt;, right_assoc=&lt;span style="color: #00007f"&gt;True&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;, operator.mul, &lt;span style="color: #007f7f"&gt;50&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, operator.div, &lt;span style="color: #007f7f"&gt;50&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;, operator.add, &lt;span style="color: #007f7f"&gt;40&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, operator.sub, &lt;span style="color: #007f7f"&gt;40&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;&amp;lt;&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;&amp;lt;&amp;#39;&lt;/span&gt;, operator.lshift, &lt;span style="color: #007f7f"&gt;35&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, operator.rshift, &lt;span style="color: #007f7f"&gt;35&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;amp;&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;amp;&amp;#39;&lt;/span&gt;, operator.and_, &lt;span style="color: #007f7f"&gt;30&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;, operator.xor, &lt;span style="color: #007f7f"&gt;29&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;, operator.or_, &lt;span style="color: #007f7f"&gt;28&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;, operator.gt, &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;gt;=&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;gt;=&amp;#39;&lt;/span&gt;, operator.ge, &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;:    Op(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;, operator.lt, &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;=&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;=&amp;#39;&lt;/span&gt;, operator.le, &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;==&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;==&amp;#39;&lt;/span&gt;, operator.eq, &lt;span style="color: #007f7f"&gt;15&lt;/span&gt;),
    &lt;span style="color: #7f007f"&gt;&amp;#39;!=&amp;#39;&lt;/span&gt;:   Op(&lt;span style="color: #7f007f"&gt;&amp;#39;!=&amp;#39;&lt;/span&gt;, operator.ne, &lt;span style="color: #007f7f"&gt;15&lt;/span&gt;),
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I also find this table much more descriptive in the sense of understanding how the operators relate to one another than the parallel 9 methods required to implement them in the pure RD version (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rd_parser_ebnf.py&lt;/span&gt;&lt;/tt&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h3&gt;Performance&lt;/h3&gt;
&lt;p&gt;Now here is the funny thing. My initial motivation for examining the infix expression hybrid was the allegedly poor performance of the RD parser for parsing expressions (as described in the &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/"&gt;previous article&lt;/a&gt;). But the performance hasn't improved! In fact, the new hybrid parser is a bit slower than the pure RD parser!&lt;/p&gt;
&lt;p&gt;And the annoying thing is that it's entirely unclear to me how to optimize it, since profiling shows that the runtime divides rather evenly between the various methods of the algorithm. Yes, the pure RD parser requires the full precedence-chain of methods called for each single terminal, but the infix version has more method calls in total.&lt;/p&gt;
&lt;p&gt;If anything, this has been a lesson in optimization, as profiling initially showed that the vast majority of the time is spent in the lexer &lt;a class="footnote-reference" href="#id6" id="id3"&gt;[3]&lt;/a&gt;. So I've managed to optimize my lexer (by precompiling all its regexes into a single large one using alternation), which greatly reduced the runtime.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;This article has presented an alternative to the pure recursive-descent parser. The hybrid parser developed here combines RD with infix expression evaluation using the Shunting Yard algorithm.&lt;/p&gt;
&lt;p&gt;We've seen that the new code is more manageable for operator-rich grammars. If even more operators are to be added to the parser (such as the full set of operators supported by C), it's much simpler to implement into the parser, and the operator table is a single place summarizing the operators, their associativities and precedences, making the parser more readable.&lt;/p&gt;
&lt;p&gt;However, this has not made the parser any faster. The pure-RD implementation is lean enough to be efficient even when the grammar consists of many precedence levels. This is an important lesson in optimization - it's difficult to assess the relative runtimes of complex chunks of code in advance, without actually trying them out and profiling them.&lt;/p&gt;
&lt;div align="center" class="align-center"&gt;&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;It would be a swell idea to read the description of the algorithm and have an intuitive understanding of it from this point and on in the article.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Suppose we had no multiplication and division and had to add the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;term&lt;/span&gt;&lt;/tt&gt; rule. In addition to writing the code for the new rule, we must modify the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;arith_expr&lt;/span&gt;&lt;/tt&gt; rule to now call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;term&lt;/span&gt;&lt;/tt&gt; instead of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;power&lt;/span&gt;&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Which makes lots of sense, as it's well known that lexing/tokenization is usually the most time consuming stage of parsing. This is because the lexer has to examine every single character of the input, while the parser above it works on the level of whole tokens.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="Recursive descent parsing"></category></entry><entry><title>Some problems of recursive descent parsers</title><link href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers" rel="alternate"></link><published>2009-03-14T11:24:39-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2009-03-14:/2009/03/14/some-problems-of-recursive-descent-parsers</id><summary type="html">
        &lt;div class="section" id="reminder-recursive-descent-rd-parsers"&gt;
&lt;h3&gt;Reminder - recursive descent (RD) parsers&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/"&gt;Here's an article&lt;/a&gt; I wrote on the subject a few months ago. It provides a good introduction on how RD parsers are constructed and what grammars they can parse.&lt;/p&gt;
&lt;p&gt;Here I want to focus on a couple of problems with the RD parser developed in â€¦&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
        &lt;div class="section" id="reminder-recursive-descent-rd-parsers"&gt;
&lt;h3&gt;Reminder - recursive descent (RD) parsers&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/"&gt;Here's an article&lt;/a&gt; I wrote on the subject a few months ago. It provides a good introduction on how RD parsers are constructed and what grammars they can parse.&lt;/p&gt;
&lt;p&gt;Here I want to focus on a couple of problems with the RD parser developed in that article, and propose solutions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="problem-1-operator-associativity"&gt;
&lt;h3&gt;Problem #1: operator associativity&lt;/h3&gt;
&lt;p&gt;If you recall from the &lt;a class="reference external" href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/"&gt;previous article&lt;/a&gt;, the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; rule of the parser looks like this (BNF notation):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;expr&amp;gt;    : &amp;lt;term&amp;gt; + &amp;lt;expr&amp;gt;
          | &amp;lt;term&amp;gt; - &amp;lt;expr&amp;gt;
          | &amp;lt;term&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's built this way (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; on the right-hand side of the expression, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;term&lt;/span&gt;&lt;/tt&gt; on the left-hand side), to avoid &lt;em&gt;left-recursion&lt;/em&gt; in the grammar, which can crash a RD parser by sending it wheeling in an infinite loop.&lt;/p&gt;
&lt;p&gt;But as I hinted in the footnotes (and some readers caught on in the comments), this injects an associativity problem into the grammar. Let's see why.&lt;/p&gt;
&lt;p&gt;Wikipedia is much better than me at explaining what &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Operator_associativity"&gt;operator associativity&lt;/a&gt; is, so I'll assume you've read and understood it.&lt;/p&gt;
&lt;p&gt;In short, however, left associativity of the minus operator means that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;5&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;(5&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;1)&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt;&lt;/tt&gt; and not &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;5&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;(1&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;2)&lt;/span&gt;&lt;/tt&gt; (which returns a different result).&lt;/p&gt;
&lt;p&gt;But if you run &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;5&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt;&lt;/tt&gt; in the parser with the above BNF for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt;, you'll get 6 instead of 2. So what went wrong?&lt;/p&gt;
&lt;p&gt;The problem is in the grammar definition (BNF) itself. The way the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; rule is defined makes it inherently right-associative instead of left-associative. The hierarchy of the rules implicitly defines their associativity, because it defines what will be grouped together. To understand it better, perhaps the code implementing the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; rule will help:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;_expr&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
    lval = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._term()

    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token.type == &lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;:
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._match(&lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;)
        op = &lt;span style="color: #00007f; font-weight: bold"&gt;lambda&lt;/span&gt; a, b: a + b
    &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token.type == &lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;:
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._match(&lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)
        op = &lt;span style="color: #00007f; font-weight: bold"&gt;lambda&lt;/span&gt; a, b: a - b
    &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt; &lt;span style="color: #7f007f"&gt;&amp;#39;returning lval = %s&amp;#39;&lt;/span&gt; % lval
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lval

    rval = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._expr()
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt; &lt;span style="color: #7f007f"&gt;&amp;#39;lval = %s, rval = %s, res = %s&amp;#39;&lt;/span&gt; % (
        lval, rval, op(lval, rval))
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; op(lval, rval)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the first &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;term&lt;/span&gt;&lt;/tt&gt; is parsed, and then the rule recursively calls itself for the next one. So the expression is being built from right to left, and this causes its right-associativity.&lt;/p&gt;
&lt;p&gt;As you can see, I've added a couple of printouts to better show what's going on. When run on the expression &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;5&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt;&lt;/tt&gt;, this prints:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;returning lval = 2
lval = 1, rval = 2, res = -1
lval = 5, rval = -1, res = 6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We clearly see the problem here. The actual returns are done from right to left because of the recursion.&lt;/p&gt;
&lt;p&gt;Note that this grammar evaluates addition, multiplication, subtraction and division in a right-associative way. This causes problems for both subtraction and division, but not for addition and multiplication, because these operations compute the same whether right-to-left or left-to-right &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-solution-for-the-associativity-problem"&gt;
&lt;h3&gt;A solution for the associativity problem&lt;/h3&gt;
&lt;p&gt;I suppose the problem can be solved by rewriting the BNF rules in some sophisticated way that makes them both left-associative and not left-recursive &lt;a class="footnote-reference" href="#id4" id="id2"&gt;[2]&lt;/a&gt;, but I'll pick another way.&lt;/p&gt;
&lt;p&gt;BNF is somewhat limiting, since it doesn't really allow much options when defining rules. All the rules must have a very strict structure, and if you want to customize something you must resort to defining sub-rules and referencing them recursively.&lt;/p&gt;
&lt;p&gt;Enter &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Ebnf"&gt;EBNF&lt;/a&gt;. It was developed to fix some of the deficiencies of plain BNF. One of those is the addition of repetition of sub-rules. For instance, we can write the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; rule in EBNF as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;expr&amp;gt;    : &amp;lt;term&amp;gt; {+ &amp;lt;term&amp;gt;}
          | &amp;lt;term&amp;gt; {- &amp;lt;term&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the braces &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;{&lt;/span&gt; &lt;span class="pre"&gt;...&lt;/span&gt; &lt;span class="pre"&gt;}&lt;/span&gt;&lt;/tt&gt;. In EBNF, these mean &amp;quot;repeated 0 or more times&amp;quot;. This is still a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt; grammar, but now it's expressed a bit more comfortably. Such a representation is very suitable for coding, because the repetition can be expressed naturally with a loop.&lt;/p&gt;
&lt;p&gt;Here's a re-implementation of the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; rule using this idiom:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;_expr&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
    lval = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._term()

    &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; ( &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token.type == &lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt; &lt;span style="color: #0000aa"&gt;or&lt;/span&gt;
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token.type == &lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;):
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token.type == &lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;:
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._match(&lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;)
            lval += &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._term()
        &lt;span style="color: #00007f; font-weight: bold"&gt;elif&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token.type == &lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;:
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._match(&lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)
            lval -= &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._term()

    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lval
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;while&lt;/span&gt;&lt;/tt&gt; loop &amp;quot;eating up&amp;quot; all successive terms in the expression and accumulating the result in the expected left-to-right manner. Now the computation &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;5&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt;&lt;/tt&gt; will correctly produce &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;2&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-code"&gt;
&lt;h3&gt;The code&lt;/h3&gt;
&lt;p&gt;This is a good place to refer to the code. In &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2009/py_rd_parser_example"&gt;here&lt;/a&gt; you will find the source of both the old (BNF-based) parser and the new (EBNF-based) one, along with the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lexer&lt;/span&gt;&lt;/tt&gt; module that implements the tokenizer. Each of the parsers is self contained and can be used separately. Note that they were developed and tested with Python 2.5&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="right-associative-operators"&gt;
&lt;h3&gt;Right-associative operators&lt;/h3&gt;
&lt;p&gt;Some operators are inherently right-associative. Exponentiation, for example. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;2^3^2&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;2^(3^2)&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;512&lt;/span&gt;&lt;/tt&gt;, and not &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(2^3)^2&lt;/span&gt;&lt;/tt&gt; (which equals 64).&lt;/p&gt;
&lt;p&gt;We can leave these operators defined as before, using a recursive rule that naturally results in right-associativity. Here's the code of the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;power&lt;/span&gt;&lt;/tt&gt; rule that was added to the EBNF-based parser to support exponentiation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #007f00"&gt;# &amp;lt;power&amp;gt;   : &amp;lt;factor&amp;gt; ** &amp;lt;power&amp;gt;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#           | &amp;lt;factor&amp;gt;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;_power&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
    lval = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._factor()

    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.cur_token.type == &lt;span style="color: #7f007f"&gt;&amp;#39;**&amp;#39;&lt;/span&gt;:
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._match(&lt;span style="color: #7f007f"&gt;&amp;#39;**&amp;#39;&lt;/span&gt;)
        lval **= &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._power()

    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; lval
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="intermission"&gt;
&lt;h3&gt;Intermission&lt;/h3&gt;
&lt;p&gt;We now have a correct recursive descent parser that uses EBNF-based rules to parse expressions with the desired associativity for each operator. This parser can be readily employed to parse simple languages - it is production-use ready. The next &amp;quot;problem&amp;quot; I present only has to do with the parser's efficiency, so it is probably of no concern unless performance is crucial.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="problem-2-efficiency"&gt;
&lt;h3&gt;Problem #2: efficiency&lt;/h3&gt;
&lt;p&gt;There's an inherent performance problem with recursive-descent parsers when dealing with expressions. This problem stems from the need to define operator precedence, and in RD parsers the only way to define this precedence is by using recursive sub-rules. For example (from the EBNF-based code):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;expr&amp;gt;    : &amp;lt;term&amp;gt; {+ &amp;lt;term&amp;gt;}
          | &amp;lt;term&amp;gt; {- &amp;lt;term&amp;gt;}
&amp;lt;term&amp;gt;    : &amp;lt;power&amp;gt; {* &amp;lt;power&amp;gt;}
          | &amp;lt;power&amp;gt; {/ &amp;lt;power&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The nesting of these rules defines the relative precedence of addition and multiplication. It tells the parser: between plus signs, dive into the expression and collect all sub-terms connected by multiply signs. In other words, it tells it to group the expression: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;5&lt;/span&gt; &lt;span class="pre"&gt;+&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt;&lt;/tt&gt; as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;5&lt;/span&gt; &lt;span class="pre"&gt;+&lt;/span&gt; &lt;span class="pre"&gt;(2&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt; &lt;span class="pre"&gt;2)&lt;/span&gt;&lt;/tt&gt; and not as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(5&lt;/span&gt; &lt;span class="pre"&gt;+&lt;/span&gt; &lt;span class="pre"&gt;2)&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt; &lt;span class="pre"&gt;2&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;To see the problem this nesting causes, I've inserted simple printouts into each of the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;term&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;power&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factor&lt;/span&gt;&lt;/tt&gt; rules to show which functions get called while parsing. Let's see what happens when the trivial expression &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;42&lt;/span&gt;&lt;/tt&gt; is parsed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;expr called with NUMBER(42) at 0
term called with NUMBER(42) at 0
power called with NUMBER(42) at 0
factor called with NUMBER(42) at 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Yikes!!!&lt;/strong&gt; 4 function calls just to parse the single-token input 42! Unfortunately, while this problem may look simple on the surface, it is not. There's simply no other way to express precedence in RD parsers - you have to use nested rules, and this nesting turns out to be inefficient for parsing expressions.&lt;/p&gt;
&lt;p&gt;The solution to this problem is to use a hybrid parser instead of a pure RD one. Some algorithms were developed to efficiently parse &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Infix_notation"&gt;infix expressions&lt;/a&gt;. &lt;a class="reference external" href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm"&gt;This article&lt;/a&gt; provides a good survey. One such algorithm can be combined with RD to provide a general-purpose parser for both expressions and higher programming language constructs.&lt;/p&gt;
&lt;p&gt;In a future article I will discuss an implementation of such a parser.&lt;/p&gt;
&lt;div align="center" class="align-center"&gt;&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;To be more precise, addition and multiplication are &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Associativity"&gt;associative binary operators&lt;/a&gt; in the mathematical sense.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;But I'm too lazy to look for such a way at the moment. Let me know if you find it.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="Recursive descent parsing"></category></entry><entry><title>Recursive descent, LL and predictive parsers</title><link href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers" rel="alternate"></link><published>2008-09-26T12:29:10-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-09-26:/2008/09/26/recursive-descent-ll-and-predictive-parsers</id><summary type="html">
        &lt;div class="section" id="introduction"&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Although I've written some recursive-descent (RD) parsers by hand, the theory behind them eluded me for some time. I had a good understanding of the theory behind bottom-up &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LR&lt;/span&gt;&lt;/tt&gt; parsers, and have used tools (like &lt;a class="reference external" href="http://dinosaur.compilertools.net/"&gt;Yacc&lt;/a&gt; and &lt;a class="reference external" href="http://www.dabeaz.com/ply/"&gt;PLY&lt;/a&gt;) to generate &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LALR&lt;/span&gt;&lt;/tt&gt; parsers for languages, but I didn't really dig â€¦&lt;/p&gt;&lt;/div&gt;</summary><content type="html">
        &lt;div class="section" id="introduction"&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Although I've written some recursive-descent (RD) parsers by hand, the theory behind them eluded me for some time. I had a good understanding of the theory behind bottom-up &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LR&lt;/span&gt;&lt;/tt&gt; parsers, and have used tools (like &lt;a class="reference external" href="http://dinosaur.compilertools.net/"&gt;Yacc&lt;/a&gt; and &lt;a class="reference external" href="http://www.dabeaz.com/ply/"&gt;PLY&lt;/a&gt;) to generate &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LALR&lt;/span&gt;&lt;/tt&gt; parsers for languages, but I didn't really dig into the books about &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;This week I've finally decided to understand what's going on. I tried to write a simple RD parser in Python (previously I've written RD parsers in C++ and Lisp), and ran into a problem which got me thinking hard about &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL&lt;/span&gt;&lt;/tt&gt; parsers. So, I've opened the &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"&gt;Dragon Book&lt;/a&gt;, and now I know much more about &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(k)&lt;/span&gt;&lt;/tt&gt;, predictive, recursive-descent parsers with and without backtracking, and what's between them.&lt;/p&gt;
&lt;p&gt;This article is a summary of my findings, written for myself to read in a few months when I forget it :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="recursive-descent-parsers"&gt;
&lt;h3&gt;Recursive descent parsers&lt;/h3&gt;
&lt;p&gt;From &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Recursive_descent"&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
A recursive descent parser is a top-down parser built from a set of mutually-recursive procedures (or a non-recursive equivalent) where each such procedure usually implements one of the production rules of the grammar. Thus the structure of the resulting program closely mirrors that of the grammar it recognizes.&lt;/blockquote&gt;
&lt;p&gt;RD parsers are the most general form of top-down parsing, and the most popular type of parsers to write by hand. However, being so general, they have several problems, like requiring backtracking (which is difficult to code correctly and efficiently).&lt;/p&gt;
&lt;p&gt;Usually, it is enough to use less general and powerful parsers for all practical needs, like parsing programming languages (and domain specific languages). This is where &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL&lt;/span&gt;&lt;/tt&gt; parsers come in.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ll-parsers"&gt;
&lt;h3&gt;LL parsers&lt;/h3&gt;
&lt;blockquote&gt;
An LL parser is a top-down parser for a subset of the context-free grammars. It parses the input from Left to right, and constructs a Leftmost derivation of the sentence (hence LL, compared with LR parser). The class of grammars which are parsable in this way is known as the LL grammars.&lt;/blockquote&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL&lt;/span&gt;&lt;/tt&gt; parsers are further classified by the amount of lookup they need. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt; parsers require 1 character of lookup, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(k)&lt;/span&gt;&lt;/tt&gt; require &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;k&lt;/span&gt;&lt;/tt&gt;, and so on. Usually, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt; is enough for most practical needs.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL&lt;/span&gt;&lt;/tt&gt; parsers are also called &lt;em&gt;predictive&lt;/em&gt;, because it's possible predict the exact path to take by a certain amount of lookup symbols, without backtracking.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-example"&gt;
&lt;h3&gt;The example&lt;/h3&gt;
&lt;p&gt;This week I tried to construct a RD parser for this simple calculator grammar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;expr&amp;gt;      :=  &amp;lt;term&amp;gt; + &amp;lt;expr&amp;gt;
            |   &amp;lt;term&amp;gt; - &amp;lt;expr&amp;gt;
            |   &amp;lt;term&amp;gt;
&amp;lt;term&amp;gt;      :=  &amp;lt;factor&amp;gt; * &amp;lt;term&amp;gt;
                &amp;lt;factor&amp;gt; / &amp;lt;term&amp;gt;
                &amp;lt;factor&amp;gt;
&amp;lt;factor&amp;gt;    :=  &amp;lt;number&amp;gt;
            |   &amp;lt;id&amp;gt;
            |   ( &amp;lt;expr&amp;gt; )
&amp;lt;number&amp;gt;    :=  \d+
&amp;lt;id&amp;gt;        :=  [a-zA-Z_]\w+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This grammar is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt; and hence parseable by a simple predictive parser with a single token lookahead. However, I then tried to add the following rule to allow input of commands into an interactive calculator prompt:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;command&amp;gt;   :=  &amp;lt;expr&amp;gt;
            |   &amp;lt;id&amp;gt; = &amp;lt;expr&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this rule added, the grammar is no longer &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt;, because looking at the first token I can't say which one of the two options of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;command&amp;gt;&lt;/span&gt;&lt;/tt&gt; it is. In order to be able to differentiate between an assignment and a single expression, I must see the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;=&lt;/span&gt;&lt;/tt&gt; token, and for this I need to see 2 tokens forward, and not just one. So, this grammar turns into a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(2)&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(2)&lt;/span&gt;&lt;/tt&gt; grammars are much more difficult to code by hand than &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt; grammars, and they are also much more difficult to turn into code automatically by parser generators. This is probably why for most languages &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL(1)&lt;/span&gt;&lt;/tt&gt; suffices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ll-parser-generators"&gt;
&lt;h3&gt;LL parser generators&lt;/h3&gt;
&lt;p&gt;Unlike &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LR&lt;/span&gt;&lt;/tt&gt; parsers, for which everyone uses parser generators &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL&lt;/span&gt;&lt;/tt&gt; parsers are commonly written by hand. It even appears that some of the most popular compilers (such as GCC) use hand-written RD parsers to parse whole languages like C. As with anything, you get maximal flexibility and efficiency when you hand-code something, as you're not constrained by the limitations of the tools and libraries you're using.&lt;/p&gt;
&lt;p&gt;Indeed, writing a simple predictive parser as a set of mutually recursive routines is simple, and can also be very educational. If you have a very small parsing task to perform, perhaps you'll be better off hand-coding a RD parser.&lt;/p&gt;
&lt;p&gt;However, automatic tools for generating &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LL&lt;/span&gt;&lt;/tt&gt; parsers exist. The most popular are probably &lt;a class="reference external" href="http://www.antlr.org/"&gt;ANTLR&lt;/a&gt; and &lt;a class="reference external" href="http://spirit.sourceforge.net/"&gt;Boost.Spirit&lt;/a&gt;. I haven't tried them, but both are widely used to write complex parsers. Both have a clear advantage over hand-written parsers - they can generate parsers with any lookup length, guessing the required length from the grammar. Hand-written parsers, as I mentioned earlier, get much more complex for any &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;k&lt;/span&gt; &lt;span class="pre"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="left-recursion"&gt;
&lt;h3&gt;Left recursion&lt;/h3&gt;
&lt;p&gt;Had my &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; rule been written like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;expr&amp;gt;      :=  &amp;lt;expr&amp;gt; + &amp;lt;term&amp;gt;
            |   &amp;lt;expr&amp;gt; - &amp;lt;term&amp;gt;
            |   &amp;lt;term&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It would have been &lt;em&gt;left recursive&lt;/em&gt;, because the non-terminal &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr&lt;/span&gt;&lt;/tt&gt; appears as the first (leftmost) symbol in its own production. Since RD parsers work top-down, to recognize &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;expr&amp;gt;&lt;/span&gt;&lt;/tt&gt; it has to first recognize &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;expr&amp;gt;&lt;/span&gt;&lt;/tt&gt;, but for that it again has to recognize &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;expr&amp;gt;&lt;/span&gt;&lt;/tt&gt; and so on, ad infinitum. This infinite recursion is the reason why RD parsers can't handle left recursion.&lt;/p&gt;
&lt;p&gt;Left recursion can also be indirect:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;a&amp;gt;   :=  &amp;lt;b&amp;gt; &amp;lt;x&amp;gt;
      |   &amp;lt;c&amp;gt;
&amp;lt;b&amp;gt;   :=  &amp;lt;a&amp;gt; &amp;lt;y&amp;gt;
      |   &amp;lt;d&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we can have the infinite derivation: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;a&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;b&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;x&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;a&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;y&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;x&amp;gt;&lt;/span&gt;&lt;/tt&gt; and so on.&lt;/p&gt;
&lt;p&gt;Techniques exist to remove left recursion from some grammars. For more information see &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Left_recursion"&gt;this&lt;/a&gt;. The grammar shown in the example above had left-recursion removed from it &lt;a class="footnote-reference" href="#id4" id="id2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="code"&gt;
&lt;h3&gt;Code&lt;/h3&gt;
&lt;p&gt;A simple recursive descent parser for a calculator, written in Python, can be downloaded &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2009/py_rd_parser_example"&gt;here&lt;/a&gt;. It also includes a fairly generic Lexer class that implements regex-based tokenization of a string.&lt;/p&gt;
&lt;div align="center" class="align-center"&gt;&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Since &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LR&lt;/span&gt;&lt;/tt&gt; parsers are table-based are too tedious and unwieldy to write by hand.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Which, however, has left it with a slight operator associativity problem. Finding it is left as an exercise for the reader).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="Recursive descent parsing"></category></entry><entry><title>Parse::RecDescent vs. YACC</title><link href="https://eli.thegreenplace.net/2004/01/29/parserecdescent-vs-yacc" rel="alternate"></link><published>2004-01-29T15:08:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2004-01-29:/2004/01/29/parserecdescent-vs-yacc</id><summary type="html">
        Parse::RecDescent (RD) looks like the best parsing option in Perl for me, for two reasons. First, it is very lightweight - only one .pm file to carry around. Second, I like recursive descent parsing :-) RD parsing is, IMHO, easier to visualize and understand. Looking at the grammar (BNF) it is â€¦</summary><content type="html">
        Parse::RecDescent (RD) looks like the best parsing option in Perl for me, for two reasons. First, it is very lightweight - only one .pm file to carry around. Second, I like recursive descent parsing :-) RD parsing is, IMHO, easier to visualize and understand. Looking at the grammar (BNF) it is immediately obvious how each rule will be parsed given the input. This is very nice for grammar debugging.&lt;p&gt;
Yesterday was my first serious experience with the RD module (historically, I did a lot of Yacc (in C), and coded some simple recursive descent parsers by hand). The module works nicely, and is easy to learn and understand. Some notable differences from Yacc:&lt;/p&gt;&lt;p&gt;&lt;ol&gt;
&lt;li&gt;Integrated lexing. Very nice ! It looks much more natural this way, and there's no need for extra headache with Lex linkage. Tokens are defined as simple regex rules in the grammar itself.&lt;/li&gt;
&lt;li&gt;Some little things that make life easier and more pleasant. For example, the rule quantifiers (s), (s?) etc.&lt;/li&gt;
&lt;li&gt;Left recursion problem. Hits blatantly when arithmetic expressions must be parsed. A different mindset must be employed when comparing with Yacc.&lt;/li&gt;
&lt;/ol&gt;
Additionally, RD has a very useful trace option, that traces parsing and allows to see where things went wrong with the grammar.
    </content><category term="misc"></category><category term="Compilation"></category><category term="Recursive descent parsing"></category></entry></feed>