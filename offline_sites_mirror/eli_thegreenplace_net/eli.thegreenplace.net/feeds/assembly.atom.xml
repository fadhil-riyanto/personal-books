<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - Assembly</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/assembly.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2024-09-14T13:15:30-07:00</updated><entry><title>WebAssembly Text code samples</title><link href="https://eli.thegreenplace.net/2023/webassembly-text-code-samples/" rel="alternate"></link><published>2023-04-22T07:46:00-07:00</published><updated>2023-04-22T14:49:03-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2023-04-22:/2023/webassembly-text-code-samples/</id><summary type="html">&lt;p&gt;This post talks about writing WebAssembly by hand (using its textual format),
and mentions a new GitHub &lt;a class="reference external" href="https://github.com/eliben/wasm-wat-samples/"&gt;repository&lt;/a&gt; I've created with code samples.&lt;/p&gt;
&lt;p&gt;A bit of nomenclature first. &lt;strong&gt;WASM&lt;/strong&gt; stands for WebAssembly - it has a &lt;a class="reference external" href="https://webassembly.github.io/spec/core/binary/index.html"&gt;binary
format&lt;/a&gt; and a
&lt;a class="reference external" href="https://webassembly.github.io/spec/core/text/index.html"&gt;textual format&lt;/a&gt;.
The textual format, called WebAssembly Text or &lt;strong&gt;WAT&lt;/strong&gt;, is …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post talks about writing WebAssembly by hand (using its textual format),
and mentions a new GitHub &lt;a class="reference external" href="https://github.com/eliben/wasm-wat-samples/"&gt;repository&lt;/a&gt; I've created with code samples.&lt;/p&gt;
&lt;p&gt;A bit of nomenclature first. &lt;strong&gt;WASM&lt;/strong&gt; stands for WebAssembly - it has a &lt;a class="reference external" href="https://webassembly.github.io/spec/core/binary/index.html"&gt;binary
format&lt;/a&gt; and a
&lt;a class="reference external" href="https://webassembly.github.io/spec/core/text/index.html"&gt;textual format&lt;/a&gt;.
The textual format, called WebAssembly Text or &lt;strong&gt;WAT&lt;/strong&gt;, is the subject of this
post.&lt;/p&gt;
&lt;div class="section" id="introduction-to-wat"&gt;
&lt;h2&gt;Introduction to WAT&lt;/h2&gt;
&lt;p&gt;WASM is a stack machine, and while stack machines can lead to wonderfully
compact bytecode, they can also be awkward to code by hand - because the
programmer needs to have a mental model of the top stack slots at all times,
remembering what they refer to. While you can certainly code directly to the
stack machine with WAT, it also has some programmer-friendly constructs
that significantly improve writability and readability. Here's an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(local.set $writeidx (i32.sub (local.get $writeidx) (i32.const 1)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is equivalent to &lt;tt class="docutils literal"&gt;writeidx &lt;span class="pre"&gt;-=&lt;/span&gt; 1&lt;/tt&gt; in many mainstream languages. The two
WAT features at play here are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The ability to declare variables and to refer to them
by name (this includes function parameters).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Folded instructions&lt;/em&gt; - allowing the programmer to condense a sequence of
stack operations into a single &lt;a class="reference external" href="https://en.wikipedia.org/wiki/S-expression"&gt;s-expr&lt;/a&gt;. This is music to
&lt;a class="reference external" href="https://eli.thegreenplace.net/tag/lisp"&gt;my Lisper ears&lt;/a&gt;!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These folded instructions can go as deep as we wish; here's an even more nested
example involving memory access:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(local.set
    $next_env_ptr
    (i32.load (i32.add  (global.get $env_ptrs)
                        (i32.mul (local.get $i) (i32.const 4)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In pseudo-C, this is equivalent to &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;next_env_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;env_ptrs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WAT has some additional ergonomic features that I like. For example, named
functions with named parameters, as well as declared return values:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(func $itoa (export &amp;quot;itoa&amp;quot;) (param $num i32) (result i32 i32)
  ...
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function has a name we can refer to in calls, a single parameter with
a name (&lt;tt class="docutils literal"&gt;$num&lt;/tt&gt;) and two return values. Calling this function can be done
in a folded expression like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(call $itoa (i32.add (local.get $n) (i32.const 1)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is equivalent to &lt;tt class="docutils literal"&gt;itoa(n+1)&lt;/tt&gt;. Another feature this example demonstrates
is &lt;em&gt;types&lt;/em&gt; - WAT functions and values (parameters, globals and locals) have
types, which makes code easier to read and understand, and also provides the
compiler an opportunity to check for correctness at compile time.&lt;/p&gt;
&lt;p&gt;Moreover, in the WASM model, type checking goes deeper and extends to stack
interactions; the WASM compiler knows how many stack slots each instruction uses
and produces, and this is verified as well - so common mistakes are easily
caught. I find that the code is much more often correct once I get it to compile
in WAT compared to other assembly languages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="samples-of-wat-code"&gt;
&lt;h2&gt;Samples of WAT code&lt;/h2&gt;
&lt;p&gt;Back to the original goal of this post. While I enjoy writing WAT code, one
aspect of the experience that could be improved is documentation. The
&lt;a class="reference external" href="https://webassembly.github.io/spec/core/index.html"&gt;WASM spec&lt;/a&gt; is
much more suitable for formal verification than for actual documentation
purposes; specifically, it's hard to grep and doesn't provide much in terms
of examples. This is alright for a spec, but I couldn't find complementary
resources that just show code samples.&lt;/p&gt;
&lt;p&gt;Therefore, I've decided to collect some of the WAT snippets I've written so far
into a GitHub repository named &lt;a class="reference external" href="https://github.com/eliben/wasm-wat-samples/"&gt;wasm-wat-samples&lt;/a&gt;. It's my humble contribution to
the world of WAT documentation. The goal of the repository is to demonstrate how
WAT concepts (including WASI) and constructs are used in practice; it's
optimized for &lt;em&gt;greppability&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I hope others find it useful as well - feel free to suggest additional samples
in issues and PRs!&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;memory&lt;/tt&gt; is implicitly the linear heap memory every WASM module has.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="WebAssembly"></category><category term="Assembly"></category></entry><entry><title>itoa (integer to string) in WebAssembly</title><link href="https://eli.thegreenplace.net/2023/itoa-integer-to-string-in-webassembly/" rel="alternate"></link><published>2023-04-17T20:09:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2023-04-17:/2023/itoa-integer-to-string-in-webassembly/</id><summary type="html">&lt;p&gt;&lt;strong&gt;Update (2023-04-22)&lt;/strong&gt;: here's a repository with many WAT code samples,
including this one: &lt;a class="reference external" href="https://github.com/eliben/wasm-wat-samples"&gt;wasm-wat-samples&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is a brief blog post that mostly consists of a single, well-documented code
snippet.&lt;/p&gt;
&lt;p&gt;I've been getting more and more interested
&lt;a class="reference external" href="https://eli.thegreenplace.net/tag/webassembly"&gt;in WebAssembly recently&lt;/a&gt;,
and found there's a dearth of high-quality WAT (&lt;em&gt;WebAssembly Text&lt;/em&gt;
language …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Update (2023-04-22)&lt;/strong&gt;: here's a repository with many WAT code samples,
including this one: &lt;a class="reference external" href="https://github.com/eliben/wasm-wat-samples"&gt;wasm-wat-samples&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is a brief blog post that mostly consists of a single, well-documented code
snippet.&lt;/p&gt;
&lt;p&gt;I've been getting more and more interested
&lt;a class="reference external" href="https://eli.thegreenplace.net/tag/webassembly"&gt;in WebAssembly recently&lt;/a&gt;,
and found there's a dearth of high-quality WAT (&lt;em&gt;WebAssembly Text&lt;/em&gt;
language) code samples dealing with some of the trickier aspects of WASM like
working with strings and passing data between WASM and the host &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; via memory.&lt;/p&gt;
&lt;p&gt;So here's a complete WASM module written in WAT that exports an &lt;tt class="docutils literal"&gt;itoa&lt;/tt&gt;
function -- just like its C counterpart, it converts an integer into a string
representation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;
    &lt;span class="c1"&gt;;; Logging function imported from the environment; will print a single&lt;/span&gt;
    &lt;span class="c1"&gt;;; i32.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;env&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;log&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;func&lt;/span&gt; &lt;span class="nv"&gt;$log&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;param&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Declare linear memory and export it to host. The offset returned by&lt;/span&gt;
    &lt;span class="c1"&gt;;; $itoa is relative to this memory.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;memory&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;memory&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;;; Using some memory for a number--&amp;gt;digit ASCII lookup-table, and then the&lt;/span&gt;
    &lt;span class="c1"&gt;;; space for writing the result of $itoa.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mf"&gt;8000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;0123456789&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="nv"&gt;$itoa_out_buf&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mf"&gt;8010&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; itoa: convert an integer to its string representation. Only supports&lt;/span&gt;
    &lt;span class="c1"&gt;;; numbers &amp;gt;= 0.&lt;/span&gt;
    &lt;span class="c1"&gt;;; Parameter: the number to convert&lt;/span&gt;
    &lt;span class="c1"&gt;;; Result: address and length of string in memory.&lt;/span&gt;
    &lt;span class="c1"&gt;;; Note: this result is only valid until the next call to $itoa which will&lt;/span&gt;
    &lt;span class="c1"&gt;;; overwrite it; obviously, this isn&amp;#39;t concurrency-safe either.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;func&lt;/span&gt; &lt;span class="nv"&gt;$itoa&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;itoa&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;param&lt;/span&gt; &lt;span class="nv"&gt;$num&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;result&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;local&lt;/span&gt; &lt;span class="nv"&gt;$numtmp&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;local&lt;/span&gt; &lt;span class="nv"&gt;$numlen&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;local&lt;/span&gt; &lt;span class="nv"&gt;$writeidx&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;local&lt;/span&gt; &lt;span class="nv"&gt;$digit&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;local&lt;/span&gt; &lt;span class="nv"&gt;$dchar&lt;/span&gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;;; Count the number of characters in the output, save it in $numlen.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.lt_s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$numlen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$numlen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$numtmp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$num&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="nv"&gt;$countloop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;$breakcountloop&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.eqz&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$numtmp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="nb"&gt;br_if&lt;/span&gt; &lt;span class="nv"&gt;$breakcountloop&lt;/span&gt;

                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$numtmp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.div_u&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$numtmp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$numlen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$numlen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                &lt;span class="nb"&gt;br&lt;/span&gt; &lt;span class="nv"&gt;$countloop&lt;/span&gt;
            &lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;

        &lt;span class="c1"&gt;;; Now that we know the length of the output, we will start populating&lt;/span&gt;
        &lt;span class="c1"&gt;;; digits into the buffer. E.g. suppose $numlen is 4:&lt;/span&gt;
        &lt;span class="c1"&gt;;;&lt;/span&gt;
        &lt;span class="c1"&gt;;;                     _  _  _  _&lt;/span&gt;
        &lt;span class="c1"&gt;;;&lt;/span&gt;
        &lt;span class="c1"&gt;;;                     ^        ^&lt;/span&gt;
        &lt;span class="c1"&gt;;;  $itoa_out_buf -----|        |---- $writeidx&lt;/span&gt;
        &lt;span class="c1"&gt;;;&lt;/span&gt;
        &lt;span class="c1"&gt;;;&lt;/span&gt;
        &lt;span class="c1"&gt;;; $writeidx starts by pointing to $itoa_out_buf+3 and decrements until&lt;/span&gt;
        &lt;span class="c1"&gt;;; all the digits are populated.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$writeidx&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.sub&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;global.get&lt;/span&gt; &lt;span class="nv"&gt;$itoa_out_buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$numlen&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="nv"&gt;$writeloop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;$breakwriteloop&lt;/span&gt;
            &lt;span class="c1"&gt;;; digit &amp;lt;- $num % 10&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$digit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.rem_u&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
            &lt;span class="c1"&gt;;; set the char value from the lookup table of digit chars&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$dchar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.load8_u&lt;/span&gt; &lt;span class="k"&gt;offset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8000&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$digit&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

            &lt;span class="c1"&gt;;; mem[writeidx] &amp;lt;- dchar&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.store8&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$writeidx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$dchar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

            &lt;span class="c1"&gt;;; num &amp;lt;- num / 10&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.div_u&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

            &lt;span class="c1"&gt;;; If after writing a number we see we wrote to the first index in&lt;/span&gt;
            &lt;span class="c1"&gt;;; the output buffer, we&amp;#39;re done.&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$writeidx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;global.get&lt;/span&gt; &lt;span class="nv"&gt;$itoa_out_buf&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="nb"&gt;br_if&lt;/span&gt; &lt;span class="nv"&gt;$breakwriteloop&lt;/span&gt;

            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.set&lt;/span&gt; &lt;span class="nv"&gt;$writeidx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.sub&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$writeidx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32.const&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
            &lt;span class="nb"&gt;br&lt;/span&gt; &lt;span class="nv"&gt;$writeloop&lt;/span&gt;
        &lt;span class="p"&gt;))&lt;/span&gt;

        &lt;span class="c1"&gt;;; return (itoa_out_buf, numlen)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;global.get&lt;/span&gt; &lt;span class="nv"&gt;$itoa_out_buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local.get&lt;/span&gt; &lt;span class="nv"&gt;$numlen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some notes about this code:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;itoa&lt;/tt&gt; uses the &lt;a class="reference external" href="https://github.com/WebAssembly/multi-value"&gt;multi-value&lt;/a&gt;
feature of WASM to return multiple values. This feature is supported pretty
&lt;a class="reference external" href="https://webassembly.org/roadmap/"&gt;uniformly by WASM hosts&lt;/a&gt; at this point.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;itoa&lt;/tt&gt; writes its string output into memory, and returns the address of this
string and its length to the host. This address (in WASM's linear memory) is
currently hard-coded; there is no dynamic memory allocation built into WASM.
It's possible to implement it, and higher-level languages do, but for a simple
examples this will do.&lt;/li&gt;
&lt;li&gt;The module exports its linear memory to the host so that the host can read
the string &lt;tt class="docutils literal"&gt;itoa&lt;/tt&gt; wrote.&lt;/li&gt;
&lt;li&gt;The algorithm is straightforward and unoptimized; it runs one O(log(N)) loop
to find the output size, and another such loop to populate the output.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the accompanying host code and instructions for compiling &amp;amp; running, see
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2023/wasm-itoa"&gt;the GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="exercises"&gt;
&lt;h2&gt;Exercises&lt;/h2&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;itoa&lt;/tt&gt; function presented here has a few limitations that can be fixed
without too much effort; if you're interested in WAT programming, these could
be good exercises:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Extend it to support negative numbers&lt;/li&gt;
&lt;li&gt;Extend it to work for other common bases like hexadecimal (will require an
additional parameter).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A note on nomenclature: by &lt;em&gt;host&lt;/em&gt; I mean the execution environment a
WASM module runs in. The most common environment is a web browser, but
recently it's more and more common to see WASM executed in non-browser
environments like Node.js, wasmtime (Rust) or wazero (Go).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="WebAssembly"></category><category term="Assembly"></category></entry><entry><title>An Intel 8080 assembler and online simulator</title><link href="https://eli.thegreenplace.net/2020/an-intel-8080-assembler-and-online-simulator/" rel="alternate"></link><published>2020-07-25T16:00:00-07:00</published><updated>2024-09-14T13:15:30-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2020-07-25:/2020/an-intel-8080-assembler-and-online-simulator/</id><summary type="html">&lt;p&gt;While going through Charles Petzold's &amp;quot;Code&amp;quot; book again, I was looking for an
easy-to-use online assembler and simulator for the classic &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Intel_8080"&gt;Intel 8080 CPU&lt;/a&gt;, but couldn't find anything that
fit my needs exactly. There are some well-done tools out there, but they seem to
be more geared to running game …&lt;/p&gt;</summary><content type="html">&lt;p&gt;While going through Charles Petzold's &amp;quot;Code&amp;quot; book again, I was looking for an
easy-to-use online assembler and simulator for the classic &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Intel_8080"&gt;Intel 8080 CPU&lt;/a&gt;, but couldn't find anything that
fit my needs exactly. There are some well-done tools out there, but they seem to
be more geared to running game ROMs and large programs on an emulator; my need
was different - I just wanted something to play with, to practice 8080 assembly
programming.&lt;/p&gt;
&lt;p&gt;So I ended up rolling my own, and the &lt;a class="reference external" href="https://github.com/eliben/js-8080-sim/"&gt;js-8080-sim&lt;/a&gt; project was born. The project has
three main parts:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;An assembler for the 8080: translating assembly language code into 8080
machine code. I wrote a custom assembler for this.&lt;/li&gt;
&lt;li&gt;A CPU simulator: simulating 8080 machine code. For this purpose I cloned
the &lt;a class="reference external" href="https://github.com/maly/8080js"&gt;maly/8080js&lt;/a&gt; project into my
repository &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; and tweaked it a little bit.&lt;/li&gt;
&lt;li&gt;A simple web UI for writing 8080 assembly code, running it and observing the
results (as changed values in memory and registers). I wrote a basic UI in
JS:&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="js 8080 web UI screenshot" class="align-center" src="https://github.com/eliben/js-8080-sim/blob/main/doc/js-sim-screenshot.png?raw=true" style="width: 650px;" /&gt;
&lt;p&gt;If you want to play with the simulator, a live version is available online at
&lt;a class="reference external" href="https://eliben.org/js8080"&gt;https://eliben.org/js8080&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The UI is purely client-side; it makes no requests and just uses your browser
as a GUI. It does use the browser's local storage to save the last program you
ran.&lt;/p&gt;
&lt;p&gt;Issues and PRs &lt;a class="reference external" href="https://github.com/eliben/js-8080-sim/"&gt;on GitHub&lt;/a&gt; welcome!&lt;/p&gt;
&lt;div class="section" id="on-javascript-and-frameworks"&gt;
&lt;h2&gt;On JavaScript and frameworks&lt;/h2&gt;
&lt;p&gt;Using JS for a project like this is very natural, because ultimately what I'm
interested in is having a convenient web UI to play with the simulator. When
I do this, I almost always end up writing vanilla HTML+CSS+JS, avoiding
frameworks. I don't write JS often, so whenever I get to work on a new project,
the framework &lt;em&gt;du juor&lt;/em&gt; has typically changed from the last time, and I just
don't have the time to keep track. Vanilla HTML+CSS+JS has much better
longevity, IMHO, although it does mean somewhat more manual work (e.g. to keep
the UI in sync with the application state).&lt;/p&gt;
&lt;p&gt;The only framework I was tempted to use is Bootstrap for the CSS and layout,
but eventually decided against it in the interest of simplicity.&lt;/p&gt;
&lt;p&gt;We're fortunate to have much more stable and usable JS and web APIs in 2020
compared to just a few years ago. For the simulator I've been using the ES6
version of JS, which is widely supported today and offers many niceties.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I went with vendoring 8080js because it appears to be unmaintained,
and I also wanted to avoid a dependency, preferring the project to be
self-contained. This was easy with 8080js because it's a single JS file
and it has a permissive 2-clause BSD license. I've reproduced the license
in full in the cloned source file. FWIW, 8080js itself is also based on
an earlier BSD-licensed simulator; OSS at its best :-)&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="JavaScript"></category><category term="Assembly"></category></entry><entry><title>"Beating" C with 400 lines of unoptimized assembly</title><link href="https://eli.thegreenplace.net/2019/beating-c-with-400-lines-of-unoptimized-assembly/" rel="alternate"></link><published>2019-11-23T09:46:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2019-11-23:/2019/beating-c-with-400-lines-of-unoptimized-assembly/</id><summary type="html">&lt;p&gt;Earlier this week I ran into a fun quick blog post named
&lt;a class="reference external" href="https://ajeetdsouza.github.io/blog/posts/beating-c-with-70-lines-of-go/"&gt;Beating C with 70 lines of Go&lt;/a&gt;,
which reimplements the basic functionality of &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; in Go using various
approaches and compares their performance. Apparently it's inspired by an
earlier &lt;a class="reference external" href="https://chrispenner.ca/posts/wc"&gt;Haskell-based post&lt;/a&gt; and several
other offshoots.&lt;/p&gt;
&lt;p&gt;This reminded me …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Earlier this week I ran into a fun quick blog post named
&lt;a class="reference external" href="https://ajeetdsouza.github.io/blog/posts/beating-c-with-70-lines-of-go/"&gt;Beating C with 70 lines of Go&lt;/a&gt;,
which reimplements the basic functionality of &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; in Go using various
approaches and compares their performance. Apparently it's inspired by an
earlier &lt;a class="reference external" href="https://chrispenner.ca/posts/wc"&gt;Haskell-based post&lt;/a&gt; and several
other offshoots.&lt;/p&gt;
&lt;p&gt;This reminded me of my earlier post about &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/wc-in-x64-assembly/"&gt;reimplementing wc in pure x64
assembly&lt;/a&gt;, where I
also measured the performance of my program against &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The optimized approach taken in the Go implementation is very similar to what I
did in assembly, so it seemed like an interesting comparison. I started by
generating a ~580 MiB file using &lt;a class="reference external" href="https://github.com/eliben/xmlgen"&gt;xmlgen&lt;/a&gt;
and ran the various versions against each other:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_TYPE=POSIX wc&lt;/tt&gt;: 2.13 sec&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;wc-naive.go&lt;/span&gt;&lt;/tt&gt;: 3.53 sec&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;wc-chunks.go&lt;/span&gt;&lt;/tt&gt;: 1.37 sec&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt;: 1.2 sec&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note the &lt;tt class="docutils literal"&gt;LC_TYPE&lt;/tt&gt; setting for the system's &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt;. This is important for a
fair comparison, because without this &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; will attempt to do &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;utf-8&lt;/span&gt;&lt;/tt&gt;
decoding on all bytes in the file, which results in significant slowdowns. Since
the Go versions use byte-counts and so does my &lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt;, I force the comparison
to be fair. In fact, this isn't a bad result for Go - the straightforward
solution is almost as fast as the same approach direct-coded in assembly!&lt;/p&gt;
&lt;p&gt;The Go blog post follows with parallelized versions which are much faster than
the serial one, but I'm excluding it here because all the other competitors are
single-threaded. This is not a serious benchmark anyway. If you prefer to
be serious, &lt;a class="reference external" href="https://github.com/expr-fi/fastlwc/"&gt;this response using SIMD-optimized C&lt;/a&gt; blows everything out of the water:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;fastlwc&lt;/tt&gt;: 0.11 sec&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The conclusion? Well, there's no real conclusion here, beyond that coding
exercises like this are fun in any language :-)&lt;/p&gt;
</content><category term="misc"></category><category term="Assembly"></category><category term="C &amp; C++"></category><category term="Go"></category></entry><entry><title>Adventures in JIT compilation: Part 2 - an x64 JIT</title><link href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/" rel="alternate"></link><published>2017-03-22T06:32:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-03-22:/2017/adventures-in-jit-compilation-part-2-an-x64-jit/</id><summary type="html">&lt;p&gt;In the &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/"&gt;first part of the series&lt;/a&gt;
I've briefly introduced the BF source language and went on to present four
interpreters with increasing degree of optimization. That post should serve as a
good backgroud before diving into actual JIT-ing.&lt;/p&gt;
&lt;p&gt;Another important part of the background puzzle is my &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction"&gt;How to …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/"&gt;first part of the series&lt;/a&gt;
I've briefly introduced the BF source language and went on to present four
interpreters with increasing degree of optimization. That post should serve as a
good backgroud before diving into actual JIT-ing.&lt;/p&gt;
&lt;p&gt;Another important part of the background puzzle is my &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction"&gt;How to JIT - an
introduction&lt;/a&gt; post from
2013; there, I discuss some of the basic tools needed to emit executable x64
machine code at run-time and actually run it on Linux. Please go through it
quickly if these things are new to you.&lt;/p&gt;
&lt;div class="section" id="the-two-phases-of-jit"&gt;
&lt;h2&gt;The two phases of JIT&lt;/h2&gt;
&lt;p&gt;As I wrote &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction"&gt;previously&lt;/a&gt;, the JIT
technique is easier to understand when divided into two distinct phases:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Create machine code at program run-time.&lt;/li&gt;
&lt;li&gt;Execute that machine code, also at program run-time.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Phase 2 for our BF JIT is exactly identical to the method described in that
introductory post. Take a look at the &lt;tt class="docutils literal"&gt;JitProgram&lt;/tt&gt; class in
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/jit_utils.h"&gt;jit_utils&lt;/a&gt;
for details. We'll be more focused on phase 1, which will be translating
BF to x64 machine code; per the definition quoted in part 1 of the
series, we're going to develop an actual BF compiler (compiling from BF source
to x64 machine code).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="compilers-assemblers-and-instruction-encoding"&gt;
&lt;h2&gt;Compilers, assemblers and instruction encoding&lt;/h2&gt;
&lt;p&gt;Traditionally, compilation was divided into several stages. The actual source
language compiler would translate some higher-level language to target-specific
assembly; then, an assembler would translate assembly to actual machine code
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. There's a number of important benefits assembly language provides over raw
machine code. Salient examples include:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Instruction encoding: it's certainly nicer to write &lt;tt class="docutils literal"&gt;inc %r13&lt;/tt&gt; to increment
the contents of register &lt;tt class="docutils literal"&gt;r13&lt;/tt&gt; than to write &lt;tt class="docutils literal"&gt;0x49, 0xFF, 0xC5&lt;/tt&gt;.
Instruction encoding for the popular architectures is &lt;a class="reference external" href="http://ref.x86asm.net/"&gt;notoriously complicated&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Naming labels and procedures for jumps/calls: it's easier to write &lt;tt class="docutils literal"&gt;jl loop&lt;/tt&gt;
than to figure out the encoding for the instruction, along with the relative
position of the &lt;tt class="docutils literal"&gt;loop&lt;/tt&gt; label and encoding the delta to it (not to mention
this delta changes every time we add instructions in between and needs to be
recomputed). Similarly for functions, &lt;tt class="docutils literal"&gt;call foo&lt;/tt&gt; instead of doing it by
address.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One of my guiding principles through the field of programming is that before
diving into the possible solutions for a problem (for example, some library for
doing X) it's worth working through the problem manually first (doing X by hand,
without libraries). Grinding your teeth over issues for a while is the best way
to appreciate what the shrinkwrapped solution/library does for you.&lt;/p&gt;
&lt;p&gt;In this spirit, our first JIT is going to be completely hand-written.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-jit-hand-rolling-x64-instruction-encoding"&gt;
&lt;h2&gt;Simple JIT - hand-rolling x64 instruction encoding&lt;/h2&gt;
&lt;p&gt;Out first JIT for this post is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/simplejit.cpp"&gt;simplejit.cpp&lt;/a&gt;. Similarly to the
interpreters of part 1, all the action happens in a single function (here called
&lt;tt class="docutils literal"&gt;simplejit&lt;/tt&gt;) invoked from &lt;tt class="docutils literal"&gt;main&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;simplejit&lt;/tt&gt; goes through the BF source
and emits x64 machine code into a memory buffer; in the end, it jumps to this
machine code to run the BF program.&lt;/p&gt;
&lt;p&gt;Here's its beginning:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MEMORY_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Registers used in the program:&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// r13: the data pointer -- contains the address of memory.data()&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// rax, rdi, rsi, rdx: used for making system calls, per the ABI.&lt;/span&gt;

&lt;span class="n"&gt;CodeEmitter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Throughout the translation loop, this stack contains offsets (in the&lt;/span&gt;
&lt;span class="c1"&gt;// emitter code vector) of locations for fixup.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// movabs &amp;lt;address of memory.data&amp;gt;, %r13&lt;/span&gt;
&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x49&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xBD&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitUint64&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As usual, we have our BF memory buffer in a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::vector&lt;/span&gt;&lt;/tt&gt;. The comments reveal
some of the conventions used througout the emitted program: our &amp;quot;data pointer&amp;quot;
will be in &lt;tt class="docutils literal"&gt;r13&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;CodeEmitter&lt;/tt&gt; is a very simple utility to append bytes and words to a vector
of bytes. Its full code &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/jit_utils.cpp"&gt;is here&lt;/a&gt;.
It's platform independent except the assumption of little-endian (for
&lt;tt class="docutils literal"&gt;EmitUint64&lt;/tt&gt; it will write the lowest byte of the 64-bit word first, then the
second lowest byte, etc.)&lt;/p&gt;
&lt;p&gt;Our first bit of actual machine code emission follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// movabs &amp;lt;address of memory.data&amp;gt;, %r13&lt;/span&gt;
&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x49&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xBD&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitUint64&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And it's a cool one, mixing elements from the host (the C++ program doing the
emission) and the JITed code. First note the usage of &lt;tt class="docutils literal"&gt;movabs&lt;/tt&gt;, a x64
instruction useful for placing 64-bit immediates in a register. This is exactly
what we're doing here - placing the address of the data buffer of &lt;tt class="docutils literal"&gt;memory&lt;/tt&gt;
in &lt;tt class="docutils literal"&gt;r13&lt;/tt&gt;. The call to &lt;tt class="docutils literal"&gt;EmitBytes&lt;/tt&gt; with a cryptic sequence of hex values is
preceded by a snippet of assembly in a comment - the assembly conveys the
meaning for human readers, the hex values are the actual encoding the machine
will understand.&lt;/p&gt;
&lt;p&gt;Then comes the BF compilation loop, which looks at the next BF instruction and
emits the appropriate machine code for it. Our compiler works in a single pass;
this means that there's a bit of trickiness in handling the jumps, as we will
soon see.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instructions&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instructions&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// inc %r13&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x49&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC5&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// dec %r13&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x49&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xCD&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Our memory is byte-addressable, so using addb/subb for modifying it.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// addb $1, 0(%r13)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x41&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// subb $1, 0(%r13)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x41&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x6D&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These are pretty straightforward; since &lt;tt class="docutils literal"&gt;r13&lt;/tt&gt; is the data pointer, &lt;tt class="docutils literal"&gt;&amp;gt;&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;&amp;lt;&lt;/tt&gt; increment and decrement it, while &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;-&lt;/tt&gt; increment and decrement
what it's pointing to. One slightly subtle aspect is that I chose a byte-value
memory for our BF implementations; this means we have to be careful when reading
or writing to memory and do byte-addressing (the &lt;tt class="docutils literal"&gt;b&lt;/tt&gt; suffixes on &lt;tt class="docutils literal"&gt;add&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;sub&lt;/tt&gt; above) rather than the default 64-bit-addressing.&lt;/p&gt;
&lt;p&gt;The code emitted for &lt;tt class="docutils literal"&gt;.&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;,&lt;/tt&gt; is a bit more exciting; in the effort of
avoiding any external dependencies, we're going to invoke
&lt;a class="reference external" href="http://man7.org/linux/man-pages/man2/syscalls.2.html"&gt;Linux system calls&lt;/a&gt;
directly. &lt;tt class="docutils literal"&gt;WRITE&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;.&lt;/tt&gt;; &lt;tt class="docutils literal"&gt;READ&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;,&lt;/tt&gt;. We're using the x64 ABI
here with the syscall identifier in &lt;tt class="docutils literal"&gt;rax&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// To emit one byte to stdout, call the write syscall with fd=1 (for&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// stdout), buf=address of byte, count=1.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// mov $1, %rax&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// mov $1, %rdi&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// mov %r13, %rsi&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// mov $1, %rdx&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// syscall&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x4C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x89&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xEE&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x0F&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x05&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// To read one byte from stdin, call the read syscall with fd=0 (for&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// stdin),&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// buf=address of byte, count=1.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x4C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x89&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xEE&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xC2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x0F&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x05&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The comments certainly help, don't they? I hope these snippets are a great
motivation for using assembly language rather than encoding instructions
manually :-)&lt;/p&gt;
&lt;p&gt;The jump instructions are always the most interesting in BF. For &lt;tt class="docutils literal"&gt;[&lt;/tt&gt; we do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// For the jumps we always emit the instruciton for 32-bit pc-relative&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// jump, without worrying about potentially short jumps and relaxation.&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// cmpb $0, 0(%r13)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x41&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Save the location in the stack, and emit JZ (with 32-bit relative&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// offset) with 4 placeholder zeroes that will be fixed up later.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x0F&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x84&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitUint32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we don't know where this jump leads at this point - it will go to the
matching &lt;tt class="docutils literal"&gt;]&lt;/tt&gt;, which we haven't encountered yet! Therefore, to keep our
compilation in a single pass &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt; we use the time-honored technique of
&lt;em&gt;backpatching&lt;/em&gt; by emitting a placeholder value for the jump and fixing it up
once we encounter the matching label. Another thing to note is always using a
32-bit pc-relative jump, for simplicity; we could save a couple of bytes with a
short jump in most cases (see &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/01/03/assembler-relaxation"&gt;my article on assembler relaxation&lt;/a&gt; for the full
scoop), but I don't think it's worth the effort here.&lt;/p&gt;
&lt;p&gt;Compiling the matching &lt;tt class="docutils literal"&gt;]&lt;/tt&gt; is a bit trickier; I hope the comments do a good
job explaining what's going on, and the code itself is optimized for readability
rather than cleverness:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;DIE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unmatched closing &amp;#39;]&amp;#39; at pc=&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// cmpb $0, 0(%r13)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x41&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// open_bracket_offset points to the JZ that jumps to this closing&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// bracket. We&amp;#39;ll need to fix up the offset for that JZ, as well as emit a&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// JNZ with a correct offset back. Note that both [ and ] jump to the&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// instruction *after* the matching bracket if their condition is&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// fulfilled.&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Compute the offset for this jump. The jump start is computed from after&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// the jump instruction, and the target is the instruction after the one&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// saved on the stack.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jump_back_from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jump_back_to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pcrel_offset_back&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;compute_relative_32bit_offset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jump_back_from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jump_back_to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// jnz &amp;lt;open_bracket_location&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitBytes&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mh"&gt;0x0F&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x85&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitUint32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pcrel_offset_back&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Also fix up the forward jump at the matching [. Note that here we don&amp;#39;t&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// need to add the size of this jmp to the &amp;quot;jump to&amp;quot; offset, since the jmp&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// was already emitted and the emitter size was bumped forward.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jump_forward_from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jump_forward_to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pcrel_offset_forward&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;compute_relative_32bit_offset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jump_forward_from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jump_forward_to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReplaceUint32AtOffset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;open_bracket_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                &lt;/span&gt;&lt;span class="n"&gt;pcrel_offset_forward&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This concludes the compiler loop; we end up with a bunch of potentially
executable machine code in &lt;tt class="docutils literal"&gt;vector&lt;/tt&gt;. This code refers to the host program (the
address of &lt;tt class="docutils literal"&gt;memory.data()&lt;/tt&gt;), but that's OK since the host program's lifetime
wraps the lifetime of the JITed code. What's remaining is to actually invoke
this machine code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// ... after the compilation loop&lt;/span&gt;

&lt;span class="c1"&gt;// The emitted code will be called as a function from C++; therefore it has to&lt;/span&gt;
&lt;span class="c1"&gt;// use the proper calling convention. Emit a &amp;#39;ret&amp;#39; for orderly return to the&lt;/span&gt;
&lt;span class="c1"&gt;// caller.&lt;/span&gt;
&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EmitByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xC3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Load the emitted code to executable memory and run it.&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;emitted_code&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;emitter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;JitProgram&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;jit_program&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;emitted_code&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// JittedFunc is the C++ type for the JIT function emitted here. The emitted&lt;/span&gt;
&lt;span class="c1"&gt;// function is callable from C++ and follows the x64 System V ABI.&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JittedFunc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;JittedFunc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JittedFunc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;jit_program&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;program_memory&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The call should be familiar from reading the &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction"&gt;How to JIT&lt;/a&gt; post.
Note that here we opted for the simplest function possible - no arguments, no
return value; in future sections we'll spice it up a bit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="taking-our-jit-for-a-spin"&gt;
&lt;h2&gt;Taking our JIT for a spin&lt;/h2&gt;
&lt;p&gt;In &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/"&gt;part 1&lt;/a&gt;,
I presented a trivial BF program that prints the numbers 1 to 5 to the screen:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++
&amp;gt;+++++
[&amp;lt;+.&amp;gt;-]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's see what our compiler translates it to. Even though the code vector inside
&lt;tt class="docutils literal"&gt;simplejit&lt;/tt&gt; is ephemeral (lives only temporarily in memory), we can serialize
it to a binary file which we can then disassemble (with &lt;tt class="docutils literal"&gt;objdump &lt;span class="pre"&gt;-D&lt;/span&gt; &lt;span class="pre"&gt;-b&lt;/span&gt; binary
&lt;span class="pre"&gt;-mi386:x86-64&lt;/span&gt;&lt;/tt&gt;). The following is the disassembly listing with comments I
embedded to explain what's going on:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; # The runtime address of memory.data() goes into r13; note that this will
 # likely be a different value in every invocation of the JIT.

  0:   49 bd f0 54 e3 00 00    movabs $0xe354f0,%r13
  7:   00 00 00

 # A sequence of 48 instructions that all do the same, for the initial sequence
 # of +s; this makes me miss our optimizing interpreter, by worry not - we&amp;#39;ll
 # make this go away later in the post.

  a:   41 80 45 00 01          addb   $0x1,0x0(%r13)
  f:   41 80 45 00 01          addb   $0x1,0x0(%r13)

 # [...] 46 more &amp;#39;addb&amp;#39;

 # &amp;gt;+++++

 fa:   49 ff c5                inc    %r13
 fd:   41 80 45 00 01          addb   $0x1,0x0(%r13)
102:   41 80 45 00 01          addb   $0x1,0x0(%r13)
107:   41 80 45 00 01          addb   $0x1,0x0(%r13)
10c:   41 80 45 00 01          addb   $0x1,0x0(%r13)
111:   41 80 45 00 01          addb   $0x1,0x0(%r13)

 # Here comes the loop! Note that the relative jump offset is already inserted
 # into the &amp;#39;je&amp;#39; instruction by the backpatching process.

116:   41 80 7d 00 00          cmpb   $0x0,0x0(%r13)
11b:   0f 84 35 00 00 00       je     0x156
121:   49 ff cd                dec    %r13
124:   41 80 45 00 01          addb   $0x1,0x0(%r13)

 # The &amp;#39;.&amp;#39; is translated into a syscall to WRITE

129:   48 c7 c0 01 00 00 00    mov    $0x1,%rax
130:   48 c7 c7 01 00 00 00    mov    $0x1,%rdi
137:   4c 89 ee                mov    %r13,%rsi
13a:   48 c7 c2 01 00 00 00    mov    $0x1,%rdx
141:   0f 05                   syscall
143:   49 ff c5                inc    %r13
146:   41 80 6d 00 01          subb   $0x1,0x0(%r13)
14b:   41 80 7d 00 00          cmpb   $0x0,0x0(%r13)

 # Jump back to beginning of loop

150:   0f 85 cb ff ff ff       jne    0x121

 # We&amp;#39;re done

156:   c3                      retq
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-does-it-perform"&gt;
&lt;h2&gt;How does it perform?&lt;/h2&gt;
&lt;p&gt;It's time to measure the performance of our JIT against the interpreters from
part 1. &lt;tt class="docutils literal"&gt;optinterp3&lt;/tt&gt; was about 10x faster than the naive interpreter - how
will this JIT measure up? Note that it has no optimizations (except not having
to recompute the jump destination for every loop iteration as the naive
interpreter did). Can you guess? The results may surprise you...&lt;/p&gt;
&lt;p&gt;The simple JIT runs &lt;tt class="docutils literal"&gt;mandelbrot&lt;/tt&gt; in 2.89 seconds, and &lt;tt class="docutils literal"&gt;factor&lt;/tt&gt; in 0.94
seconds - much faster still than &lt;tt class="docutils literal"&gt;opt3interp&lt;/tt&gt;; here's the comparison plot
(omitting the slower interpreters since they skew the scale):&lt;/p&gt;
&lt;img alt="BF opt3 vs simplejit" class="align-center" src="https://eli.thegreenplace.net/images/2017/bf-runtime-vs-simplejit.png" /&gt;
&lt;p&gt;Why is this so? &lt;tt class="docutils literal"&gt;opt3interp&lt;/tt&gt; is heavily optimized - it folds entire loops into
a single operation; &lt;tt class="docutils literal"&gt;simplejit&lt;/tt&gt; does none of this - we've just seen the
embarrassing sequence of &lt;tt class="docutils literal"&gt;addb&lt;/tt&gt;s it emits for a long sequence of &lt;tt class="docutils literal"&gt;+&lt;/tt&gt;s.&lt;/p&gt;
&lt;p&gt;The reason is that the &lt;em&gt;baseline&lt;/em&gt; performance of the JIT is vastly better. I've
mentioned this briefly in part 1 - imagine what's needed to interpret a
single instruction in the fastest interpreter.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Advance &lt;tt class="docutils literal"&gt;pc&lt;/tt&gt; and compare it to program size.&lt;/li&gt;
&lt;li&gt;Grab the instruction at &lt;tt class="docutils literal"&gt;pc&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Switch on the value of the instruction to the right &lt;tt class="docutils literal"&gt;case&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Execute the &lt;tt class="docutils literal"&gt;case&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This requires a whole sequence of machine instructions, with at least two
branches (one for the loop, one for the &lt;tt class="docutils literal"&gt;switch&lt;/tt&gt;). On the other hand, the JIT
just emits a &lt;em&gt;single instruction&lt;/em&gt; - no branches. I would say that - depending on
what the compiler did while compiling the interpreter - the JIT is between 4 and
8 times faster at running any given BF operation. It has to run many more BF
operations because it doesn't optimize, but this difference is insufficient to
close the huge baseline gap. Later in this post we're going to see an optimized
JIT which performs even better.&lt;/p&gt;
&lt;p&gt;But first, let's talk about this painful instruction encoding business.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="manually-encoding-instructions"&gt;
&lt;h2&gt;Manually encoding instructions&lt;/h2&gt;
&lt;p&gt;As promised, &lt;tt class="docutils literal"&gt;simplejit&lt;/tt&gt; is completely self-contained. It doesn't use any
external libraries, and encodes all the instructions by hand. It's not hard to
see how painful that process is, and the code is absolutely unreadable unless
accompanied by detailed comments; moreover, changing the code is a pain, and
changes happen in unexpected ways. For example, if we want to use some other
register in an instruction, the change to emitted code won't be intuitive.
&lt;tt class="docutils literal"&gt;add %r8, %r9&lt;/tt&gt; is encoded as &lt;tt class="docutils literal"&gt;0x4C, 0x01, 0xC8&lt;/tt&gt;, but &lt;tt class="docutils literal"&gt;add %r8, %r10&lt;/tt&gt; is
&lt;tt class="docutils literal"&gt;0x4C, 0x01, 0xD0&lt;/tt&gt;; since registers are specified in sub-byte nibbles,
one needs very good memory and tons of experience to predict what goes where.&lt;/p&gt;
&lt;p&gt;Would you expect related instructions to look somewhat similar?
They don't. &lt;tt class="docutils literal"&gt;inc %r13&lt;/tt&gt; is encoded as &lt;tt class="docutils literal"&gt;0x49, 0xFF, 0xC0&lt;/tt&gt;, for example.
To put it bluntly - unless you're &lt;a class="reference external" href="http://www.catb.org/jargon/html/story-of-mel.html"&gt;Mel&lt;/a&gt;, you're going to have a
hard time. Now imagine that you have to support emitting code for multiple
architectures!&lt;/p&gt;
&lt;p&gt;This is why all compilers, VMs and related projects have their own layers to
help with this encoding task, along with related tasks like labels and jump
computations. Most are not exposed for easy usage outside their project; others,
like &lt;a class="reference external" href="http://luajit.org/dynasm.html"&gt;DynASM&lt;/a&gt; (developed as part of the LuaJIT
project) are packaged for separate usage. DynASM is an example of a low-level
framework - providing instruction encoding and not much else; some frameworks
are higher-level, doing more compiler-y things like register allocation. One
example is &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1"&gt;libjit&lt;/a&gt;;
another is LLVM.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="asmjit"&gt;
&lt;h2&gt;asmjit&lt;/h2&gt;
&lt;p&gt;While looking for a library to help me encode instructions, I initially tried
DynASM. It's an interesting approach - and you can see &lt;a class="reference external" href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html"&gt;Josh Haberman's post&lt;/a&gt;
about using it for a simple BF JIT, but I found it to be a bit too
abandonware-ish for my taste. Besides, I don't like the funky preprocessor
approach with a dependency on Lua.&lt;/p&gt;
&lt;p&gt;So I found another project that seemed to fit the bill - &lt;a class="reference external" href="https://github.com/asmjit/asmjit"&gt;asmjit&lt;/a&gt; - a pure C++ library without any
preprocessing. &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; began about 3 years ago to ease its author's
development of fast kernels for graphics code. Its documentation isn't much
better than &lt;tt class="docutils literal"&gt;dynasm&lt;/tt&gt;'s, but being just a C++ library I found it easier to dive
into the source when questions arose the docs couldn't answer. Besides, the
author is very active and quick in answering questions on GitHub and adding
missing featuers. Therefore, the rest of this post shows BF JITs that use
&lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; - these can also serve as a non-trivial tutorial for the library.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simpleasmjit-jit-with-sane-instruction-encoding"&gt;
&lt;h2&gt;simpleasmjit - JIT with sane instruction encoding&lt;/h2&gt;
&lt;p&gt;Enter &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/simpleasmjit.cpp"&gt;simpleasmjit.cpp&lt;/a&gt; -
the same simple JIT (no optimizations) as &lt;tt class="docutils literal"&gt;simplejit&lt;/tt&gt;, but using &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt;
for the instruction encoding, labels and so on. Just for fun, we'll mix things
up a bit. First, we'll change the JITed function signature from &lt;tt class="docutils literal"&gt;void
&lt;span class="pre"&gt;(*)(void)&lt;/span&gt;&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;void &lt;span class="pre"&gt;(*)(uint64_t)&lt;/span&gt;&lt;/tt&gt;; the address of the BF memory buffer will
be passed as argument into the JITed function rather than hard-coded into it.&lt;/p&gt;
&lt;p&gt;Second, we'll use actual C functions to emit / input characters, rather than
system calls. Moreover, since &lt;tt class="docutils literal"&gt;putchar&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;getchar&lt;/tt&gt; may be macros on some
systems, taking their address can be unsafe. So we'll wrap them in actual C++
functions, whose address it &lt;em&gt;is&lt;/em&gt; safe to take in emitted code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;myputchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;mygetchar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getchar&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;simpleasmjit&lt;/tt&gt; starts by initializing an &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; runtime, code holder and
assembler &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;JitRuntime&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_runtime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CodeHolder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jit_runtime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCodeInfo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;X86Assembler&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, we'll give a mnemonic name to our data pointer, and emit a copy of the
address of the memory buffer into it (it's in &lt;tt class="docutils literal"&gt;rdi&lt;/tt&gt; initially, as the first
function argument in the x64 ABI):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// We pass the data pointer as an argument to the JITed function, so it&amp;#39;s&lt;/span&gt;
&lt;span class="c1"&gt;// expected to be in rdi. Move it to r13.&lt;/span&gt;
&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;X86Gp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;r13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we get to the usual BF processing loop that emits code for every BF op:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instructions&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instructions&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// inc %r13&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// dec %r13&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// addb $1, 0(%r13)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// subb $1, 0(%r13)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice the difference! No more obscure hex codes - &lt;tt class="docutils literal"&gt;assm.inc(dataptr)&lt;/tt&gt; is so
much nicer than &lt;tt class="docutils literal"&gt;0x49, 0xFF, 0xC5&lt;/tt&gt;, isn't it?&lt;/p&gt;
&lt;p&gt;For input and output we emit calls to our wrapper functions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// call myputchar [dataptr]&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;movzx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;imm_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myputchar&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// [dataptr] = call mygetchar&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Store only the low byte to memory to avoid overwriting unrelated data.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;imm_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mygetchar&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The magic is in the &lt;tt class="docutils literal"&gt;imm_ptr&lt;/tt&gt; modifier, which places the address of the
function in the emitted code.&lt;/p&gt;
&lt;p&gt;Finally, the code handling &lt;tt class="docutils literal"&gt;[&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;]&lt;/tt&gt; is also much simpler due to asmjit's
&lt;em&gt;labels&lt;/em&gt;, which can be used before they're actually emitted:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newLabel&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;close_label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newLabel&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Jump past the closing &amp;#39;]&amp;#39; if [dataptr] = 0; close_label wasn&amp;#39;t bound&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// yet (it will be bound when we handle the matching &amp;#39;]&amp;#39;), but asmjit lets&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// us emit the jump now and will handle the back-patching later.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;close_label&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// open_label is bound past the jump; all in all, we&amp;#39;re emitting:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//    cmpb 0(%r13), 0&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//    jz close_label&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// open_label:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//    ...&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;open_label&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Save both labels on the stack.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BracketLabels&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;open_label&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;close_label&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;DIE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unmatched closing &amp;#39;]&amp;#39; at pc=&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;BracketLabels&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;labels&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//    cmpb 0(%r13), 0&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//    jnz open_label&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// close_label:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//    ...&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jnz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;labels&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open_label&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;labels&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close_label&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We just have to remember which label we used for the jump and emit the exact
same &lt;tt class="docutils literal"&gt;Label&lt;/tt&gt; object - &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; handles the backpatching on its own!
Moreover, all the jump offset computations are performed automatically.&lt;/p&gt;
&lt;p&gt;Finally, after emitting the code we can call it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JittedFunc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;JittedFunc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_runtime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// [...]&lt;/span&gt;
&lt;span class="c1"&gt;// Call it, passing the address of memory as a parameter.&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's it. This JIT emits virtually the same exact code as &lt;tt class="docutils literal"&gt;simplejit&lt;/tt&gt;, and
thus we don't expect it to perform any differently. The main point of this
exercise is to show how much simpler and more pleasant emitting code is with a
library like &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt;. It hides all the icky encoding and offset computations,
letting us focus on what's actually unique for our program - the sequence of
instructions emitted.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="optasmjit-combining-bf-optimizations-with-a-jit"&gt;
&lt;h2&gt;optasmjit - combining BF optimizations with a JIT&lt;/h2&gt;
&lt;p&gt;Finally, it's time to combine the clever optimizations we've developed in part 1
with the JIT. Here, I'm essentially taking &lt;tt class="docutils literal"&gt;optinterp3&lt;/tt&gt; from part
1 and bolting a JIT backend onto it. The result is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/optasmjit.cpp"&gt;optasmjit.cpp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Recall that instead of the 8 BF ops, we have an extended set, with integer
arguments, that conveys higher-level ops in some cases:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;BfOpKind&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;INVALID_OP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;INC_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;DEC_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;INC_DATA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;DEC_DATA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;READ_STDIN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;WRITE_STDOUT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;LOOP_SET_TO_ZERO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;LOOP_MOVE_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;LOOP_MOVE_DATA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;JUMP_IF_DATA_ZERO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;JUMP_IF_DATA_NOT_ZERO&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The translation phase from BF ops to a sequence of &lt;tt class="docutils literal"&gt;BfOpKind&lt;/tt&gt; is exactly the
same as it was in &lt;tt class="docutils literal"&gt;optinterp3&lt;/tt&gt;. Let's take a look at how a couple of the new
ops are implemented now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;BfOpKind&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;INC_PTR&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As before with the interpreters, an increment of 1 is replaced by the addition
of an argument. We use a different instruction for this - &lt;tt class="docutils literal"&gt;add&lt;/tt&gt; instead of
&lt;tt class="docutils literal"&gt;inc&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;. How about something more interesting:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;BfOpKind&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;LOOP_MOVE_DATA&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Only move if the current data isn&amp;#39;t 0:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//   cmpb 0(%r13), 0&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//   jz skip_move&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//   &amp;lt;...&amp;gt; move data&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// skip_move:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;skip_move&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newLabel&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skip_move&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Use rax as a temporary holding the value of at the original pointer;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// then use al to add it to the new location, so that only the target&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// location is affected: addb %al, 0(%r13)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;asmjit&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;x86&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;byte_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;assm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skip_move&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I'll just note again how much simpler this code is to write with &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; than
without it. Also note the careful handling of the byte-granulated data when
touching memory - I ran into a number of nasty bugs when developing this. In
fact, using the native machine word size (64 bits in this case) for BF memory
cells would've made everything much simpler; 8-bit cells are closer to the
common semantics of the language and provide an extra challenge.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;Let's see how &lt;tt class="docutils literal"&gt;optasmjit&lt;/tt&gt; fares against the fastest interpreter and the
unoptimized JIT - 0.93 seconds for &lt;tt class="docutils literal"&gt;mandelbrot&lt;/tt&gt;, 0.3 seconds for &lt;tt class="docutils literal"&gt;factor&lt;/tt&gt; -
another factor of 3 in performance:&lt;/p&gt;
&lt;img alt="BF opt3 vs simplejit vs optasmjit" class="align-center" src="https://eli.thegreenplace.net/images/2017/bf-runtime-vs-optasmjit.png" /&gt;
&lt;p&gt;Notably, the performance delta with the optimized interpreter is huge: the JIT
is more than 4x faster. If we compare it all the way to the initial simple
interpreter, &lt;tt class="docutils literal"&gt;optasmjit&lt;/tt&gt; is about 40x faster - making it hard to even
compare on the same chart :-)&lt;/p&gt;
&lt;img alt="BF full performance comparison for part 2" class="align-center" src="https://eli.thegreenplace.net/images/2017/bf-runtime-full-part2.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="jits-are-fun"&gt;
&lt;h2&gt;JITs are fun!&lt;/h2&gt;
&lt;p&gt;I find writing JITs lots of fun. It's really nice to be able to hand-craft every
instruction emitted by the compiler. While this is quite painful to do without
any encoding help, libraries like &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; make the process much more
pleasant.&lt;/p&gt;
&lt;p&gt;We've done quite a bit in this part of the series. &lt;tt class="docutils literal"&gt;optasmjit&lt;/tt&gt; is a genuine
optimizing JIT for BF! It:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Parses BF source&lt;/li&gt;
&lt;li&gt;Translates it to a sequence of higher-level ops&lt;/li&gt;
&lt;li&gt;Optimizes these ops&lt;/li&gt;
&lt;li&gt;Compiles the ops to tight x64 assembly in memory and runs them&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's connect these steps to some real compiler jargon. &lt;tt class="docutils literal"&gt;BfOpKind&lt;/tt&gt; ops can be
seen as the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Intermediate_representation"&gt;compiler IR&lt;/a&gt;. Translation of
human-readable source code to IR is often the first step in compilation (though
it in itself is sometimes divided into multiple steps for realistic languages).
The translation/compilation of ops to assembly is often called &amp;quot;lowering&amp;quot;; in
some compilers this involves multiple steps and intermediate IRs.&lt;/p&gt;
&lt;p&gt;I left a lot of code out of the blog post - otherwise it would be huge! I
encourage you to go back through the full source files discussed here and
understand what's going on - every JIT is a single standalone C++ file.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;Links to all posts in this series:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/"&gt;Part 1 - an interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/"&gt;Part 2 - an x64 JIT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-3-llvm/"&gt;Part 3 - LLVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-4-in-python/"&gt;Part 4 - Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I said &lt;em&gt;traditionally&lt;/em&gt; because many modern compilers no longer work this
way. For example, LLVM compiles IR to another, much lower-level IR that
represents machine-code level instructions; assembly can be emitted from
this IR, but also machine code directly - so the assembler is integrated
into the compiler.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Some compilers would do two passes; this is similar to our first
interpreter optimization in part 1: the first pass collects information
(such as location of all matching &lt;tt class="docutils literal"&gt;]&lt;/tt&gt;s), so the second pass already
knows what offsets to emit.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Please refer to asmjit's documentation for the full scoop. I'll also
mention that asmjit has a &amp;quot;compiler&amp;quot; layer which does more sophisticated
things like register allocation; in this post I'm only using the base
assembly layer.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Wondering whether we could have
just used &lt;tt class="docutils literal"&gt;add 1&lt;/tt&gt; instead of &lt;tt class="docutils literal"&gt;inc&lt;/tt&gt; in the first place? Certainly! In
fact, while there probably used to be a good reason for a separate
&lt;tt class="docutils literal"&gt;inc&lt;/tt&gt; instruction, in these days of complex multi-port pipelined x64
CPUs, it's not clear which one is faster. I just wanted to show both for
diversity.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Compilation"></category><category term="Code generation"></category><category term="Assembly"></category></entry><entry><title>Some notes on Luz - an assembler, linker and CPU simulator</title><link href="https://eli.thegreenplace.net/2017/some-notes-on-luz-an-assembler-linker-and-cpu-simulator/" rel="alternate"></link><published>2017-01-05T06:27:00-08:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-01-05:/2017/some-notes-on-luz-an-assembler-linker-and-cpu-simulator/</id><summary type="html">&lt;p&gt;A few years ago I &lt;a class="reference external" href="https://eli.thegreenplace.net/2010/05/05/introducing-luz"&gt;wrote about Luz&lt;/a&gt; - a
self-educational project to implement a CPU simulator and a toolchain for it,
consisting of an assembler and a linker. Since then, I received some questions
by email that made me realize I could do a better job explaining what the
project …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A few years ago I &lt;a class="reference external" href="https://eli.thegreenplace.net/2010/05/05/introducing-luz"&gt;wrote about Luz&lt;/a&gt; - a
self-educational project to implement a CPU simulator and a toolchain for it,
consisting of an assembler and a linker. Since then, I received some questions
by email that made me realize I could do a better job explaining what the
project is and what one can learn from it.&lt;/p&gt;
&lt;p&gt;So I went back to the &lt;a class="reference external" href="https://github.com/eliben/luz-cpu"&gt;Luz repository&lt;/a&gt; and
fixed it up to be more modern, in-line with current documentation standards on
GitHub. The landing &lt;cite&gt;README&lt;/cite&gt; page should now provide a good overview, but I also
wanted to write up some less formal documentation I could point to - a place to
show-off some of the more interesting features in Luz; a blog post seemed like
the perfect medium for this.&lt;/p&gt;
&lt;p&gt;As before, it makes sense to start with the Luz toplevel diagram:&lt;/p&gt;
&lt;img alt="Luz toplevel diagram" class="align-center" src="https://eli.thegreenplace.net/images/2010/05/luz_proj_toplevel.png" /&gt;
&lt;p&gt;Luz is a collection of related libraries and programs written in Python,
implementing all the stages shown in the diagram above.&lt;/p&gt;
&lt;div class="section" id="the-cpu-simulator"&gt;
&lt;h2&gt;The CPU simulator&lt;/h2&gt;
&lt;p&gt;The Luz CPU is inspired by MIPS (for the instruction set), by Altera Nios II
(for the way &amp;quot;peripherals&amp;quot; are attached to the CPU), and by MPC 555 (for the
memory controller) and is aimed at embedded uses, like Nios II. The &lt;a class="reference external" href="https://github.com/eliben/luz-cpu/blob/main/doc/luz_user_manual.rst"&gt;Luz user
manual&lt;/a&gt;
lists the complete instruction set explaining what each instructions means.&lt;/p&gt;
&lt;p&gt;The simulator itself is functional only - it performs the instructions one after
the other, without trying to simulate how long their execution takes. It's not
very remarkable and is designed to be simple and readable. The most interesting
feature it has, IMHO, is how it maps &amp;quot;peripherals&amp;quot; and even CPU control
registers into memory. Rather than providing special instructions or traps for
OS system calls, Luz facilitates &amp;quot;bare-metal&amp;quot; programming (by which I mean,
without an OS) by mapping &amp;quot;peripherals&amp;quot; into memory, allowing the programmer to
access them by reading and writing special memory locations.&lt;/p&gt;
&lt;p&gt;My inspiration here was soft-core embeddable CPUs like Nios II, which let you
configure what peripherals to connect and how to map them. The CPU can be
configured before it's loaded onto real HW, for example to attach as many SPI
interfaces as needed. For Luz, to create a new peripheral and attach it to the
simulator one implements the &lt;tt class="docutils literal"&gt;Peripheral&lt;/tt&gt; interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Peripheral&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot; An abstract memory-mapped perhipheral interface.&lt;/span&gt;
&lt;span class="sd"&gt;        Memory-mapped peripherals are accessed through memory&lt;/span&gt;
&lt;span class="sd"&gt;        reads and writes.&lt;/span&gt;

&lt;span class="sd"&gt;        The address given to reads and writes is relative to the&lt;/span&gt;
&lt;span class="sd"&gt;        peripheral&amp;#39;s memory map.&lt;/span&gt;
&lt;span class="sd"&gt;        Width is 1, 2, 4 for byte, halfword and word accesses.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;read_mem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;NotImplementedError&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;write_mem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;NotImplementedError&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Luz implements some built-in features as peripherals as well; for example, the
&lt;a class="reference external" href="https://github.com/eliben/luz-cpu/blob/main/luz_asm_sim/lib/simlib/peripheral/coreregisters.py"&gt;core registers&lt;/a&gt;
(interrupt control, exception control, etc). The idea here is that embedded CPUs
can have multiple custom &amp;quot;registers&amp;quot; to control various features, and creating
dedicated names for them bloats instruction encoding (you need 5 bits to encode
one of 32 registers, etc.); it's better to just map them to memory.&lt;/p&gt;
&lt;p&gt;Another example is the &lt;a class="reference external" href="https://github.com/eliben/luz-cpu/blob/main/luz_asm_sim/lib/simlib/peripheral/debugqueue.py"&gt;debug queue&lt;/a&gt;
- a peripheral useful for testing and debugging. It's a single word mapped to
address &lt;tt class="docutils literal"&gt;0xF0000&lt;/tt&gt; in the simulator. When the peripheral gets a write, it
stores it in a special queue and optionally emits the value to stdout. The
queue can later be examined. Here is a simple Luz assembly program that makes
use of it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Counts from 0 to 9 [inclusive], pushing these numbers into the debug queue

    .segment code
    .global asm_main

    .define ADDR_DEBUG_QUEUE, 0xF0000

asm_main:
    li $k0, ADDR_DEBUG_QUEUE

    li $r9, 10                          # r9 is the loop limit
    li $r5, 0                           # r5 is the loop counter

loop:
    sw $r5, 0($k0)                      # store loop counter to debug queue
    addi $r5, $r5, 1                    # increment loop counter
    bltu $r5, $r9, loop                 # loop back if not reached limit

    halt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the interactive runner to run this program we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ python run_test_interactive.py loop_simple_debugqueue
DebugQueue: 0x0
DebugQueue: 0x1
DebugQueue: 0x2
DebugQueue: 0x3
DebugQueue: 0x4
DebugQueue: 0x5
DebugQueue: 0x6
DebugQueue: 0x7
DebugQueue: 0x8
DebugQueue: 0x9
Finished successfully...
Debug queue contents:
[&amp;#39;0x0&amp;#39;, &amp;#39;0x1&amp;#39;, &amp;#39;0x2&amp;#39;, &amp;#39;0x3&amp;#39;, &amp;#39;0x4&amp;#39;, &amp;#39;0x5&amp;#39;, &amp;#39;0x6&amp;#39;, &amp;#39;0x7&amp;#39;, &amp;#39;0x8&amp;#39;, &amp;#39;0x9&amp;#39;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="assembler"&gt;
&lt;h2&gt;Assembler&lt;/h2&gt;
&lt;p&gt;There's a small snippet of Luz assembly shown above. It's your run-of-the-mill
RISC assembly, with the familiar set of instructions, fairly simple addressing
modes and almost every instruction requiring registers (note how we can't store
into the debug queue directly, for example, without dereferencing a register
that holds its address).&lt;/p&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/eliben/luz-cpu/blob/main/doc/luz_user_manual.rst"&gt;Luz user manual&lt;/a&gt;
contains a complete reference for the instructions, including their encodings.
Every instruction is a 32-bit word, with the 6 high bits for the opcode (meaning
up to 64 distinct instructions are supported).&lt;/p&gt;
&lt;p&gt;The code snippet also shows off some special features of the full Luz toolchain,
like the special label &lt;tt class="docutils literal"&gt;asm_main&lt;/tt&gt;. I'll discuss these later on in the section
about linking.&lt;/p&gt;
&lt;p&gt;Assembly languages are usually fairly simple to parse, and Luz is no exception.
When I started working on Luz, I decided to use the &lt;a class="reference external" href="http://www.dabeaz.com/ply/"&gt;PLY&lt;/a&gt; library for the lexer and parser mainly because I
wanted to play with it. These days I'd probably just hand-roll a parser.&lt;/p&gt;
&lt;p&gt;Luz takes another cool idea from MIPS - &lt;a class="reference external" href="https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/altReg.html"&gt;register aliases&lt;/a&gt;. While
the assembler doesn't enforce any specific ABI on the coder, some conventions are
very important when writing large assembly programs, and especially when
interfacing with routines written by other programmers. To facilitate this, Luz
designates register aliases for callee-saved registers and temporary registers.&lt;/p&gt;
&lt;p&gt;For example, the general-purpose register number 19 can be referred to in Luz
assembly as &lt;tt class="docutils literal"&gt;$r19&lt;/tt&gt; but also as &lt;tt class="docutils literal"&gt;$s1&lt;/tt&gt; - the callee-saved register 1. When
writing standalone Luz programs, one is free to ignore these conventions. To
get a taste of how ABI-conformant Luz assembly would look, take a look at
&lt;a class="reference external" href="https://github.com/eliben/luz-cpu/tree/main/luz_asm_sim/tests_full/procedure_call_stack_convention"&gt;this example&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To be honest, ABI was on my mind because I was initially envisioning a full
programming environment for Luz, including a C compiler. When you have a
compiler, you must have some set of conventions for generated code like
procedure parameter passing, saved registers and so on; in other words, the
platform ABI.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linker"&gt;
&lt;h2&gt;Linker&lt;/h2&gt;
&lt;p&gt;In my view, one of the distinguishing features of Luz from other assembler
projects out there is the linker. Luz features a full linker that supports
creating single &amp;quot;binaries&amp;quot; from multiple assembly files, handling all the dirty
work necessary to make that happen. Each assembly file is first &amp;quot;assembled&amp;quot; into
a position-independent object file; these are glued together by the linker which
applies the necessary relocations to resolve symbols across object files. The
&lt;a class="reference external" href="https://github.com/eliben/luz-cpu/tree/main/luz_asm_sim/tests_full/prime_sieve"&gt;prime sieve example&lt;/a&gt;
shows this in action - the program is divided into three &lt;tt class="docutils literal"&gt;.lasm&lt;/tt&gt; files: two
for subroutines and one for &amp;quot;main&amp;quot;.&lt;/p&gt;
&lt;p&gt;As we've seen above, the main subroutine in Luz is called &lt;tt class="docutils literal"&gt;asm_main&lt;/tt&gt;. This is
a special name for the linker (not unlike the &lt;tt class="docutils literal"&gt;_start&lt;/tt&gt; symbol for &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux"&gt;modern
Linux assemblers&lt;/a&gt;).
The linker collects a set of object files produced by assembly, and makes sure
to invoke &lt;tt class="docutils literal"&gt;asm_main&lt;/tt&gt; from the special location &lt;tt class="docutils literal"&gt;0x100000&lt;/tt&gt;. This is where
the simulator starts execution.&lt;/p&gt;
&lt;p&gt;Luz also has the concept of &lt;a class="reference external" href="https://github.com/eliben/luz-cpu/blob/main/luz_asm_sim/lib/asmlib/objectfile.py"&gt;object files&lt;/a&gt;.
They are not unlike ELF images in nature: there's a segment table, an export
table and a relocation table for each object, serving the expected roles. It is
the job of the linker to make sense in this list of objects and correctly
connect all call sites to final subroutine addresses.&lt;/p&gt;
&lt;p&gt;Luz's &lt;a class="reference external" href="https://github.com/eliben/luz-cpu/blob/main/luz_asm_sim/luz_asm.py"&gt;standalone assembler&lt;/a&gt; can
write an assembled image into a file in &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Intel_HEX"&gt;Intel HEX format&lt;/a&gt;, a popular format used in embedded
systems to encode binary images or data in ASCII.&lt;/p&gt;
&lt;p&gt;The linker was quite a bit of effort to develop. Since all real Luz programs are
small I didn't really need to break them up into multiple assembly files; but
I really wanted to learn how to write a real linker :) Moreover, as already
mentioned my original plans for Luz included a C compiler, and that would make a
linker very helpful, since I'd need to link some &amp;quot;system&amp;quot; code into the user's
program. Even today, Luz has some &amp;quot;startup code&amp;quot; it links into every image:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# The special segments added by the linker.
# __startup: 3 words
# __heap: 1 word
#
LINKER_STARTUP_CODE = string.Template(r&amp;#39;&amp;#39;&amp;#39;
        .segment __startup

    LI      $$sp, ${SP_POINTER}
    CALL    asm_main

        .segment __heap
        .global __heap
    __heap:
        .word 0
&amp;#39;&amp;#39;&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code sets up the stack pointer to the initial address allocated for the
stack, and calls the user's &lt;tt class="docutils literal"&gt;asm_main&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="debugger-and-disassembler"&gt;
&lt;h2&gt;Debugger and disassembler&lt;/h2&gt;
&lt;p&gt;Luz comes with a simple program runner that will execute a Luz program
(consisting of multiple assembly files); it also has an interactive mode - a
debugger. Here's a sample session with the simple loop example shown above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ python run_test_interactive.py -i loop_simple_debugqueue

LUZ simulator started at 0x00100000

[0x00100000] [lui $sp, 0x13] &amp;gt;&amp;gt; set alias 0
[0x00100000] [lui $r29, 0x13] &amp;gt;&amp;gt; s
[0x00100004] [ori $r29, $r29, 0xFFFC] &amp;gt;&amp;gt; s
[0x00100008] [call 0x40003 [0x10000C]] &amp;gt;&amp;gt; s
[0x0010000C] [lui $r26, 0xF] &amp;gt;&amp;gt; s
[0x00100010] [ori $r26, $r26, 0x0] &amp;gt;&amp;gt; s
[0x00100014] [lui $r9, 0x0] &amp;gt;&amp;gt; s
[0x00100018] [ori $r9, $r9, 0xA] &amp;gt;&amp;gt; s
[0x0010001C] [lui $r5, 0x0] &amp;gt;&amp;gt; s
[0x00100020] [ori $r5, $r5, 0x0] &amp;gt;&amp;gt; s
[0x00100024] [sw $r5, 0($r26)] &amp;gt;&amp;gt; s
[0x00100028] [addi $r5, $r5, 0x1] &amp;gt;&amp;gt; s
[0x0010002C] [bltu $r5, $r9, -2] &amp;gt;&amp;gt; s
[0x00100024] [sw $r5, 0($r26)] &amp;gt;&amp;gt; s
[0x00100028] [addi $r5, $r5, 0x1] &amp;gt;&amp;gt; s
[0x0010002C] [bltu $r5, $r9, -2] &amp;gt;&amp;gt; s
[0x00100024] [sw $r5, 0($r26)] &amp;gt;&amp;gt; s
[0x00100028] [addi $r5, $r5, 0x1] &amp;gt;&amp;gt; r
$r0   = 0x00000000   $r1   = 0x00000000   $r2   = 0x00000000   $r3   = 0x00000000
$r4   = 0x00000000   $r5   = 0x00000002   $r6   = 0x00000000   $r7   = 0x00000000
$r8   = 0x00000000   $r9   = 0x0000000A   $r10  = 0x00000000   $r11  = 0x00000000
$r12  = 0x00000000   $r13  = 0x00000000   $r14  = 0x00000000   $r15  = 0x00000000
$r16  = 0x00000000   $r17  = 0x00000000   $r18  = 0x00000000   $r19  = 0x00000000
$r20  = 0x00000000   $r21  = 0x00000000   $r22  = 0x00000000   $r23  = 0x00000000
$r24  = 0x00000000   $r25  = 0x00000000   $r26  = 0x000F0000   $r27  = 0x00000000
$r28  = 0x00000000   $r29  = 0x0013FFFC   $r30  = 0x00000000   $r31  = 0x0010000C

[0x00100028] [addi $r5, $r5, 0x1] &amp;gt;&amp;gt; s 100
[0x00100030] [halt] &amp;gt;&amp;gt; q
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are many interesting things here demonstrating how Luz works:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Note the start up at &lt;tt class="docutils literal"&gt;0x1000000&lt;/tt&gt; - this is where Luz places the start-up
segment - three instructions that set up the stack pointer and then &lt;tt class="docutils literal"&gt;call&lt;/tt&gt;
the user's code (&lt;tt class="docutils literal"&gt;asm_main&lt;/tt&gt;). The user's &lt;tt class="docutils literal"&gt;asm_main&lt;/tt&gt; starts running at
the fourth instruction executed by the simulator.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;li&lt;/tt&gt; is a pseudo-instruction, broken into two real instructions: &lt;tt class="docutils literal"&gt;lui&lt;/tt&gt;
for the upper half of the register, followed by &lt;tt class="docutils literal"&gt;ori&lt;/tt&gt; for the lower half of
the register. The reason for this is &lt;tt class="docutils literal"&gt;li&lt;/tt&gt; having a 32-bit immediate, which
can't fit in a Luz instruction. Therefore, it's broken into two parts which
only need 16-bit immediates. This trick is common in RISC ISAs.&lt;/li&gt;
&lt;li&gt;Jump labels are resolved to be relative by the assembler: the jump to &lt;tt class="docutils literal"&gt;loop&lt;/tt&gt;
is replaced by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-2&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Disassembly! The debugger shows the instruction decoded from every word where
execution stops. Note how this exposes pseudo-instructions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="the-in-progress-rtl-implementation"&gt;
&lt;h2&gt;The in-progress RTL implementation&lt;/h2&gt;
&lt;p&gt;Luz was a hobby project, but an ambitious one :-) Even before I wrote the first
line of the assembler or simulator, I started working on an actual CPU
implementation in synthesizable VHDL, meaning to get a complete RTL image to run
on FPGAs. Unfortunately, I didn't finish this part of the project
and what you find in Luz's &lt;tt class="docutils literal"&gt;experimental/luz_uc&lt;/tt&gt; directory is only 75%
complete. The ALU is there, the registers, the hookups to peripherals, even
parts of the control path - dealing with instruction fetching, decoding, etc. My
original plan was to implement a pipelined CPU (a RISC ISA makes this relatively
simple), which perhaps was a bit too much. I should have started simpler.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Luz was an extremely educational project for me. When I started working on it,
I mostly had embedded programming experience and was just starting to get
interested in systems programming. Luz flung me into the world of assemblers,
linkers, binary images, calling conventions, and so on. Besides, Python was
a new language for me at the time - Luz started just months after
&lt;a class="reference external" href="https://eli.thegreenplace.net/2008/05/14/python"&gt;I first got into Python&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Its ~8000 lines of Python code are thus likely not my best Python code, but they
should be readable and well commented. I did modernize it a bit over the years,
for example to make it run on both Python 2 and 3.&lt;/p&gt;
&lt;p&gt;I still hope to get back to the RTL implementation project one day. It's really
very close to being able to run realistic assembly programs on &lt;em&gt;real hardware&lt;/em&gt;
(FPGAs). My dream back then was to fully close the loop by adding a Luz code
generation backend to &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser&lt;/a&gt;. Maybe
I'll still fulfill it one day :-)&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Assembly"></category><category term="EE &amp; Embedded"></category><category term="Linkers and Loaders"></category><category term="Python"></category></entry><entry><title>wc in x64 assembly</title><link href="https://eli.thegreenplace.net/2016/wc-in-x64-assembly/" rel="alternate"></link><published>2016-08-23T05:18:00-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-08-23:/2016/wc-in-x64-assembly/</id><summary type="html">&lt;p&gt;In the past few weeks there appears to be a resurgence of interest in assembly
programming; most likely, this is due to the release of the source code for the
&lt;a class="reference external" href="https://github.com/chrislgarry/Apollo-11"&gt;Appolo 11 guidance computer on GitHub&lt;/a&gt; - a truly awesome repository, if
you haven't seen it yet.&lt;/p&gt;
&lt;p&gt;This inspired me to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the past few weeks there appears to be a resurgence of interest in assembly
programming; most likely, this is due to the release of the source code for the
&lt;a class="reference external" href="https://github.com/chrislgarry/Apollo-11"&gt;Appolo 11 guidance computer on GitHub&lt;/a&gt; - a truly awesome repository, if
you haven't seen it yet.&lt;/p&gt;
&lt;p&gt;This inspired me to dig up a project I did ~3 years ago - a reimplementation of
the &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; command-line tool in pure x64 assembly. It's been &lt;a class="reference external" href="https://github.com/eliben/wcx64"&gt;open on GitHub&lt;/a&gt; from the start, but I never really mentioned
it anywhere. Summoning my best powers of imagination, I named the project...
wait for it... &lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt;. It's ~400 lines of assembly code (most of which are
comments) in the default &lt;a class="reference external" href="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax"&gt;gas syntax&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As a compiler hacker, and an embedded programmer back in the day, I've done my
share of writing and digging in assembly code; wrote &lt;a class="reference external" href="https://eli.thegreenplace.net/2010/05/05/introducing-luz"&gt;my own assembler&lt;/a&gt;, and did work on
LLVM's assembler. There's an &lt;a class="reference external" href="https://eli.thegreenplace.net/tag/assembly"&gt;Assembly tag&lt;/a&gt; in this blog with a bunch of posts
being assembly-related. I wrote &amp;quot;production&amp;quot; assembly for many architectures -
from small 8-bit controllers, to x64, to obscure DSPs. However, almost all of
this code was self-contained for very specific tasks.&lt;/p&gt;
&lt;p&gt;The idea of &lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt; was to understand how realistic programs could be written
from start to end, including dealing with the OS, the file system, input-output
and so on. It's a nice &amp;quot;code kata&amp;quot; exercise I find useful when exploring new
programming languages, because you get to do a lot of things &amp;quot;real&amp;quot; programs do,
just confined to a very simple task. Here are some of the interesting things
you'll find in &lt;a class="reference external" href="https://github.com/eliben/wcx64"&gt;the code&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Processing command-line arguments (&lt;tt class="docutils literal"&gt;argc&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;Reading from files and from the standard input and writing to standard output,
using system calls.&lt;/li&gt;
&lt;li&gt;Writing functions that adhere to the x64 ABI calling convention, including
passing and returning arguments and callee-saved registers.&lt;/li&gt;
&lt;li&gt;Fundamentals of string processing: very simple parsing of text using a
two-state state machine, converting numbers to strings, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And some facts about the outcome:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt; doesn't need any C runtime/support code to work. It invokes Linux
system calls directly, and is completely self-contained.&lt;/li&gt;
&lt;li&gt;When assembled and linked, the binary size is 6.5 Kib.&lt;/li&gt;
&lt;li&gt;It's fast! On a couple of samples I tried, it's between 6 and 13 times faster
than the command-line &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; tool for processing 1 GiB files.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The performance is surprising to me. I didn't expect the difference to be this
great. True, the inner loop of &lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt; is tight assembly, but I really didn't
spend any time optimizing it, opting for clarity instead. My guess is that the
real &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; supports more features, like multi-byte characters.&lt;/p&gt;
</content><category term="misc"></category><category term="Assembly"></category></entry><entry><title>C++: Deleting destructors and virtual operator delete</title><link href="https://eli.thegreenplace.net/2015/c-deleting-destructors-and-virtual-operator-delete/" rel="alternate"></link><published>2015-08-21T05:37:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2015-08-21:/2015/c-deleting-destructors-and-virtual-operator-delete/</id><summary type="html">&lt;p&gt;This post starts with a fairly obscure topic - how an overloaded &lt;tt class="docutils literal"&gt;operator
delete&lt;/tt&gt; behaves in light of polymorphism; amazingly, it then gets even more
obscure - shedding light on the trickery the compiler employs to make this
work, by generating more than one destructor for certain classes. If you're into
such …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post starts with a fairly obscure topic - how an overloaded &lt;tt class="docutils literal"&gt;operator
delete&lt;/tt&gt; behaves in light of polymorphism; amazingly, it then gets even more
obscure - shedding light on the trickery the compiler employs to make this
work, by generating more than one destructor for certain classes. If you're into
such things, read on. If not, sorry about that; I heard that three new
Javascript libraries were released this week for MVC JSON-based dynamic CSS
layout. Everyone's switching! Hurry up to keep up with the cool guys and leave
this grumpy compiler engineer to mumble to himself.&lt;/p&gt;
&lt;div class="section" id="virtual-operator-delete"&gt;
&lt;h2&gt;Virtual operator delete?&lt;/h2&gt;
&lt;p&gt;Consider this code sample:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Animal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Sheep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Sheep says baaaaa&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Sheep&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Sheep is dead&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Reclaiming Sheep storage from %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sheep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happens when &lt;tt class="docutils literal"&gt;ap&lt;/tt&gt; is deleted? Two things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The destructor of the object pointed to by &lt;tt class="docutils literal"&gt;ap&lt;/tt&gt; is called.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; is called on &lt;tt class="docutils literal"&gt;ap&lt;/tt&gt; to reclaim heap storage.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Part 1 is fairly clear: the &lt;em&gt;static&lt;/em&gt; type of &lt;tt class="docutils literal"&gt;ap&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;Animal&lt;/tt&gt;, but the
compiler knows that &lt;tt class="docutils literal"&gt;Animal&lt;/tt&gt; has a virtual destructor. So it looks up the
&lt;em&gt;actual&lt;/em&gt; destructor to invoke in the virtual table stored in the object &lt;tt class="docutils literal"&gt;ap&lt;/tt&gt;
points to. Since the &lt;em&gt;dynamic&lt;/em&gt; type of &lt;tt class="docutils literal"&gt;ap&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;Sheep&lt;/tt&gt;, the destructor found
there will be &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Sheep::~Sheep&lt;/span&gt;&lt;/tt&gt;, which is correct.&lt;/p&gt;
&lt;p&gt;What about that &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt;, though? Is &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; virtual too?
Is is also stored in the virtual table? Because if it isn't, how does the
compiler know which &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; to invoke?&lt;/p&gt;
&lt;p&gt;No, &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; is &lt;em&gt;not&lt;/em&gt; virtual. It is &lt;em&gt;not&lt;/em&gt; stored in the virtual
table. In fact, &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; is a static member. The C++11 standard says
so explicitly in secton 12.5:&lt;/p&gt;
&lt;blockquote&gt;
Any deallocation function for a class X is a static member (even if not
explicitly declared &lt;tt class="docutils literal"&gt;static&lt;/tt&gt;).&lt;/blockquote&gt;
&lt;p&gt;It also adds:&lt;/p&gt;
&lt;blockquote&gt;
Since member allocation and deallocation functions are static they cannot be
virtual.&lt;/blockquote&gt;
&lt;p&gt;And if you keep reading, it actually mandates that even though this is the case,
when the base destructor is virtual &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; will be correctly looked
up in the scope of the class that is the &lt;em&gt;dynamic&lt;/em&gt;, not the &lt;em&gt;static&lt;/em&gt; type of the
object.&lt;/p&gt;
&lt;p&gt;Indeed, the code snippet above works correctly and prints:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Sheep says baaaaa
Sheep is dead
Reclaiming Sheep storage from 0x1ed1be0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="deleting-destructor"&gt;
&lt;h2&gt;Deleting destructor&lt;/h2&gt;
&lt;p&gt;So how does this work, if &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; is not virtual? Then answer is in
a special destructor created for by the compiler. It's called the &lt;em&gt;deleting
destructor&lt;/em&gt; and its existence is described by the &lt;a class="reference external" href="https://mentorembedded.github.io/cxx-abi/abi.html"&gt;Itanium C++ ABI&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;em&gt;deleting destructor of a class T&lt;/em&gt; -  A function that, in addition to the
actions required of a complete object destructor, calls the appropriate
deallocation function (i.e,. &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt;) for T.&lt;/blockquote&gt;
&lt;p&gt;The ABI goes on to provide more details:&lt;/p&gt;
&lt;blockquote&gt;
The entries for virtual destructors are actually pairs of entries. The first
destructor, called the complete object destructor, performs the destruction
without calling delete() on the object. The second destructor, called the
deleting destructor, calls delete() after destroying the object.&lt;/blockquote&gt;
&lt;p&gt;So now the mechanics of this operation should be fairly clear. The compiler
mimics &amp;quot;virtuality&amp;quot; of &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; by invoking it from the destructor.
Since the destructor is virtual, what ends up called eventually is the
destructor for the dynamic type of the object. In our example this would be
the destructor of &lt;tt class="docutils literal"&gt;Sheep&lt;/tt&gt;, which can call the right &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; since
it's in the same static scope.&lt;/p&gt;
&lt;p&gt;However, as the ABI says, such classes need two destructors. If an object is
destructed but not deleted from the heap, calling &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; is wrong.
So a separate version of the destructor exists for non-&lt;tt class="docutils literal"&gt;delete&lt;/tt&gt; destructions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="examining-how-the-compiler-implements-deleting-destructors"&gt;
&lt;h2&gt;Examining how the compiler implements deleting destructors&lt;/h2&gt;
&lt;p&gt;That's quite a bit of theory. Let's see how this is done in practice by studying
the machine code generated by gcc for our code sample. First, I'll slightly
modify &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; to invoke another function that just creates and discards a new
&lt;tt class="docutils literal"&gt;Sheep&lt;/tt&gt; without involving the heap.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Sheep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sheep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And compiling this with the flags &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;g++ -O2 -g -static -std=c++11 -fno-inline -fno-exceptions
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get the following disassembly for &lt;tt class="docutils literal"&gt;main&lt;/tt&gt;. I've annotated the disassembly
with comments to explain what's going on:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mo"&gt;0000000000400&lt;/span&gt;&lt;span class="n"&gt;cf0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cf0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cf1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;$0x8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call operator new to allocate a new object of type Sheep, and call&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// the constructor of Sheep. Neither Sheep nor Animal have fields, so&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// their size is 8 bytes for the virtual table pointer.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// The pointer to the object will live in %rbx. The vtable pointer in this&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// object (set up by the constructor of Sheep) points to the the virtual&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// table of Sheep, because this is the actual type of the object (even&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// though we hold it by a pointer to Animal here).&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cf6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401750&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Znwm&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cfb&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cfe&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4011f&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN5SheepC1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// The first 8 bytes of an Animal object is the vtable pointer. So move&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// the address of vtable into %rax, and the object pointer itself (&amp;quot;this&amp;quot;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// into %rdi.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Since the vtable&amp;#39;s first entry is the say() method, the call that&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// actually happens here is Sheep::say(ap) where ap is the object pointer&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// passed into the (implicit) &amp;quot;this&amp;quot; parameter.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d06&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d09&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d0c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Once again, move the vtable address into %rax and the object pointer&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// into %rdi. This time, invoke the function that lives at offset 0x10 in&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// the vtable. This is the deleting destructor, as we&amp;#39;ll soon see.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d0e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d11&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d14&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;0x10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Finally call foo() and return.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d17&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4010&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Z3foov&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d1c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d1e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d1f&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;retq&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A diagram of the memory layout of the virtual table for &lt;tt class="docutils literal"&gt;Sheep&lt;/tt&gt; can be helpful
here. Since neither &lt;tt class="docutils literal"&gt;Animal&lt;/tt&gt; nor &lt;tt class="docutils literal"&gt;Sheep&lt;/tt&gt; have any fields, the only
&amp;quot;contents&amp;quot; of a &lt;tt class="docutils literal"&gt;Sheep&lt;/tt&gt; object is the vtable pointer which occupies the first
8 bytes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                          Virtual table for Sheep:
ap:
--------------            -----------------------
| vtable ptr | ---------&amp;gt; |     Sheep::say()    |  0x00
--------------            -----------------------
                          |   Sheep::~Sheep()   |  0x08
                          -----------------------
                          | Sheep deleting dtor |  0x10
                          -----------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The two destructors seen here have the roles described earlier. Let's see their
annotated disassembly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Sheep::~Sheep&lt;/span&gt;
&lt;span class="mo"&gt;0000000000401140&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN5SheepD1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call printf(&amp;quot;Sheep is dead\n&amp;quot;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401140&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401141&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;$0x49dc7c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;esi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401146&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401149&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;movq&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;$0x49dd50&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401150&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401152&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;$0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401157&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;446260&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;___printf_chk&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;40115&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;40115f&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call Animal::~Animal, destroying the base class. Note the cool tail&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// call here (using jmpq instead of a call instruction - control does not&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// return here but the return instruction from _ZN6AnimalD1Ev will return&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// straight to the caller).&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401160&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;jmpq&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;4010f&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN6AnimalD1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401165&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nopw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;40116f&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nop&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Sheep deleting destructor. The D0 part of the mangled name for deleting&lt;/span&gt;
&lt;span class="c1"&gt;// destructors, as opposed to D1 for the regular destructor, is mandated by&lt;/span&gt;
&lt;span class="c1"&gt;// the ABI name mangling rules.&lt;/span&gt;
&lt;span class="mo"&gt;00000000004011&lt;/span&gt;&lt;span class="n"&gt;c0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN5SheepD0Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;c0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call Sheep::~Sheep&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401140&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN5SheepD1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;c9&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;cc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call Sheep::operator delete&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;jmpq&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mi"&gt;401190&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN5SheepdlEPv&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;d2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nopw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4011&lt;/span&gt;&lt;span class="n"&gt;dc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nopl&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, going back to the amended code sample, let's see what code is generated for
&lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mo"&gt;00000000004010&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Z3foov&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4010&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;$0x18&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4010&lt;/span&gt;&lt;span class="n"&gt;d4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4010&lt;/span&gt;&lt;span class="n"&gt;d7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;movq&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;$0x49dd30&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4010&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401140&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN5SheepD1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4010e4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;$0x18&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4010e8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;retq&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4010e9&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nopl&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; just calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Sheep::~Sheep&lt;/span&gt;&lt;/tt&gt;. It shouldn't call the deleting destructor,
because it does not actually delete an object from the heap.&lt;/p&gt;
&lt;p&gt;It is also interesting to examine how the destructor(s) of &lt;tt class="docutils literal"&gt;Animal&lt;/tt&gt; look,
since unlike &lt;tt class="docutils literal"&gt;Sheep&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;Animal&lt;/tt&gt; does not define a custom &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Animal::~Animal&lt;/span&gt;
&lt;span class="mf"&gt;00000000004010f&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN6AnimalD1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4010f&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;movq&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;$0x49dcf0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4010f&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;retq&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4010f&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nopl&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Animal deleting destructor&lt;/span&gt;
&lt;span class="mo"&gt;0000000000401100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN6AnimalD0Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401100&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call Animal::~Animal&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401101&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401104&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;4010f&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN6AnimalD1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401109&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;40110&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call global ::operator::delete&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;40110&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;jmpq&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;4011f&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZdlPv&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401112&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nopw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;40111&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nopl&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As expected, the destructor of &lt;tt class="docutils literal"&gt;Animal&lt;/tt&gt; calls the global &lt;tt class="docutils literal"&gt;::operator
delete&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="classes-with-virtual-destructors-vs-regular-destructors"&gt;
&lt;h2&gt;Classes with virtual destructors vs. regular destructors&lt;/h2&gt;
&lt;p&gt;I want to emphasize that this special treatment - generation of a deleting
destructor, is done not for classes that have a custom &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt;, but
for all classes with virtual destructors. This is because when we &lt;tt class="docutils literal"&gt;delete&lt;/tt&gt; an
object through a pointer to the base class, the compiler has no way of knowing
what &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; to invoke, so this has to be done for every class
where the destructor is virtual &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. Here's a clarifying example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Regular&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Regular&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Regular dtor&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Virtual&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Virtual dtor&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Regular&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Regular&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Virtual&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Virtual&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only difference between &lt;tt class="docutils literal"&gt;Regular&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Virtual&lt;/tt&gt; here is the destructor
being virtual in the latter. Let's examine the machine code for &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; to see
how the two &lt;tt class="docutils literal"&gt;delete&lt;/tt&gt; statements are lowered:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mo"&gt;0000000000400&lt;/span&gt;&lt;span class="n"&gt;cf0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cf0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cf1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;$0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Allocate a new Regular object with the global ::operator new&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cf6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4016&lt;/span&gt;&lt;span class="n"&gt;a0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Znwm&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// If hr != nullptr, call Regular::~Regular, and then call the global&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// ::operator delete on hr.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cfb&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;cfe&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;je&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d13&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x23&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d03&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d06&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401130&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN7RegularD1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d0b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d0e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401160&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZdlPv&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d13&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;$0x8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Allocate a new Virtual object with the global ::operator new&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4016&lt;/span&gt;&lt;span class="n"&gt;a0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Znwm&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d1d&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d20&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Call the constructor for Virtual. We didn&amp;#39;t define a default&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// constructor, but the compiler did - to populate the vtable pointer&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// properly.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;401150&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_ZN7VirtualC1Ev&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// If hv != nullptr, call the deleting destructor of Virtual through the&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// virtual table. Do not call operator delete for vr; this will be done by&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// the deleting destructor.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d28&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d2b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;je&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d36&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x46&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d2d&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d30&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rdi&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d33&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;callq&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;0x8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d36&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d38&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d39&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;retq&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="n"&gt;d3a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;nopw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key difference here is that for deleting &lt;tt class="docutils literal"&gt;Regular&lt;/tt&gt;, the compiler inserts a
call to the (global) &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt; after the destructor. However, for
&lt;tt class="docutils literal"&gt;Virtual&lt;/tt&gt; it can't do that so it just calls the deleting destructor, which
will take care of the deletion as we've seen earlier.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Why this set of options? Without &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O2&lt;/span&gt;&lt;/tt&gt;, the code produced by the
compiler is overly verbose. With &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O2&lt;/span&gt;&lt;/tt&gt; it's much better but most
function calls are inlined, making the special calls generated for the
deleting destructor hard to follow; hence &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fno-inline&lt;/span&gt;&lt;/tt&gt;. I'm also
disabling exceptions because these complicate the code around destructors
without being relevant to the main goal of the article.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;One of the derived classes may declare its own &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt;, and
the compiler doesn't know that. In fact, a pointer to a derived class can
come from a shared library that was built completely separately from the
main program (as &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2015/operator-delete-shared-lib"&gt;this sample demonstrates&lt;/a&gt; ).&lt;/p&gt;
&lt;p class="last"&gt;But even if none of the derived classes defines a custom &lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt;,
it's important to know the dynamic type of the deleted object when the
destructor is called to pass the correct address to the global
&lt;tt class="docutils literal"&gt;operator delete&lt;/tt&gt;. An interesting discussion of this issue can be found
in &lt;a class="reference external" href="https://www.reddit.com/r/cpp/comments/3huvd1/c_deleting_destructors_and_virtual_operator_delete/cuay6u1"&gt;this Reddit comment thread&lt;/a&gt;.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="C &amp; C++"></category><category term="Assembly"></category><category term="Compilation"></category></entry><entry><title>Getting started with libjit - part 3</title><link href="https://eli.thegreenplace.net/2014/01/07/getting-started-with-libjit-part-3" rel="alternate"></link><published>2014-01-07T06:00:59-08:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-01-07:/2014/01/07/getting-started-with-libjit-part-3</id><summary type="html">
        &lt;p&gt;This is part 3 in a series of articles on libjit. &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;Part 1&lt;/a&gt; served as a basic introduction to the library and showed how to get started, along with some simple performance measurements. &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/12/getting-started-with-libjit-part-2/"&gt;Part 2&lt;/a&gt; peered deeper into the capabilities of libjit, focusing on interface between native and JITed code …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;This is part 3 in a series of articles on libjit. &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;Part 1&lt;/a&gt; served as a basic introduction to the library and showed how to get started, along with some simple performance measurements. &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/12/getting-started-with-libjit-part-2/"&gt;Part 2&lt;/a&gt; peered deeper into the capabilities of libjit, focusing on interface between native and JITed code. In this part, I'm switching gears and looking at the internals of libjit. I'll follow through the compilation of a simple function with libjit, highlighting some interesting aspects of libjit's design on the way.&lt;/p&gt;
&lt;div class="section" id="input-code"&gt;
&lt;h3&gt;Input code&lt;/h3&gt;
&lt;p&gt;I'll reuse the iterative GCD example from part 1. The equivalent C code is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;gcd_iter&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; u, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; v) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; t;
  &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; (v) {
    t = u;
    u = v;
    v = t % v;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; u &amp;lt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; ? -u : u; &lt;span style="color: #007f00"&gt;/* abs(u) */&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Take a look at &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;part 1&lt;/a&gt; (or the &lt;tt class="docutils literal"&gt;gcd_iter.c&lt;/tt&gt; sample in &lt;a class="reference external" href="https://github.com/eliben/libjit-samples"&gt;the repository&lt;/a&gt;) for details on the libjit calls required to emulate this function.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="libjit-ir"&gt;
&lt;h3&gt;libjit IR&lt;/h3&gt;
&lt;p&gt;The libjit API includes &lt;tt class="docutils literal"&gt;jit_dump_function&lt;/tt&gt;, which can dump the contents of a &lt;tt class="docutils literal"&gt;jit_function_t&lt;/tt&gt; for us. It has two modes of operation. Before the function is compiled to native code, the libjit IR will be dumped. If the function has already been compiled (with &lt;tt class="docutils literal"&gt;jit_function_compile&lt;/tt&gt;), the produced machine code is disassembled &lt;a class="footnote-reference" href="#id7" id="id2"&gt;[1]&lt;/a&gt; and the assembly is dumped. In this article we'll be looking at both dumps, starting with the &amp;quot;uncompiled&amp;quot; libjit IR.&lt;/p&gt;
&lt;p&gt;Before I show the IR dump, a short introduction to how libjit does things. Internally, the IR is divided into &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Basic_block"&gt;basic blocks&lt;/a&gt;, which is a convenient abstraction often used by compilers to represent intermediate code. Basic blocks may serve as targets of braches (&lt;tt class="docutils literal"&gt;goto&lt;/tt&gt; instructions in libjit IR); therefore, each may have one or more labels referring to it. The libjit API has functions that explicitly create basic blocks, but the functions I used do so implicitly. This is more convenient. For example, &lt;tt class="docutils literal"&gt;jit_insn_branch_if&lt;/tt&gt; both ends the current basic block (because it's an exit point) and may create an additional basic block at its destination (unless it already exists).&lt;/p&gt;
&lt;p&gt;Another thing to note is that while C code that uses the libjit API has named variables for values and labels, libjit is oblivious to it. Unlike LLVM, libjit does not have a way to give meaningful names to values and labels, so it just generates numbered names. However, even so the correspondence between libjit API calls and the IR is very obvious and easy to follow, as the following annotated dump shows. I'm using some of the nomenclature (such as label names) from the API calls in the comments to help pinpoint the correspondence between them.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt; gcd [uncompiled](i1 : &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;, i2 : &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;) : &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// Note that some ABI details are exposed here. This is built on&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// a x64 Linux machine, where the first two integer arguments to&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// a function are passed in rdi and rsi&lt;/span&gt;
      incoming_reg(i1, rdi)
      incoming_reg(i2, rsi)
      &lt;span style="color: #007f00"&gt;// label_while:&lt;/span&gt;
.L0:
      &lt;span style="color: #007f00"&gt;// if (v == 0) goto label_after_while&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// libjit folds a comparison instruction into a branch - hence it&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// seems that i7 is not necessary and can be optimized away as&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// dead code&lt;/span&gt;
      i7 = i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L1
.L:
      &lt;span style="color: #007f00"&gt;// t &amp;lt;- u&lt;/span&gt;
      i5 = i1
      &lt;span style="color: #007f00"&gt;// u &amp;lt;- v&lt;/span&gt;
      i1 = i2
      &lt;span style="color: #007f00"&gt;// v &amp;lt;- t % v via a temporary&lt;/span&gt;
      i8 = i5 % i2
      i2 = i8 i7 = i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L2

      &lt;span style="color: #007f00"&gt;// goto label_while&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L0
      &lt;span style="color: #007f00"&gt;// ends_in_dead is a marker libjit places on blocks that don&amp;#39;t&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// have a fall-through edge. These are blocks that end with&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// unconditional branches, returns, etc.&lt;/span&gt;
      ends_in_dead
.L1:
      i9 = i1 &amp;gt;= &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// if (u &amp;gt;= 0) then goto label_pos&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i1 &amp;gt;= &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L2
.L:
      &lt;span style="color: #007f00"&gt;// return -u&lt;/span&gt;
      i10 = -i1
      return_int(i10)
      ends_in_dead
.L2:
      &lt;span style="color: #007f00"&gt;// label_pos: return u&lt;/span&gt;
      return_int(i1)
      ends_in_dead
.L:
.L:
end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most important thing to remember about this IR dump is that it's very closely parallel to the libjit API calls used to create it. In this respect, libjit is very much like LLVM: the IR is directly created by the builder API. An important difference is that unlike LLVM, where a textual representation of the IR is a language that can be used for full serialization (and even directly programmed in), in the case of libjit no such representation exists. The above is just a dump for debugging purposes.&lt;/p&gt;
&lt;p&gt;I still think it's pretty useful for verifying that the code created by the API calls makes sense. While less important when the API calls are made manually, as they were here, it becomes crucial when the calls are generated programmatically - such as by a front-end that compiles some language to libjit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="from-libjit-ir-to-machine-code"&gt;
&lt;h3&gt;From libjit IR to machine code&lt;/h3&gt;
&lt;p&gt;Now it's time to examine the machine code produced by libjit for &lt;tt class="docutils literal"&gt;gcd_iter&lt;/tt&gt; on my x64 machine. The following is an annotated disassembly dump, which I'll then use as a springboard to dive into some of the internal workings of libjit.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;                  &lt;span style="color: #007f00"&gt;// Prologue&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058713f:     push   %rbp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587140:     mov    %rsp,%rbp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587143:     sub    $0x20,%rsp
                  &lt;span style="color: #007f00"&gt;// r14 and r15 are callee-saved; save them since&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// we&amp;#39;ll use them&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587147:     mov    %r14,(%rsp)
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058714b:     mov    %r15,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rsp)
                  &lt;span style="color: #007f00"&gt;// rdi holds u, rsi holds v. Put them in r15 and r14&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// respectively&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587150:     mov    %rdi,%r15
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587153:     mov    %rsi,%r14

                  &lt;span style="color: #007f00"&gt;// label_while:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (v == 0) goto after_while&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587156:     test   %r14d,%r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587159:     je     &lt;span style="color: #007f7f"&gt;0x7f94005871ab&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// t &amp;lt;- u&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058715f:     mov    %r15d,%eax
                  &lt;span style="color: #007f00"&gt;// u &amp;lt;- v&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587162:     mov    %r14d,%r15d
                  &lt;span style="color: #007f00"&gt;// save t on the stack&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587165:     mov    %eax,-&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rbp)
                  &lt;span style="color: #007f00"&gt;// if (v != 0) goto v_nonzero&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587168:     test   %r14d,%r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058716b:     jne    &lt;span style="color: #007f7f"&gt;0x7f9400587181&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise call&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// jit_exception_builtin(JIT_RESULT_DIVISION_BY_ZERO)&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058716d:     mov    $0xfffffffe,%edi
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587172:     mov    $0x8,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587177:     mov    $0x4060ea,%r11
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058717e:     callq  *%r11

                  &lt;span style="color: #007f00"&gt;// v_nonzero:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (v != -1) godo ready_for_rem&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587181:     cmp    $0xffffffff,%r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587185:     jne    &lt;span style="color: #007f7f"&gt;0x7f94005871a2&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (t != -2**32) goto ready_for_rem&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587187:     cmp    $0x80000000,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058718c:     jne    &lt;span style="color: #007f7f"&gt;0x7f94005871a2&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise call&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// jit_exception_builtin(JIT_RESULT_ARITHMETIC)&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// Because a minimum signed number is divided by -1;&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// the quotient is then an arithmetic overflow.&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// [-2^32 is representable in 2s complement 32-bit, but&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;//  not 2^32]&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058718e:     mov    $0xffffffff,%edi
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587193:     mov    $0x8,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587198:     mov    $0x4060ea,%r11
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058719f:     callq  *%r11

                  &lt;span style="color: #007f00"&gt;// ready_for_rem:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// sign-extend t (eax) into (edx) for division and&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// perform signed division. Remainder is in rdx,&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// which is moved to r14, so v &amp;lt;- t % u&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// then goto label_while&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a2:     cltd
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a3:     idiv   %r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a6:     mov    %rdx,%r14
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a9:     jmp    &lt;span style="color: #007f7f"&gt;0x7f9400587156&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// after_while:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (u &amp;gt;= 0) goto u_nonnegative&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ab:     test   %r15d,%r15d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ae:     jge    &lt;span style="color: #007f7f"&gt;0x7f94005871be&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// ... otherwise place u into the return register&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// and negate it, then goto epilogue&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871b4:     mov    %r15d,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871b7:     neg    %eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871b9:     jmpq   &lt;span style="color: #007f7f"&gt;0x7f94005871c1&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// u_nonnegative:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// Place u into the return register rax&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871be:     mov    %r15d,%eax

                  &lt;span style="color: #007f00"&gt;// epilogue:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// Restore saved regs &amp;amp; epilogue&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871c1:     mov    (%rsp),%r14
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871c5:     mov    &lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rsp),%r15
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ca:     mov    %rbp,%rsp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871cd:     pop    %rbp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ce:     retq
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While in general the control flow here is very similar to the IR version and hence easy to understand, there's a bunch of error checking going on before the remainder operation is performed, and this complicates matters. libjit turns out to be very meticulous about arithmetic errors and implants runtime checks against two situations that are undefined by the C standard.&lt;/p&gt;
&lt;p&gt;The easier one is division by zero. When &lt;tt class="docutils literal"&gt;v&lt;/tt&gt; is zero, the operation &lt;tt class="docutils literal"&gt;t % v&lt;/tt&gt; has undefined behavior. libjit inserts a runtime check comparing the divisor to zero and calling an exception function &lt;a class="footnote-reference" href="#id8" id="id3"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The more complex error case arises in division by -1. Since integers are represented in 2s complement, there is a single negative number (-2^32 for 32-bit &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;s) that does not have a positive mirror. If this negative number is divided by -1, the result is arithmetic overflow, which is also undefined behavior. Here again, libjit inserts the requisite runtime checks that ensure this case gets caught and properly reported &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="instruction-selection"&gt;
&lt;h3&gt;Instruction selection&lt;/h3&gt;
&lt;p&gt;The code generated for the remainder operation is a great opportunity to peer into the innards of libjit. What defines such complex behavior - generating a whole code sequence with multiple checks and calls, for a single operation? After all, on the libjit IR level, the remainder is just the &lt;tt class="docutils literal"&gt;%&lt;/tt&gt; operator.&lt;/p&gt;
&lt;p&gt;The following is a fast paced quest through the source code of libjit. Code references are typically made to function names and files relative to the root directory of a libjit source snapshot.&lt;/p&gt;
&lt;p&gt;We'll start by looking into &lt;tt class="docutils literal"&gt;jit_insn_rem&lt;/tt&gt;, which creates the remainder operation. Together with the other instruction creation APIs of libjit, this function lives in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-insn.c&lt;/span&gt;&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;jit_insn_rem&lt;/tt&gt; adds an &lt;em&gt;instruction description entry&lt;/em&gt; to the function - an instance of the &lt;tt class="docutils literal"&gt;jit_opcode_descr&lt;/tt&gt; structure.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;jit_value_t &lt;span style="color: #00007f"&gt;jit_insn_rem&lt;/span&gt;
              (jit_function_t func, jit_value_t value1, jit_value_t value2)
{
      &lt;span style="color: #00007f; font-weight: bold"&gt;static&lt;/span&gt; jit_opcode_descr &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; rem_descr = {
              JIT_OP_IREM,
              JIT_OP_IREM_UN,
              JIT_OP_LREM,
              JIT_OP_LREM_UN,
              JIT_OP_FREM,
              JIT_OP_DREM,
              JIT_OP_NFREM,
              jit_intrinsic(jit_int_rem, descr_e_pi_ii),
              jit_intrinsic(jit_uint_rem, descr_e_pI_II),
              jit_intrinsic(jit_long_rem, descr_e_pl_ll),
              jit_intrinsic(jit_ulong_rem, descr_e_pL_LL),
              jit_intrinsic(jit_float32_rem, descr_f_ff),
              jit_intrinsic(jit_float64_rem, descr_d_dd),
              jit_intrinsic(jit_nfloat_rem, descr_D_DD)
      };
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; apply_arith(func, &amp;amp;rem_descr, value1, value2, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most interesting part of this entry for us at this point is the opcode; &lt;tt class="docutils literal"&gt;JIT_OP_IREM&lt;/tt&gt; is the signed integer remainder opcode.&lt;/p&gt;
&lt;p&gt;There are many entries in the &lt;tt class="docutils literal"&gt;jit_opcode_descr&lt;/tt&gt; structure - per type of operands. Some of the entries are filled with intrinsics rather than opcodes, because libjit needs an intrinsic for architectures on which the opcode is not supported natively.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;jit_function_compile&lt;/tt&gt; initiates the IR -&amp;gt; native compilation sequence in libjit. You can trace it through in the libjit code - the code is quite easy to follow. Eventually &lt;tt class="docutils literal"&gt;compile_block&lt;/tt&gt;, which is responsible for generating code for a single basic block, calls &lt;tt class="docutils literal"&gt;_jit_gen_insn&lt;/tt&gt; per instruction. This is the point when libjit switches from a target-independent code generation algorithm to a target-specific backend, that knows how to lower libjit IR instructions to actual native instructions. This part has to be implemented per backend (target architecture). I'll follow through the flow of the x86-64 backend. The meat of &lt;tt class="docutils literal"&gt;_jit_gen_insn&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-rules-x86-64.c&lt;/span&gt;&lt;/tt&gt; is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;switch&lt;/span&gt;(insn-&amp;gt;opcode)
{
&lt;span style="color: #007f00"&gt;#define JIT_INCLUDE_RULES&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#include &amp;quot;jit-rules-x86-64.inc&amp;quot;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#undef JIT_INCLUDE_RULES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;.inc&lt;/tt&gt; file being included into the &lt;tt class="docutils literal"&gt;switch&lt;/tt&gt; statement is auto-generated in libjit from a corresponding &lt;tt class="docutils literal"&gt;.ins&lt;/tt&gt; file &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[4]&lt;/a&gt;. The &lt;tt class="docutils literal"&gt;.ins&lt;/tt&gt; file is an instruction selector, written in a libjit-specific DSL. It contains &amp;quot;rules&amp;quot; for generating code per IR opcode. Before we look at the complex remainder opcode, let's start with something simpler to get a feel for how the thing works:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;JIT_OP_PUSH_INT: note
      [imm] -&amp;gt; {
        x86_64_push_imm(inst, $1);
        gen-&amp;gt;stack_changed = 1;
      }
      [local] -&amp;gt; {
        x86_64_push_membase_size(inst, X86_64_RBP, $1, 4);
        gen-&amp;gt;stack_changed = 1;
      }
      [reg] -&amp;gt; {
        x86_64_push_reg_size(inst, $1, 4);
        gen-&amp;gt;stack_changed = 1;
      }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This rule tells the code generator how to handle the &lt;tt class="docutils literal"&gt;JIT_OP_PUSH_INT&lt;/tt&gt; (push an integer onto the stack) opcode for x86-64. Notice that there are separate rules based on whether the argument of the opcode is an immediate, a reference to a label or a register. For example, when it's a register, the rule says to call &lt;tt class="docutils literal"&gt;x86_64_push_reg_size&lt;/tt&gt;. This is a macro defined thus:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;#define x86_64_push_reg_size(inst, reg, size) \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;      do { \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              if((size) == 2) \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              { \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;                      *(inst)++ = (unsigned char)0x66; \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              } \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              x86_64_rex_emit64((inst), (size), 0, 0, (reg)); \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              *(inst)++ = (unsigned char)0x50 + ((reg) &amp;amp; 0x7); \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;      } while(0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, if you really want to verify this, it's time to look into the Intel Architecture Manual, volume 2 (the instruction set reference). Enjoy :-)&lt;/p&gt;
&lt;p&gt;Now, back to our remainder. &lt;tt class="docutils literal"&gt;JIT_OP_IREM&lt;/tt&gt; has the following entry:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;JIT_OP_IREM: more_space
      [any, immzero] -&amp;gt; {
        inst = throw_builtin(inst, func, JIT_RESULT_DIVISION_BY_ZERO);
      }
      [reg, imm, if(&amp;quot;$2 == 1&amp;quot;)] -&amp;gt; {
        x86_64_clear_reg(inst, $1);
      }
      [reg, imm, if(&amp;quot;$2 == -1&amp;quot;)] -&amp;gt; {
        /* Dividing by -1 gives an exception if the argument
           is minint, or simply gives a remainder of zero */
        jit_int min_int = jit_min_int;
        unsigned char *patch;
        x86_64_cmp_reg_imm_size(inst, $1, min_int, 4);
        patch = inst;
        x86_branch8(inst, X86_CC_NE, 0, 0);
        inst = throw_builtin(inst, func, JIT_RESULT_ARITHMETIC);
        x86_patch(patch, inst);
        x86_64_clear_reg(inst, $1);
      }
      [=reg(&amp;quot;rdx&amp;quot;), *reg(&amp;quot;rax&amp;quot;), imm, scratch dreg, scratch reg(&amp;quot;rdx&amp;quot;)] -&amp;gt; {
        x86_64_mov_reg_imm_size(inst, $4, $3, 4);
        x86_64_cdq(inst);
        x86_64_idiv_reg_size(inst, $4, 4);
      }
      [=reg(&amp;quot;rdx&amp;quot;), *reg(&amp;quot;rax&amp;quot;), dreg, scratch reg(&amp;quot;rdx&amp;quot;)] -&amp;gt; {
        jit_int min_int = jit_min_int;
        unsigned char *patch, *patch2;
#ifndef JIT_USE_SIGNALS
        x86_64_test_reg_reg_size(inst, $3, $3, 4);
        patch = inst;
        x86_branch8(inst, X86_CC_NE, 0, 0);
        inst = throw_builtin(inst, func, JIT_RESULT_DIVISION_BY_ZERO);
        x86_patch(patch, in have ast);
#endif
        x86_64_cmp_reg_imm_size(inst, $3, -1, 4); part 2
        patch = inst;
        x86_branch8(inst, X86_CC_NE, 0, 0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's kind-of long, but most of it describes some special cases when one of the operands is constant. For example, the second code block describes the case where the divisor is a constant 1. In this case, the remainder is always 0 so the target register is just cleared. The most interesting case is the most general one - the last, where division is done between two registers. In this case, you'll see that the rule is just a template for generate code - it's very similar to the machine code we've seen in the disassembly above. It checks for a zero divisor, and then for arithmetic error. Macros are used to actually generate the machine code, as demonstrated above with &lt;tt class="docutils literal"&gt;x86_64_push_reg_size&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="liveness-analysis-and-register-allocation"&gt;
&lt;h3&gt;Liveness analysis and register allocation&lt;/h3&gt;
&lt;p&gt;Another important mechanism in libjit I want to take a look at is liveness analysis (together with related target-independent optimizations) and register allocation. Since covering these topics in detail would require a book or two, I'll only skim through them on a high level, trusting the reader has some knowledge of compiler backends (or at least the will to dive deeper wherever necessary).&lt;/p&gt;
&lt;p&gt;libjit's rule-based code generation machinery already knows which registers values live in. A brief look at the machine code it generates immediately suggests that some sort of register allocation happened - there are almost no unnecessary stack spills. This happens in the &lt;tt class="docutils literal"&gt;codegen_prepare&lt;/tt&gt; function, which runs liveness analysis followed by register allocation.&lt;/p&gt;
&lt;p&gt;The liveness analysis done by libjit seems pretty standard. It places its results in the &lt;tt class="docutils literal"&gt;flags&lt;/tt&gt; field of each instruction. It also runs some simple optimizations - forward and backward copy propagations. For example, recall that in the IR we had:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;.L0:
      &lt;span style="color: #007f00"&gt;// if (v == 0) goto label_after_while&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// libjit folds a comparison instruction into a branch - hence it&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// seems that i7 is not necessary and can be optimized away as&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// dead code&lt;/span&gt;
    i7 = i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now it's time to explain how the &amp;quot;optimized away as dead code&amp;quot; part happened. When liveness analysis gets to the &lt;tt class="docutils literal"&gt;i7 = i2 == 0&lt;/tt&gt; instruction, it notices that he destination value is not live - nothing uses it. The instruction is then replaced with a &lt;tt class="docutils literal"&gt;JIT_OP_NOP&lt;/tt&gt;, which is simply ignored during code generation.&lt;/p&gt;
&lt;p&gt;A more sophisticated analysis enables libjit to replace the second instruction in the pair &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[5]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;i8 = i5 % i2
i2 = i8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since &lt;tt class="docutils literal"&gt;i8&lt;/tt&gt; is not used anywhere else, backward copy propagation simply replaces the first assignment by &lt;tt class="docutils literal"&gt;i2 = i5 % i2&lt;/tt&gt; and the second becomes dead code, which is replaced with a &lt;tt class="docutils literal"&gt;JIT_OP_NOP&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Register allocation happens in two stages. First, a simplistic global register allocation is done right after liveness analysis. All the values in the function are ordered from most to least used, and registers are allocated to the most used values. While not as optimal as graph coloring, this is a relatively cheap and simple heuristic that ensures, in most cases, that the hottest values remain in registers across basic blocks and not too many spills are generated.&lt;/p&gt;
&lt;p&gt;The second stage happens as each instruction gets generated - this is local register allocation within a block. &lt;tt class="docutils literal"&gt;_jit_regs_assign&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-reg-alloc.c&lt;/span&gt;&lt;/tt&gt; is the function to look out for. Calls to it are automatically created in the &lt;tt class="docutils literal"&gt;.inc&lt;/tt&gt; file. This stage is tasked with the detailed allocation of registers to instructions that require registers, spilling of existing values from registers (if the required registers are occupied), and so on.&lt;/p&gt;
&lt;p&gt;On a high level, this code is a classical low-level register allocator with a lot of careful bookkeeping (such as ABI constraints and instructions that force special registers). It keeps track of the values contained in each register and uses liveness analysis to try to spill registers with the minimal cost, when spilling is required. It also uses the global register information computed during global allocation, so it's not completely blind to what's going on outside the basic block.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="optimization"&gt;
&lt;h3&gt;Optimization&lt;/h3&gt;
&lt;p&gt;Apart from the copy propagations and dead code elimination mentioned above, libjit doesn't come with a lot of optimizations built in. It has the scaffolding ready to set custom optimization levels on each function, but these don't do much today. Perhaps it was added for future needs or for custom backends that may do more optimization during instruction selection, etc.&lt;/p&gt;
&lt;p&gt;The only other target-independent optimization (which runs by default, unless you explicitly set the optimization level to 0) is an attempt to simplify the control-flow graph of functions. This happens in the &lt;tt class="docutils literal"&gt;optimize&lt;/tt&gt; function, which first builds the CFG with &lt;tt class="docutils literal"&gt;_jit_block_build_cfg&lt;/tt&gt; and then optimizes it with &lt;tt class="docutils literal"&gt;_jit_block_clean_cfg&lt;/tt&gt;. According to comments in the code, it's based on the &amp;quot;Clean&amp;quot; algorithm from &lt;a class="reference external" href="http://www.cs.princeton.edu/~ras/clean.ps"&gt;this paper&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;While the first two parts in this series concentrated on how to use libjit, this part focuses on how libjit works under the hood. It's an audacious goal to try to cover such an intricate piece of software in a single article, so my attempt should be considered at most a high-level overview with a bit of in-depth focus here and there. I hope people who find libjit interesting and wonder how it works will find it useful; it can also be useful just to students of compilers that look for additional real-world examples to study. Software projects rarely have their internals documented, and being presented with a large lump of code is daunting. Perhaps this article can soften the learning curve.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There's no magic here - libjit doesn't carry a disassembler of its own. It simply dumps the raw binary code into a temporary files and runs it through &lt;tt class="docutils literal"&gt;objdump&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;jit_exception_builtin&lt;/tt&gt; lives in host code, and the host-JIT interface was explained in detail in &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/12/getting-started-with-libjit-part-2/"&gt;part 2&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;By the way, this behavior is documented in the libjit API for &lt;tt class="docutils literal"&gt;jit_insn_div&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;jit_insn_rem&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I'll leave the details of this auto-generated instruction selection out of this article, but it's pretty standard in compilers. LLVM has an elaborate auto-generation framework based on TableGen. libjit has a simpler home-cooked solution. It's pretty easy to find out how it works by tracing the flow in the Makefile and looking at the &lt;tt class="docutils literal"&gt;tools/&lt;/tt&gt; directory.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I found the &lt;tt class="docutils literal"&gt;_JIT_COMPILE_DEBUG&lt;/tt&gt; flag very useful when looking at this. Turn it on in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-config.h&lt;/span&gt;&lt;/tt&gt;. Similarly, &lt;tt class="docutils literal"&gt;JIT_REG_DEBUG&lt;/tt&gt; helps observe the inner workings of the register allocator.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Assembly"></category><category term="C &amp; C++"></category><category term="Code generation"></category></entry><entry><title>The cost of dynamic (virtual calls) vs. static (CRTP) dispatch in C++</title><link href="https://eli.thegreenplace.net/2013/12/05/the-cost-of-dynamic-virtual-calls-vs-static-crtp-dispatch-in-c" rel="alternate"></link><published>2013-12-05T06:13:30-08:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-12-05:/2013/12/05/the-cost-of-dynamic-virtual-calls-vs-static-crtp-dispatch-in-c</id><summary type="html">
        &lt;p&gt;A couple of years ago I wrote &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/"&gt;an article about the Curiously Recurring Template Pattern in C++&lt;/a&gt;, focusing on the motivation behind it and how to implement it.&lt;/p&gt;
&lt;p&gt;That article mentioned runtime performance as the main reason for employing CRTP instead of the more traditional runtime polymorphism (dispatch via virtual …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;A couple of years ago I wrote &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/"&gt;an article about the Curiously Recurring Template Pattern in C++&lt;/a&gt;, focusing on the motivation behind it and how to implement it.&lt;/p&gt;
&lt;p&gt;That article mentioned runtime performance as the main reason for employing CRTP instead of the more traditional runtime polymorphism (dispatch via virtual functions). While some rationale for the cost of virtual calls was given, I didn't go too deep into it. Today I want to fix that by carefully analyzing the performance of virtual calls as opposed to the static calls made possible by CRTP.&lt;/p&gt;
&lt;div class="section" id="mandatory-precaution-about-benchmarks"&gt;
&lt;h3&gt;Mandatory precaution about benchmarks&lt;/h3&gt;
&lt;p&gt;Benchmarking in 2013 is really hard. Today's CPUs are super-pipelined, branch-predicting out-of-order executing beasts. The memory hierarchy is very deep and the caches have complex behavior. All of this makes detailed performance analysis devilishly complex, and the &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/12/03/intel-i7-loop-performance-anomaly/"&gt;results are sometimes baffling&lt;/a&gt;. We're clearly long past counting MIPS. Add to that overly-clever optimizing compilers that occasionally produce not quite the code you expected, and it's apparent why so many online resources and articles provide bad benchmarks.&lt;/p&gt;
&lt;p&gt;So any benchmarks need to be taken with a large grain of salt, including the one posted here. Personally, I'm trying to validate the benchmarks I'm running by attacking them with the scientific method:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;First, create a &lt;em&gt;hypothesis&lt;/em&gt; about the relative speed of two approaches.&lt;/li&gt;
&lt;li&gt;Take a detailed look at the code generated by the compiler to verify the hypothesis w.r.t. code generation - is this the machine code you expected to see?&lt;/li&gt;
&lt;li&gt;Run the benchmark and compare the runtime to the initial hypothesis, as well as to (2) - while not perfect, performance is easier to correlate to machine code than to original source code.&lt;/li&gt;
&lt;li&gt;If anything doesn't feel right, or just to make (3) more careful, use low-level counters to make sure that the amount of instructions executed and other such details makes sense given (2).&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="hypothesis-what-makes-virtual-calls-slower"&gt;
&lt;h3&gt;Hypothesis - what makes virtual calls slower&lt;/h3&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/"&gt;previous article&lt;/a&gt; listed the following components in the runtime cost of virtual calls:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Extra indirection (pointer dereference) for each call to a virtual method.&lt;/li&gt;
&lt;li&gt;Virtual methods usually can’t be inlined, which may be a significant cost hit for some small methods.&lt;/li&gt;
&lt;li&gt;Additional pointer per object. On 64-bit systems which are prevalent these days, this is 8 bytes per object. For small objects that carry little data this may be a serious overhead.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While the third component can definitely play a role in some scenarios (i.e. a lot of small objects where the additional memory means less of them fit into L1 data cache), I'll focus on the first two in this article, because they are easier to expose in a simple synthetic benchmark.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-source-code-what-are-we-comparing"&gt;
&lt;h3&gt;The source code - what are we comparing?&lt;/h3&gt;
&lt;p&gt;There's a plethora of uses for polymorphism in C++. Here I'll focus on a basic one that will let me expose the performance characteristics of virtual calls. I'll define a simple interface with a couple of methods and one implementation of it:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;DynamicInterface&lt;/span&gt; {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; uint64_t getvalue() = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
};

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;DynamicImplementation&lt;/span&gt; : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; DynamicInterface {
  uint64_t counter;

&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  DynamicImplementation()
    : counter(&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) {
    counter += n;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; uint64_t getvalue() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; counter;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The following code runs the actual benchmark:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; N = &lt;span style="color: #007f7f"&gt;40000&lt;/span&gt;;

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run_dynamic(DynamicInterface* obj) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; j = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; j &amp;lt; i; ++j) {
      obj-&amp;gt;tick(j);
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What this does is simply invoke the virtual method &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; on the base pointer &lt;tt class="docutils literal"&gt;obj&lt;/tt&gt; in the order of &lt;tt class="docutils literal"&gt;O(N^2)&lt;/tt&gt; times.&lt;/p&gt;
&lt;p&gt;The alternative statically-polymorphic implementation is this &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;template&lt;/span&gt; &amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;typename&lt;/span&gt; Implementation&amp;gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;CRTPInterface&lt;/span&gt; {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) {
    impl().tick(n);
  }

  uint64_t getvalue() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; impl().getvalue();
  }
&lt;span style="color: #00007f; font-weight: bold"&gt;private&lt;/span&gt;:
  Implementation&amp;amp; impl() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; *&lt;span style="color: #00007f; font-weight: bold"&gt;static_cast&lt;/span&gt;&amp;lt;Implementation*&amp;gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;);
  }
};

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;CRTPImplementation&lt;/span&gt; : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; CRTPInterface&amp;lt;CRTPImplementation&amp;gt; {
  uint64_t counter;
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  CRTPImplementation()
    : counter(&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) {
    counter += n;
  }

  uint64_t getvalue() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; counter;
  }
};

&lt;span style="color: #00007f; font-weight: bold"&gt;template&lt;/span&gt; &amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;typename&lt;/span&gt; Implementation&amp;gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run_crtp(CRTPInterface&amp;lt;Implementation&amp;gt;* obj) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; j = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; j &amp;lt; i; ++j) {
      obj-&amp;gt;tick(j);
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="generated-code-how-virtual-calls-look-under-the-hood"&gt;
&lt;h3&gt;Generated code - how virtual calls look under the hood&lt;/h3&gt;
&lt;p&gt;Now let's spend some time studying the machine code generated by gcc -O2 (version 4.8) from the code above. The code for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;DynamicImplementation::tick&lt;/span&gt;&lt;/tt&gt; is very compact:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;0000000000400&lt;/span&gt;cf0 &amp;lt;_ZN21DynamicImplementation4tickEm&amp;gt;:
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;cf0:       add    %rsi,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rdi)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;cf4:       retq
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To understand what this means, some familiarity with the &lt;a class="reference external" href="http://mentorembedded.github.io/cxx-abi/abi.html"&gt;Itanium C++ ABI&lt;/a&gt; is required. The ABI in this case mandates both the name mangling that produces the weird symbol name, and the layout of the object in memory, which mandates how its fields are accessed. Here's a short description for the code above:&lt;/p&gt;
&lt;p&gt;Since &lt;tt class="docutils literal"&gt;DynamicInterface&lt;/tt&gt; has virtual methods, the class hierarchy it begets comes with a virtual method table, a pointer to which resides in each object. This is the way the compiler arranges for the runtime code to call the correct method when an actual object is used. The address of the virtual method table (&lt;tt class="docutils literal"&gt;vptr&lt;/tt&gt;) is in the beginning of the object, and the actual class members come afterwards. So &lt;tt class="docutils literal"&gt;counter&lt;/tt&gt; lives at offset 8 in &lt;tt class="docutils literal"&gt;DynamicImplementation&lt;/tt&gt; objects.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;add    %rsi,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rdi)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;%rdi&lt;/tt&gt; is the first argument to &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt;, which is the hidden &lt;tt class="docutils literal"&gt;this&lt;/tt&gt; pointer - the address of the object. Hence &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;0x8(%rdi)&lt;/span&gt;&lt;/tt&gt; is the address of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;this-&amp;gt;counter&lt;/span&gt;&lt;/tt&gt;. The instruction, then, adds &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; (passed in &lt;tt class="docutils literal"&gt;%rsi&lt;/tt&gt; according to the calling convention) to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;this-&amp;gt;counter&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;By the way, whenever you're curious about object layouts and want to verify your understanding of the ABI, I find &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/"&gt;Clang's ability to dump the class record layouts&lt;/a&gt; very helpful. In this case:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;*** Dumping AST Record Layout
   0 | class DynamicImplementation
   0 |   class DynamicInterface (primary base)
   0 |     (DynamicInterface vtable pointer)
   8 |   uint64_t counter
     | [sizeof=16, dsize=16, align=8
     |  nvsize=16, nvalign=8]

*** Dumping AST Record Layout
   0 | class CRTPImplementation
   0 |   class CRTPInterface&amp;lt;class CRTPImplementation&amp;gt; (base) (empty)
   0 |   uint64_t counter
     | [sizeof=8, dsize=8, align=8
     |  nvsize=8, nvalign=8]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On to the invocation of &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; now. This is the disassembly for &lt;tt class="docutils literal"&gt;run_dynamic&lt;/tt&gt;, annotated with comments:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;0000000000400&lt;/span&gt;c10 &amp;lt;_Z11run_dynamicP16DynamicInterface&amp;gt;:
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c10:       push   %r13
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c12:       mov    $0x1,%r13d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c18:       push   %r12
        &lt;span style="color: #007f00"&gt;// r12d holds i, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c1a:       xor    %r12d,%r12d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c1d:       push   %rbp
        &lt;span style="color: #007f00"&gt;// Place obj in %rbp&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c1e:       mov    %rdi,%rbp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c21:       push   %rbx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c22:       sub    $0x8,%rsp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c26:       nopw   %cs:&lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c30:       test   %r12d,%r12d
        &lt;span style="color: #007f00"&gt;// when i is 0, the body of the loop won&amp;#39;t run, so increment&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;// both i and j and try again.&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c33:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c5e
        &lt;span style="color: #007f00"&gt;// rbx holds j, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c35:       xor    %ebx,%ebx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c37:       nopw   &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
        &lt;span style="color: #007f00"&gt;// Place the address of obj&amp;#39;s vtable in rax&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40:       mov    &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rbp),%rax
        &lt;span style="color: #007f00"&gt;// j is the second argument of tick&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c44:       mov    %rbx,%rsi
        &lt;span style="color: #007f00"&gt;// j++&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c47:       add    $0x1,%rbx
        &lt;span style="color: #007f00"&gt;// obj is the first argument of tick (&amp;#39;this&amp;#39; pointer)&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4b:       mov    %rbp,%rdi
        &lt;span style="color: #007f00"&gt;// tick is the first entry in the vtable.&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;// This calls obj-&amp;gt;tick(obj, j)&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4e:       callq  *(%rax)
        &lt;span style="color: #007f00"&gt;// Compare j &amp;lt; i and perform inner loop&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c50:       cmp    %ebx,%r12d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c53:       ja     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40
        &lt;span style="color: #007f00"&gt;// Compare i == 40000 and perform outer loop&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c55:       cmp    $0x9c40,%r13d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c5c:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c68
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c5e:       add    $0x1,%r13d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c62:       add    $0x1,%r12d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c66:       jmp    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c30
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c68:       add    $0x8,%rsp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c6c:       pop    %rbx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c6d:       pop    %rbp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c6e:       pop    %r12
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c70:       pop    %r13
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c72:       retq
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c73:       data32 data32 data32 nopw %cs:&lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The interesting parts here are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;How &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;obj-&amp;gt;tick&lt;/span&gt;&lt;/tt&gt; is actually invoked. Since &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; is the first method in &lt;tt class="docutils literal"&gt;DynamicInterface&lt;/tt&gt;, it sits in the first slot in the vtable. So to actually call it, we have a double indirection from &lt;tt class="docutils literal"&gt;obj&lt;/tt&gt; - one to get to the vtable, the other to get to the method in the vtable.&lt;/li&gt;
&lt;li&gt;The constituents of the inner loop - the part that the program spends the vast majority of its time executing. We'll get back to it for a more careful analysis later.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="how-crtp-calls-look-under-the-hood"&gt;
&lt;h3&gt;How CRTP calls look under the hood&lt;/h3&gt;
&lt;p&gt;Now it's time to disassemble the equivalent code that uses CRTP for static polymorphism. Again, we'll want to start with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPImplementation::tick&lt;/span&gt;&lt;/tt&gt;, but we won't find it in the disassembly because it was fully inlined into &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;. The compiler was able to inline it because it could know statically (at compile time) which method is called. Such inlining is an important tenet of the &amp;quot;zero-cost abstractions&amp;quot; philosophy of modern C++.&lt;/p&gt;
&lt;p&gt;Let's go straight to &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;, then:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;0000000000400&lt;/span&gt;d00 &amp;lt;_Z8run_crtpI18CRTPImplementationEvP13CRTPInterfaceIT_E&amp;gt;:
        &lt;span style="color: #007f00"&gt;// Place obj-&amp;gt;counter into rdx&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d00:       mov    (%rdi),%rdx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d03:       mov    $0x1,%esi
        &lt;span style="color: #007f00"&gt;// rcx holds i, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d08:       xor    %ecx,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d0a:       nopw   &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d10:       test   %ecx,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d12:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d36
        &lt;span style="color: #007f00"&gt;// rax holds j, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d14:       xor    %eax,%eax
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d16:       nopw   %cs:&lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
        &lt;span style="color: #007f00"&gt;// counter += j&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d20:       add    %rax,%rdx
        &lt;span style="color: #007f00"&gt;// j++ and perform inner loop&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d23:       add    $0x1,%rax
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d27:       cmp    %eax,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d29:       ja     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d20
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d2b:       cmp    $0x9c40,%esi
        &lt;span style="color: #007f00"&gt;// when we&amp;#39;re done, put the final value back into obj-&amp;gt;counter&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d31:       mov    %rdx,(%rdi)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d34:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d3e
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d36:       add    $0x1,%esi
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d39:       add    $0x1,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d3c:       jmp    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d10
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d3e:       repz retq
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's not hard to see we'd expect this code to run much faster, for two main reasons:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Since the &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; dispatch was inlined, the compiler was free to see that all it does is a simple member increment. The member is then saved in &lt;tt class="docutils literal"&gt;rdx&lt;/tt&gt; and the loop can then simply bump a register, instead of having a &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; on each iteration.&lt;/li&gt;
&lt;li&gt;As there's no call involved, the inner loop is shorter.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="performance-numbers"&gt;
&lt;h3&gt;Performance numbers&lt;/h3&gt;
&lt;p&gt;As expected, the CRTP approach is much faster. The benchmark above takes 1.25 seconds on my i7-4771 CPU for &lt;tt class="docutils literal"&gt;run_dynamic&lt;/tt&gt; and 0.21 seconds for &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt; This is a huge difference, and it's much larger than I expected. I was looking for a 2x boost, not 6x &lt;a class="footnote-reference" href="#id5" id="id2"&gt;[2]&lt;/a&gt;. So here comes the 4th bullet of the benchmarking methodology I outlined above. Let's look more carefully at the numbers.&lt;/p&gt;
&lt;p&gt;I'll start with producing a trace of the inner loop for both cases, to see the sequence of instructions executed. Since the loop is short, this can be easily done with basic disassembly reading, and also verifying with &lt;tt class="docutils literal"&gt;gdb&lt;/tt&gt; by stepping through the execution for a few iterations.&lt;/p&gt;
&lt;p&gt;Here is the inner loop for &lt;tt class="docutils literal"&gt;run_dynamic&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40:     mov    &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rbp),%rax
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c44:     mov    %rbx,%rsi
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c47:     add    $0x1,%rbx
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4b:     mov    %rbp,%rdi
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4e:     callq  *(%rax) ... calls tick
    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;ce0: add    %rsi,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rdi)
    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;ce4: retq
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c50:     cmp    %ebx,%r12d
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c53:     ja     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How many times we'd expect it to run? The double loop has a simple summing pattern so we can compute it's in the vicinity of &lt;tt class="docutils literal"&gt;N/2 * N&lt;/tt&gt;, which in our case means 800e6 (800 million times).&lt;/p&gt;
&lt;p&gt;Since the loop above is 9 instructions long, it means 7.2e9 instructions total. Let's look at detailed &lt;tt class="docutils literal"&gt;perf stat&lt;/tt&gt; numbers for this run:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Performance counter stats for &amp;#39;build/vcall-benchmark d&amp;#39;:

      1253.807247 task-clock                #    0.999 CPUs utilized
              107 context-switches          #    0.085 K/sec
                0 cpu-migrations            #    0.000 K/sec
              318 page-faults               #    0.254 K/sec
    4,807,848,980 cycles                    #    3.835 GHz
  &amp;lt;not supported&amp;gt; stalled-cycles-frontend
  &amp;lt;not supported&amp;gt; stalled-cycles-backend
    7,203,771,146 instructions              #    1.50  insns per cycle
    2,400,716,784 branches                  # 1914.742 M/sec
           58,358 branch-misses             #    0.00% of all branches

      1.255560284 seconds time elapsed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Indeed, the amount of instructions fits our expectation.&lt;/p&gt;
&lt;p&gt;Now, let's turn to &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;. Its inner loop is this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;400d20:     add    %rax,%rdx
400d23:     add    $0x1,%rax
400d27:     cmp    %eax,%ecx
400d29:     ja     400d20
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So only 4 instructions. In other words, we'd expect the total amount of instructions executed to be in the area of 3.2e9. Let's see:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Performance counter stats for &amp;#39;build/vcall-benchmark c&amp;#39;:

       215.919352 task-clock                #    0.997 CPUs utilized
               18 context-switches          #    0.083 K/sec
                0 cpu-migrations            #    0.000 K/sec
              318 page-faults               #    0.001 M/sec
      809,355,502 cycles                    #    3.748 GHz
  &amp;lt;not supported&amp;gt; stalled-cycles-frontend
  &amp;lt;not supported&amp;gt; stalled-cycles-backend
    3,202,645,106 instructions              #    3.96  insns per cycle
      800,522,521 branches                  # 3707.507 M/sec
           53,684 branch-misses             #    0.01% of all branches

      0.216596060 seconds time elapsed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bingo!&lt;/p&gt;
&lt;p&gt;But wait, a 2.25x difference in the amount of instructions should not have translated to a 6x difference in runtime, right? Note the amount of branches, though. While the CRTP run has one branch per inner loop, the numbers for the dynamic run show 3 branches per inner loop (for a total of 2.4e9). What gives?&lt;/p&gt;
&lt;p&gt;The CPU considers indirect calls and returns as branches for this purpose, and if you think about it, this makes sense. An indirect branch or return transfer control to a location the CPU cannot determine statically (unlike a direct call, for instance) - it depends on the contents of registers &amp;amp; stack. So the CPU doesn't know where to fetch instructions ahead-of-time in order to satisfy its eternally hungry super-pipeline. True, the branch predictor alleviates most of that cost, but such instructions are still more expensive for the CPU than, say, simple adds, because they cannot pump through the pipeline as quickly.&lt;/p&gt;
&lt;p&gt;Moreover, the &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;ret&lt;/tt&gt; instructions push and pop data to the stack, which resides in memory. It's almost certainly in L1 cache, but that's still more expensive to access than registers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="variation-o3-compilation"&gt;
&lt;h3&gt;Variation: -O3 compilation&lt;/h3&gt;
&lt;p&gt;Vigilant readers might have noticed that I did not set the highest optimization level of gcc for this benchmark. This was done on purpose, to make the results simpler to explain.&lt;/p&gt;
&lt;p&gt;When compiled with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt;, the dynamic version runs as before (and the code produced for it is the same), but the CRTP version runs even faster and finishes within 0.17 seconds, which is 7.2x faster than the dynamic version.&lt;/p&gt;
&lt;p&gt;The extra boost comes from auto-vectorization. When one looks at the code produced by the compiler for &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;, one can see SIMD instructions in there. The inner loop was unrolled 4x and the operations are performed on whole quad-words, combining several inner loop iterations at a time.&lt;/p&gt;
&lt;p&gt;So this is an example where previous optimizations (inlining) enabled the compiler to apply even more advanced optimizations such as vectorization to make the code faster yet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="variation-disabling-inlining"&gt;
&lt;h3&gt;Variation: disabling inlining&lt;/h3&gt;
&lt;p&gt;It's also interesting to build the benchmark with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fno-inline&lt;/span&gt;&lt;/tt&gt; and compare the results. Curiously, in this case the CRTP approach runs 1.5x &lt;em&gt;slower&lt;/em&gt; than virtual calls. Before you read on, can you guess why?&lt;/p&gt;
&lt;p&gt;The reason is quite simple. Note that for proper CRTP, the interface class implements the interface methods and calls through to the implementation. So to actually invoke &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt; calls:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPInterface&amp;lt;CRTPImplementation&amp;gt;::tick&lt;/span&gt;&lt;/tt&gt;, which calls&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPInterface&amp;lt;CRTPImplementation&amp;gt;::impl&lt;/span&gt;&lt;/tt&gt;, and then calls&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPImplementation::tick&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is a lot of calls, which all have to be executed when the inliner is turned off. When it's turned on, &lt;em&gt;all&lt;/em&gt; of these calls get inlined and the actual instructions of the leaf call are embedded into &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;There are two lessons here:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Be careful with benchmarking, but you already knew that ;-)&lt;/li&gt;
&lt;li&gt;When implementing inlining in a compiler, it's super important to make the inliner iterative - doing multiple passes on the code and discovering new inlining opportunities in each iteration.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="devirtualization"&gt;
&lt;h3&gt;Devirtualization&lt;/h3&gt;
&lt;p&gt;A brand new optimization that I recently heard about is &lt;em&gt;devirtualization&lt;/em&gt;. The idea is to find cases of dynamic dispatch where the actual type at a given call site can always to proven to be known at compile time, and specialize those call sites to dispatch statically. This carries the promise of making virtual calls as fast as static dispatch in some special cases.&lt;/p&gt;
&lt;p&gt;While this definitely sound interesting, at the time of writing this article devirtualization is still experimental (support in gcc started trickling in version 4.7). In any case, the example examined in this article is probably simple enough to trigger the optimization, but as you can see it didn't happen, even though the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fdevirtualize&lt;/span&gt;&lt;/tt&gt; flag should be on in gcc with optimization levels &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O2&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt;. It will be interesting to follow the development of this optimization and see what cases of virtual calls it can detect and optimize in the future.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusions"&gt;
&lt;h3&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;There are a lot of lessons to be learned here, so I'll just list them in an arbitrary order:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Benchmarking is an art - if everything is too easy, you're either doing something trivial or wrong. Always cross-verify your assumptions and results with hard data like disassembly listings and detailed performance numbers.&lt;/li&gt;
&lt;li&gt;Beware of different compilers and different targets. The above discusses gcc 4.8 for x86-64. Elsewhere, you may expect slightly or considerably different results. Ah, if only programming was easy. But then I guess programmers wouldn't get paid a lot for clicking in front of computers all day.&lt;/li&gt;
&lt;li&gt;Compiler optimizations are, by definition, a multi-layered affair. Each is simple but they enable each other. Inlining enables some additional optimizations (such as moving hot code out of inner loops). Other optimizations may enable inlining (by making the leaf methods smaller).&lt;/li&gt;
&lt;li&gt;CRTP, when implemented correctly, is recognized by the compiler as static dispatch and optimized accordingly.&lt;/li&gt;
&lt;li&gt;CRTP can thus be significantly more efficient than virtual calls, mostly due to inlining. This also means that inlining is &lt;em&gt;crucial&lt;/em&gt; to its performance (as it is to many performance features of C++).&lt;/li&gt;
&lt;/ul&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is a degenerate use of CRTP, for sure. It's not here to be realistic - just to demonstrate the same mechanism used in a simple scenario. See the &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/"&gt;previous article&lt;/a&gt; for a more use-focused discussion of CRTP.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;These numbers depend on the CPU, of course. When I tried the same benchmark on a Xeon E5-2690 (Sandy Bridge) with gcc 4.6.3 (same code generated) the speed difference is just 3x (0.46 vs 1.39 sec).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Assembly"></category><category term="C &amp; C++"></category></entry></feed>