<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - Python internals</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/python-internals.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2023-06-30T23:16:27-07:00</updated><entry><title>The scope of index variables in Python's for loops</title><link href="https://eli.thegreenplace.net/2015/the-scope-of-index-variables-in-pythons-for-loops/" rel="alternate"></link><published>2015-01-17T06:24:00-08:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2015-01-17:/2015/the-scope-of-index-variables-in-pythons-for-loops/</id><summary type="html">&lt;p&gt;I'll start with a quiz. What does this function do?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you think &amp;quot;computes the sum and product of the items in &lt;tt class="docutils literal"&gt;lst&lt;/tt&gt;&amp;quot;, don't feel
too bad about …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'll start with a quiz. What does this function do?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you think &amp;quot;computes the sum and product of the items in &lt;tt class="docutils literal"&gt;lst&lt;/tt&gt;&amp;quot;, don't feel
too bad about yourself. The bug here is often tricky to spot. If you did see it,
well done - but buried in mountains of real code, and when you don't &lt;em&gt;know&lt;/em&gt; it's
a quiz, discovering the bug is significantly more difficult.&lt;/p&gt;
&lt;p&gt;The bug here is due to using &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; instead of &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; in the body of the second
&lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop. But wait, how does this even work? Shouldn't &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; be invisible
outside of the first loop? &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; Well, no. In fact, Python formally acknowledges
that the names defined as &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop targets (a more formally rigorous name
for &amp;quot;index variables&amp;quot;) leak into the enclosing function scope. So this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is valid and prints 3, by design. In this writeup I want to explore why this is
so, why it's unlikely to change, and also use it as a tracer bullet to dig into
some interesting parts of the CPython compiler.&lt;/p&gt;
&lt;p&gt;And by the way, if you're not convinced this behavior can cause real problems,
consider this snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;lst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you'd expect this to print &lt;tt class="docutils literal"&gt;[0, 1, 2, 3]&lt;/tt&gt;, no such luck. This code will,
instead, emit &lt;tt class="docutils literal"&gt;[3, 3, 3, 3]&lt;/tt&gt;, because there's just a single &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; in the scope
of &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;, and this is what all the &lt;tt class="docutils literal"&gt;lambda&lt;/tt&gt;s capture.&lt;/p&gt;
&lt;div class="section" id="the-official-word"&gt;
&lt;h2&gt;The official word&lt;/h2&gt;
&lt;p&gt;The Python reference documentation explicitly documents this behavior in the
&lt;a class="reference external" href="https://docs.python.org/dev/reference/compound_stmts.html#for"&gt;section on for loops&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
The for-loop makes assignments to the variables(s) in the target list. [...]
Names in the target list are not deleted when the loop is finished, but if
the sequence is empty, they will not have been assigned to at all by the
loop.&lt;/blockquote&gt;
&lt;p&gt;Note the last sentence - let's try it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[]:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Indeed, a &lt;tt class="docutils literal"&gt;NameError&lt;/tt&gt; is raised. Later on, we'll see that this is a natural
outcome of the way the Python VM executes its bytecode.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="why-this-is-so"&gt;
&lt;h2&gt;Why this is so&lt;/h2&gt;
&lt;p&gt;I actually asked Guido van Rossum about this behavior and he was gracious enough
to reply with some historical background (thanks Guido!). The motivation is
keeping Python's simple approach to names and scopes without resorting to hacks
(such as deleting all the values defined in the loop after it's done - think
about the complications with exceptions, etc.) or more complex scoping rules.&lt;/p&gt;
&lt;p&gt;In Python, the scoping rules are fairly simple and elegant: a block is either a
module, a function body or a class body. Within a function body, names are
visible from the point of their definition to the end of the block (including
nested blocks such as nested functions). That's for local names, of course;
global names (and other &lt;em&gt;nonlocal&lt;/em&gt; names) have slightly different rules, but
that's not pertinent to our discussion.&lt;/p&gt;
&lt;p&gt;The important point here is: the innermost possible scope is a function body.
Not a &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop body. Not a &lt;tt class="docutils literal"&gt;with&lt;/tt&gt; block body. Python does not have nested
lexical scopes below the level of a function, unlike some other languages (C and
its progeny, for example).&lt;/p&gt;
&lt;p&gt;So if you just go about implementing Python, this behavior is what you'll likely
to end with. Here's another enlightening snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Would it surprise you to find out that &lt;tt class="docutils literal"&gt;d&lt;/tt&gt; is visible and accessible after the
&lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop is finished? No, this is just the way Python works. So why would
the index variable be treated any differently?&lt;/p&gt;
&lt;p&gt;By the way, the index variables of list comprehensions are also leaked to the
enclosing scope. Or, to be precise, &lt;em&gt;were&lt;/em&gt; leaked, before Python 3 came along.&lt;/p&gt;
&lt;p&gt;Python 3 fixed the leakage from list comprehensions, along with other breaking
changes. Make no mistake, changing such behavior is a major breakage in
backwards compatibility. This is why I think the current behavior stuck and
won't be changed.&lt;/p&gt;
&lt;p&gt;Moreover, many folks still find this a useful feature of Python. Consider:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;somegenerator&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
    &lt;span class="n"&gt;dostuffwith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;The loop executed &lt;/span&gt;&lt;span class="si"&gt;{0}&lt;/span&gt;&lt;span class="s1"&gt; times!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you have no idea how many items &lt;tt class="docutils literal"&gt;somegenerator&lt;/tt&gt; actually returned, this is
a pretty succinct way to know. Otherwise you'd have to keep a separate counter.&lt;/p&gt;
&lt;p&gt;Here's another example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;somegenerator&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isinteresing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;
&lt;span class="n"&gt;dostuffwith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is a useful pattern for finding things in a loop and using them afterwards
&lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are other uses people came up with over the years that justify keeping
this behavior in place. It's hard enough to instill breaking changes for
features the core developers deem detrimental and harmful. When the feature is
argued by many to be useful, and moreover is used in a huge bunch of code in the
real world, the chances of removing it are zero.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="under-the-hood"&gt;
&lt;h2&gt;Under the hood&lt;/h2&gt;
&lt;p&gt;Now the fun part. Let's see how the Python compiler and VM conspire to make this
behavior possible. In this particular case, I think the most lucid way to
present things is going backwards from the bytecode. I hope this may also serve
as an interesting example on how to go about digging in Python's internals &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;
in order to find stuff out (it's so much fun, seriously!)&lt;/p&gt;
&lt;p&gt;Let's take a part of the function presented at the start of this article and
disassemble it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The resulting bytecode is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 0 LOAD_CONST               1 (0)
 3 STORE_FAST               1 (a)

 6 SETUP_LOOP              24 (to 33)
 9 LOAD_FAST                0 (lst)
12 GET_ITER
13 FOR_ITER                16 (to 32)
16 STORE_FAST               2 (i)

19 LOAD_FAST                1 (a)
22 LOAD_FAST                2 (i)
25 INPLACE_ADD
26 STORE_FAST               1 (a)
29 JUMP_ABSOLUTE           13
32 POP_BLOCK

33 LOAD_FAST                1 (a)
36 RETURN_VALUE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a reminder, &lt;tt class="docutils literal"&gt;LOAD_FAST&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;STORE_FAST&lt;/tt&gt; are the opcodes Python uses to
access names that are only used within a function. Since the Python compiler
knows statically (at compile-time) how many such names exist in each function,
they can be accessed with static array offsets as opposed to a hash table, which
makes access significanly faster (hence the &lt;tt class="docutils literal"&gt;_FAST&lt;/tt&gt; suffix). But I digress.
What's really important here is that &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; are treated identically.
They are both fetched with &lt;tt class="docutils literal"&gt;LOAD_FAST&lt;/tt&gt; and modified with &lt;tt class="docutils literal"&gt;STORE_FAST&lt;/tt&gt;.
There is absolutely no reason to assume that their visibility is in any way
different &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So how did this come to be? Somehow, the compiler figured that &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; is just
another local name within &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;. This logic lives in the symbol table code,
when the compiler walks over the AST to create a control-flow graph from which
bytecode is later emitted; there are more details about this process in
&lt;a class="reference external" href="https://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1"&gt;my article about symbol tables&lt;/a&gt;
- so I'll just stick to the essentials here.&lt;/p&gt;
&lt;p&gt;The symtable code doesn't treat &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; statements very specially. In
&lt;tt class="docutils literal"&gt;symtable_visit_stmt&lt;/tt&gt; we have:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;For_kind&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;VISIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;For&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;VISIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;For&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;VISIT_SEQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;For&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;For&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;orelse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;VISIT_SEQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;For&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;orelse&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The loop target is visited as any other expression. Since this code visits the
AST, it's worthwhile to dump it to see how the node for the &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; statement
looks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;For(target=Name(id=&amp;#39;i&amp;#39;, ctx=Store()),
    iter=Name(id=&amp;#39;lst&amp;#39;, ctx=Load()),
    body=[AugAssign(target=Name(id=&amp;#39;a&amp;#39;, ctx=Store()),
                    op=Add(),
                    value=Name(id=&amp;#39;i&amp;#39;, ctx=Load()))],
    orelse=[])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; lives in a &lt;tt class="docutils literal"&gt;Name&lt;/tt&gt; node. These are handled in the symbol table code by
the following clause in &lt;tt class="docutils literal"&gt;symtable_visit_expr&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;Name_kind&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;symtable_add_def&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;USE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DEF_LOCAL&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;VISIT_QUIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* ... */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the name &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; is clearly tagged with &lt;tt class="docutils literal"&gt;DEF_LOCAL&lt;/tt&gt; (because of the
&lt;tt class="docutils literal"&gt;*_FAST&lt;/tt&gt; opcodes emitted to access it, but this is also easy to observe if the
symbol table is dumped using the &lt;tt class="docutils literal"&gt;symtable&lt;/tt&gt; module), the code above evidently
calls &lt;tt class="docutils literal"&gt;symtable_add_def&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;DEF_LOCAL&lt;/tt&gt; as the third argument. This is
the right time to glance at the AST above and notice the &lt;tt class="docutils literal"&gt;ctx=Store&lt;/tt&gt; part
of the &lt;tt class="docutils literal"&gt;Name&lt;/tt&gt; node of &lt;tt class="docutils literal"&gt;i&lt;/tt&gt;. So it's the AST that already comes in carrying
the information that &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; is stored to in the &lt;tt class="docutils literal"&gt;target&lt;/tt&gt; part of the &lt;tt class="docutils literal"&gt;For&lt;/tt&gt;
node. Let's see how that comes to be.&lt;/p&gt;
&lt;p&gt;The AST-building part of the compiler goes over the parse tree (which is a
fairly low-level hierarchical representation of the source code - some
background is available &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees"&gt;here&lt;/a&gt;)
and, among other things, sets the &lt;tt class="docutils literal"&gt;expr_context&lt;/tt&gt; attributes on some nodes,
most notably &lt;tt class="docutils literal"&gt;Name&lt;/tt&gt; nodes. Think about it this way, in the following
statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Both &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;bar&lt;/tt&gt; are going to end up in &lt;tt class="docutils literal"&gt;Name&lt;/tt&gt; nodes. But while
&lt;tt class="docutils literal"&gt;bar&lt;/tt&gt; is only being loaded from, &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is actually being stored into in this
code. The &lt;tt class="docutils literal"&gt;expr_context&lt;/tt&gt; attribute is used to distinguish between uses for
later consumption by the symbol table code &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Back to our &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop targets, though. These are handled in the function that
creates an AST for &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; statements -  &lt;tt class="docutils literal"&gt;ast_for_for_stmt&lt;/tt&gt;. Here are the
relevant parts of this function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stmt_ty&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;ast_for_for_stmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;compiling&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;asdl_seq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;suite_seq&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;expr_ty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;expr_ty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* ... */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node_target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CHILD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;_target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ast_for_exprlist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node_target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Store&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_target&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Check the # of children rather than the length of _target, since&lt;/span&gt;
&lt;span class="cm"&gt;       for x, in ... has 1 element in _target, but still requires a Tuple. */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr_ty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;asdl_seq_GET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NCH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node_target&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Store&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lineno&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;col_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;c_arena&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* ... */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;For&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;suite_seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINENO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;n_col_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;c_arena&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;Store&lt;/tt&gt; context is created in the call to &lt;tt class="docutils literal"&gt;ast_for_exprlist&lt;/tt&gt;, which
creates the node for the target (recall the the &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop target may be a
sequence of names for tuple unpacking, not just a single name).&lt;/p&gt;
&lt;p&gt;This function is probably the most important part in the process of explaining
why &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; loop targets are treated similarly to other names &lt;em&gt;within&lt;/em&gt; the loop.
After this tagging happens in the AST, the code for handling such names in the
symbol table and VM is no different from other names.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wrapping-up"&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;This article discusses a particular behavior of Python that may be considered a
&amp;quot;gotcha&amp;quot; by some. I hope the article does a decent job of explaining how this
behavior flows naturally from the naming and scoping semantics of Python, why
it can be useful and hence is unlikely to ever change, and how the internals of
the Python compiler make it work under the hood. Thanks for reading!&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Here I'm tempted to make a Microsoft Visual C++ 6 joke, but the fact that
most readers of this blog in 2015 won't get it is somewhat disturbing
(because it reflects my age, not the abilities of my readers).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;You could argue that &lt;tt class="docutils literal"&gt;dowithstuff(i)&lt;/tt&gt; could go into the &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; right
before the &lt;tt class="docutils literal"&gt;break&lt;/tt&gt; here. But this isn't always convenient. Besides,
according to Guido there's a nice separation of concerns here - the loop
is used for searching, and only that. What happens with the value after
the search is done is not the loop's concern. I think this is a very good
point.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;As usual for my articles on Python's internals, this is about Python 3.
Specifically, I'm looking at the &lt;tt class="docutils literal"&gt;default&lt;/tt&gt; branch of the Python
repository, where work on the next release (3.5) is being done. But for
this particular topic, the source code of any release in the 3.x series
should do.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Another thing clear from the disassembly is why &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; remains invisible
if the loop doesn't execute. The &lt;tt class="docutils literal"&gt;GET_ITER&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;FOR_ITER&lt;/tt&gt; pair of
opcodes treat the thing we loop over as an iterator and then call its
&lt;tt class="docutils literal"&gt;__next__&lt;/tt&gt; method. If that call ends up raising &lt;tt class="docutils literal"&gt;StopIteration&lt;/tt&gt;, the
VM catches it and exits the loop. Only if an actual value is returned
does the VM proceed to execute &lt;tt class="docutils literal"&gt;STORE_FAST&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;i&lt;/tt&gt;, thus bringing it
into existence for subsequent code to refer to.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;It's a curious design, which I suspect stems from the desire for
relatively clean recursive visitation code in AST consumers such as the
symbol table code and CFG generation.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Python internals"></category><category term="Python"></category></entry><entry><title>Using ASDL to describe ASTs in compilers</title><link href="https://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers" rel="alternate"></link><published>2014-06-04T06:25:55-07:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-06-04:/2014/06/04/using-asdl-to-describe-asts-in-compilers</id><summary type="html">
        &lt;p&gt;ASTs (Abstract Syntax Trees) are an &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/"&gt;important data structure&lt;/a&gt; in compiler front-ends. If you've written a few parsers, you almost definitely ran into the need to describe the result of the parsing in terms of an AST. While the kinds of nodes such ASTs have and their structure is very …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;ASTs (Abstract Syntax Trees) are an &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/"&gt;important data structure&lt;/a&gt; in compiler front-ends. If you've written a few parsers, you almost definitely ran into the need to describe the result of the parsing in terms of an AST. While the kinds of nodes such ASTs have and their structure is very specific to the source language, many commonalities come up. In other words, coding &amp;quot;yet another AST&amp;quot; gets really old after you've done it a few times.&lt;/p&gt;
&lt;p&gt;Worry not, as you'd expect from the programmer crowd, this problem was &amp;quot;solved&amp;quot; by adding another level of abstraction. Yes, an &lt;strong&gt;abstraction&lt;/strong&gt; over &lt;strong&gt;Abstract&lt;/strong&gt; Syntax Trees, oh my! The abstraction here is some textual format (let's call it a DSL to sound smart) that describes what the AST looks like, along with machinery to auto-generate the code that implements this AST.&lt;/p&gt;
&lt;p&gt;Most solutions in this domain are ad-hoc, but one that I've seen used more than once is &lt;a class="reference external" href="http://asdl.sourceforge.net/"&gt;ASDL&lt;/a&gt; - Abstract Syntax Definition Language. The self-description from the website sounds about right:&lt;/p&gt;
&lt;blockquote&gt;
The Zephyr Abstract Syntax Description Lanuguage (ASDL) is a language designed to describe the tree-like data structures in compilers. Its main goal is to provide a method for compiler components written in different languages to interoperate. ASDL makes it easier for applications written in a variety of programming languages to communicate complex recursive data structures.&lt;/blockquote&gt;
&lt;p&gt;To give an example, here's a short snippet from an ASDL definition of a simple programming language:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;program = Program(class* classes)

class = Class(identifier name, identifier? parent, feature* features)

[...]

expression = Assign(identifier name, expression expr)
           | StaticDispatch(expression expr, identifier type_name,
                            identifier name, expression* actual)
           | Dispatch(expression expr, identifier name, expression* actual)

[...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The way to read this is: a &lt;em&gt;program&lt;/em&gt; node consists of one or more &lt;em&gt;classes&lt;/em&gt;. Each &lt;em&gt;class&lt;/em&gt; has these children: a &lt;em&gt;name&lt;/em&gt; which is an identifier, an optional &lt;em&gt;parent&lt;/em&gt; which is also an identifier, and a (potentially empty) list of &lt;em&gt;features&lt;/em&gt;, each of which is a feature node. And so on.&lt;/p&gt;
&lt;p&gt;The full details are available in the paper &amp;quot;The Zephyr Abstract Syntax Definition Language&amp;quot; by Wang et.al. Unfortunately, a link to this paper isn't always trivial to find, so I have a PDF copy in the &lt;tt class="docutils literal"&gt;docs&lt;/tt&gt; directory of my &lt;a class="reference external" href="https://github.com/eliben/asdl_parser"&gt;asdl_parser project&lt;/a&gt;, which I'm going to discuss soon.&lt;/p&gt;
&lt;div class="section" id="type-safety-in-asdl"&gt;
&lt;h3&gt;Type safety in ASDL&lt;/h3&gt;
&lt;p&gt;In addition to providing a concise description of nodes from which code (in many languages) can be generated automatically, I like ASDL for another reason. It provides some type safety when constructing the AST in the parser.&lt;/p&gt;
&lt;p&gt;Take the snippet above, for example. A &lt;em&gt;program&lt;/em&gt; has the &lt;em&gt;classes&lt;/em&gt; attribute, which is a (potentially empty) sequence of &lt;em&gt;class&lt;/em&gt; nodes. Each such class has to be a &lt;em&gt;Class&lt;/em&gt;, which is precisely defined. It can be nothing else. The &lt;em&gt;expression&lt;/em&gt; below that shows it differently - an expression can be either a &lt;em&gt;Assign&lt;/em&gt;, &lt;em&gt;StaticDispatch&lt;/em&gt;, etc.&lt;/p&gt;
&lt;p&gt;The set of possibilities is statically defined. This makes it possible to insert some degree of static checking into the (auto-generated) AST construction code. So the constructed AST can't be completely bogus even before semantic analysis is applied. Even though I love Python, I do appreciate a bit of static type checking in the right places. Key data structures like ASTs are, I believe, one of the places when such type checking makes sense.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="asdl-in-upstream-cpython"&gt;
&lt;h3&gt;ASDL in upstream CPython&lt;/h3&gt;
&lt;p&gt;Starting with Python 2.5, the CPython compiler (the part responsible for emitting bytecode from Python source) uses an ASDL description to create an AST for Python source. The AST is created by the parser (from the parse tree - more details in &lt;a class="reference external" href="http://legacy.python.org/dev/peps/pep-0339/"&gt;PEP 339&lt;/a&gt;), and is then used to create the control-flow graph, from which bytecode is emitted.&lt;/p&gt;
&lt;p&gt;The ASDL description lives in &lt;tt class="docutils literal"&gt;Parser/Python.asdl&lt;/tt&gt; in the CPython source tree. &lt;tt class="docutils literal"&gt;Parser/asdl_c.py&lt;/tt&gt; is a script that runs whenever someone modifies this ASDL description. It uses the &lt;tt class="docutils literal"&gt;Parser/asdl.py&lt;/tt&gt; module to parse the ASDL file into an internal form and then emits C code that describes the ASTs. This C code lives in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Include/Python-ast.h&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Python/Python-ast.c&lt;/span&gt;&lt;/tt&gt; &lt;a class="footnote-reference" href="#id2" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This may be more details than you wanted to hear :-) The gist of it, however, is - CPython's ASTs are described in ASDL, and if you want a quick glance of how these ASTs look, &lt;tt class="docutils literal"&gt;Parser/Python.asdl&lt;/tt&gt; is the file to look at.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="my-rewrite-of-the-asdl-parser"&gt;
&lt;h3&gt;My rewrite of the ASDL parser&lt;/h3&gt;
&lt;p&gt;Up until very recently, the ASDL description of the CPython AST was parsed by a tool that relied on the &lt;a class="reference external" href="http://pages.cpsc.ucalgary.ca/~aycock/spark/"&gt;SPARK parsing toolkit&lt;/a&gt;. In fact, &lt;tt class="docutils literal"&gt;Parser/spark.py&lt;/tt&gt; was carried around in the distribution just for this purpose.&lt;/p&gt;
&lt;p&gt;A few months ago I was looking for something to conveniently implement the AST for a toy compiler I was hacking on. Being a CPython developer, ASDL immediately sprang to mind, but I was reluctant to carry the SPARK dependency and/or learn how to use it. The ASDL language seemed simple enough to not require such machinery. Surely a simple recursive-descent parser would do. So I implemented my own stand-alone parser for ASDL, using modern Python 3.x - and it's available in a &lt;a class="reference external" href="https://github.com/eliben/asdl_parser"&gt;public Github repository right here&lt;/a&gt;. Feel free to use it, and let me know how it goes!&lt;/p&gt;
&lt;p&gt;Since my parser turned out to be much simpler and easier to grok than upstream CPython's SPARK-based parser, I proposed to replace it in &lt;a class="reference external" href="http://bugs.python.org/issue19655"&gt;Issue 19655&lt;/a&gt;. After some delays (caused mainly by waiting for 3.4 release and then getting distracted by other stuff), the change &lt;a class="reference external" href="http://hg.python.org/cpython/rev/b769352e2922"&gt;landed in the default branch&lt;/a&gt; (on its way to 3.5) about a month ago. The result is pleasing - the new parser is shorter, doesn't require the SPARK dependency (which was now dropped), has tests and is much more maintainable.&lt;/p&gt;
&lt;p&gt;In the interest of not changing too much at once, I left the interface to the C code generator (&lt;tt class="docutils literal"&gt;Parser/asdl_c.py&lt;/tt&gt;) the same, so there is absolutely no difference in the produced C code. Some time in the future it may make sense to revise this decision. The C generator is also fairly old code that could use some modernization and tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="historical-note-ast-description-in-pycparser"&gt;
&lt;h3&gt;Historical note - AST description in pycparser&lt;/h3&gt;
&lt;p&gt;I first ran into this problem (high-level description of ASTs) when I was working on &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser&lt;/a&gt; (which is &lt;a class="reference external" href="https://eli.thegreenplace.net/2008/11/15/pycparser-v10-is-out/"&gt;quite an old project&lt;/a&gt; by now).&lt;/p&gt;
&lt;p&gt;Back at the time, I looked at the &lt;tt class="docutils literal"&gt;compiler&lt;/tt&gt; module of Python 2.x and liked its approach of simple textual description of the AST which is then parsed and from which the code for AST nodes is emitted. The &lt;tt class="docutils literal"&gt;compiler&lt;/tt&gt; module was a maintenance headache (because it duplicated a lot of the AST logic from the actual compiler) and is gone in Python 3.x, replaced by the &lt;tt class="docutils literal"&gt;ast&lt;/tt&gt; module which provides access to the same C-based AST generated by &lt;tt class="docutils literal"&gt;Parser/asdl_c.py&lt;/tt&gt; as is used by the CPython compiler.&lt;/p&gt;
&lt;p&gt;pycparser's AST description is a simple textual file that's very similar in spirit to ASDL. If I were to do this today, I'd probably also pick ASDL since it's more &amp;quot;standard&amp;quot;, as well as for the extra type safety guarantees it provides.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Even though these files are auto-generated, they are also checked into the CPython Mercurial repository. This is because we don't want people building Python from source to depend on the tools required to generate such files. Only core CPython developers who want to play with the internals need them.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="Python"></category><category term="Python internals"></category></entry><entry><title>Faster XML iteration with ElementTree</title><link href="https://eli.thegreenplace.net/2012/06/17/faster-xml-iteration-with-elementtree" rel="alternate"></link><published>2012-06-17T05:28:44-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-06-17:/2012/06/17/faster-xml-iteration-with-elementtree</id><summary type="html">
        &lt;p&gt;As I've &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/02/python-development-improving-elementtree-for-3-3/"&gt;mentioned previously&lt;/a&gt;, starting with Python 3.3 the C accelerator of the &lt;tt class="docutils literal"&gt;xml.etree.ElementTree&lt;/tt&gt; module is going to be imported by default. This should make quite a bit of code faster for those who were not aware of the existence of the accelerator, and reduce the amount …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;As I've &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/02/python-development-improving-elementtree-for-3-3/"&gt;mentioned previously&lt;/a&gt;, starting with Python 3.3 the C accelerator of the &lt;tt class="docutils literal"&gt;xml.etree.ElementTree&lt;/tt&gt; module is going to be imported by default. This should make quite a bit of code faster for those who were not aware of the existence of the accelerator, and reduce the amount of boilerplate importing for everyone.&lt;/p&gt;
&lt;p&gt;As Python 3.3 is nearing its first beta, more work was done in the past few weeks; mostly fixing all kinds of problems that arose from the aforementioned transition. But in this post I want to focus on one feature that was added this weekend - much faster iteration over the parsed XML tree.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;ElementTree&lt;/tt&gt; offers a few tools for iterating over the tree and for finding interesting elements in it, but the basis for them all is the &lt;tt class="docutils literal"&gt;iter&lt;/tt&gt; method:&lt;/p&gt;
&lt;blockquote&gt;
Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not None or '*', only elements whose tag equals tag are returned from the iterator.&lt;/blockquote&gt;
&lt;p&gt;And until very recently, this &lt;tt class="docutils literal"&gt;iter&lt;/tt&gt; was implemented in Python, even when the C accelerator was loaded. This was achieved by calling &lt;tt class="docutils literal"&gt;PyRun_String&lt;/tt&gt; on a &amp;quot;bootstrap&amp;quot; string defining the method (as well as a bunch of other Python code), when the C extension module was being initialized. In the past few months I've been slowly and surely decimating this bootstrap code, trying to move as much functionality as possible into the C code and replacing stuff with actual C API calls. The last bastion was &lt;tt class="docutils literal"&gt;iter&lt;/tt&gt; (and its cousin &lt;tt class="docutils literal"&gt;itertext&lt;/tt&gt;) because its implementation in C is not trivial.&lt;/p&gt;
&lt;p&gt;Well, that last bastion has now fallen and the C accelerator of &lt;tt class="docutils literal"&gt;ElementTree&lt;/tt&gt; no longer has any Python bootstrap code - &lt;tt class="docutils literal"&gt;iter&lt;/tt&gt; is actually implemented in C. And the great &amp;quot;side effect&amp;quot; of this is that the &lt;tt class="docutils literal"&gt;iter&lt;/tt&gt; method (and all the other methods that rely on it, like &lt;tt class="docutils literal"&gt;find&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;iterfind&lt;/tt&gt; and others) is now much faster. On a relatively large XML document I timed a &lt;strong&gt;10x speed boost&lt;/strong&gt; for simple iteration looking for a specific tag. I hope that this will make a lot of XML processing code in Python much faster out-of-the-box.&lt;/p&gt;
&lt;p&gt;This change is already in Python trunk and will be part of the 3.3 release. I must admit that I didn't spend much time optimizing the C code implementing &lt;tt class="docutils literal"&gt;iter&lt;/tt&gt;, so there may still be an area for improvement. I have a hunch that it can be made a few 10s of percents faster with a bit of effort. If you're interested to help, drop me a line and I will be happy to discuss it.&lt;/p&gt;

    </content><category term="misc"></category><category term="C &amp; C++"></category><category term="Python"></category><category term="Python internals"></category></entry><entry><title>Under the hood of Python class definitions</title><link href="https://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions" rel="alternate"></link><published>2012-06-15T05:51:41-07:00</published><updated>2023-02-04T15:35:51-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-06-15:/2012/06/15/under-the-hood-of-python-class-definitions</id><summary type="html">
        &lt;p&gt;This is a fast-paced walk-through of the internals of defining new classes in Python. It shows what actually happens inside the Python interpreter when a new class definition is encountered and processed. Beware, this is advanced material. If the prospect of pondering the metaclass of the metaclass of your class …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;This is a fast-paced walk-through of the internals of defining new classes in Python. It shows what actually happens inside the Python interpreter when a new class definition is encountered and processed. Beware, this is advanced material. If the prospect of pondering the metaclass of the metaclass of your class makes you feel nauseated, you better stop now.&lt;/p&gt;
&lt;p&gt;The focus is on the official (CPython) implementation of Python 3. For modern releases of Python 2 the concepts are similar, although there will be some slight differences in the details.&lt;/p&gt;
&lt;div class="section" id="on-the-bytecode-level"&gt;
&lt;h3&gt;On the bytecode level&lt;/h3&gt;
&lt;p&gt;I'll start right with the bytecode, ignoring all the good work done by the Python compiler &lt;a class="footnote-reference" href="#id11" id="id1"&gt;[1]&lt;/a&gt;. For simplicity, this function will be used to demonstrate the bytecode generated by a class definition, since it's easy to disassemble functions:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;myfunc&lt;/span&gt;():
    &lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Joe&lt;/span&gt;:
        attr = &lt;span style="color: #007f7f"&gt;100.02&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Disassembling &lt;tt class="docutils literal"&gt;myfunc&lt;/tt&gt; will show us the steps needed to define a new class:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(myfunc.__code__)
 &lt;span style="color: #007f7f"&gt;14&lt;/span&gt;           &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; LOAD_BUILD_CLASS
              &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; (&amp;lt;code &lt;span style="color: #00007f"&gt;object&lt;/span&gt; Joe at &lt;span style="color: #007f7f"&gt;0x7fe226335b80&lt;/span&gt;, &lt;span style="color: #00007f"&gt;file&lt;/span&gt; &lt;span style="color: #7f007f"&gt;&amp;quot;disassemble.py&amp;quot;&lt;/span&gt;, line &lt;span style="color: #007f7f"&gt;14&lt;/span&gt;&amp;gt;)
              &lt;span style="color: #007f7f"&gt;4&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;2&lt;/span&gt; (&lt;span style="color: #7f007f"&gt;&amp;#39;Joe&amp;#39;&lt;/span&gt;)
              &lt;span style="color: #007f7f"&gt;7&lt;/span&gt; MAKE_FUNCTION            &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
             &lt;span style="color: #007f7f"&gt;10&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;2&lt;/span&gt; (&lt;span style="color: #7f007f"&gt;&amp;#39;Joe&amp;#39;&lt;/span&gt;)
             &lt;span style="color: #007f7f"&gt;13&lt;/span&gt; CALL_FUNCTION            &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;
             &lt;span style="color: #007f7f"&gt;16&lt;/span&gt; STORE_FAST               &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; (Joe)
             &lt;span style="color: #007f7f"&gt;19&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; (&lt;span style="color: #00007f"&gt;None&lt;/span&gt;)
             &lt;span style="color: #007f7f"&gt;22&lt;/span&gt; RETURN_VALUE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The number immediately preceding the instruction name is its offset in the binary representation of the code object. All the instructions until and including the one at offset 16 are for defining the class. The last two instructions are for &lt;tt class="docutils literal"&gt;myfunc&lt;/tt&gt; to return &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Let's go through them, step by step. Documentation of the Python bytecode instructions is available in the &lt;a class="reference external" href="http://docs.python.org/dev/library/dis.htm"&gt;dis module&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;LOAD_BUILD_CLASS&lt;/tt&gt; is a special instruction used for creating classes. It pushes the function &lt;tt class="docutils literal"&gt;builtins.__build_class__&lt;/tt&gt; onto the stack. We'll examine this function in much detail later.&lt;/p&gt;
&lt;p&gt;Next, a code object, followed by a name (&lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;) are pushed onto the stack as well. The code object is interesting, let's peek inside:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(myfunc.__code__.co_consts[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;])
 &lt;span style="color: #007f7f"&gt;14&lt;/span&gt;           &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; LOAD_FAST                &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; (__locals__)
              &lt;span style="color: #007f7f"&gt;3&lt;/span&gt; STORE_LOCALS
              &lt;span style="color: #007f7f"&gt;4&lt;/span&gt; LOAD_NAME                &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; (__name__)
              &lt;span style="color: #007f7f"&gt;7&lt;/span&gt; STORE_NAME               &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; (__module__)
             &lt;span style="color: #007f7f"&gt;10&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; (&lt;span style="color: #7f007f"&gt;&amp;#39;myfunc.&amp;lt;locals&amp;gt;.Joe&amp;#39;&lt;/span&gt;)
             &lt;span style="color: #007f7f"&gt;13&lt;/span&gt; STORE_NAME               &lt;span style="color: #007f7f"&gt;2&lt;/span&gt; (__qualname__)

 &lt;span style="color: #007f7f"&gt;15&lt;/span&gt;          &lt;span style="color: #007f7f"&gt;16&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; (&lt;span style="color: #007f7f"&gt;100.02&lt;/span&gt;)
             &lt;span style="color: #007f7f"&gt;19&lt;/span&gt; STORE_NAME               &lt;span style="color: #007f7f"&gt;3&lt;/span&gt; (attr)

 &lt;span style="color: #007f7f"&gt;16&lt;/span&gt;          &lt;span style="color: #007f7f"&gt;22&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;2&lt;/span&gt; (&amp;lt;code &lt;span style="color: #00007f"&gt;object&lt;/span&gt; foo at &lt;span style="color: #007f7f"&gt;0x7fe226335c40&lt;/span&gt;, &lt;span style="color: #00007f"&gt;file&lt;/span&gt; &lt;span style="color: #7f007f"&gt;&amp;quot;disassemble.py&amp;quot;&lt;/span&gt;, line &lt;span style="color: #007f7f"&gt;16&lt;/span&gt;&amp;gt;)
             &lt;span style="color: #007f7f"&gt;25&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;3&lt;/span&gt; (&lt;span style="color: #7f007f"&gt;&amp;#39;myfunc.&amp;lt;locals&amp;gt;.Joe.foo&amp;#39;&lt;/span&gt;)
             &lt;span style="color: #007f7f"&gt;28&lt;/span&gt; MAKE_FUNCTION            &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
             &lt;span style="color: #007f7f"&gt;31&lt;/span&gt; STORE_NAME               &lt;span style="color: #007f7f"&gt;4&lt;/span&gt; (foo)
             &lt;span style="color: #007f7f"&gt;34&lt;/span&gt; LOAD_CONST               &lt;span style="color: #007f7f"&gt;4&lt;/span&gt; (&lt;span style="color: #00007f"&gt;None&lt;/span&gt;)
             &lt;span style="color: #007f7f"&gt;37&lt;/span&gt; RETURN_VALUE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code defines the innards of the class. Some generic bookkeeping, followed by definitions for the &lt;tt class="docutils literal"&gt;attr&lt;/tt&gt; attribute and &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; method.&lt;/p&gt;
&lt;p&gt;Now let's get back to the first disassembly. The next instruction (at offset 7) is &lt;tt class="docutils literal"&gt;MAKE_FUNCTION&lt;/tt&gt; &lt;a class="footnote-reference" href="#id12" id="id2"&gt;[2]&lt;/a&gt;. This instruction pulls two things from the stack - a name and a code object. So in our case, it gets the name &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; and the code object we saw disassembled above. It creates a function with the given name and the code object as its code and pushes it back to the stack.&lt;/p&gt;
&lt;p&gt;This is followed by once again pushing the name &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; onto the stack. Here's what the stack looks like now (TOS means &amp;quot;top of stack&amp;quot;):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;TOS&amp;gt; name &amp;quot;Joe&amp;quot;
     function &amp;quot;Joe&amp;quot; with code for defining the class
     function builtins.__build_class__
     -----------------------------------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point (offset 13), &lt;tt class="docutils literal"&gt;CALL_FUNCTION 2&lt;/tt&gt; is executed. The 2 simply means that the function was passed two positional arguments (and no keyword arguments). &lt;tt class="docutils literal"&gt;CALL_FUNCTION&lt;/tt&gt; first takes the arguments from the stack (the rightmost on top), and then the function itself. So the call is equivalent to:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;builtins.__build_class__(function defining &amp;quot;Joe&amp;quot;, &amp;quot;Joe&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="build-me-a-class-please"&gt;
&lt;h3&gt;Build me a class, please&lt;/h3&gt;
&lt;p&gt;A quick peek into the &lt;tt class="docutils literal"&gt;builtins&lt;/tt&gt; module in &lt;tt class="docutils literal"&gt;Python/bltinmodule.c&lt;/tt&gt; reveals that &lt;tt class="docutils literal"&gt;__build_class__&lt;/tt&gt; is implemented by the function &lt;tt class="docutils literal"&gt;builtin___build_class__&lt;/tt&gt; (I'll call it BBC for simplicity) in the same file.&lt;/p&gt;
&lt;p&gt;As any Python function, BBC accepts both positional and keyword arguments. The positional arguments are:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;func, name, base1, base2, ... baseN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we see only the function and name were passed for &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;, since it has no base classes. The only keyword argument BBC understands is &lt;tt class="docutils literal"&gt;metaclass&lt;/tt&gt; &lt;a class="footnote-reference" href="#id13" id="id3"&gt;[3]&lt;/a&gt;, allowing the Python 3 way of defining &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;metaclasses&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;SomeOtherJoe&lt;/span&gt;(metaclass=JoeMeta):
  [...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So back to BBC, here's what it does &lt;a class="footnote-reference" href="#id14" id="id4"&gt;[4]&lt;/a&gt;:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The first chunk of code deals with extracting the arguments and setting defaults.&lt;/li&gt;
&lt;li&gt;Next, if no metaclass is supplied, BBC looks at the base classes and takes the metaclass of the first base class. If there are no base classes, the default metaclass &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; is used.&lt;/li&gt;
&lt;li&gt;If the metaclass is really a class (note that in Python any callable can be given as a metaclass), look at the bases again to determine &amp;quot;the most derived&amp;quot; metaclass.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The last point deserves a bit of elaboration. If our class has bases, then some rules apply for the metaclasses that are allowed. The metaclasses of its bases must be either subclasses or superclasses of our class's metaclass. Any other arrangement will result in this &lt;tt class="docutils literal"&gt;TypeError&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;metaclass conflict: the metaclass of a derived class must be a (non-strict)
                    subclass of the metaclasses of all its bases
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Eventually, given that there are no conflicts, the most derived metaclass will be chosen. The most derived metaclass is the one which is a subtype of the explicitly specified metaclass and the metaclasses of all the base classes. In other words, if our class's metaclass is &lt;tt class="docutils literal"&gt;Meta1&lt;/tt&gt;, only one of the bases has a metaclass and that's &lt;tt class="docutils literal"&gt;Meta2&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;Meta2&lt;/tt&gt; is a subclass of &lt;tt class="docutils literal"&gt;Meta1&lt;/tt&gt;, it is &lt;tt class="docutils literal"&gt;Meta2&lt;/tt&gt; that will be picked to serve as the eventual metaclass of our class.&lt;/p&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;At this point BBC has a metaclass &lt;a class="footnote-reference" href="#id15" id="id5"&gt;[5]&lt;/a&gt;, so it starts by calling its &lt;tt class="docutils literal"&gt;__prepare__&lt;/tt&gt; method to create a namespace dictionary for the class. If there's no such method, an empty dict is used.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As documented in the &lt;a class="reference external" href="http://docs.python.org/dev/reference/datamodel.html"&gt;data model reference&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
If the metaclass has a __prepare__() attribute (usually implemented as a class or static method), it is called before the class body is evaluated with the name of the class and a tuple of its bases for arguments. It should return an object that supports the mapping interface that will be used to store the namespace of the class. The default is a plain dictionary. This could be used, for example, to keep track of the order that class attributes are declared in by returning an ordered dictionary.&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="5"&gt;
&lt;li&gt;The function argument is invoked, passing the namespace dict as the only argument. If we look back at the disassembly of this function (the second one), we see that the first argument is placed into the &lt;tt class="docutils literal"&gt;f_locals&lt;/tt&gt; attribute of the frame (with the &lt;tt class="docutils literal"&gt;STORE_LOCALS&lt;/tt&gt; instruction). In other words, this dictionary is then used to populate the class attributes. The function itself returns &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; - its outcome is modifying the namespace dictionary.&lt;/li&gt;
&lt;li&gt;Finally, the metaclass is called with the name, list of bases and namespace dictionary as arguments.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The last step defers to the metaclass to actually create a new class with the given definition. &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;Recall that&lt;/a&gt; when some class &lt;tt class="docutils literal"&gt;MyKlass&lt;/tt&gt; has a metaclass &lt;tt class="docutils literal"&gt;MyMeta&lt;/tt&gt;, then the class definition of &lt;tt class="docutils literal"&gt;MyKlass&lt;/tt&gt; is equivalent to &lt;a class="footnote-reference" href="#id16" id="id6"&gt;[6]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;MyKlass = MyMeta(name, bases, namespace_dict)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The flow of BBC outlined above directly embodies this equivalence.&lt;/p&gt;
&lt;p&gt;So what happens next? Well, the metaclass &lt;tt class="docutils literal"&gt;MyMeta&lt;/tt&gt; is a class, right? And what happens when a class is &amp;quot;called&amp;quot;? &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"&gt;It's instantiated&lt;/a&gt;. How is a class's instantiation done? By invoking its metaclass's &lt;tt class="docutils literal"&gt;__call__&lt;/tt&gt;. So wait, this is the metaclass's metaclass we're talking about here, right? Yes! A metaclass is just a class, after all &lt;a class="footnote-reference" href="#id17" id="id7"&gt;[7]&lt;/a&gt;, and has a metaclass of its own - so Python has to keep the meta-flow going.&lt;/p&gt;
&lt;p&gt;Realistically, what probably happens is this:&lt;/p&gt;
&lt;p&gt;Most chances are that your class has no metaclass specified explicitly. Then, its default metaclass is &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;, so the call above is actually:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;MyKlass = &lt;span style="color: #00007f"&gt;type&lt;/span&gt;(name, bases, namespace_dict)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The metaclass of &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; happens to be &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; itself, so here &lt;tt class="docutils literal"&gt;type.__call__&lt;/tt&gt; is called.&lt;/p&gt;
&lt;p&gt;In the more complex case that your class &lt;em&gt;does&lt;/em&gt; have a metaclass, most chances are that the metaclass itself has no metaclass &lt;a class="footnote-reference" href="#id18" id="id8"&gt;[8]&lt;/a&gt;, so &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; is used for it. Therefore, the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;MyMeta(...)&lt;/span&gt;&lt;/tt&gt; call is also served by &lt;tt class="docutils literal"&gt;type.__call__&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="type-call"&gt;
&lt;h3&gt;type_call&lt;/h3&gt;
&lt;p&gt;In &lt;tt class="docutils literal"&gt;Objects/typeobject.c&lt;/tt&gt;, the &lt;tt class="docutils literal"&gt;type.__call__&lt;/tt&gt; slot is getting mapped to the function &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt;. I've already spent some time explaining &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"&gt;how it works&lt;/a&gt;, so it's important to review that article at this point.&lt;/p&gt;
&lt;p&gt;Things are a bit different here, however. The &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"&gt;object creation sequence article&lt;/a&gt; explained how instances are created, so the &lt;tt class="docutils literal"&gt;tp_new&lt;/tt&gt; slot called from &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; went to &lt;tt class="docutils literal"&gt;object&lt;/tt&gt;. Here, since &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; will actually call &lt;tt class="docutils literal"&gt;tp_new&lt;/tt&gt; on a metaclass, and the metaclass's base is &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; (see &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/04/03/the-fundamental-types-of-python-a-diagram/"&gt;this diagram&lt;/a&gt;), we'll have to study how the &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; function (also from &lt;tt class="docutils literal"&gt;Objects/typeobject.c&lt;/tt&gt;) works.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-brief-recap"&gt;
&lt;h3&gt;A brief recap&lt;/h3&gt;
&lt;p&gt;I feel that the flow here is relatively convoluted, so lest we lose focus, let's have a brief recap of how we got thus far. The following is a much simplified version of the flow described so far in this article:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;When a new class &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; is defined...&lt;/li&gt;
&lt;li&gt;The Python interpreter arranges the builtin function &lt;tt class="docutils literal"&gt;builtin__build_class__&lt;/tt&gt; (BBC) to be called, giving it the class name and its innards compiled into a code object.&lt;/li&gt;
&lt;li&gt;BBC finds the metaclass of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; and calls it to create the new class.&lt;/li&gt;
&lt;li&gt;When any class in Python is called, it means that its metaclass's &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; slot is invoked. So to create &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;, this is the &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; of its metaclass's metaclass. In most cases this is the &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; function (since the metaclass's metaclass is almost always &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;, or something that eventually delegates to it).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; creates a new instance of the type it's bound to by calling its &lt;tt class="docutils literal"&gt;tp_new&lt;/tt&gt; slot.&lt;/li&gt;
&lt;li&gt;In our case, that is served by the &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; function.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The next section picks up from step 6.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="type-new"&gt;
&lt;h3&gt;type_new&lt;/h3&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; function is a complex beast - it's over 400 lines long. There's a good reason for this, however, since it plays a very fundamental role in the Python object system. It's literally responsible for creating all Python types. I'll go over its functionality in major blocks, pasting short snippets of code where relevant.&lt;/p&gt;
&lt;p&gt;Let's start at the beginning. The signature of &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;static&lt;/span&gt; PyObject *
type_new(PyTypeObject *metatype, PyObject *args, PyObject *kwds)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When called to create our class &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;, the arguments will be:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;metatype&lt;/tt&gt; - the metaclass, so it's &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; itself.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;args&lt;/tt&gt; - we saw in the description of BBC above that this is the class name, list of base classes and a namespace dict.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;kwds&lt;/tt&gt; - since &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; has no metaclass, this will be empty.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At this point, it may be useful &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;to recall that&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Joe&lt;/span&gt;:
  ... contents
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is equivalent to:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Joe = &lt;span style="color: #00007f"&gt;type&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;joe&amp;#39;&lt;/span&gt;, (), &lt;span style="color: #00007f"&gt;dict&lt;/span&gt; of contents)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; serves both approaches, of course.&lt;/p&gt;
&lt;p&gt;It starts by handling the special 1-argument call of the &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; function, which returns the type. Then, it tries to see if the requested type has a metaclass that's more suitable than the one passed in. This is necessary to handle a direct call to &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; as shown above - if one of the bases has a metaclass, that metaclass should be used for the creation &lt;a class="footnote-reference" href="#id19" id="id9"&gt;[9]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Next, &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; handles some special class methods (for example &lt;tt class="docutils literal"&gt;__slots__&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;Finally, the type object itself is allocated and initialized. Since the &lt;a class="reference external" href="http://www.python.org/download/releases/2.2/descrintro/"&gt;unification of types and classes&lt;/a&gt; in Python, user-defined classes are represented similarly to built-in types inside the CPython VM. However, there's still a difference. Unlike built-in types (and new types exported by C extension) which are statically allocated and are essentially &amp;quot;singletons&amp;quot;, user-defined classes have to be implemented by dynamically allocated type objects on the heap &lt;a class="footnote-reference" href="#id20" id="id10"&gt;[10]&lt;/a&gt;. For this purpose, &lt;tt class="docutils literal"&gt;Include/object.h&lt;/tt&gt; defines an &amp;quot;extended type object&amp;quot;, &lt;tt class="docutils literal"&gt;PyHeapTypeObject&lt;/tt&gt;. This struct starts with a &lt;tt class="docutils literal"&gt;PyTypeObject&lt;/tt&gt; member, so it can be passed around to Python C code expecting any normal type. The extra information it carries is used mainly for book-keeping in the type-handling code (&lt;tt class="docutils literal"&gt;Objects/typeobject.c&lt;/tt&gt;). &lt;tt class="docutils literal"&gt;PyHeapTypeObject&lt;/tt&gt; is an interesting type to discuss but would deserve an article of its own, so I'll stop right here.&lt;/p&gt;
&lt;p&gt;Just as an example of one of the special cases handled by &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; for members of new classes, let's look at &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt;.  The data model reference &lt;a class="reference external" href="http://docs.python.org/dev/reference/datamodel.html#object.__new__"&gt;says&lt;/a&gt; about it:&lt;/p&gt;
&lt;blockquote&gt;
Called to create a new instance of class cls. __new__() is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument.&lt;/blockquote&gt;
&lt;p&gt;It's interesting to see how this statement is embodied in the code of &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;/* Special-case __new__: if it&amp;#39;s a plain function,&lt;/span&gt;
&lt;span style="color: #007f00"&gt;   make it a static function */&lt;/span&gt;
tmp = _PyDict_GetItemId(dict, &amp;amp;PyId___new__);
&lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (tmp != &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; PyFunction_Check(tmp)) {
    tmp = PyStaticMethod_New(tmp);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (tmp == &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;)
        &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; error;
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (_PyDict_SetItemId(dict, &amp;amp;PyId___new__, tmp) &amp;lt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;)
        &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; error;
    Py_DECREF(tmp);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So when the dict of the new class has a &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; method, it's automatically replaced with a corresponding static method.&lt;/p&gt;
&lt;p&gt;After some more handling of special cases, &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; returns the object representing the newly created type.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;This has been a relatively dense article. If you got lost, don't despair. The important part to remember is the flow described in &amp;quot;A brief recap&amp;quot; - the rest of the article just explains the items in that list in more detail.&lt;/p&gt;
&lt;p&gt;The Python type system is very powerful, dynamic and flexible. Since this all has to be implemented in the low-level and type-rigid C, and at the same time be relatively efficient, the implementation is almost inevitably complex. If you're just writing Python code, you almost definitely don't have to be aware of all these details. However, if you're writing non-trivial C extensions, and/or hacking on CPython itself, understanding the contents of this article (at least on an approximate level) can be useful and educational.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Many thanks to Nick Coghlan for reviewing this article.&lt;/em&gt;&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;If you're interested in the compilation part, &lt;a class="reference external" href="https://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/"&gt;this article&lt;/a&gt; provides a good overview.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In the distant past, &lt;tt class="docutils literal"&gt;MAKE_FUNCTION&lt;/tt&gt; was used both for creating functions and classes. However, when lexical scoping was added to Python, a new instruction for creating functions was added - &lt;tt class="docutils literal"&gt;MAKE_CLOSURE&lt;/tt&gt;. So nowadays, as strange as it sounds, &lt;tt class="docutils literal"&gt;MAKE_FUNCTION&lt;/tt&gt; is only used for creating &lt;em&gt;classes&lt;/em&gt;, not &lt;em&gt;functions&lt;/em&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id13" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The other keyword arguments, if they exist, are passed to the metaclass when it's getting called.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id14" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;You may find it educational to open the file &lt;tt class="docutils literal"&gt;Python/bltinmodule.c&lt;/tt&gt; from the Python source distribution and follow along.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id15" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There always is &lt;em&gt;some&lt;/em&gt; metaclass, because all classes eventually derive from &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; whose metaclass is &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id16" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;With the caveat that BBC also calls &lt;tt class="docutils literal"&gt;__prepare__&lt;/tt&gt;. For a more equivalent sequence, take a look at &lt;a class="reference external" href="http://docs.python.org/dev/library/types.html?highlight=new_class#types.new_class"&gt;types.new_class&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id17" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;As I mentioned earlier, any callable can be specified as a metaclass. If the callable is a function and not a class, it's simply called as the last step of BBC - the rest of the discussion doesn't apply.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id18" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I've never encountered real-world Python code where a metaclass has a metaclass of its own. If you have, please let me know - I'm genuinely curious about the use cases for such a construct.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id19" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id9"&gt;[9]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;If you've noticed that this is a duplication of effort, you're right. BBC also computes the metaclass, but to handle the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;type(...)&lt;/span&gt;&lt;/tt&gt; call, &lt;tt class="docutils literal"&gt;type_new&lt;/tt&gt; has to do this again. I think that creating new classes is a rare enough occurrence that the extra work done here doesn't count for much.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id20" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id10"&gt;[10]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Since they have to be garbage collected and fully deleted when no longer needed.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Python internals"></category></entry><entry><title>Python object creation sequence</title><link href="https://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence" rel="alternate"></link><published>2012-04-16T07:03:41-07:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-04-16:/2012/04/16/python-object-creation-sequence</id><summary type="html">
        &lt;p&gt;&lt;em&gt;[The Python version described in this article is 3.x]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This article aims to explore the process of creating new objects in Python. As I explained in &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"&gt;a previous article&lt;/a&gt;, object creation is just a special case of calling a callable. Consider this Python code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Joe&lt;/span&gt;:
    &lt;span style="color: #00007f; font-weight: bold"&gt;pass&lt;/span&gt;

j = Joe …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
        &lt;p&gt;&lt;em&gt;[The Python version described in this article is 3.x]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This article aims to explore the process of creating new objects in Python. As I explained in &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"&gt;a previous article&lt;/a&gt;, object creation is just a special case of calling a callable. Consider this Python code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Joe&lt;/span&gt;:
    &lt;span style="color: #00007f; font-weight: bold"&gt;pass&lt;/span&gt;

j = Joe()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happens when &lt;tt class="docutils literal"&gt;j = Joe()&lt;/tt&gt; is executed? Python sees it as a call to the callable &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;, and routes it to the internal function &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt;, with &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; passed as the first argument. &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt; looks at the type of its first argument to extract its &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; attribute.&lt;/p&gt;
&lt;p&gt;Now, what is the type of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;? Whenever we define a new Python class, unless we explicitly specify &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;a metaclass&lt;/a&gt; for it, its type is &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;. Therefore, when &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt; attempts to look at the type of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;, it finds &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; and picks its &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; attribute. In other words, the function &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;Objects/typeobject.c&lt;/tt&gt; is invoked &lt;a class="footnote-reference" href="#id5" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is an interesting function, and it's short, so I'll paste it wholly here:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;static&lt;/span&gt; PyObject *
&lt;span style="color: #00007f"&gt;type_call&lt;/span&gt;(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj;

    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (type-&amp;gt;tp_new == &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;) {
        PyErr_Format(PyExc_TypeError,
                     &lt;span style="color: #7f007f"&gt;&amp;quot;cannot create &amp;#39;%.100s&amp;#39; instances&amp;quot;&lt;/span&gt;,
                     type-&amp;gt;tp_name);
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
    }

    obj = type-&amp;gt;tp_new(type, args, kwds);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (obj != &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;) {
        &lt;span style="color: #007f00"&gt;/* Ugly exception: when the call was type(something),&lt;/span&gt;
&lt;span style="color: #007f00"&gt;           don&amp;#39;t call tp_init on the result. */&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (type == &amp;amp;PyType_Type &amp;amp;&amp;amp;
            PyTuple_Check(args) &amp;amp;&amp;amp; PyTuple_GET_SIZE(args) == &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; &amp;amp;&amp;amp;
            (kwds == &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt; ||
             (PyDict_Check(kwds) &amp;amp;&amp;amp; PyDict_Size(kwds) == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;)))
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; obj;
        &lt;span style="color: #007f00"&gt;/* If the returned object is not an instance of type,&lt;/span&gt;
&lt;span style="color: #007f00"&gt;           it won&amp;#39;t be initialized. */&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (!PyType_IsSubtype(Py_TYPE(obj), type))
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; obj;
        type = Py_TYPE(obj);
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (type-&amp;gt;tp_init != &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp;
            type-&amp;gt;tp_init(obj, args, kwds) &amp;lt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
            Py_DECREF(obj);
            obj = &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
        }
    }
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; obj;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what arguments is &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; being passed in our case? The first one is &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; itself - but how is it represented? Well, &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; is a class, so it's a &lt;em&gt;type&lt;/em&gt; (&lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/"&gt;all classes are types in Python 3&lt;/a&gt;). Types are represented inside the CPython VM by &lt;tt class="docutils literal"&gt;PyTypeObject&lt;/tt&gt; objects &lt;a class="footnote-reference" href="#id6" id="id2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; does is first call the &lt;tt class="docutils literal"&gt;tp_new&lt;/tt&gt; attribute of the given type. Then, it checks for a special case we can ignore for simplicity, makes sure &lt;tt class="docutils literal"&gt;tp_new&lt;/tt&gt; returned an object of the expected type, and then calls &lt;tt class="docutils literal"&gt;tp_init&lt;/tt&gt;. If an object of a different type was returned, it is not being initialized.&lt;/p&gt;
&lt;p&gt;Translated to Python, what happens is this: if your class defines the &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; special method, it gets called first when a new instance of the class is created. This method has to return some object. Usually, this will be of the required type, but this doesn't have to be the case. Objects of the required type get &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; invoked on them. Here's an example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Joe&lt;/span&gt;:
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__new__&lt;/span&gt;(cls, *args, **kwargs):
        obj = &lt;span style="color: #00007f"&gt;super&lt;/span&gt;(Joe, cls).__new__(cls)
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;__new__ called. got new obj id=0x%x&amp;#39;&lt;/span&gt; % &lt;span style="color: #00007f"&gt;id&lt;/span&gt;(obj))
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; obj

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, arg):
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;__init__ called (self=0x%x) with arg=%s&amp;#39;&lt;/span&gt; % (&lt;span style="color: #00007f"&gt;id&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;), arg))
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.arg = arg

j = Joe(&lt;span style="color: #007f7f"&gt;12&lt;/span&gt;)
&lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #00007f"&gt;type&lt;/span&gt;(j))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This prints:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;__new__ called. got new obj id=0x7f88e7218290
__init__ called (self=0x7f88e7218290) with arg=12
&amp;lt;class &amp;#39;__main__.Joe&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="customizing-the-sequence"&gt;
&lt;h3&gt;Customizing the sequence&lt;/h3&gt;
&lt;p&gt;As we saw above, since the type of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;, the &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; function is invoked to define the creation sequence for &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; instances. This sequence can be changed by specifying a custom type for &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; - in other words, a metaclass. Let's modify the previous example to specify a custom metaclass for &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;MetaJoe&lt;/span&gt;(&lt;span style="color: #00007f"&gt;type&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__call__&lt;/span&gt;(cls, *args, **kwargs):
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;MetaJoe.__call__&amp;#39;&lt;/span&gt;)
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Joe&lt;/span&gt;(metaclass=MetaJoe):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__new__&lt;/span&gt;(cls, *args, **kwargs):
        obj = &lt;span style="color: #00007f"&gt;super&lt;/span&gt;(Joe, cls).__new__(cls)
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;__new__ called. got new obj id=0x%x&amp;#39;&lt;/span&gt; % &lt;span style="color: #00007f"&gt;id&lt;/span&gt;(obj))
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; obj

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, arg):
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;__init__ called (self=0x%x) with arg=%s&amp;#39;&lt;/span&gt; % (&lt;span style="color: #00007f"&gt;id&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;), arg))
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.arg = arg

j = Joe(&lt;span style="color: #007f7f"&gt;12&lt;/span&gt;)
&lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #00007f"&gt;type&lt;/span&gt;(j))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now the type of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; is not &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;, but &lt;tt class="docutils literal"&gt;MetaJoe&lt;/tt&gt;. Consequently, when &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt; picks the call function to execute for &lt;tt class="docutils literal"&gt;j = Joe(12)&lt;/tt&gt;, it takes &lt;tt class="docutils literal"&gt;MetaJoe.__call__&lt;/tt&gt;. The latter prints a notice about itself and returns &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;, so we don't expect the &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; methods of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; to be called at all. Indeed, this is the outcome:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;MetaJoe.__call__
&amp;lt;class &amp;#39;NoneType&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="digging-deeper-tp-new"&gt;
&lt;h3&gt;Digging deeper - tp_new&lt;/h3&gt;
&lt;p&gt;Alright, so now we have a better understanding of the object creation sequence. One crucial piece of the puzzle is still missing, though. While we almost always define &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; for our classes, defining &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; is rather rare &lt;a class="footnote-reference" href="#id7" id="id3"&gt;[3]&lt;/a&gt;. Moreover, from a quick look at the code it's obvious that &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; is more fundamental in a way. This method is used to create a new object. It is called once and only once per instantiation. &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt;, on the other hand, already gets a constructed object and may not be called at all; it can also be called multiple times.&lt;/p&gt;
&lt;p&gt;Since the &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; parameter passed to &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; in our case is &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; does not define a custom &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; method, then &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;type-&amp;gt;tp_new&lt;/span&gt;&lt;/tt&gt; defers to the &lt;tt class="docutils literal"&gt;tp_new&lt;/tt&gt; slot of the base type. The base type of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; (&lt;a class="reference external" href="https://eli.thegreenplace.net/2012/04/03/the-fundamental-types-of-python-a-diagram/"&gt;and all other Python objects&lt;/a&gt;, except &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; itself) is &lt;tt class="docutils literal"&gt;object&lt;/tt&gt;. The &lt;tt class="docutils literal"&gt;object.tp_new&lt;/tt&gt; slot is implemented in CPython by the &lt;tt class="docutils literal"&gt;object_new&lt;/tt&gt; function in &lt;tt class="docutils literal"&gt;Objects/typeobject.c&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;object_new&lt;/tt&gt; is actually very simple. It does some argument checking, verifies that the type we're trying to instantiate is not &lt;a class="reference external" href="http://docs.python.org/dev/library/abc.html"&gt;abstract&lt;/a&gt;, and then does this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; type-&amp;gt;tp_alloc(type, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;tp_alloc&lt;/tt&gt; is a low-level slot of the type object in CPython. It's not directly accessible from Python code, but should be familiar to C extension developers. A custom type defined in a C extension may override this slot to supply a custom memory allocation scheme for instances of itself. Most C extension types will, however, defer this allocation to the function &lt;tt class="docutils literal"&gt;PyType_GenericAlloc&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;This function is part of the public C API of CPython, and it also happens to be assigned to the &lt;tt class="docutils literal"&gt;tp_alloc&lt;/tt&gt; slot of &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; (defined in &lt;tt class="docutils literal"&gt;Objects/typeobject.c&lt;/tt&gt;). It figures out how much memory the new object needs &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[4]&lt;/a&gt;, allocates a memory chunk from CPython's memory allocator and initializes it all to zeros. It then initializes the bare essential &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; fields (type and reference count), does some GC bookkeeping and returns. The result is a freshly allocated instance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Lest we lose the forest for the trees, let's revisit the question this article began with. What happens when CPython executes &lt;tt class="docutils literal"&gt;j = Joe()&lt;/tt&gt;?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Since &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; has no explicit metaclass, &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; is its type. So the &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; slot of &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;, which is &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt;, is called.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; starts by calling the &lt;tt class="docutils literal"&gt;tp_new&lt;/tt&gt; slot of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;:&lt;ul&gt;
&lt;li&gt;Since &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; has no explicit base clase, its base is &lt;tt class="docutils literal"&gt;object&lt;/tt&gt;. Therefore, &lt;tt class="docutils literal"&gt;object_new&lt;/tt&gt; is called.&lt;/li&gt;
&lt;li&gt;Since &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; is a Python-defined class, it has no custom &lt;tt class="docutils literal"&gt;tp_alloc&lt;/tt&gt; slot. Therefore, &lt;tt class="docutils literal"&gt;object_new&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;PyType_GenericAlloc&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyType_GenericAlloc&lt;/tt&gt; allocates and initializes a chunk of memory big enough to contain &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; then goes on and calls &lt;tt class="docutils literal"&gt;Joe.__init__&lt;/tt&gt; on the newly created object.&lt;ul&gt;
&lt;li&gt;Since &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; does not define &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt;, its base's &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; is called, which is &lt;tt class="docutils literal"&gt;object_init&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;object_init&lt;/tt&gt; does nothing.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The new object is returned from &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; and is bound to the name &lt;tt class="docutils literal"&gt;j&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is the vanilla flow for an object of a class that doesn't have a custom metaclass, doesn't have an explicit base class, and doesn't define its own &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; methods. However, this article should have made it quite clear where these custom capabilities plug in to modify the object creation sequence. As you can see, Python is amazingly flexible. Practically every single step of the process described above can be customized, even for user-defined types implemented in Python. Types implemented in a C extension can customize even more, such as the exact memory allocation strategy used to create instances of the type.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The &lt;tt class="docutils literal"&gt;PyTypeObject&lt;/tt&gt; structure definition for &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;PyType_Type&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;Objects/typeobject.c&lt;/tt&gt;. You can see that &lt;tt class="docutils literal"&gt;type_call&lt;/tt&gt; is being assigned to its &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; slot.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A future article will show how this comes to be when a new class is created.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Even when we do explicitly override &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; in our classes, we almost certainly defer the actual object creation to the base's &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This information is available in the &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; header of any type.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Python internals"></category></entry><entry><title>The fundamental types of Python - a diagram</title><link href="https://eli.thegreenplace.net/2012/04/03/the-fundamental-types-of-python-a-diagram" rel="alternate"></link><published>2012-04-03T20:33:09-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-04-03:/2012/04/03/the-fundamental-types-of-python-a-diagram</id><summary type="html">
        &lt;p&gt;The aim of this post is to present a succinct diagram that correlates some basic properties of all Python objects with the fundamental types &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;object&lt;/tt&gt;. This is not a tutorial - it's more of a reference snapshot that puts things in order. To properly understand why things are the …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;The aim of this post is to present a succinct diagram that correlates some basic properties of all Python objects with the fundamental types &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;object&lt;/tt&gt;. This is not a tutorial - it's more of a reference snapshot that puts things in order. To properly understand why things are the way they are, check out the existing and future writings in the &lt;a class="reference external" href="https://eli.thegreenplace.net/tag/python-internals"&gt;Python internals category&lt;/a&gt; of this blog, as well as other resources available online.&lt;/p&gt;
&lt;p&gt;In Python, &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/"&gt;every object has a type&lt;/a&gt;. Types are also objects - rather special objects. A type object, like any other object, has a type of its own. It also has a sequence of &amp;quot;base types&amp;quot; - in other words, types from which it inherits. This is unlike non-type objects, which don't have base types.&lt;/p&gt;
&lt;p&gt;Consider this exemplary piece of code (Python 3):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;# Some types&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Base&lt;/span&gt;:
    &lt;span style="color: #00007f; font-weight: bold"&gt;pass&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Klass&lt;/span&gt;(Base):
    &lt;span style="color: #00007f; font-weight: bold"&gt;pass&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Meta&lt;/span&gt;(&lt;span style="color: #00007f"&gt;type&lt;/span&gt;):
    &lt;span style="color: #00007f; font-weight: bold"&gt;pass&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;KlassWithMeta&lt;/span&gt;(metaclass=Meta):
    &lt;span style="color: #00007f; font-weight: bold"&gt;pass&lt;/span&gt;

&lt;span style="color: #007f00"&gt;# Non-types&lt;/span&gt;
kwm = KlassWithMeta()
mylist = []
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The following diagram describes the types and bases of all the objects created in this code. Non-type objects only have types and no bases:&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/2012/04/typediagram.png" /&gt;
&lt;p&gt;Some interesting things to note:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The default type of all new types is &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;. This can be overridden by explicitly specifying the &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;metaclass&lt;/a&gt; for a type.&lt;/li&gt;
&lt;li&gt;Built-in types like &lt;tt class="docutils literal"&gt;list&lt;/tt&gt; and user-defined types like &lt;tt class="docutils literal"&gt;Base&lt;/tt&gt; are equivalent as far as Python is concerned.&lt;/li&gt;
&lt;li&gt;The special type &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; is the default type of all objects - &lt;em&gt;including itself&lt;/em&gt;. It is an object, and as such, inherits from &lt;tt class="docutils literal"&gt;object&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;The special type &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; is the pinnacle of every inheritance hierarchy - it's the ultimate base type of all Python types.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;type&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; are the only types in Python that really stand out from other types (and hence they are colored differently). &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; is its own type. &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; has no base type.&lt;/li&gt;
&lt;/ul&gt;

    </content><category term="misc"></category><category term="Python internals"></category></entry><entry><title>Python objects, types, classes, and instances - a glossary</title><link href="https://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary" rel="alternate"></link><published>2012-03-30T07:35:53-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-03-30:/2012/03/30/python-objects-types-classes-and-instances-a-glossary</id><summary type="html">
        &lt;p&gt;While writing the article on the &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"&gt;internals of Python callables&lt;/a&gt;, it occurred to me that some things in Python have more than one name. At the same time, some names are sometimes used to refer to more than one entity, and which one is implied has to be understood from …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;While writing the article on the &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"&gt;internals of Python callables&lt;/a&gt;, it occurred to me that some things in Python have more than one name. At the same time, some names are sometimes used to refer to more than one entity, and which one is implied has to be understood from context. Therefore, I think it's a good idea to collect this nomenclature in a single place for the sake of my future writings. This way I'll just be able to point here every time I discuss these topics, instead of explaining them over and over again.&lt;/p&gt;
&lt;p&gt;Specifically, I want to define what I mean by &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;objects&lt;/em&gt;, &lt;em&gt;classes&lt;/em&gt; and &lt;em&gt;instances&lt;/em&gt;. Note that this refers to Python 3.x, but is mostly applicable for 2.x as well &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="objects"&gt;
&lt;h3&gt;Objects&lt;/h3&gt;
&lt;p&gt;It's easiest to start with &lt;em&gt;objects&lt;/em&gt;. The Python &lt;a class="reference external" href="http://docs.python.org/dev/reference/datamodel.html"&gt;data model reference&lt;/a&gt; has a pretty good definition:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer,” code is also represented by objects.)&lt;/p&gt;
&lt;p&gt;Every object has an identity, a type and a value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, everything in Python is an object. Lists are objects. 42 is an object. Modules are objects. Functions are objects. Python bytecode is also kept in an object. All of these have types and unique IDs:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; def foo(): pass
...
&amp;gt;&amp;gt;&amp;gt; type(foo), id(foo)
(&amp;lt;class &amp;#39;function&amp;#39;&amp;gt;, 38110760)
&amp;gt;&amp;gt;&amp;gt; type(foo.__code__), id(foo.__code__)
(&amp;lt;class &amp;#39;code&amp;#39;&amp;gt;, 38111680)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This &amp;quot;everything is an object&amp;quot; model is backed by the CPython implementation. Indeed, if you look into the code of CPython, you'll notice that every entity mentioned above can be manipulated via a pointer to the &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; base struct.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="types"&gt;
&lt;h3&gt;Types&lt;/h3&gt;
&lt;p&gt;The data model reference is useful here too:&lt;/p&gt;
&lt;blockquote&gt;
[...] An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type.&lt;/blockquote&gt;
&lt;p&gt;So, every object in Python has a type. Its type can be discovered by calling the &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; builtin function &lt;a class="footnote-reference" href="#id4" id="id2"&gt;[2]&lt;/a&gt;. The type is an object too, so it has a type of its own, which is called &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;. This last fact may not be very exciting or useful when you're just writing Python code, but it's hugely important if you want to understand the internals of CPython:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; type(42)
&amp;lt;class &amp;#39;int&amp;#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(type(42))
&amp;lt;class &amp;#39;type&amp;#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(type(type(42)))
&amp;lt;class &amp;#39;type&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yep, it's turtles all the way down.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="classes"&gt;
&lt;h3&gt;Classes&lt;/h3&gt;
&lt;p&gt;In the olden days, there was a difference between user-defined classes and built in types. But &lt;a class="reference external" href="http://www.python.org/download/releases/2.2.3/descrintro/"&gt;since 2.2&lt;/a&gt;, as long as you're using &amp;quot;new-style&amp;quot; classes (classes that inherit from &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; in 2.x, and are default in 3.x), there is no real difference. Essentially, a &lt;em&gt;class&lt;/em&gt; is a mechanism Python gives us to create new user-defined types from Python code.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; class Joe: pass
...
&amp;gt;&amp;gt;&amp;gt; j = Joe()
&amp;gt;&amp;gt;&amp;gt; type(j)
&amp;lt;class &amp;#39;__main__.Joe&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the class mechanism, we've created &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; - a user-defined type. &lt;tt class="docutils literal"&gt;j&lt;/tt&gt; is an instance of the class &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;. In other words, it's an object and its type is &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;As any other type, &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; is an object itself, and it has a type too. This type is &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; type(type(j))
&amp;lt;class &amp;#39;type&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The terms &amp;quot;class&amp;quot; and &amp;quot;type&amp;quot; are an example of two names referring to the same concept. To avoid this confusion, I will always try to say &amp;quot;type&amp;quot; when I mean a type, and &amp;quot;user-defined class&amp;quot; (or &amp;quot;user-defined type&amp;quot;) when referring to a new type created using the &lt;tt class="docutils literal"&gt;class&lt;/tt&gt; construct. Note that when we create new types using the C API of CPython, there's no &amp;quot;class&amp;quot; mentioned - we create a new &amp;quot;type&amp;quot;, not a new &amp;quot;class&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="instances"&gt;
&lt;h3&gt;Instances&lt;/h3&gt;
&lt;p&gt;Not unlike the ambiguity between &amp;quot;class&amp;quot; and &amp;quot;type&amp;quot;, &amp;quot;instance&amp;quot; is synonymous to &amp;quot;object&amp;quot;. Think of it this way: &lt;em&gt;objects are instances of types&lt;/em&gt;. So, &amp;quot;42 is an instance of the type &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;&amp;quot; is equivalent to &amp;quot;42 is an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; object&amp;quot;. I usually use &amp;quot;instance&amp;quot; and &amp;quot;object&amp;quot; interchangeably. In some cases when I want to specifically refer to objects as artifacts of the CPython implementation, I will try to use &amp;quot;instance&amp;quot; to refer to actual instances of classes. Another place where the term &amp;quot;instance&amp;quot; is explicitly used by Python is in built-ins like &lt;tt class="docutils literal"&gt;isinstance&lt;/tt&gt; and the special &lt;tt class="docutils literal"&gt;__instancecheck__&lt;/tt&gt; attribute.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;As we've seen, there are two pairs of roughly synonymous terms in Python nomenclature. Types and classes are interchangeable concepts. I prefer to say &amp;quot;type&amp;quot; wherever possible, leaving the term &amp;quot;class&amp;quot; for user-defined types created with the &amp;quot;class&amp;quot; construct. IMHO &amp;quot;type&amp;quot; is a better term, and Python wouldn't be worse if the &amp;quot;class&amp;quot; concept was wiped out completely.&lt;/p&gt;
&lt;p&gt;Similarly, objects and instances are terms that mean the same thing, but perhaps from slightly different angles. Sometimes it's more convenient to use &amp;quot;instance&amp;quot; (i.e. when specifically talking about specific objects being instances of specific types - as in &amp;quot;&lt;tt class="docutils literal"&gt;j&lt;/tt&gt; is an instance of &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt;&amp;quot;), and sometimes it's better to use &amp;quot;object&amp;quot; (i.e. when discussing the guts of the CPython implementation).&lt;/p&gt;
&lt;p&gt;I sincerely hope this post is more helpful than confusing! For me, it's an aid that serves as a simple glossary when my usage of these terms in some article may be unclear or ambiguous.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;As long as you forget about the existence of classic 2.x classes and take it as a fact that all user-defined classes inherit from &lt;tt class="docutils literal"&gt;object&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;An alternative is the &lt;tt class="docutils literal"&gt;__class__&lt;/tt&gt; attribute.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Python"></category><category term="Python internals"></category></entry><entry><title>Python internals: how callables work</title><link href="https://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work" rel="alternate"></link><published>2012-03-23T10:53:32-07:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2012-03-23:/2012/03/23/python-internals-how-callables-work</id><summary type="html">
        &lt;p&gt;&lt;em&gt;[The Python version described in this article is 3.x, more specifically - the  3.3 alpha release of CPython.]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The concept of a &lt;em&gt;callable&lt;/em&gt; is fundamental in Python. When thinking about what can be &amp;quot;called&amp;quot;, the immediately obvious answer is functions. Whether it's user defined functions (written by you), or …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;&lt;em&gt;[The Python version described in this article is 3.x, more specifically - the  3.3 alpha release of CPython.]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The concept of a &lt;em&gt;callable&lt;/em&gt; is fundamental in Python. When thinking about what can be &amp;quot;called&amp;quot;, the immediately obvious answer is functions. Whether it's user defined functions (written by you), or builtin functions (most probably implemented in C inside the CPython interpreter), functions were meant to be called, right?&lt;/p&gt;
&lt;p&gt;Well, there are also methods, but they're not very interesting because they're just special functions that are bound to objects. What else can be called? You may, or may not be familiar with the ability to call &lt;em&gt;objects&lt;/em&gt;, as long as they belong to classes that define the &lt;tt class="docutils literal"&gt;__call__&lt;/tt&gt; magic method. So objects can act as functions. And thinking about this a bit further, classes are callable too. After all, here's how we create new objects:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Joe&lt;/span&gt;:
  ... [contents of class]

joe = Joe()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we &amp;quot;call&amp;quot; &lt;tt class="docutils literal"&gt;Joe&lt;/tt&gt; to create a new instance. So classes can act as functions as well!&lt;/p&gt;
&lt;p&gt;It turns out that all these concepts are nicely united in the CPython implementation. Everything in Python is an object, and that includes every entity described in the previous paragraphs (user &amp;amp; builtin functions, methods, objects, classes). All these calls are served by a single mechanism. This mechanism is elegant and not that difficult to understand, so it's worth knowing about. But let's start at the beginning.&lt;/p&gt;
&lt;div class="section" id="compiling-calls"&gt;
&lt;h3&gt;Compiling calls&lt;/h3&gt;
&lt;p&gt;CPython executes our program in two major steps:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The Python source code is compiled to bytecode.&lt;/li&gt;
&lt;li&gt;A VM executes that bytecode, using a toolbox of built-in objects and modules to help it do its job.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this section I'll provide a quick overview of how the first step applies to making calls. I won't get too deep since these details are not the really interesting part I want to focus on in the article. If you want to learn more about the flow Python source undergoes in the compiler, read &lt;a class="reference external" href="https://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/"&gt;this&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Briefly, the Python compiler identifies everything followed by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(arguments...)&lt;/span&gt;&lt;/tt&gt; inside an expression as a call &lt;a class="footnote-reference" href="#id7" id="id1"&gt;[1]&lt;/a&gt;. The AST node for this is &lt;tt class="docutils literal"&gt;Call&lt;/tt&gt;. The compiler emits code for &lt;tt class="docutils literal"&gt;Call&lt;/tt&gt; in the &lt;tt class="docutils literal"&gt;compiler_call&lt;/tt&gt; function in &lt;tt class="docutils literal"&gt;Python/compile.c&lt;/tt&gt;. In most cases, the &lt;tt class="docutils literal"&gt;CALL_FUNCTION&lt;/tt&gt; bytecode instruction is going to be emitted. There are some variations I'm going to ignore for the purpose of the article. For example, if the call has &amp;quot;star args&amp;quot; - &lt;tt class="docutils literal"&gt;func(a, b, *args)&lt;/tt&gt;, there's a special instruction for handling that - &lt;tt class="docutils literal"&gt;CALL_FUNCTION_VAR&lt;/tt&gt;. It and other special instructions are just variations on the same theme.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="call-function"&gt;
&lt;h3&gt;CALL_FUNCTION&lt;/h3&gt;
&lt;p&gt;So &lt;tt class="docutils literal"&gt;CALL_FUNCTION&lt;/tt&gt; is the instruction we're going to focus on here. This is &lt;a class="reference external" href="http://docs.python.org/dev/library/dis.html"&gt;what it does&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;CALL_FUNCTION(argc)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Calls a function. The low byte of &lt;em&gt;argc&lt;/em&gt; indicates the number of positional parameters, the high byte the number of keyword parameters. On the stack, the opcode finds the keyword parameters first. For each keyword argument, the value is on top of the key. Below the keyword parameters, the positional parameters are on the stack, with the right-most parameter on top. Below the parameters, the function object to call is on the stack. Pops all function arguments, and the function itself off the stack, and pushes the return value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CPython bytecode is evaluated by the the mammoth function &lt;tt class="docutils literal"&gt;PyEval_EvalFrameEx&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;Python/ceval.c&lt;/tt&gt;. The function is scary but it's nothing more than a fancy dispatcher of opcodes. It reads instructions from the code object of the given frame and executes them. Here, for example, is the handler for &lt;tt class="docutils literal"&gt;CALL_FUNCTION&lt;/tt&gt; (cleaned up a bit to remove tracing and timing macros):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;TARGET(CALL_FUNCTION)
{
    PyObject **sp;
    sp = stack_pointer;
    x = call_function(&amp;amp;sp, oparg);
    stack_pointer = sp;
    PUSH(x);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (x != &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;)
        DISPATCH();
    &lt;span style="color: #00007f; font-weight: bold"&gt;break&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not too bad - it's actually very readable. &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; does the actual call (we'll examine it in a bit), &lt;tt class="docutils literal"&gt;oparg&lt;/tt&gt; is the numeric argument of the instruction, and &lt;tt class="docutils literal"&gt;stack_pointer&lt;/tt&gt; points to the top of the stack &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[2]&lt;/a&gt;. The value returned by &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; is pushed back to the stack, and &lt;tt class="docutils literal"&gt;DISPATCH&lt;/tt&gt; is just some macro magic to invoke the next instruction.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; is also in &lt;tt class="docutils literal"&gt;Python/ceval.c&lt;/tt&gt;. It implements the actual functionality of the instruction. At 80 lines it's not very long, but long enough so I won't paste it wholly here. Instead I'll explain the flow in general and paste small snippets where relevant; you're welcome to follow along with the code open in your favorite editor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="any-call-is-just-an-object-call"&gt;
&lt;h3&gt;Any call is just an object call&lt;/h3&gt;
&lt;p&gt;The most important first step in understanding how calls work in Python is to ignore most of what &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; does. Yes, I mean it. The vast majority of the code in this function deals with optimizations for various common cases. It can be removed without hurting the correctness of the interpreter, only its performance. If we ignore all optimizations for the time being, all &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; does is decode the amount of arguments and amount of keyword arguments from the single argument of &lt;tt class="docutils literal"&gt;CALL_FUNCTION&lt;/tt&gt; and forwards it to &lt;tt class="docutils literal"&gt;do_call&lt;/tt&gt;. We'll get back to the optimizations later since they are interesting, but for the time being, let's see what the core flow is.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;do_call&lt;/tt&gt; loads the arguments from the stack into &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; objects (a tuple for the positional arguments, a dict for the keyword arguments), does a bit of tracing and optimization of its own, but eventually calls &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt; is a super-important function. It's also available to extensions in the Python C API. Here it is, in all its glory:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;PyObject *
&lt;span style="color: #00007f"&gt;PyObject_Call&lt;/span&gt;(PyObject *func, PyObject *arg, PyObject *kw)
{
    ternaryfunc call;

    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; ((call = func-&amp;gt;ob_type-&amp;gt;tp_call) != &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;) {
        PyObject *result;
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (Py_EnterRecursiveCall(&lt;span style="color: #7f007f"&gt;&amp;quot; while calling a Python object&amp;quot;&lt;/span&gt;))
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
        result = (*call)(func, arg, kw);
        Py_LeaveRecursiveCall();
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (result == &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; !PyErr_Occurred())
            PyErr_SetString(
                PyExc_SystemError,
                &lt;span style="color: #7f007f"&gt;&amp;quot;NULL result without error in PyObject_Call&amp;quot;&lt;/span&gt;);
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; result;
    }
    PyErr_Format(PyExc_TypeError, &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;#39;%.200s&amp;#39; object is not callable&amp;quot;&lt;/span&gt;,
                 func-&amp;gt;ob_type-&amp;gt;tp_name);
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Deep recursion protection and error handling aside &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[3]&lt;/a&gt;, &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt;  extracts the &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; attribute &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[4]&lt;/a&gt; of the object's type and calls it. This is possible since &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; holds a function pointer.&lt;/p&gt;
&lt;p&gt;Let it sink for a moment. &lt;em&gt;This is it&lt;/em&gt;. Ignoring all kinds of wonderful optimizations, this is what &lt;em&gt;all calls in Python&lt;/em&gt; boil down to:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Everything in Python is an object &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[5]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Every object has a type; the type of an object dictates the stuff that can be done to/with the object.&lt;/li&gt;
&lt;li&gt;When an object is called, its type's &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; attribute is called.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a user of Python, your only direct interaction with &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; is when you want your objects to be callable. If you define your class in Python, you have to implement the &lt;tt class="docutils literal"&gt;__call__&lt;/tt&gt; method for this purpose. This method gets directly mapped to &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; by CPython. If you define your class as a C extension, you have to assign &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; in the type object of your class manually.&lt;/p&gt;
&lt;p&gt;But recall that classes themselves are &amp;quot;called&amp;quot; to create new objects, so &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; plays a role here as well. Even more fundamentally, when you define a class there is also a call involved - on the class's metaclass. This is an interesting topic and I'll cover it in a future article.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="extra-credit-optimizations-in-call-function"&gt;
&lt;h3&gt;Extra credit: Optimizations in CALL_FUNCTION&lt;/h3&gt;
&lt;p&gt;This part is optional, since the main point of the article was delivered in the previous section. That said, I think this material is interesting, since it provides examples of how some things you wouldn't usually think of as objects, actually &lt;em&gt;are&lt;/em&gt; objects in Python.&lt;/p&gt;
&lt;p&gt;As I mentioned earlier, we could just use &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt; for every &lt;tt class="docutils literal"&gt;CALL_FUNCTION&lt;/tt&gt; and be done with it. In reality, it makes sense to do some optimizations to cover common cases where that may be an overkill. &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt; is a very generic function that needs all its arguments in special tuple and dictionary objects (for positional and keyword arguments, respectively). These arguments need to be taken from the stack and arranged in the containers &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt; expects. In some common cases we can avoid a lot of this overhead, and this is what the optimizations in &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; are about.&lt;/p&gt;
&lt;p&gt;The first special case &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; addresses is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;/* Always dispatch PyCFunction first, because these are&lt;/span&gt;
&lt;span style="color: #007f00"&gt;   presumed to be the most frequent callable object.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;*/&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (PyCFunction_Check(func) &amp;amp;&amp;amp; nk == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This handles objects of type &lt;tt class="docutils literal"&gt;builtin_function_or_method&lt;/tt&gt; (represented by the &lt;tt class="docutils literal"&gt;PyCFunction&lt;/tt&gt; type in the C implementation). There are a lot of those in Python, as the comment above notes. All functions and methods implemented in C, whether in the CPython interpreter, or in C extensions, fall into this category. For example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; type(chr)
&amp;lt;class &amp;#39;builtin_function_or_method&amp;#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(&amp;quot;&amp;quot;.split)
&amp;lt;class &amp;#39;builtin_function_or_method&amp;#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; from pickle import dump
&amp;gt;&amp;gt;&amp;gt; type(dump)
&amp;lt;class &amp;#39;builtin_function_or_method&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's an additional condition in that &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; - that the amount of keyword arguments passed to the function is zero. This allows some important optimizations. If the function in question accepts no arguments (marked by the &lt;tt class="docutils literal"&gt;METH_NOARGS&lt;/tt&gt; flag when the function is created) or just a single object argument (&lt;tt class="docutils literal"&gt;METH_0&lt;/tt&gt; flag), &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; doesn't go through the usual argument packing and can call the underlying function pointer directly. To understand how this is possible, reading about &lt;tt class="docutils literal"&gt;PyCFunction&lt;/tt&gt; and the &lt;tt class="docutils literal"&gt;METH_&lt;/tt&gt; flags in &lt;a class="reference external" href="http://docs.python.org/dev/c-api/structures.html"&gt;this part of the documentation&lt;/a&gt; is highly recommended.&lt;/p&gt;
&lt;p&gt;Next, there's some special handling for methods of classes written in Python:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (PyMethod_Check(func) &amp;amp;&amp;amp; PyMethod_GET_SELF(func) != &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;) {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PyMethod&lt;/tt&gt; is the internal object used to represent &lt;a class="reference external" href="http://docs.python.org/dev/c-api/method.html"&gt;bound methods&lt;/a&gt;. The special thing about methods is that they carry around a reference to the object they're bound to. &lt;tt class="docutils literal"&gt;call_function&lt;/tt&gt; extracts this object and places it on the stack, in preparation for what comes next.&lt;/p&gt;
&lt;p&gt;Here's the rest of the call code (after it in &lt;tt class="docutils literal"&gt;call_object&lt;/tt&gt; there's only some stack cleanup):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (PyFunction_Check(func))
    x = fast_function(func, pp_stack, n, na, nk);
&lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;
    x = do_call(func, pp_stack, na, nk);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;do_call&lt;/tt&gt; we've already met - it implements the most generic form of calling. However, there's one more optimization - if &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;PyFunction&lt;/tt&gt; (an object used &lt;a class="reference external" href="http://docs.python.org/dev/c-api/function.html"&gt;internally&lt;/a&gt; to represent functions defined in Python code), a separate path is taken - &lt;tt class="docutils literal"&gt;fast_function&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;To understand what &lt;tt class="docutils literal"&gt;fast_function&lt;/tt&gt; does, it's important to first consider what happens when a Python function is executed. Simply put, its code object is evaluated (with &lt;tt class="docutils literal"&gt;PyEval_EvalCodeEx&lt;/tt&gt; itself). This code expects its arguments to be on the stack. Therefore, in most cases there's no point packing the arguments into containers and unpacking them again. With some care, they can just be left on the stack and a lot of precious CPU cycles can be spared.&lt;/p&gt;
&lt;p&gt;Everything else falls back to &lt;tt class="docutils literal"&gt;do_call&lt;/tt&gt;. This, by the way, includes &lt;tt class="docutils literal"&gt;PyCFunction&lt;/tt&gt; objects that &lt;em&gt;do&lt;/em&gt; have keyword arguments. A curious aspect of this fact is that it's somewhat more efficient to not pass keyword arguments to C functions that either accept them or are fine with just positional arguments. For example &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[6]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ ~/test/python_src/33/python -m timeit -s&amp;#39;s=&amp;quot;a;b;c;d;e&amp;quot;&amp;#39; &amp;#39;s.split(&amp;quot;;&amp;quot;)&amp;#39;
1000000 loops, best of 3: 0.3 usec per loop
$ ~/test/python_src/33/python -m timeit -s&amp;#39;s=&amp;quot;a;b;c;d;e&amp;quot;&amp;#39; &amp;#39;s.split(sep=&amp;quot;;&amp;quot;)&amp;#39;
1000000 loops, best of 3: 0.469 usec per loop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a big difference, but the input is very small. For larger strings the difference is almost invisible:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ ~/test/python_src/33/python -m timeit -s&amp;#39;s=&amp;quot;a;b;c;d;e&amp;quot;*1000&amp;#39; &amp;#39;s.split(&amp;quot;;&amp;quot;)&amp;#39;
10000 loops, best of 3: 98.4 usec per loop
$ ~/test/python_src/33/python -m timeit -s&amp;#39;s=&amp;quot;a;b;c;d;e&amp;quot;*1000&amp;#39; &amp;#39;s.split(sep=&amp;quot;;&amp;quot;)&amp;#39;
10000 loops, best of 3: 98.7 usec per loop
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;The aim of this article was to discuss what it means to be callable in Python, approaching this concept from the lowest possible level - the implementation details of the CPython virtual machine. Personally, I find this implementation very elegant, since it unifies several concepts into a single one. As the extra credit section showed, Python entities we don't usually think of as objects - functions and methods - actually are objects and can also be handled in the same uniform manner. As I promised, future article(s) will dive deeper into the meaning of &lt;tt class="docutils literal"&gt;tp_call&lt;/tt&gt; for creating new Python objects and classes.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is an intentional simplification - &lt;tt class="docutils literal"&gt;()&lt;/tt&gt; serve other roles like class definitions (for listing base classes), function definitions (for listing arguments), decorators, etc - these are not in expressions. I'm also ignoring generator expressions on purpose.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The CPython VM is a &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Stack_machine"&gt;stack machine&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;Py_EnterRecursiveCall&lt;/tt&gt; is needed where C code may end up calling Python code, to allow CPython keep track of its recursion level and bail out when it's too deep.  Note that functions written in C don't have to abide by this recursion limit. This is why &lt;tt class="docutils literal"&gt;do_call&lt;/tt&gt; special-cases &lt;tt class="docutils literal"&gt;PyCFunction&lt;/tt&gt; before calling &lt;tt class="docutils literal"&gt;PyObject_Call&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;By &amp;quot;attribute&amp;quot; here I mean a structure field (sometimes also called &amp;quot;slot&amp;quot; in the documentation). If you're completely unfamiliar with the way Python C extensions are defined, go over &lt;a class="reference external" href="http://docs.python.org/dev/extending/newtypes.html"&gt;this page&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;When I say that &lt;em&gt;everything&lt;/em&gt; is an object - I mean it. You may think of objects as instances of classes you defined. However, deep down on the C level, CPython creates and juggles a lot of objects on your behalf. Types (classes), builtins, functions, modules - all these are represented by objects.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This example will only run on Python 3.3, since the &lt;tt class="docutils literal"&gt;sep&lt;/tt&gt; keyword argument to &lt;tt class="docutils literal"&gt;split&lt;/tt&gt; is new in this version. In prior versions of Python &lt;tt class="docutils literal"&gt;split&lt;/tt&gt; only accepted positional arguments.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Python internals"></category></entry><entry><title>Less copies in Python with the buffer protocol and memoryviews</title><link href="https://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews" rel="alternate"></link><published>2011-11-28T07:48:55-08:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2011-11-28:/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews</id><summary type="html">
        &lt;p&gt;For one of the hobby projects I'm currently hacking on, I recently had to do a lot of binary data processing in memory. Large chunks of data are being read from a file, then examined and modified in memory and finally used to write some reports.&lt;/p&gt;
&lt;p&gt;This made me think …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;For one of the hobby projects I'm currently hacking on, I recently had to do a lot of binary data processing in memory. Large chunks of data are being read from a file, then examined and modified in memory and finally used to write some reports.&lt;/p&gt;
&lt;p&gt;This made me think about the most efficient way to read data from a file into a modifiable memory chunk in Python. As we all know, the standard file &lt;tt class="docutils literal"&gt;read&lt;/tt&gt; method, for a file opened in binary mode, returns a &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; object &lt;a class="footnote-reference" href="#id10" id="id1"&gt;[1]&lt;/a&gt;, which is immutable:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;# Snippet #1&lt;/span&gt;

f = &lt;span style="color: #00007f"&gt;open&lt;/span&gt;(FILENAME, &lt;span style="color: #7f007f"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;)
data = f.read()
&lt;span style="color: #007f00"&gt;# oops: TypeError: &amp;#39;bytes&amp;#39; object does not support item assignment&lt;/span&gt;
data[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] = &lt;span style="color: #007f7f"&gt;97&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This reads the whole contents of  the file into &lt;tt class="docutils literal"&gt;data&lt;/tt&gt; - a &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; object which is read only. But what if we now want to perform some modifications on the data? Then, we need to somehow get it into a writable object. The most straightforward writable data buffer in Python is a &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt;. So we can do this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;# Snippet #2&lt;/span&gt;

f = &lt;span style="color: #00007f"&gt;open&lt;/span&gt;(FILENAME, &lt;span style="color: #7f007f"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;)
data = &lt;span style="color: #00007f"&gt;bytearray&lt;/span&gt;(f.read())
data[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] = &lt;span style="color: #007f7f"&gt;97&lt;/span&gt; &lt;span style="color: #007f00"&gt;# OK!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, the &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; object returned by &lt;tt class="docutils literal"&gt;f.read()&lt;/tt&gt; is passed into the &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; constructor, which copies its contents into an internal buffer. Since &lt;tt class="docutils literal"&gt;data&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt;, we can manipulate it.&lt;/p&gt;
&lt;p&gt;Although it appears that the goal has been achieved, I don't like this solution. The extra copy made by &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; is bugging me. Why is this copy needed? &lt;tt class="docutils literal"&gt;f.read()&lt;/tt&gt; just returns a throwaway buffer we don't need anyway - can't we just initialize the &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; directly, without copying a temporary buffer?&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/2011/yes-we-can-thumb.jpg" /&gt;
&lt;p&gt;This use case is one of the reasons the Python buffer protocol exists.&lt;/p&gt;
&lt;div class="section" id="the-buffer-protocol-introduction"&gt;
&lt;h3&gt;The buffer protocol - introduction&lt;/h3&gt;
&lt;p&gt;The buffer protocol is described in the &lt;a class="reference external" href="http://docs.python.org/dev/c-api/buffer.html"&gt;Python documentation&lt;/a&gt; and in &lt;a class="reference external" href="http://www.python.org/dev/peps/pep-3118/"&gt;PEP 3118&lt;/a&gt; &lt;a class="footnote-reference" href="#id11" id="id2"&gt;[2]&lt;/a&gt;. Briefly, it provides a way for Python objects to expose their internal buffers to other objects. This is useful to avoid extra copies and for certain kinds of sharing. There are many examples of the buffer protocol in use. In the core language - in builtin types such as &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt;, in the standard library (for example &lt;tt class="docutils literal"&gt;array.array&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt;) and 3rd party libraries (some important Python libraries such as &lt;tt class="docutils literal"&gt;numpy&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PIL&lt;/tt&gt; rely extensively on the buffer protocol for performance).&lt;/p&gt;
&lt;p&gt;There are usually two or more parties involved in each protocol. In the case of the Python buffer protocol, the parties are a &amp;quot;producer&amp;quot; (or &amp;quot;provider&amp;quot;) and a &amp;quot;consumer&amp;quot;. The producer exposes its internals via the buffer protocol, and the consumer accesses those internals.&lt;/p&gt;
&lt;p&gt;Here I want to focus specifically on one use of the buffer protocol that's relevant to this article. The producer is the built-in &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; type, and the consumer is a method in the &lt;tt class="docutils literal"&gt;file&lt;/tt&gt; object named &lt;tt class="docutils literal"&gt;readinto&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-more-efficient-way-to-read-into-a-bytearray"&gt;
&lt;h3&gt;A more efficient way to read into a bytearray&lt;/h3&gt;
&lt;p&gt;Here's the way to do what Snippet #2 did, just without the extra copy:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;# Snippet #3&lt;/span&gt;

f = &lt;span style="color: #00007f"&gt;open&lt;/span&gt;(FILENAME, &lt;span style="color: #7f007f"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;)
data = &lt;span style="color: #00007f"&gt;bytearray&lt;/span&gt;(os.path.getsize(FILENAME))
f.readinto(data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First, a &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; is created and pre-allocated to the size of the data we're going to read into it. The pre-allocation is important - since &lt;tt class="docutils literal"&gt;readinto&lt;/tt&gt; directly accesses the internal buffer of &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt;, it won't write more than has been allocated. Next, the &lt;tt class="docutils literal"&gt;file.readinto&lt;/tt&gt; method is used to read the data directly into the bytearray's internal storage, without going via temporary buffers.&lt;/p&gt;
&lt;p&gt;The result: this code runs ~30% faster than snippet #2 &lt;a class="footnote-reference" href="#id12" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="variations-on-the-theme"&gt;
&lt;h3&gt;Variations on the theme&lt;/h3&gt;
&lt;p&gt;Other objects and modules could be used here. For example, the built-in &lt;tt class="docutils literal"&gt;array.array&lt;/tt&gt; class also supports the buffer protocol, so it can also be written and read from a file directly and efficiently. The same goes for &lt;tt class="docutils literal"&gt;numpy&lt;/tt&gt; arrays. On the consumer side, the &lt;tt class="docutils literal"&gt;socket&lt;/tt&gt; module can also read directly into a buffer with the &lt;tt class="docutils literal"&gt;read_into&lt;/tt&gt; method. I'm sure that it's easy to find many other sample uses of this protocol in Python itself and some 3rd partly libraries - if you find something interesting, please let me know.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-buffer-protocol-implementation"&gt;
&lt;h3&gt;The buffer protocol - implementation&lt;/h3&gt;
&lt;p&gt;Let's see how Snippet #3 works under the hood using the buffer protocol &lt;a class="footnote-reference" href="#id13" id="id4"&gt;[4]&lt;/a&gt;. We'll start with the producer.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; declares that it implements the buffer protocol by filling the &lt;tt class="docutils literal"&gt;tp_as_buffer&lt;/tt&gt; slot of its type object &lt;a class="footnote-reference" href="#id14" id="id5"&gt;[5]&lt;/a&gt;. What's placed there is the address of  a &lt;tt class="docutils literal"&gt;PyBufferProcs&lt;/tt&gt; structure, which is a simple container for two function pointers:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; (*getbufferproc)(PyObject *, Py_buffer *, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;);
&lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; (*releasebufferproc)(PyObject *, Py_buffer *);
&lt;span style="color: #007f00"&gt;/* ... */&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;struct&lt;/span&gt; {
     getbufferproc bf_getbuffer;
     releasebufferproc bf_releasebuffer;
} PyBufferProcs;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bf_getbuffer&lt;/tt&gt; is the function used to obtain a buffer from the object providing it, and &lt;tt class="docutils literal"&gt;bf_releasebuffer&lt;/tt&gt; is the function used to notify the object that the provided buffer is no longer needed.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; implementation in &lt;tt class="docutils literal"&gt;Objects/bytearrayobject.c&lt;/tt&gt; initializes an instance of &lt;tt class="docutils literal"&gt;PyBufferProces&lt;/tt&gt; thus:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;static&lt;/span&gt; PyBufferProcs bytearray_as_buffer = {
    (getbufferproc)bytearray_getbuffer,
    (releasebufferproc)bytearray_releasebuffer,
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The more interesting function here is &lt;tt class="docutils literal"&gt;bytearray_getbuffer&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;static&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;
&lt;span style="color: #00007f"&gt;bytearray_getbuffer&lt;/span&gt;(PyByteArrayObject *obj, Py_buffer *view, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; flags)
{
    &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; ret;
    &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; *ptr;
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (view == &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;) {
        obj-&amp;gt;ob_exports++;
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
    }
    ptr = (&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; *) PyByteArray_AS_STRING(obj);
    ret = PyBuffer_FillInfo(view, (PyObject*)obj, ptr, Py_SIZE(obj), &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, flags);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (ret &amp;gt;= &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
        obj-&amp;gt;ob_exports++;
    }
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; ret;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It simply uses the &lt;tt class="docutils literal"&gt;PyBuffer_FillInfo&lt;/tt&gt; API to fill the &lt;a class="reference external" href="http://docs.python.org/dev/c-api/buffer.html#the-buffer-structure"&gt;buffer structure&lt;/a&gt; passed to it. &lt;tt class="docutils literal"&gt;PyBuffer_FillInfo&lt;/tt&gt; provides a simplified method of filling the buffer structure, which is suitable for unsophisticated objects like &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; (if you want to see a more complex example that has to fill the buffer structure manually, take a look at the corresponding function of &lt;tt class="docutils literal"&gt;array.array&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;On the consumer side, the code that interests us is the &lt;tt class="docutils literal"&gt;buffered_readinto&lt;/tt&gt; function in &lt;tt class="docutils literal"&gt;Modules\_io\bufferedio.c&lt;/tt&gt; &lt;a class="footnote-reference" href="#id15" id="id6"&gt;[6]&lt;/a&gt;. I won't show its full code here since it's quite complex, but with regards to the buffer protocol, the flow is simple:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Use the &lt;tt class="docutils literal"&gt;PyArg_ParseTuple&lt;/tt&gt; function with the &lt;tt class="docutils literal"&gt;w*&lt;/tt&gt; format specifier to parse its argument as a R/W buffer object, which itself calls &lt;tt class="docutils literal"&gt;PyObject_GetBuffer&lt;/tt&gt; - a Python API that invokes the producer's &amp;quot;get buffer&amp;quot; function.&lt;/li&gt;
&lt;li&gt;Read data from the file directly into this buffer.&lt;/li&gt;
&lt;li&gt;Release the buffer using the &lt;tt class="docutils literal"&gt;PyBuffer_Release&lt;/tt&gt; API &lt;a class="footnote-reference" href="#id16" id="id7"&gt;[7]&lt;/a&gt;, which eventually gets routed to the &lt;tt class="docutils literal"&gt;bytearray_releasebuffer&lt;/tt&gt; function in our case.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To conclude, here's what the call sequence looks like when &lt;tt class="docutils literal"&gt;f.readinto(data)&lt;/tt&gt; is executed in the Python code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;buffered_readinto
|
\--&amp;gt; PyArg_ParseTuple(..., &amp;quot;w*&amp;quot;, ...)
|    |
|    \--&amp;gt; PyObject_GetBuffer(obj)
|         |
|         \--&amp;gt; obj-&amp;gt;ob_type-&amp;gt;tp_as_buffer-&amp;gt;bf_getbuffer
|
|--&amp;gt; ... read the data
|
\--&amp;gt; PyBuffer_Release
     |
     \--&amp;gt; obj-&amp;gt;ob_type-&amp;gt;tp_as_buffer-&amp;gt;bf_releasebuffer
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-views"&gt;
&lt;h3&gt;Memory views&lt;/h3&gt;
&lt;p&gt;The buffer protocol is an internal implementation detail of Python, accessible only on the C-API level. And that's a good thing, since the buffer protocol requires certain low-level behavior such as properly releasing buffers. &lt;a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#typememoryview"&gt;Memoryview objects&lt;/a&gt; were created to expose it to a user's Python code in a safe manner:&lt;/p&gt;
&lt;blockquote&gt;
memoryview objects allow Python code to access the internal data of an object that supports the buffer protocol without copying.&lt;/blockquote&gt;
&lt;p&gt;The linked documentation page explains &lt;tt class="docutils literal"&gt;memoryviews&lt;/tt&gt; quite well and should be immediately comprehensible if you've reached so far in this article. Therefore I'm not going to explain how a &lt;tt class="docutils literal"&gt;memoryview&lt;/tt&gt; works, just show some examples of its use.&lt;/p&gt;
&lt;p&gt;It is a known fact that in Python, slices on strings and bytes make copies. Sometimes when performance matters and the buffers are large, this is a big waste. Suppose you have a large buffer and you want to pass just half of it to some function (that will send it to a socket or do something else &lt;a class="footnote-reference" href="#id17" id="id8"&gt;[8]&lt;/a&gt;). Here's what happens (annotated Python pseudo-code):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;mybuf = ... &lt;span style="color: #007f00"&gt;# some large buffer of bytes&lt;/span&gt;
func(mybuf[:&lt;span style="color: #00007f"&gt;len&lt;/span&gt;(mybuf)//&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;])
  &lt;span style="color: #007f00"&gt;# passes the first half of mybuf into func&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;# COPIES half of mybuf&amp;#39;s data to a new buffer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The copy can be expensive if there's a lot of data involved. What's the alternative? Using a &lt;tt class="docutils literal"&gt;memoryview&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;mybuf = ... &lt;span style="color: #007f00"&gt;# some large buffer of bytes&lt;/span&gt;
mv_mybuf = memoryview(mybuf) &lt;span style="color: #007f00"&gt;# a memoryview of mybuf&lt;/span&gt;
func(mv_mybuf[:&lt;span style="color: #00007f"&gt;len&lt;/span&gt;(mv_mybuf)//&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;])
  &lt;span style="color: #007f00"&gt;# passes the first half of mybuf into func as a &amp;quot;sub-view&amp;quot; created&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;# by slicing a memoryview.&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;# NO COPY is made here!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;tt class="docutils literal"&gt;memoryview&lt;/tt&gt; behaves just like &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; in many useful contexts (for example, it supports the mapping protocol) so it provides an adequate replacement if used carefully. The great thing about it is that it uses the buffer protocol beneath the covers to avoid copies and just juggle pointers to data. The performance difference is dramatic - I timed a 300x speedup on slicing out a half of a 1MB &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; buffer when using a &lt;tt class="docutils literal"&gt;memoryview&lt;/tt&gt; as demonstrated above. And this speedup will get larger with larger buffers, since it's O(1) vs. the O(n) of copying.&lt;/p&gt;
&lt;p&gt;But there's more. On writable producers such as &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt;, a &lt;tt class="docutils literal"&gt;memoryview&lt;/tt&gt; creates a writable view that can be modified:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt;&amp;gt;&amp;gt; buf = &lt;span style="color: #00007f"&gt;bytearray&lt;/span&gt;(b&lt;span style="color: #7f007f"&gt;&amp;#39;abcdefgh&amp;#39;&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; mv = memoryview(buf)
&amp;gt;&amp;gt;&amp;gt; mv[&lt;span style="color: #007f7f"&gt;4&lt;/span&gt;:&lt;span style="color: #007f7f"&gt;6&lt;/span&gt;] = b&lt;span style="color: #7f007f"&gt;&amp;#39;ZA&amp;#39;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; buf
&lt;span style="color: #00007f"&gt;bytearray&lt;/span&gt;(b&lt;span style="color: #7f007f"&gt;&amp;#39;abcdZAgh&amp;#39;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This gives us a way to do something we couldn't achieve by any other means - read from a file (or receive from a socket) &lt;em&gt;directly into the middle of some existing buffer&lt;/em&gt; &lt;a class="footnote-reference" href="#id18" id="id9"&gt;[9]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;buf = &lt;span style="color: #00007f"&gt;bytearray&lt;/span&gt;(...) &lt;span style="color: #007f00"&gt;# pre-allocated to the needed size&lt;/span&gt;
mv = memoryview(buf)
numread = f.readinto(mv[some_offset:])
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;This article demonstrated the Python buffer protocol, showing both how it works and what it can be used for. The main &lt;em&gt;use&lt;/em&gt; of the buffer protocol to the Python programmer is optimization of certain patterns of coding, by avoiding unnecessary data copies.&lt;/p&gt;
&lt;p&gt;Any mention of optimization in Python code is sure to draw fire from people claiming that if I want to write fast code, I shouldn't use Python at all. But I disagree. Python these days is fast enough to be suitable for many tasks that were previously only in the domain of C/C++. I want to keep using it while I can, and only resort to low-level C/C++ when I must.&lt;/p&gt;
&lt;p&gt;Employing the buffer protocol to have zero-copy buffer manipulations on the Python level is IMHO a huge boon that can stall (or even avoid) the transition of some performance-sensitive code from Python to C. That's because when dealing with data processing, we often use a lot of C APIs anyway, the only Python overhead being the passing of data between these APIs. A speed boost in this code can make a huge difference and bring the Python code very close to the performance we could have with plain C.&lt;/p&gt;
&lt;p&gt;The article also gave a glimpse into one aspect of the implementation of Python, hopefully showing that it's not difficult at all to dive right into the code and understand how Python does something it does.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In this article I'm focusing on the latest Python 3.x, although most of it also applies to Python 2.7&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The buffer protocol existed in Python prior to 2.6, but was then greatly enhanced. The PEP also describes the change that was made to the buffer protocol with the move to Python 3.x (and later backported to the 2.x line starting with 2.6).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;This is on the latest build of Python 3.3. Roughly the same speedup can be seen on Python 2.7. With Python 3.2 there appears to be a speed regression that makes the two snippets perform similarly, but it has been fixed in 3.3&lt;/p&gt;
&lt;p class="last"&gt;Another note on the benchmarking: it's recommended to use large files (say, ~100 MB and up) to get reliable measurements. For small files too many irrelevant factors come into play and offset the benchmarks. In addition, the code should be run in a loop to avoid differences due to warm/cold disk cache issues. I'm using the &lt;tt class="docutils literal"&gt;timeit&lt;/tt&gt; module, which is perfect for this purpose.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id13" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;All the code displayed here is taken from the latest development snapshot of Python 3.3 (&lt;tt class="docutils literal"&gt;default&lt;/tt&gt; branch).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id14" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Type objects are a fascinating aspect of Python's implementation, and I hope to cover it in a separate article one day. Briefly, it allows Python objects to declare which services they provide (or, in other terms, which interfaces they implement). More information can be found &lt;a class="reference external" href="http://docs.python.org/dev/c-api/typeobj.html"&gt;in the documentation&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id15" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Since the built-in &lt;tt class="docutils literal"&gt;open&lt;/tt&gt; function, when asked to open a file in binary mode for reading, returns an &lt;tt class="docutils literal"&gt;io.BufferedReader&lt;/tt&gt; object by default. This can be controlled with the &lt;em&gt;buffering&lt;/em&gt; argument.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id16" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Releasing the buffer structure is an important part of the buffer protocol. Each time it's requested for a buffer, &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; increments a reference count, and decrements it when the buffer is released. While the refcount is positive (meaning that there are consumer objects directly relying on the internal buffer), &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; won't agree to resize or do other operations that may invalidate the internal buffer. Otherwise, this would be an avenue for insidious memory bugs.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id17" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Networking code is actually a common use case. When sending data over sockets, it's frequently sliced and diced to build frames. This can involve a lot of copying. Other data-munging applications such as encryption and compression are also culprits.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id18" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id9"&gt;[9]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This code snippet was borrowed from Antoine Pitrou's post on python-dev.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Python"></category><category term="Python internals"></category></entry><entry><title>Understanding UnboundLocalError in Python</title><link href="https://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python" rel="alternate"></link><published>2011-05-15T05:43:47-07:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2011-05-15:/2011/05/15/understanding-unboundlocalerror-in-python</id><summary type="html">
        &lt;p&gt;If you're closely following the &lt;a class="reference external" href="http://stackoverflow.com/questions/tagged/python"&gt;Python tag on StackOverflow&lt;/a&gt;, you'll notice that the same question comes up at least once a week. The question goes on like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;():
    x += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt; x
foo()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why, when run, this results in the following error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Traceback (most recent call …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
        &lt;p&gt;If you're closely following the &lt;a class="reference external" href="http://stackoverflow.com/questions/tagged/python"&gt;Python tag on StackOverflow&lt;/a&gt;, you'll notice that the same question comes up at least once a week. The question goes on like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;():
    x += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt; x
foo()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why, when run, this results in the following error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Traceback (most recent call last):
  File &amp;quot;unboundlocalerror.py&amp;quot;, line 8, in &amp;lt;module&amp;gt;
    foo()
  File &amp;quot;unboundlocalerror.py&amp;quot;, line 4, in foo
    x += 1
UnboundLocalError: local variable &amp;#39;x&amp;#39; referenced before assignment
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are a few variations on this question, with the same core hiding underneath. Here's one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;lst = [&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;]

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;():
    lst.append(&lt;span style="color: #007f7f"&gt;5&lt;/span&gt;)   &lt;span style="color: #007f00"&gt;# OK&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;#lst += [5]     # ERROR here&lt;/span&gt;

foo()
&lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt; lst
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lst.append(5)&lt;/span&gt;&lt;/tt&gt; statement successfully appends 5 to the list. However, substitute it for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lst&lt;/span&gt; &lt;span class="pre"&gt;+=&lt;/span&gt; &lt;span class="pre"&gt;[5]&lt;/span&gt;&lt;/tt&gt;, and it raises &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;UnboundLocalError&lt;/span&gt;&lt;/tt&gt;, although at first sight it should accomplish the same.&lt;/p&gt;
&lt;p&gt;Although this exact question is answered in Python's official FAQ (&lt;a class="reference external" href="http://docs.python.org/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value"&gt;right here&lt;/a&gt;), I decided to write this article with the intent of giving a deeper explanation. It will start with a basic FAQ-level answer, which should satisfy one only wanting to know how to &amp;quot;solve the damn problem and move on&amp;quot;. Then, I will dive deeper, looking at the formal definition of Python to understand what's going on. Finally, I'll take a look what happens behind the scenes in the implementation of CPython to cause this behavior.&lt;/p&gt;
&lt;div class="section" id="the-simple-answer"&gt;
&lt;h3&gt;The simple answer&lt;/h3&gt;
&lt;p&gt;As mentioned above, this problem is covered in the Python FAQ. For completeness, I want to explain it here as well, quoting the FAQ when necessary.&lt;/p&gt;
&lt;p&gt;Let's take the first code snippet again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;():
    x += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt; x
foo()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So where does the exception come from? Quoting the FAQ:&lt;/p&gt;
&lt;blockquote&gt;
This is because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope.&lt;/blockquote&gt;
&lt;p&gt;But &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+=&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt; is similar to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt;, so it should first read &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt;, perform the addition and then assign back to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt;. As mentioned in the quote above, Python considers &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; a variable local to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;foo&lt;/span&gt;&lt;/tt&gt;, so we have a problem - a variable is read (referenced) before it's been assigned. Python raises the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;UnboundLocalError&lt;/span&gt;&lt;/tt&gt; exception in this case &lt;a class="footnote-reference" href="#id7" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So what do we do about this? The solution is very simple - Python has the &lt;a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#the-global-statement"&gt;global  statement&lt;/a&gt; just for this purpose:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;():
    &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; x
    x += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt; x
foo()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This prints &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;11&lt;/span&gt;&lt;/tt&gt;, without any errors. The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;global&lt;/span&gt;&lt;/tt&gt; statement tells Python that inside &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;foo&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; refers to the global variable &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt;, even if it's assigned in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;foo&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Actually, there is another variation on the question, for which the answer is a bit different. Consider this code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;external&lt;/span&gt;():
    x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;internal&lt;/span&gt;():
        x += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(x)
    internal()

external()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This kind of code may come up if you're into closures and other techniques that use Python's lexical scoping rules. The error this generates is the familiar &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;UnboundLocalError&lt;/span&gt;&lt;/tt&gt;. However, applying the &amp;quot;global fix&amp;quot;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;external&lt;/span&gt;():
    x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;internal&lt;/span&gt;():
        &lt;span style="color: #00007f; font-weight: bold"&gt;global&lt;/span&gt; x
        x += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(x)
    internal()

external()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Doesn't help - another error is generated: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;NameError:&lt;/span&gt; &lt;span class="pre"&gt;global&lt;/span&gt; &lt;span class="pre"&gt;name&lt;/span&gt; &lt;span class="pre"&gt;'x'&lt;/span&gt; &lt;span class="pre"&gt;is&lt;/span&gt; &lt;span class="pre"&gt;not&lt;/span&gt; &lt;span class="pre"&gt;defined&lt;/span&gt;&lt;/tt&gt;. Python is right here - after all, there's no &lt;em&gt;global&lt;/em&gt; variable named &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt;, there's only an &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;external&lt;/span&gt;&lt;/tt&gt;. It may be not local to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;internal&lt;/span&gt;&lt;/tt&gt;, but it's not global. So what can you do in this situation? If you're using Python 3, you have the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nonlocal&lt;/span&gt;&lt;/tt&gt; keyword. Replacing &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;global&lt;/span&gt;&lt;/tt&gt; by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nonlocal&lt;/span&gt;&lt;/tt&gt; in the last snippet makes everything work as expected. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;nonlocal&lt;/span&gt;&lt;/tt&gt; is a new statement in Python 3, and there is no equivalent in Python 2 &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-formal-answer"&gt;
&lt;h3&gt;The formal answer&lt;/h3&gt;
&lt;p&gt;Assignments in Python are used to bind names to values and to modify attributes or items of mutable objects. I could find two places in the Python (2.x) documentation where it's defined how an assignment to a local variable works.&lt;/p&gt;
&lt;p&gt;One is section 6.2 &amp;quot;Assignment statements&amp;quot; in the &lt;a class="reference external" href="http://docs.python.org/reference/simple_stmts.html"&gt;Simple Statements&lt;/a&gt; chapter of the language reference:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Assignment of an object to a single target is recursively defined as follows. If the target is an identifier (name):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;If the name does not occur in a global statement in the current code block: the name is bound to the object in the current local namespace.&lt;/li&gt;
&lt;li&gt;Otherwise: the name is bound to the object in the current global namespace.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Another is section 4.1 &amp;quot;Naming and binding&amp;quot; of the &lt;a class="reference external" href="http://docs.python.org/reference/executionmodel.html"&gt;Execution model&lt;/a&gt; chapter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a name is bound in a block, it is a local variable of that block.&lt;/p&gt;
&lt;p&gt;[...]&lt;/p&gt;
&lt;p&gt;When a name is used in a code block, it is resolved using the nearest enclosing scope. [...] If the name refers to a local variable that has not been bound, a UnboundLocalError exception is raised.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is all clear, but still, another small doubt remains. All these rules apply to assignments of the form &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;var&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;value&lt;/span&gt;&lt;/tt&gt; which clearly bind &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;var&lt;/span&gt;&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;value&lt;/span&gt;&lt;/tt&gt;. But the code snippets we're having a problem with here have the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+=&lt;/span&gt;&lt;/tt&gt; assignment. Shouldn't that just modify the bound value, without re-binding it?&lt;/p&gt;
&lt;p&gt;Well, no. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+=&lt;/span&gt;&lt;/tt&gt; and its cousins (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-=&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;*=&lt;/span&gt;&lt;/tt&gt;, etc.) are what Python calls &amp;quot;&lt;a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#augmented-assignment-statements"&gt;augmented assignment statements&lt;/a&gt;&amp;quot; [&lt;em&gt;emphasis mine&lt;/em&gt;]:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, &lt;strong&gt;and assigns the result to the original target&lt;/strong&gt;. The target is only evaluated once.&lt;/p&gt;
&lt;p&gt;An augmented assignment expression like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+=&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt; &lt;strong&gt;can be rewritten as&lt;/strong&gt; &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt; to achieve a similar, but not exactly equal effect. In the augmented version, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.&lt;/p&gt;
&lt;p&gt;With the exception of assigning to tuples and multiple targets in a single statement, &lt;strong&gt;the assignment done by augmented assignment statements is handled the same way as normal assignments&lt;/strong&gt;. Similarly, with the exception of the possible in-place behavior, the binary operation performed by augmented assignment is the same as the normal binary operations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So when earlier I said that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+=&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt; is &lt;em&gt;similar to&lt;/em&gt; &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt;, I wasn't telling all the truth, but it was accurate with respect to binding. Apart for possible optimization, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+=&lt;/span&gt;&lt;/tt&gt; counts exactly as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;=&lt;/span&gt;&lt;/tt&gt; when binding is considered. If you think carefully about it, it's unavoidable, because some types Python works with are immutable. Consider strings, for example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x = &lt;span style="color: #7f007f"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
x += &lt;span style="color: #7f007f"&gt;&amp;quot;def&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first line binds &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; to the value &amp;quot;abc&amp;quot;. The second line doesn't modify the value &amp;quot;abc&amp;quot; to be &amp;quot;abcdef&amp;quot;. &lt;em&gt;Strings are immutable in Python&lt;/em&gt;. Rather, it creates the new value &amp;quot;abcdef&amp;quot; somewhere in memory, and re-binds &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; to it. This can be seen clearly when examining the object ID for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; before and after the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+=&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; x = &lt;span style="color: #7f007f"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="color: #00007f"&gt;id&lt;/span&gt;(x)
&lt;span style="color: #007f7f"&gt;11173824&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; x += &lt;span style="color: #7f007f"&gt;&amp;quot;def&amp;quot;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="color: #00007f"&gt;id&lt;/span&gt;(x)
&lt;span style="color: #007f7f"&gt;32831648&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; x
&lt;span style="color: #7f007f"&gt;&amp;#39;abcdef&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that some types in Python &lt;em&gt;are&lt;/em&gt; mutable. For example, lists can actually be modified in-place:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; y = [&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;]
&amp;gt;&amp;gt;&amp;gt; &lt;span style="color: #00007f"&gt;id&lt;/span&gt;(y)
&lt;span style="color: #007f7f"&gt;32413376&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; y += [&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;]
&amp;gt;&amp;gt;&amp;gt; &lt;span style="color: #00007f"&gt;id&lt;/span&gt;(y)
&lt;span style="color: #007f7f"&gt;32413376&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; y
[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;id(y)&lt;/span&gt;&lt;/tt&gt; didn't change after &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+=&lt;/span&gt;&lt;/tt&gt;, because the object &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;y&lt;/span&gt;&lt;/tt&gt; referenced was just modified. Still, Python re-bound &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;y&lt;/span&gt;&lt;/tt&gt; to the same object &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-too-much-information-answer"&gt;
&lt;h3&gt;The &amp;quot;too much information&amp;quot; answer&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;This section is of interest only to those curious about the implementation internals of Python itself.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;One of the stages in the compilation of Python into bytecode is building the symbol table &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[4]&lt;/a&gt;. An important goal of building the symbol table is for Python to be able to mark the scope of variables it encounters - which variables are local to functions, which are global, which are free (lexically bound) and so on.&lt;/p&gt;
&lt;p&gt;When the symbol table code sees a variable is assigned in a function, it marks it as local. Note that it doesn't matter if the assignment was done before usage, after usage, or maybe not actually executed due to a condition in code like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;():
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; something_false_at_runtime:
        x = &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(x)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;symtable&lt;/span&gt;&lt;/tt&gt; module to examine the symbol table information gathered on some Python code during compilation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;symtable&lt;/span&gt;

code = &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;x = 10&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;def foo():&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    x += 1&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    print(x)&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

table = symtable.symtable(code, &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;string&amp;gt;&amp;#39;&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;exec&amp;#39;&lt;/span&gt;)

foo_namespace = table.lookup(&lt;span style="color: #7f007f"&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;).get_namespace()
sym_x = foo_namespace.lookup(&lt;span style="color: #7f007f"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(sym_x.get_name())
&lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(sym_x.is_local())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This prints:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x
True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we see that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; was marked as local in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;foo&lt;/span&gt;&lt;/tt&gt;. Marking variables as local turns out to be important for optimization in the bytecode, since the compiler can generate a special instruction for it that's very fast to execute. There's an excellent &lt;a class="reference external" href="http://tech.blog.aknin.name/2010/06/05/pythons-innards-naming/"&gt;article here&lt;/a&gt; explaining this topic in depth; I'll just focus on the outcome.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;compiler_nameop&lt;/span&gt;&lt;/tt&gt; function in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Python/compile.c&lt;/span&gt;&lt;/tt&gt; handles variable name references. To generate the correct opcode, it queries the symbol table function &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PyST_GetScope&lt;/span&gt;&lt;/tt&gt;. For our &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt;, this returns a bitfield with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LOCAL&lt;/span&gt;&lt;/tt&gt; in it. Having seen &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LOCAL&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;compiler_nameop&lt;/span&gt;&lt;/tt&gt; generates a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LOAD_FAST&lt;/span&gt;&lt;/tt&gt;. We can see this in the disassembly of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;foo&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;35           0 LOAD_FAST                0 (x)
             3 LOAD_CONST               1 (1)
             6 INPLACE_ADD
             7 STORE_FAST               0 (x)

36          10 LOAD_GLOBAL              0 (print)
            13 LOAD_FAST                0 (x)
            16 CALL_FUNCTION            1
            19 POP_TOP
            20 LOAD_CONST               0 (None)
            23 RETURN_VALUE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first block of instructions shows what &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+=&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt; was compiled to. You will note that already here (before it's actually assigned), &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LOAD_FAST&lt;/span&gt;&lt;/tt&gt; is used to retrieve the value of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LOAD_FAST&lt;/span&gt;&lt;/tt&gt; is the instruction that will cause the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;UnboundLocalError&lt;/span&gt;&lt;/tt&gt; exception to be raised at runtime, because it is actually executed before any &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;STORE_FAST&lt;/span&gt;&lt;/tt&gt; is done for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt;. The gory details are in the bytecode interpreter code in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Python/ceval.c&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;TARGET(LOAD_FAST)
    x = GETLOCAL(oparg);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (x != &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;) {
        Py_INCREF(x);
        PUSH(x);
        FAST_DISPATCH();
    }
    format_exc_check_arg(PyExc_UnboundLocalError,
        UNBOUNDLOCAL_ERROR_MSG,
        PyTuple_GetItem(co-&amp;gt;co_varnames, oparg));
    &lt;span style="color: #00007f; font-weight: bold"&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ignoring the macro-fu for the moment, what this basically says is that once &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LOAD_FAST&lt;/span&gt;&lt;/tt&gt; is seen, the value of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; is obtained from an indexed array of objects &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[5]&lt;/a&gt;. If no &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;STORE_FAST&lt;/span&gt;&lt;/tt&gt; was done before, this value is still &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;NULL&lt;/span&gt;&lt;/tt&gt;, the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;if&lt;/span&gt;&lt;/tt&gt; branch is not taken &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[6]&lt;/a&gt; and the exception is raised.&lt;/p&gt;
&lt;p&gt;You may wonder why Python waits until runtime to raise this exception, instead of detecting it in the compiler. The reason is this code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;x = &lt;span style="color: #007f7f"&gt;10&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;():
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; something_true():
        x = &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
    x += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(x)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Suppose &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;something_true&lt;/span&gt;&lt;/tt&gt; is a function that returns &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;True&lt;/span&gt;&lt;/tt&gt;, possibly due to some user input. In this case, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt; binds &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt;&lt;/tt&gt; locally, so the reference to it in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;+=&lt;/span&gt; &lt;span class="pre"&gt;1&lt;/span&gt;&lt;/tt&gt; is no longer unbound. This code will then run without exceptions. Of course if &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;something_true&lt;/span&gt;&lt;/tt&gt; actually turns out to return &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/tt&gt;, the exception will be raised. Python has no way to resolve this at compile time, so the error detection is postponed to runtime.&lt;/p&gt;
&lt;div align="center" class="align-center"&gt;&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is quite useful, if you think about it. In C &amp;amp; C++ you can use the value of an un-initialized variable, which is almost always a bug. Some compilers (with some settings) warn you about this, but in Python it's just a plain error.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;If you're using Python 2 and still need such code to work, the common workaround is the following: if you have data in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;external&lt;/span&gt;&lt;/tt&gt; which you want to modify in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;internal&lt;/span&gt;&lt;/tt&gt;, store it inside a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;dict&lt;/span&gt;&lt;/tt&gt; instead of a stand-alone variable.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Could this be spared? Due to the dynamic nature of Python, that would be hard to do. At compilation time, when Python is compiled to bytecode, there's no way to know what the real type of the objects is. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;y&lt;/span&gt;&lt;/tt&gt; in the example above could be some user-defined type with an overloaded &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;+=&lt;/span&gt;&lt;/tt&gt; operator which returns a new object, so Python compiler has to create generic code that re-binds the variable.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I've written comprehensively on the internals of symbol table construction in Python's compiler (&lt;a class="reference external" href="https://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/"&gt;part 1&lt;/a&gt; and &lt;a class="reference external" href="https://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/"&gt;part 2&lt;/a&gt;).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;GETLOCAL(i)&lt;/span&gt;&lt;/tt&gt; is a macro for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(fastlocals[i])&lt;/span&gt;&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Had the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;if&lt;/span&gt;&lt;/tt&gt; been entered, the exception raising code would not have been reached, since &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;FAST_DISPATCH&lt;/span&gt;&lt;/tt&gt; expands to a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goto&lt;/span&gt;&lt;/tt&gt; that takes control elsewhere.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Python internals"></category></entry></feed>