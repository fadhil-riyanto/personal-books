<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - Lisp</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/lisp.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2024-05-04T19:46:23-07:00</updated><entry><title>Building abstractions using higher-order functions</title><link href="https://eli.thegreenplace.net/2023/building-abstractions-using-higher-order-functions/" rel="alternate"></link><published>2023-02-04T05:40:00-08:00</published><updated>2023-03-06T13:26:10-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2023-02-04:/2023/building-abstractions-using-higher-order-functions/</id><summary type="html">&lt;p&gt;A &lt;em&gt;higher-order function&lt;/em&gt; is a function that takes other functions as arguments,
or returns a function as its result. Higher-order functions are an exceptionally
powerful software design tool because they can easily create new abstractions
and are composable. In this post I will present a case study - a set of â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;A &lt;em&gt;higher-order function&lt;/em&gt; is a function that takes other functions as arguments,
or returns a function as its result. Higher-order functions are an exceptionally
powerful software design tool because they can easily create new abstractions
and are composable. In this post I will present a case study - a set of
functions that defines an interesting problem domain. By reading and
understanding this code, hopefully anyone can appreciate the power and beauty of
higher-order functions and how they enable constructing powerful abstractions
from basic building blocks.&lt;/p&gt;
&lt;p&gt;One of my &lt;a class="reference external" href="https://eli.thegreenplace.net/2005/06/12/lessons-from-paip"&gt;all-time favorite&lt;/a&gt; programming
books is Peter Norvig's &lt;a class="reference external" href="https://norvig.github.io/paip-lisp/#/"&gt;PAIP&lt;/a&gt; . In
section &lt;em&gt;6.4 - A set of Searching Tools&lt;/em&gt;, it presents some code for defining
different variants of tree searching that I've always found very elegant.&lt;/p&gt;
&lt;p&gt;Here's a quick reimplementation of the main idea in Clojure (see &lt;a class="reference external" href="https://github.com/eliben/paip-in-clojure/tree/master/src/paip/6_tools"&gt;this
repository&lt;/a&gt; for
the full, runnable code); I'm using Clojure since it's a modern Lisp that &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/clojure-the-perfect-language-to-expand-your-brain/"&gt;I
enjoy learning and using&lt;/a&gt;
from time to time.&lt;/p&gt;
&lt;p&gt;First, some prerequisites. As is often the case in dynamically-typed Lisp,
entities can be described in a very abstract way. The code presented here
searches trees, but there is no tree data structure per-se; it's defined using
functions. Specifically, there's a notion of a &amp;quot;state&amp;quot; (tree node) and a way
to get from a given state to its children states (successors); a function maps
between the two.&lt;/p&gt;
&lt;p&gt;In our case let's have integers as states; then, an infinite binary tree can
be defined using the following successor function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;binary-tree&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A successors function representing a binary tree.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given a state (a number), it returns its children as a list. Simplistically, in
this tree, node N has the children 2N and 2N+1.&lt;/p&gt;
&lt;p&gt;Here are the first few layers of such a tree:&lt;/p&gt;
&lt;object class="align-center" data="https://eli.thegreenplace.net/images/2023/binary-tree-graph.svg" type="image/svg+xml"&gt;Binary tree with 15 nodes 1-15&lt;/object&gt;
&lt;p&gt;In one sense, the tree is infinite because &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;binary-tree&lt;/span&gt;&lt;/tt&gt; will happily return
the successors for any node we ask:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (binary-tree 9999)
(19998 19999)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But in another sense, &lt;em&gt;there is no tree&lt;/em&gt;. This is a beautiful implication
of using functions instead of concrete data - they easily enable &lt;em&gt;lazy
evaluation&lt;/em&gt;. We cannot materialize an infinite tree inside a
necessarily finite computer, but we can operate on it all the same because of
this abstraction. As far as the search algorithm is concerned, there exists an
abstract &lt;em&gt;state space&lt;/em&gt; and we tell it how to navigate and interpret it.&lt;/p&gt;
&lt;p&gt;Now we're ready to look at the generic search function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Finds a state that satisfies goal?-fn; Starts with states, and searches&lt;/span&gt;
&lt;span class="s"&gt;  according to successors and combiner. If successful, returns the state;&lt;/span&gt;
&lt;span class="s"&gt;  otherwise returns nil.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;combiner&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;empty?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;combiner&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="nv"&gt;combiner&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's dig in. The function accepts the following parameters:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;states&lt;/tt&gt;: a list of starting states for the search. When invoked by the
user, this list will typically have a single element; when &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt;
calls itself, this list is the states that it plans to explore next.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt;: a goal detection function. The search doesn't know anything
about states and what the goal of the search is, so this is parameterized
by a function. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt; is expected to return &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; for a goal
state (the state we were searching for) and &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; for all other states.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;: the search function also doesn't know anything about what
kind of tree it's searching through; what are the children of a given state?
Is it searching a binary tree? A N-nary tree? Something more exotic? All of
this is parameterized via the &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; function provided by the user.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt;: finally, the search strategy can be parameterized as well.
There are many different kinds of searches possible - BFS, DFS and others.
&lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; takes a list of successors for the current state the search is
looking at, as well as a list of all the other states the search still plans
to look at. It combines these into a single list &lt;em&gt;somehow&lt;/em&gt;, and thus guides
the order in which the search happens.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Even before we see how this function is used, it's already apparent that this
is quite a powerful abstraction. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt; defines the essence of what
it means to &amp;quot;search a tree&amp;quot;, while being oblivious to what the tree contains,
how it's structured and even what order it should be searched in; all of this
is supplied by functions passed in as parameters.&lt;/p&gt;
&lt;p&gt;Let's see an example, doing a BFS search on our infinite binary tree. First,
we define a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;breadth-first-search&lt;/span&gt;&lt;/tt&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;breadth-first-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search old states first until goal is reached.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;prepend&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function takes a start state (a single state, not a list), &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;, but it sets the &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; parameter to the &lt;tt class="docutils literal"&gt;prepend&lt;/tt&gt;
function, which is defined as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;prepend&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It defines the search strategy (BFS = first look at the rest of the states and
only then at successors of the current state), but still leaves the tree
structure and the notion of what a goal is to parameters. Let's see it in
action:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (breadth-first-search 1 #(= % 9) binary-tree)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we pass the anonymous function literal &lt;tt class="docutils literal"&gt;#(= % 9)&lt;/tt&gt; as the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt;
parameter. This function simply checks whether the state passed to it is the
number 9. We also pass &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;binary-tree&lt;/span&gt;&lt;/tt&gt; as the &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;, since we're going
to be searching in our infinite binary tree. BFS works layer by layer, so it
has no issue with that and finds the state quickly.&lt;/p&gt;
&lt;p&gt;We can turn on verbosity (refer to &lt;a class="reference external" href="https://github.com/eliben/paip-in-clojure/tree/master/src/paip/6_tools"&gt;the full code&lt;/a&gt; to
see how it works) to see what &lt;tt class="docutils literal"&gt;states&lt;/tt&gt; parameter &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt; gets called
with, observing the progression of the search:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (with-verbose (breadth-first-search 1 #(= % 9) binary-tree))
;; Search: (1)
;; Search: (2 3)
;; Search: (3 4 5)
;; Search: (4 5 6 7)
;; Search: (5 6 7 8 9)
;; Search: (6 7 8 9 10 11)
;; Search: (7 8 9 10 11 12 13)
;; Search: (8 9 10 11 12 13 14 15)
;; Search: (9 10 11 12 13 14 15 16 17)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the &lt;tt class="docutils literal"&gt;prepend&lt;/tt&gt; combiner in action; for example, after &lt;tt class="docutils literal"&gt;(3 4 5)&lt;/tt&gt;, the
combiner prepends &lt;tt class="docutils literal"&gt;(4 5)&lt;/tt&gt; to the successors of 3 (the list &lt;tt class="docutils literal"&gt;(6 7)&lt;/tt&gt;), getting
&lt;tt class="docutils literal"&gt;(4 5 6 7)&lt;/tt&gt; as the set of states to search through. Overall, observing the
first element in the &lt;tt class="docutils literal"&gt;states&lt;/tt&gt; list through the printed lines, it's clear this
is classical BFS where the tree is visited in &amp;quot;layers&amp;quot;.&lt;/p&gt;
&lt;p&gt;Implementing DFS using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt; is similarly easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;depth-first-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search new states first until goal is reached.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only difference from BFS is the &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; parameter - here we use
&lt;tt class="docutils literal"&gt;concat&lt;/tt&gt; since we want to examine the successors of the first state &lt;em&gt;before&lt;/em&gt;
we examine the other states on the list. If we run &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;depth-first-search&lt;/span&gt;&lt;/tt&gt; on our
infinite binary tree we'll get a stack overflow (unless we're looking for a
state that's on the left-most path), so let's create a safer tree first. This
function can serve as a &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; to define a &amp;quot;finite&amp;quot; binary tree, with
the given maximal state value:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;finite-binary-tree&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Returns a successor function that generates a binary tree with n nodes.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;= &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;binary-tree&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the clever use of higher-order functions here. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;finite-binary-tree&lt;/span&gt;&lt;/tt&gt; is
not a &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; function itself - rather it's a generator of such
functions; given a value, it creates a new function that acts as &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;
but limits the the states' value to &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(finite-binary-tree&lt;/span&gt; 15)&lt;/tt&gt; will create a &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; function
that represents exactly the binary tree on the diagram above; if we ask it about
successors of states on the fourth layer, it will say there are none:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (def f15 (finite-binary-tree 15))
#&amp;#39;paip.core/f15
paip.core=&amp;gt; (f15 4)
(8 9)
paip.core=&amp;gt; (f15 8)
()
paip.core=&amp;gt; (f15 7)
(14 15)
paip.core=&amp;gt; (f15 15)
()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As another test, let's try to look for a state that's not in our finite tree.
Out infinite tree theoretically has &lt;em&gt;all&lt;/em&gt; the states:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (breadth-first-search 1 #(= % 33) binary-tree)
33
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But not the finite tree:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (breadth-first-search 1 #(= % 33) (finite-binary-tree 15))
nil
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With our finite tree, we are ready to use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;depth-first-search&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (with-verbose (depth-first-search 1 #(= % 9) (finite-binary-tree 15)))
;; Search: (1)
;; Search: (2 3)
;; Search: (4 5 3)
;; Search: (8 9 5 3)
;; Search: (9 5 3)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the search order; when &lt;tt class="docutils literal"&gt;(2 3)&lt;/tt&gt; is explored, 2's successors &lt;tt class="docutils literal"&gt;(4 5)&lt;/tt&gt; then
come &lt;em&gt;before&lt;/em&gt; 3 in the next call; this is the definition of DFS.&lt;/p&gt;
&lt;p&gt;We can implement more advanced search strategies using this infrastructure. For
example, suppose we have a heuristic that tells us which states to prioritize in
order to get to the goal faster (akin to A* search on graphs). We can define
a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;best-first-search&lt;/span&gt;&lt;/tt&gt; that sorts the states according to our heuristic and
tries the most promising states first (&amp;quot;best&amp;quot; as in &amp;quot;best looking among the
current candidates&amp;quot;, not as in &amp;quot;globally best&amp;quot;).&lt;/p&gt;
&lt;p&gt;First, let's define a couple of helper higher-order functions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;diff&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Given n, returns a function that computes the distance of its argument from n.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Math/abs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;sorter&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Returns a combiner function that sorts according to cost-fn.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;new &lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sort-by &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="k"&gt;new &lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;diff&lt;/tt&gt; is a function generator like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;finite-binary-tree&lt;/span&gt;&lt;/tt&gt;; it takes a target
number &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; and returns a function that computes its parameter &lt;tt class="docutils literal"&gt;x&lt;/tt&gt;'s distance
from &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;sorter&lt;/tt&gt; returns a function that serves as the &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; for our
search, based on a cost function. This is done by concatenating the two lists
(successors of first state and the rest of the states) first, and then sorting
them by the cost function. &lt;tt class="docutils literal"&gt;sorter&lt;/tt&gt; is a powerful example of modeling with
higher-order functions.&lt;/p&gt;
&lt;p&gt;With these building blocks in place, we can define &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;best-first-search&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;best-first-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search lowest cost states first until goal is reached.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sorter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, this is just like the earlier BFS and DFS - only the strategy
(&lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt;) changes. Let's use it to find 9 again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (with-verbose (best-first-search 1 #(= % 9) (finite-binary-tree 15) (diff 9)))
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6 2)
;; Search: (6 14 15 2)
;; Search: (12 13 14 15 2)
;; Search: (13 14 15 2)
;; Search: (14 15 2)
;; Search: (15 2)
;; Search: (2)
;; Search: (5 4)
;; Search: (10 11 4)
;; Search: (11 4)
;; Search: (4)
;; Search: (9 8)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it finds the state eventually, we discover that our heuristic is not a
great match for this problem, as it sends the search astray. The goal of this
post is to demonstrate the power of higher-order functions in building modular
code, not to discover an optimal heuristic for searching in binary trees, though
:-)&lt;/p&gt;
&lt;p&gt;One last search variant before we're ready to wrap up. As we've seen with the
infinite tree, sometimes the search space is too large and we have to compromise
on which states to look at and which to ignore. This technique works
particularly well if the target is not some single value that we must find, but
rather we want to get a &amp;quot;good enough&amp;quot; result in a sea of bad options. We can
use a technique called &lt;em&gt;beam search&lt;/em&gt;; think of a beam of light a flashlight
produces in a very dark room; we can see what the beam points at, but not much
else.&lt;/p&gt;
&lt;p&gt;Beam search is somewhat similar to our &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;best-first-search&lt;/span&gt;&lt;/tt&gt;, but after combining
and sorting the list of states to explore, it only keeps the first N, where
N is given by the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;beam-width&lt;/span&gt;&lt;/tt&gt; parameter:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;beam-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search highest scoring states first until goal is reached, but never consider&lt;/span&gt;
&lt;span class="s"&gt;  more than beam-width states at a time.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;beam-width&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;new&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;sorted&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;sorter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;new&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take &lt;/span&gt;&lt;span class="nv"&gt;beam-width&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, higher-order functions at play: as its &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;beam-search&lt;/span&gt;&lt;/tt&gt;
creates an anonymous function that sorts the list based on &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cost-fn&lt;/span&gt;&lt;/tt&gt;, and then
keeps only the first &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;beam-width&lt;/span&gt;&lt;/tt&gt; states on that list.&lt;/p&gt;
&lt;p&gt;Exercise: Try to run it - what beam width do you need to set in order to
successfully find 9 using our cost heuristic? How can this be improved?&lt;/p&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post attempts a code-walkthrough approach to demonstrating the power of
higher-order functions. I always found this particular example from PAIP very
elegant; a particularly powerful insight is the distilled difference between
DFS and BFS. While most programmers intuitively understand the difference and
could write down the pseudo-code for both search strategies, modeling the
problem with higher-order functions lets us really get to the essence of the
difference - &lt;tt class="docutils literal"&gt;concat&lt;/tt&gt; vs. &lt;tt class="docutils literal"&gt;prepend&lt;/tt&gt; as the combiner step.&lt;/p&gt;
&lt;p&gt;See also: &lt;a class="reference external" href="https://eli.thegreenplace.net/2023/higher-order-functions-in-go/"&gt;this code sample ported to Go&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category><category term="Programming"></category></entry><entry><title>Why is it easy to implement a Lisp?</title><link href="https://eli.thegreenplace.net/2022/why-is-it-easy-to-implement-a-lisp/" rel="alternate"></link><published>2022-06-20T06:50:00-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2022-06-20:/2022/why-is-it-easy-to-implement-a-lisp/</id><summary type="html">&lt;p&gt;A few weeks ago, an &lt;a class="reference external" href="https://news.ycombinator.com/item?id=31547765"&gt;interesting HN thread&lt;/a&gt; caught my eye. When
implementing an interpreter for a programming language, Lisp is often cited
as a particularly attractive example due to its simplicity. Why is that?&lt;/p&gt;
&lt;p&gt;I've really enjoyed implementing Lisp interpreters and compilers in the past
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;, so I'd like â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;A few weeks ago, an &lt;a class="reference external" href="https://news.ycombinator.com/item?id=31547765"&gt;interesting HN thread&lt;/a&gt; caught my eye. When
implementing an interpreter for a programming language, Lisp is often cited
as a particularly attractive example due to its simplicity. Why is that?&lt;/p&gt;
&lt;p&gt;I've really enjoyed implementing Lisp interpreters and compilers in the past
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;, so I'd like to reflect a bit on this topic. But first, an important
clarification: when I say &amp;quot;Lisp&amp;quot; I mean a family of languages, some of them
minimal (like the original Lisp 1.5 or older versions of Scheme), and some very
large and complicated (like Common Lisp, Racket or Clojure).&lt;/p&gt;
&lt;p&gt;So why &lt;em&gt;are&lt;/em&gt; interpreters for Lisp relatively easy to write? The answer is
twofold: (1) it's easy to write a Lisp frontend and (2) it's easy to write a
Lisp backend.&lt;/p&gt;
&lt;div class="section" id="frontend-uniform-syntax"&gt;
&lt;h2&gt;Frontend - uniform syntax&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Uniform syntax&lt;/em&gt; is one of Lisp's greatest strengths. It's what makes parsing
the language simple, and also enables powerful macro systems that are very
common in real-life Lisp implementations.&lt;/p&gt;
&lt;p&gt;Lisp programs consist of &lt;em&gt;lists&lt;/em&gt;, which have this structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;( item item ... )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;tt class="docutils literal"&gt;(&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;)&lt;/tt&gt; are the literal paren characters, and each item is
potentially a nested list. There is also a small number of special tokens a Lisp
supports, such as a single quote for symbols and double quotes for strings.&lt;/p&gt;
&lt;p&gt;As far as the lexer goes, it has to recognize only a handful of special
characters. The parser only has a single rule to parse a list recursively;
there's no operator precedence to worry about; in fact, there are no operators
at all:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(minus x y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is parsed exactly the same as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(- x y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the latter, &lt;tt class="docutils literal"&gt;-&lt;/tt&gt; is just another symbol. The interpreter (backend) may
attribute some special semantics to it, but as far as the parser is concerned
this is a non-issue. Lisps are almost universally dynamically typed, which
simplifies the parser further.&lt;/p&gt;
&lt;p&gt;A simple parser is great, but that's not all. Parsers typically produce some
sort of &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/"&gt;parse tree or AST&lt;/a&gt;,
which then serves as input to the interpreter or the compiler backend. In Lisp,
an AST is trivial: it's just the nested representation of the parsed input list.&lt;/p&gt;
&lt;p&gt;Back to our &lt;tt class="docutils literal"&gt;(minus x y)&lt;/tt&gt; example; its &amp;quot;AST&amp;quot; representation is a tree node
with &lt;tt class="docutils literal"&gt;minus&lt;/tt&gt; at the root and &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; as child nodes. This is similar
to the AST nodes produced from expressions in &amp;quot;standard&amp;quot; programming languages,
but in Lisp everything is a list / expression. So there's no need to design
special AST data structures and map the parser's output to them - it emerges
out of the structure of Lisp automatically. In fact, Lisp programs are famously
just Lisp data, which is why in Lisp macros are not a special language but
rather just Lisp code that manipulates other lisp code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="backend-meta-circular-evaluator"&gt;
&lt;h2&gt;Backend - meta-circular evaluator&lt;/h2&gt;
&lt;img alt="Eval/Apply diagram from SICP" class="align-center" src="https://eli.thegreenplace.net/images/2022/evalapply.png" /&gt;
&lt;p&gt;Lisp was designed to be simple to interpret (at least in a straightforward way,
without worrying about efficiency). This goes back all the way to John
McCarthy's 1960 paper titled &lt;em&gt;Recursive Functions of Symbolic Expressions
and Their Computation by Machine&lt;/em&gt;. The clearest formulation I could find for
this is in Paul Graham's 2002 essay &lt;em&gt;The Roots of Lisp&lt;/em&gt;. Here's the entire
Lisp interpreter:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun eval. (e a)
  (cond
    ((atom e) (assoc. e a))
    ((atom (car e))
      (cond
        ((eq (car e) &amp;#39;quote) (cadr e))
          ((eq (car e) &amp;#39;atom) (atom (eval. (cadr e) a)))
          ((eq (car e) &amp;#39;eq) (eq (eval. (cadr e) a) (eval. (caddr e) a)))
          ((eq (car e) &amp;#39;car) (car (eval. (cadr e) a)))
          ((eq (car e) &amp;#39;cdr) (cdr (eval. (cadr e) a)))
          ((eq (car e) &amp;#39;cons) (cons (eval. (cadr e) a) (eval. (caddr e) a)))
          ((eq (car e) &amp;#39;cond) (evcon. (cdr e) a))
          (&amp;#39;t (eval. (cons (assoc. (car e) a) (cdr e)) a))))
    ((eq (caar e) &amp;#39;label)
      (eval. (cons (caddar e) (cdr e)) (cons (list (cadar e) (car e)) a)))
    ((eq (caar e) &amp;#39;lambda)
      (eval. (caddar e) (append. (pair. (cadar e) (evlis. (cdr e) a)) a)))))

(defun evcon. (c a)
  (cond ((eval. (caar c) a)
         (eval. (cadar c) a))
         (&amp;#39;t (evcon. (cdr c) a))))

(defun evlis. (m a)
  (cond ((null. m) &amp;#39;())
         (&amp;#39;t (cons (eval. (car m) a) (evlis. (cdr m) a)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code assumes that there are a few more primitives defined in the language,
using lower-level primitives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun pair. (x y)
  (cond ((and. (null. x) (null. y)) &amp;#39;())
        ((and. (not. (atom x)) (not. (atom y)))
         (cons (list (car x) (car y))
               (pair. (cdr x) (cdr y))))))

(defun assoc. (x y)
  (cond ((eq (caar y) x) (cadar y))
         (&amp;#39;t (assoc. x (cdr y)))))

(defun null. (x) (eq x &amp;#39;()))

(defun and. (x y)
  (cond (x (cond (y &amp;#39;t) (&amp;#39;t &amp;#39;())))
        (&amp;#39;t &amp;#39;())))

(defun not. (x)
  (cond (x &amp;#39;())
        (&amp;#39;t &amp;#39;t)))

(defun append. (x y)
  (cond ((null. x) y)
        (&amp;#39;t (cons (car x) (append. (cdr x) y)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It also relies on several &amp;quot;built-ins&amp;quot;: &lt;tt class="docutils literal"&gt;quote&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;atom&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;eq&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;car&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;cdr&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;cons&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The built-ins &lt;tt class="docutils literal"&gt;cons&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;car&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;cdr&lt;/tt&gt; are the basic tools for working with
the list data structure: &lt;tt class="docutils literal"&gt;cons&lt;/tt&gt; creates a pair with a head and tail; &lt;tt class="docutils literal"&gt;car&lt;/tt&gt;
grabs the head and &lt;tt class="docutils literal"&gt;cdr&lt;/tt&gt; grabs the tail. Compound accessors like &lt;tt class="docutils literal"&gt;cadr&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;caddar&lt;/tt&gt; are a combination of the latter two, and can be trivially constructed
using them as primitives. For example, &lt;tt class="docutils literal"&gt;(cadr x)&lt;/tt&gt; is the same as &lt;tt class="docutils literal"&gt;(car (cdr
x))&lt;/tt&gt;, meaning the second element from the list. Recall that Lisp's lists
represent nested trees - so these primitives are just convenience helpers to
grab specific children and other descendants from a given node.&lt;/p&gt;
&lt;p&gt;I highly recommend reading &lt;em&gt;The Roots of Lisp&lt;/em&gt; for all the details - it's short
and very readable. What's important for our goal here is to note how small the
evaluator is, and how little supporting infrastructure it requires.&lt;/p&gt;
&lt;p&gt;The one issue folks may run into when implementing a Lisp interpreter in a
systems programming language is the need for some sort of automatic memory
management, which is assumed by the Lisp specification (there's a &lt;tt class="docutils literal"&gt;cons&lt;/tt&gt; to
build new lists, but no explicit way to free up this memory). While &lt;a class="reference external" href="https://github.com/eliben/bobscheme"&gt;Bob&lt;/a&gt;'s first interpreter is in Python, I
specifically &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/04/09/a-c-vm-added-to-bob"&gt;wrote another version in C++&lt;/a&gt; to practice
implementing a GC for Lisp.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;The most serious implementation is
&lt;a class="reference external" href="https://eli.thegreenplace.net/2010/11/06/bob-a-scheme-interpreter-compiler-and-vm-in-python"&gt;Bob&lt;/a&gt;,
which is a whole suite of interpreters and compilers for Scheme, written
in Python and C++.&lt;/p&gt;
&lt;p&gt;There's also a fairly functional series of interpreters and
compilers while &lt;a class="reference external" href="https://eli.thegreenplace.net/2007/12/06/sicp-sections-411-412"&gt;working through SICP&lt;/a&gt;.&lt;/p&gt;
&lt;p class="last"&gt;Finally, another series of interpreters while working through the
&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/book-review-essentials-of-programming-languages-by-d-friedman-and-m-wand/"&gt;EOPL book&lt;/a&gt;.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Lisp"></category><category term="Compilation"></category></entry><entry><title>The Y combinator in Go with generics</title><link href="https://eli.thegreenplace.net/2022/the-y-combinator-in-go-with-generics/" rel="alternate"></link><published>2022-06-11T07:55:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2022-06-11:/2022/the-y-combinator-in-go-with-generics/</id><summary type="html">&lt;p&gt;A few years ago I've &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/some-notes-on-the-y-combinator/"&gt;written in some detail&lt;/a&gt; about
the Y combinator, including implementations in Clojure and Python.&lt;/p&gt;
&lt;p&gt;This short post is showing how to implement the Y combinator in Go using
generics; in general, static typing makes the Y combinator somewhat less
appealing, but I figured that generics â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;A few years ago I've &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/some-notes-on-the-y-combinator/"&gt;written in some detail&lt;/a&gt; about
the Y combinator, including implementations in Clojure and Python.&lt;/p&gt;
&lt;p&gt;This short post is showing how to implement the Y combinator in Go using
generics; in general, static typing makes the Y combinator somewhat less
appealing, but I figured that generics will at least allow the implementation to
be reasonably reusable. Not that this is useful in any real-world scenario, of
course :-)&lt;/p&gt;
&lt;p&gt;I won't explain how the Y combinator itself
works here (please refer to the &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/some-notes-on-the-y-combinator/"&gt;previous post&lt;/a&gt; for
that), only the Go specifics. The full, runnable code for this post is available
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2022/ycombinator-go"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;any&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;TagFunc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;any&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;CombinatorFunc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;any&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;CombinatorFunc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Y combinator's definition uses several kinds of anonymous functions. In Go,
we need those to have explicit types. &lt;tt class="docutils literal"&gt;Func&lt;/tt&gt; is the underlying computation
function - it's what the function type would be if we'd used normal recursion.
It's parameterized with two generic types: &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; for its parameter type and
&lt;tt class="docutils literal"&gt;U&lt;/tt&gt; for its return type.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;FuncTag&lt;/tt&gt; is the type of the functions users should write now.
&lt;tt class="docutils literal"&gt;CombinatorFunc&lt;/tt&gt; is only used in the definition of the Y combinator itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;any&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;TagFunc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;CombinatorFunc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}(&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;CombinatorFunc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;U&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's how to use it. To define a recursive factorial-computing function that
does not refer to itself by name, the user has to create a &amp;quot;tag&amp;quot; function that
takes and returns a &lt;tt class="docutils literal"&gt;Func&lt;/tt&gt;. At this point we also instantiate the &lt;tt class="docutils literal"&gt;Func&lt;/tt&gt;
to have the exact types we need:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;factorial_tag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And the actual factorial function that users can call is created with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;fac&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;factorial_tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now &lt;tt class="docutils literal"&gt;fac&lt;/tt&gt; is function of type &lt;tt class="docutils literal"&gt;Func&lt;/tt&gt;: it computes and returns the factorial
of its parameter, and can be simply invoked as &lt;tt class="docutils literal"&gt;answer := fac(param)&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;We can also try the other example in my previous post - a function that finds
the sum of values in a binary tree. It demonstrates a slightly more complicated
recursive flow as well as different types for the function's parameter and
return value:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;left&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Node&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;right&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Node&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;treesum_tag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And once again, the actual usable function is generated by invoking &lt;tt class="docutils literal"&gt;Y&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;treesum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;treesum_tag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</content><category term="misc"></category><category term="Go"></category><category term="Lisp"></category></entry><entry><title>Clojure - the perfect language to expand your brain?</title><link href="https://eli.thegreenplace.net/2017/clojure-the-perfect-language-to-expand-your-brain/" rel="alternate"></link><published>2017-08-04T05:25:00-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-08-04:/2017/clojure-the-perfect-language-to-expand-your-brain/</id><summary type="html">&lt;p&gt;I sometimes get asked for recommendations of what programming language to &amp;quot;learn
next&amp;quot;. It's great that folks appreciate the fact that being exposed to several
sufficiently different programming languages is an important step on the path
to programming enlightenment. But it's also true that, given limited free time,
the choice â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;I sometimes get asked for recommendations of what programming language to &amp;quot;learn
next&amp;quot;. It's great that folks appreciate the fact that being exposed to several
sufficiently different programming languages is an important step on the path
to programming enlightenment. But it's also true that, given limited free time,
the choice of which languages to learn is important. As the famous quote by
&lt;a class="reference external" href="https://en.wikiquote.org/wiki/Alan_Perlis"&gt;Alan Perlis&lt;/a&gt; says:&lt;/p&gt;
&lt;blockquote&gt;
A language that doesn't affect the way you think about programming, is not
worth knowing.&lt;/blockquote&gt;
&lt;p&gt;In this post I want to explain why I think Clojure is a &lt;em&gt;terrific&lt;/em&gt; language for
this task. Whatever your background, it's &lt;a class="reference external" href="http://www.paulgraham.com/icad.html"&gt;almost guaranteed&lt;/a&gt; to affect the way you think about
programming. It's a fairly new language (from 2007) that did a good job of
collecting insights and paradigms from many existing languages and organizing
them into a coherent whole. It's chock-full of great ideas. In
other words, the &lt;em&gt;perfect language to expand your brain&lt;/em&gt;.&lt;/p&gt;
&lt;img alt="Brain with Clojure inside" class="align-center" src="https://eli.thegreenplace.net/images/2017/brainclojure.png" /&gt;
&lt;div class="section" id="it-s-a-lisp"&gt;
&lt;h2&gt;It's a Lisp!&lt;/h2&gt;
&lt;p&gt;First and foremost, Clojure belongs to the Lisp family of languages, like Common
Lisp, Scheme and Racket. Lisp is one of the oldest and still most important
families of programming languages to be familiar with. Being a Lisp in this case
means several things:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Clojure is a dynamic language. No matter where you stand on the static vs.
dynamic typing debate, knowing languages in both camps is important. Clojure
has a kind of optional typing, but in essence it's dynamic.&lt;/li&gt;
&lt;li&gt;It promotes combinations of built-in data structures (lists, maps, vectors)
over objects and has very good reasons for doing so.&lt;/li&gt;
&lt;li&gt;It promotes programming with higher-order functions. Some built-in features
like &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/reducers-transducers-and-coreasync-in-clojure/"&gt;reducers and transducers&lt;/a&gt;
rely heavily on composing higher order functions for transforming other
functions.&lt;/li&gt;
&lt;li&gt;It has uniform syntax with full Lisp-style macro support! This capability
has proved to be very elusive for non-Lisp languages, and seeing some &lt;em&gt;real&lt;/em&gt;
macros in action is enlightening. Clojure has a whole Go-like CSP equivalent
implemented using macros in &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;It encourages REPL-based development, where functionality is built and testsed
gradually from the bottom up in an interactive terminal.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Importantly, Clojure is a very &lt;em&gt;modern&lt;/em&gt; Lisp, with tons of libraries for tasks
common in our day and age. It also builds upon important recent research in data
structures, such as efficient persistent vectors, that only appeared in the
1990s or later. I've been dabbling with various Lisps for almost 15 years, and
Clojure is the first Lisp I'd consider using in production.&lt;/p&gt;
&lt;p&gt;I want the stress the importance of full Lisp-style macros once again. Lisp's
(and Clojure's) uniform syntax and macros force us to think about the
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Meta-circular_evaluator"&gt;Meta-circular abstraction&lt;/a&gt; - there's just no way
around it! We have to think of our code as data, and this has profound
implications. Back in 2005, when I was still a programming neophyte, I faced a
performance challenge for a data-decoding program I was hacking on in Perl.
Having learned some Lisp, I had the insight of &lt;a class="reference external" href="https://eli.thegreenplace.net/2005/09/04/cool-hack-creating-custom-subroutines-on-the-fly-in-perl"&gt;generating and evaluating new
Perl code on the fly&lt;/a&gt;,
which turned out to be key to the success of that program. I'm confident I could
not have come up with that solution back then without being aware of the &amp;quot;Lisp
way&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pragmatism-and-hard-won-experience"&gt;
&lt;h2&gt;Pragmatism and hard-won experience&lt;/h2&gt;
&lt;p&gt;The designers of Clojure are extremely pragmatic, building upon decades of
industry experience. I strongly recommend watching some &lt;a class="reference external" href="https://www.youtube.com/user/ClojureTV"&gt;YouTube videos of talks&lt;/a&gt; by leading Clojure developers. In
particular, watch a few of the more popular talks by Rich Hickey - Clojure's
original designer. The Alan Perlis quote mentioned above may be his most
popular, but there's another I find at least as insightful:&lt;/p&gt;
&lt;blockquote&gt;
Simplicity does not precede complexity, but follows it.&lt;/blockquote&gt;
&lt;p&gt;There's a certain quality in programmers I believe we can all recognize. It can
only come from &lt;em&gt;real&lt;/em&gt;, hard-won experience of building systems for many years
and pondering about how to build such systems more effectively next time. Rich
Hickey certainly belongs to this quality category - his talks are very
insightful, and this philosophy reigns in the design and implementation of
Clojure, as well as its (friendly and vibrant) community.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sequences-and-laziness-for-powerful-in-language-data-processing"&gt;
&lt;h2&gt;Sequences and laziness for powerful in-language data processing&lt;/h2&gt;
&lt;p&gt;Applications that process and extract useful bits of information from large
datasets all look alike in many programming languages, at least to some extent.
What we &lt;em&gt;really&lt;/em&gt; want in many cases is SQL-like primitives built into our
languages, but this is often challenging (.NET's LINQ is one example of a
successful approach).&lt;/p&gt;
&lt;p&gt;Clojure combines pervasive sequence protocols with persistent data structures
and laziness to make this kind of task natural, using only built-in tools.
Here's a realistic example of a function taken from the &lt;a class="reference external" href="https://pragprog.com/book/vmclojeco/clojure-applied"&gt;Clojure Applied&lt;/a&gt; book:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;revenue-by-department&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;carts&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="ss"&gt;:settled?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;carts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcat &lt;/span&gt;&lt;span class="ss"&gt;:line-items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;line-summary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;group-by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:dept&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reduce-kv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;dept-total&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the functions used here are built-ins, including the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&amp;gt;&lt;/span&gt;&lt;/tt&gt; macro. This
code reads like SQL and it's efficient too. In fact, it can be made somewhat
more efficient and even seamlessly parallelized using &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/reducers-transducers-and-coreasync-in-clojure/"&gt;Reducers and Transducers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://clojure.org/guides/spec"&gt;clojure.spec&lt;/a&gt; library provides a degree
of type-safety for nested data structures. If you've ever written comments like
&amp;quot;this maps strings to lists, where each list element is a map of ...&amp;quot;,
&lt;tt class="docutils literal"&gt;clojure.spec&lt;/tt&gt; makes it more formal and verifiable. This is very useful when
working with data, and is another example of where Clojure's pragmatism shines;
the language is dynamic in its core, but when you need static checking - it's
there, optionally (&lt;tt class="docutils literal"&gt;core.typed&lt;/tt&gt; is another option for a more statically typed
flavor).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-right-approach-to-object-orientation"&gt;
&lt;h2&gt;The right approach to object-orientation&lt;/h2&gt;
&lt;p&gt;Historically, Lisp programmers weren't the biggest proponents of OOP. This
doesn't mean that OOP has absolutely no value in Lisp-y languages, however.
Common Lisp has had CLOS for decades, and Clojure also comes with an array of
OO-like features.&lt;/p&gt;
&lt;p&gt;That said, Clojure's flavor of OOP is particularly powerful and tends to
discourage bad practices. Clojure uses &amp;quot;protocols&amp;quot;, which are a kind of
interfaces, and encourages thinking in terms of protocols rather than in terms
of classes with inheritance hierarchies, sort of like Go. Add to that an ability
to do true &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-4/"&gt;multiple dispatch&lt;/a&gt;
and you have a powerful modeling tool at your fingertips.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="built-in-support-for-concurrency-and-parallelism"&gt;
&lt;h2&gt;Built-in support for concurrency and parallelism&lt;/h2&gt;
&lt;p&gt;It wouldn't be a real language of the 2000s without powerful support for
concurrency and parallelism right at the core. Clojure supports this in many
ways, which are interleaved.&lt;/p&gt;
&lt;p&gt;First, it's a functional language with persistent data structures. Persistent
data structures are effectively immutable, which makes them very attractive in a
multi-threaded context. Clojure has a great implementation of persistent data
structures even for things like vectors (which are quite challenging to
implement in an efficient manner). This is a bigger deal than may originally
appear. Pure functions are often great in theory but fail in practice due to too
much copying of non-trivial data structures; Clojure's elegant usage of
persistent data structures solves this problem, making pure functions efficient
and thus much more applicable to a wide array of problems.&lt;/p&gt;
&lt;p&gt;Second, Clojure doesn't lock itself in the closet of purism and does support
lower-level primitives for concurrency and mutation, where needed. Atoms are
built-in mutable state units with atomic updates. &lt;a class="reference external" href="https://clojure.org/reference/refs"&gt;Refs and transactions&lt;/a&gt; go further, implementing STM.&lt;/p&gt;
&lt;p&gt;Third, Clojure comes with a bunch of concurrency tools built in. Promises,
futures and threads leverage the underlying JVM's threading utilities.&lt;/p&gt;
&lt;p&gt;Finally, Clojure has a pretty good implementation of Go's CSP in the
&lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; module. It provides two useful things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Channels and Go &lt;tt class="docutils literal"&gt;select&lt;/tt&gt;-like functionality (&lt;tt class="docutils literal"&gt;alts!!&lt;/tt&gt;) which makes it
easy to work with safe concurrent queues and &amp;quot;share data by communicating&amp;quot;.&lt;/li&gt;
&lt;li&gt;go-blocks with non-blocking primitives that &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/clojure-concurrency-and-blocking-with-coreasync/"&gt;make it possible&lt;/a&gt;
to write cooperative &amp;quot;green threads&amp;quot; with ease.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion-try-it"&gt;
&lt;h2&gt;Conclusion - try it&lt;/h2&gt;
&lt;p&gt;Finally, it's important to mention that Clojure is far from being an academic
exercise. It's used in production by several companies, and has strong roots in
the massive Java ecosystem. Clojure's interoperability with Java is seamless -
Java code can be called from Clojure with no special provisions, and all core
Clojure entities are Java objects deep under the hood.&lt;/p&gt;
&lt;p&gt;On the client side, Clojurescript has been gaining traction recently as another
language-compiled-to-JS option. It brings the elegance of Clojure to client-side
programming, among with some unique features like &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; for
callback-free concurrency.&lt;/p&gt;
&lt;p&gt;This doesn't mean that you should only consider Clojure as a fit for your next
project. On the contrary, I recommend learning if even if there's little chance
of using it in production any time soon. In fact, this was exactly my situation,
Clojure is a great language to expand your programming horizons; who knows,
maybe in the future you'll find it useful for some real work. If you do, great!
If you don't, learning it will positively affect how you use other programming
languages.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category><category term="Programming"></category></entry><entry><title>Clojure concurrency and blocking with core.async</title><link href="https://eli.thegreenplace.net/2017/clojure-concurrency-and-blocking-with-coreasync/" rel="alternate"></link><published>2017-06-23T06:01:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-06-23:/2017/clojure-concurrency-and-blocking-with-coreasync/</id><summary type="html">&lt;p&gt;This article is an attempt to dig into the performance problem of concurrent
applications using &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; in situations where blocking operations are
involved. &amp;quot;Blocking&amp;quot; operations happen when the running program has to wait for
something happening outside it; a canonical example is issuing an HTTP request
and waiting for â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;This article is an attempt to dig into the performance problem of concurrent
applications using &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; in situations where blocking operations are
involved. &amp;quot;Blocking&amp;quot; operations happen when the running program has to wait for
something happening outside it; a canonical example is issuing an HTTP request
and waiting for the remote server to respond. Such operations are also sometimes
called &amp;quot;synchronous&amp;quot;.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; library comes with many high-level features like transducers
and pipelines; in this article I want to focus on the two fundamental mechanisms
it provides for launching a new computation concurrently: threads and go-blocks.&lt;/p&gt;
&lt;p&gt;New threads can be created with &lt;tt class="docutils literal"&gt;(thread &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;. This call runs the body in a
new thread and (immediately) returns a channel to which the result of the body
will be posted. Similarly, a go-block is created with &lt;tt class="docutils literal"&gt;(go &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt; - it also
launches the computation concurrently, but instead of creating a new thread it
posts the computation onto a &lt;em&gt;thread pool&lt;/em&gt; of fixed size that the library
maintains for all its go-blocks. Most of the article is focusing on exploring
the differences between these two methods.&lt;/p&gt;
&lt;div class="section" id="the-go-block-thread-pool"&gt;
&lt;h2&gt;The go-block thread pool&lt;/h2&gt;
&lt;p&gt;In any given executing Clojure process, a single thread pool is dedicated to
running all go-blocks. A quick glance at the Clojure source code shows that the
size of this pool is 8, meaning that 8 physical threads are launched &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. This
number is hard-coded, though it can be modified by setting the
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clojure.core.async.pool-size&lt;/span&gt;&lt;/tt&gt; property for the JVM running the program. So 8
is the default number of threads &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; has at its disposal to implement
its ad-hoc cooperative multitasking.&lt;/p&gt;
&lt;p&gt;Let's start with a cute little experiment to determine the size of the thread
pool empirically; this exercise will also shed some light on the effect of
blocking calls inside go-blocks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;launch-n-go-blocks&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Thread/sleep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function launches &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; go-blocks, each sleeping for 10 milliseconds and
then pushing a number into a shared channel. Then it waits to receive all
numbers from the channel and returns; the effect is to block until all the
go-blocks are done. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;receive-in&lt;/span&gt;&lt;/tt&gt; is a simple function used throughout this
article:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Receive n items from the given channel and return them as a vector.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;inc &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;launch-n-go-blocks&lt;/span&gt;&lt;/tt&gt; several times, with an increasing &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;
and observe what happens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Launching  1 -&amp;gt; &amp;quot;Elapsed time: 11.403985 msecs&amp;quot;
Launching  2 -&amp;gt; &amp;quot;Elapsed time: 11.050685 msecs&amp;quot;
Launching  3 -&amp;gt; &amp;quot;Elapsed time: 10.37412 msecs&amp;quot;
Launching  4 -&amp;gt; &amp;quot;Elapsed time: 10.342037 msecs&amp;quot;
Launching  5 -&amp;gt; &amp;quot;Elapsed time: 10.359517 msecs&amp;quot;
Launching  6 -&amp;gt; &amp;quot;Elapsed time: 10.409539 msecs&amp;quot;
Launching  7 -&amp;gt; &amp;quot;Elapsed time: 10.543612 msecs&amp;quot;
Launching  8 -&amp;gt; &amp;quot;Elapsed time: 10.429726 msecs&amp;quot;
Launching  9 -&amp;gt; &amp;quot;Elapsed time: 20.480441 msecs&amp;quot;
Launching 10 -&amp;gt; &amp;quot;Elapsed time: 20.442724 msecs&amp;quot;
Launching 11 -&amp;gt; &amp;quot;Elapsed time: 21.115002 msecs&amp;quot;
Launching 12 -&amp;gt; &amp;quot;Elapsed time: 21.192993 msecs&amp;quot;
Launching 13 -&amp;gt; &amp;quot;Elapsed time: 21.113135 msecs&amp;quot;
Launching 14 -&amp;gt; &amp;quot;Elapsed time: 21.376159 msecs&amp;quot;
Launching 15 -&amp;gt; &amp;quot;Elapsed time: 20.754207 msecs&amp;quot;
Launching 16 -&amp;gt; &amp;quot;Elapsed time: 20.654873 msecs&amp;quot;
Launching 17 -&amp;gt; &amp;quot;Elapsed time: 31.084513 msecs&amp;quot;
Launching 18 -&amp;gt; &amp;quot;Elapsed time: 31.152651 msecs&amp;quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ignoring the minor fluctuations in measurements, there's a very clear pattern
here; let's plot it:&lt;/p&gt;
&lt;img alt="Runtime of launching go-blocks with sleeps" class="align-center" src="https://eli.thegreenplace.net/images/2017/go-block-sleep-runtime.png" /&gt;
&lt;p&gt;The reason for this behavior is the blocking nature of &lt;tt class="docutils literal"&gt;Thread/sleep&lt;/tt&gt;. This
function blocks the &lt;em&gt;current thread&lt;/em&gt; for the specified duration (10 ms in our
case); so the go-block executing it will block the thread it's currently running
on. This thread is then effectively out of the pool until the sleep finishes.
The plot immediately suggests the pool size is 8; as long as 8 or fewer
go-blocks are launched, they all finish within ~10 ms because they all run
concurrently. As soon as we go above 8, the runtime jumps to ~20 ms because one
of the go-blocks will have to wait until there's a free thread in the pool.&lt;/p&gt;
&lt;p&gt;Let's try the same experiment using &lt;tt class="docutils literal"&gt;thread&lt;/tt&gt; instead of &lt;tt class="docutils literal"&gt;go&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;launch-n-threads&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/thread&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Thread/sleep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, each time through the loop &lt;em&gt;a new thread&lt;/em&gt; is launched, regardless of the
number of threads already executing &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. All these threads can run
concurrently, so the runtime plot is:&lt;/p&gt;
&lt;img alt="Runtime of launching threads with sleeps" class="align-center" src="https://eli.thegreenplace.net/images/2017/thread-sleep-runtime.png" /&gt;
&lt;p&gt;The Clojure documentation and talks / presentations by developers are careful to
warn against running blocking operations in go-blocks &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;; it's also not hard
to understand why this is so by thinking a bit about the fixed thread-pool based
implementation. That said, it's still useful to actually see this in action
using an easy-to-understand experiment. In the next section we'll explore the
real-life performance implications of blocking inside go-blocks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="blocking-i-o"&gt;
&lt;h2&gt;Blocking I/O&lt;/h2&gt;
&lt;p&gt;The sleeping example shown earlier is artificial, but the perils of blocking
inside go-blocks are real. Blocking happens quite often in realistic programs,
most often in the context of I/O. I/O devices tend to be significantly slower
than the CPU executing our program, especially if by &amp;quot;I/O device&amp;quot; we mean a web
server located half-way across the world to which we issue an HTTP request.&lt;/p&gt;
&lt;p&gt;So the next example is going to be a simple concurrent HTTP client; again, two
versions are studied and compared - one with go-blocks, another with threads.
For this sample, we'll be using the &lt;a class="reference external" href="https://github.com/dakrone/clj-http"&gt;clj-http&lt;/a&gt; library &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;, which provides a simple
API to issue blocking HTTP requests. The full code is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/clojure-blocking-async/src/clojure_blocking_async/http_client.clj"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;url-template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;https://github.com/eliben/pycparser/pull/%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;blocking-get-page&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clj-http.client/get&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;url-template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;go-blocking-generator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;doseq &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;blocking-get-page&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-blocking-generator&lt;/span&gt;&lt;/tt&gt; is called, it launches &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; go-blocks, each
requesting a different page from &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser's&lt;/a&gt; pull requests on GitHub. Fetching one
page takes between 760 and 990 ms on my machine, depending on the exact page.
When run with &lt;tt class="docutils literal"&gt;n=20&lt;/tt&gt;, this version takes about 2300 ms. Now let's do the same
with threads:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;thread-blocking-generator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;doseq &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;blocking-get-page&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;n=20&lt;/tt&gt;, this version takes only 1000 ms. As expected, all threads
manage to run at the same time, which is mostly spent waiting on the remote
server. In the go-blocks version, only 8 blocks run concurrently because of the
thread pool size; this example should really drive home the notion of just how
bad blocking I/O in go-blocks is. Most of the blocks sit there waiting for the
thread pool to have a vacant spot, when all they have to do is just issue a HTTP
request and wait anyway.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="parallelizing-cpu-bound-tasks"&gt;
&lt;h2&gt;Parallelizing CPU-bound tasks&lt;/h2&gt;
&lt;p&gt;We've seen how go-blocks interact with blocking operations; now let's examine
CPU-bound tasks, which spend their time doing actual computations on the CPU
rather than waiting for I/O. In an older post, I explored the effects of using
threads and processes &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/01/16/python-parallelizing-cpu-bound-tasks-with-multiprocessing"&gt;in Python to parallelize a simple numeric problem&lt;/a&gt;.
Here I'll be using a similar example: naÃ¯vely factorizing a large integer.&lt;/p&gt;
&lt;p&gt;Here's the function that factorizes a number into a vector of factors:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Naive factorization function; takes an integer n and returns a vector of&lt;/span&gt;
&lt;span class="s"&gt;  factors.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;mod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;quot &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It takes around 2.3 ms to factorize the number 29 * 982451653; I'll refer to it
as &lt;tt class="docutils literal"&gt;mynum&lt;/tt&gt; from now on &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;. Let's examine a few strategies of factorizing a
large set of numbers in parallel. We'll start with a simple &amp;quot;serial&amp;quot; factorizer,
which should also introduce the API:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;serial-factorizer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Simple serial factorizer.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zipmap &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each factorizer function in this sample takes a sequence of numbers and returns
a new map, which maps a number to its vector of factors. If we run
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;serial-factorizer&lt;/span&gt;&lt;/tt&gt; on a sequence of 1000 &lt;tt class="docutils literal"&gt;mynum&lt;/tt&gt;s, it takes ~2.3 seconds;
no surprises here!&lt;/p&gt;
&lt;p&gt;Now, a parallel factorizer using go-blocks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;async-go-factorizer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parallel factorizer for nums, launching n go blocks.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;;;; Push nums into an input channel; spin up n go-blocks to read from this&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;;;; channel and add numbers to an output channel.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go-loop&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n-maps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a pattern that should be familiar by now, this function creates a couple of
local channels and spins up a number of go-blocks to read and write from these
channels; the code should be self-explanatory. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;receive-n-maps&lt;/span&gt;&lt;/tt&gt; is similar to
the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;receive-n&lt;/span&gt;&lt;/tt&gt; function we've seen earlier in the article, just with maps
instead of vectors.&lt;/p&gt;
&lt;p&gt;Knowing that my machine has 8 CPU threads (4 cores, hyper-threaded), I
benchmarked &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;async-go-factorizer&lt;/span&gt;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;n=8&lt;/tt&gt;, and it took around 680 ms, a
3.4x speedup over the serial version &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's try the same with threads instead of go-blocks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;async-thread-factorizer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Same as async-go-factorizer, but with thread instead of go.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/thread&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n-maps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The performance is pretty much the same - 680 ms for 1000 numbers with
parallelism of &lt;tt class="docutils literal"&gt;n=8&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;This is an important point! On purely CPU-bound workloads, go-blocks are no
worse than threads because all the physical cores are kept busy doing useful
work at all time. There's no waiting involved, so there's no opportunity to
steal an idle core for a different thread. One minor gotcha is to be wary of
the go-block thread pool size; if you run your program on a dual socket machine
with dozens of cores, you may want to bump that number up and use a wider
parallelism setting.&lt;/p&gt;
&lt;p&gt;For completeness (and fun!) let's try a couple more methods of parallelizing
this computation. The pattern in these parallel factorizers is so common that
&lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; has a function for it - &lt;tt class="docutils literal"&gt;pipeline&lt;/tt&gt;; here's how we use it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;async-with-pipeline&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parallel factorizer using async/pipeline.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/pipeline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-map &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n-maps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;async/pipeline&lt;/tt&gt; takes an input channel, output channel and a transducer, as
well as the parallelism. It takes care of spinning go-blocks and connecting all
the channels properly &lt;a class="footnote-reference" href="#footnote-7" id="footnote-reference-7"&gt;[7]&lt;/a&gt;. This takes about the same amount of time as the
other versions shown earlier, which isn't surprising.&lt;/p&gt;
&lt;p&gt;Finally, let's try something slightly different and use Clojure's parallel
&lt;tt class="docutils literal"&gt;fold&lt;/tt&gt; from the &lt;tt class="docutils literal"&gt;clojure.core.reducers&lt;/tt&gt; library (both &lt;tt class="docutils literal"&gt;fold&lt;/tt&gt; and
transducers are described in &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/reducers-transducers-and-coreasync-in-clojure/"&gt;my earlier article&lt;/a&gt;
- check it out!)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;conjmap&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;xs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;xs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;rfold&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parallel factorizer using r/fold.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;r/fold&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;conjmap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;r/map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-map &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we don't have to set the parallelism; &lt;tt class="docutils literal"&gt;r/fold&lt;/tt&gt; determines it on its own.
This approach takes 1.15 seconds on 1000 numbers, quite a bit slower than the
earlier attempts. It's entirely possible that the fork-join approach used by
&lt;tt class="docutils literal"&gt;r/fold&lt;/tt&gt; is less efficient than the manual chunking to different threads done
by the other versions.&lt;/p&gt;
&lt;p&gt;The conclusion from this section, however, should be that for purely CPU-bound
tasks it doesn't matter much whether go-blocks or explicit threads are used -
the performance should be more-or-less the same. That said, realistic programs
don't often spend time purely in CPU-bound tasks; the reality is usually
somewhere in between - some tasks do computations, other tasks wait on things.
Let's see a benchmark that combines the two.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="combining-blocking-and-cpu-bound-tasks"&gt;
&lt;h2&gt;Combining blocking and CPU-bound tasks&lt;/h2&gt;
&lt;p&gt;This section shows an artificial benchmark that explores how a combination of
blocking and CPU-bound tasks behaves when launched on go-blocs vs. threads. The
CPU bound task will be the same factorization but this time with a larger number
that was carefully tuned to take about 230 ms to factorize on my machine. The
blocking &amp;quot;task&amp;quot; will be &lt;tt class="docutils literal"&gt;(Thread/sleep 250)&lt;/tt&gt;. I deliberately choose the same
duration for the two kinds of tasks here to make comparisons easier, but the
principle applies more generally.&lt;/p&gt;
&lt;p&gt;Here is the go-block version of the benchmark:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;launch-go-blocking-and-compute&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nblock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ncompute&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nblock&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Thread/sleep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;250&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ncompute&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;mynum&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nblock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ncompute&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;nblock&lt;/tt&gt; is the number of blocking tasks to launch; &lt;tt class="docutils literal"&gt;ncompute&lt;/tt&gt; is the number
of CPU-bound tasks to launch. The rest of the code is straightforward. You can
guess what the threading version looks like by now - check out the &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/clojure-blocking-async/src/clojure_blocking_async/combine_cpubound_blocking.clj"&gt;full code
sample&lt;/a&gt;
if not.&lt;/p&gt;
&lt;p&gt;The parameter space here is pretty large; let's try 32 blocking and 16 compute
tasks in parallel:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nblock=32, ncompute=16

launch-go-blocking-and-compute: 1521 ms
launch-thread-blocking-and-compute: 530 ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The larger we set &lt;tt class="docutils literal"&gt;nblock&lt;/tt&gt;, the worse the situation becomes for the go-block
version:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nblock=64, ncompute=16

launch-go-blocking-and-compute: 3200 ms
launch-thread-blocking-and-compute: 530 ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Up to some limit, the threading version is only limited by &lt;tt class="docutils literal"&gt;ncompute&lt;/tt&gt;, since
these actually occupy the CPU cores; all the blocking tasks are run in the
background and can complete at the same time (after the initial 250 ms).&lt;/p&gt;
&lt;p&gt;The go-block version fares much worse, because the blocking tasks can occupy
threads while the compute tasks just wait in a queue. Depending on the exact
mixture of blocking and compute-bound tasks, this can range from more-or-less
the same to &lt;em&gt;exteremely&lt;/em&gt; bad for the go-blocks version. YMMV!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="managing-callback-hell-with-go-blocks"&gt;
&lt;h2&gt;Managing callback-hell with go-blocks&lt;/h2&gt;
&lt;p&gt;We've seen the issues that come up when mixing blocking I/o with go-blocks. The
reason for this is the cooperative concurrency approach implemented by go-blocks
on top of a fixed thread pool. For cooperative concurrency to work well with
I/O, the language should either make the scheduler aware of the I/O calls (to be
able to switch to another context while blocking) or the I/O should be
non-blocking. The former requires runtime support in the language, like Go; the
latter is what programming environments like Python (with &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt;) and
Node.js (with its fully non-blocking standard library) do. The same applies to
Clojure, where &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; is just a library without actual runtime support.&lt;/p&gt;
&lt;p&gt;The good news is that non-blocking I/O libraries are very popular these days,
and Clojure has a good number of them for all the common tasks you can think of.
Another good news is that &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;'s channels make it very easy to deal
with non-blocking I/O without sliding into &lt;a class="reference external" href="http://callbackhell.com/"&gt;callback hell&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's a code sample that uses the asynchronous mode of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clj-http&lt;/span&gt;&lt;/tt&gt; to repeat
the concurrent HTTP request benchmark:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;go-async-generator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;doseq &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clj-http.client/get&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;url-template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:async?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;response&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;response&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;;; Exception callback.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;exc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;throw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;exc&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When passed the &lt;tt class="docutils literal"&gt;{:async? true}&lt;/tt&gt; option, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clj-http.client/get&lt;/span&gt;&lt;/tt&gt; does a
non-blocking request with a callback for the response (and another callback for
an error). Our &amp;quot;response callback&amp;quot; simply spins a go-block that places the
response into a channel. Now another go-block (or thread) can wait on the
channel to perform the next step; compare that to cascading callbacks!&lt;/p&gt;
&lt;p&gt;The performance is good too - when run with multiple requests in parallel, this
version runs as fast as the thread-launching example from earlier in the article
(the full code &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/clojure-blocking-async/src/clojure_blocking_async/http_client_async.clj"&gt;is here&lt;/a&gt;).
All the &lt;tt class="docutils literal"&gt;get&lt;/tt&gt; requests are launched one after another, with no blocking. When
the results arrive, go-blocks patiently &amp;quot;park&amp;quot; while sending them into a
channel, but this is an explicit context-switch operation, so all of them
peacefully run concurrently on the underlying thread pool.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Would launching a thread inside the callback work as well in the last example?
Yes, I think it would. So why use go-blocks?&lt;/p&gt;
&lt;p&gt;The reason is scalability. Launching threads is fine as long as you don't have
too many, and as long as the latency of the launch is not too important. Threads
are OS constructs and have fairly heavy resource requirements - in terms of
memory consumption and context-switching time. go-blocks are extremely
lightweight in comparison.&lt;/p&gt;
&lt;p&gt;Therefore, if you want to serve 1000s of connections concurrently from a single
machine - go-blocks are the way to go, combined with non-blocking APIs. Note
that go-blocks use a thread pool that can use multipe cores, so this isn't just
a single-core concurrent multitasking solution (such as you may encounter in
Node.js or Python's &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;If the number of concurrent tasks is not too large or blocking I/O is involved,
I'd recommend using &lt;tt class="docutils literal"&gt;async/thread&lt;/tt&gt;. It avoids the pitfalls of blocking I/O,
and in other cases performance is the same. &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;'s wonderful tools
like channels and &lt;tt class="docutils literal"&gt;alts!!&lt;/tt&gt; are still available, making concurrent programming
much more pleasant.&lt;/p&gt;
&lt;p&gt;However, note that Clojure is a multi-environment language, and in some
environments (most notably ClojureScript), threads are simply unavailable. In
these cases using go-blocks is your only chance at any kind of reasonable
concurrency (the alternative being callbacks).&lt;/p&gt;
&lt;p&gt;Another use case for go-blocks is to implement coroutines which can be useful in
some cases - such as agents in games, as a &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines"&gt;replacement for complex state
machines&lt;/a&gt;,
etc. But here again, beware of the actual scale. If it's possible to use
threads, just use threads. go-blocks are trickier to use correctly and one has
to be always aware of what may block, lest performance is dramatically degraded.&lt;/p&gt;
&lt;p&gt;If there's something I'm missing, please let me know!&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is for the standard JVM implementation of Clojure; in ClojureScript
there would just be a single thread, since JS doesn't support in-browser
threads (yet).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The JVM also has some limit on the number of threads it runs at the same
time, but it's fairly high so we'll ignore it here.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;W.r.t. transgressions committed in the code sample show here,
&lt;tt class="docutils literal"&gt;Thread/sleep&lt;/tt&gt; is a big no-no inside go-blocks. By now I hope that it's
obvious why. &lt;tt class="docutils literal"&gt;timeout&lt;/tt&gt; is the right function for &amp;quot;waiting&amp;quot; inside
go-blocks, since it &amp;quot;parks&amp;quot; the go-block rather than blocking it. Parking
is go-block friendly since it actually frees up the thread the go-block
is running on. Similarly, &lt;tt class="docutils literal"&gt;&amp;gt;!&lt;/tt&gt; is the right channel sending function to
use inside go-blocks; &lt;tt class="docutils literal"&gt;&amp;gt;!!&lt;/tt&gt; blocks the whole thread.&lt;/p&gt;
&lt;p class="last"&gt;This is also a good place to mention that similar thread pool size
&amp;quot;artifacts&amp;quot; &lt;a class="reference external" href="https://www.future-processing.pl/blog/on-problems-with-threads-in-node-js/"&gt;can be found in Node.js&lt;/a&gt;,
which uses &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt; to handle events. &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt; uses its own thread pool
to execute blocking calls, thus giving the calling application a sense of
concurrency (up to some thread pool size).&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This sample is inspired by &lt;a class="reference external" href="http://martintrojer.github.io/clojure/2013/07/07/coreasync-and-blocking-io"&gt;Martin Trojer's blog post&lt;/a&gt;,
which is the best introduction to the issues with blocking I/O in
go-blocks I found before starting this article.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Why this particular number? The second factor is a large-ish prime, so it
will make the factorizer sweat a bit (by iterating over all the odd numbers
up to its square root); the multiplication by another (prime) factor
ensures more of the paths in the &lt;tt class="docutils literal"&gt;factorize&lt;/tt&gt; function are exercised.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Benchmarking multi-core CPU performance with modern CPUs is notoriously
tricky; CPUs regulate their frequency based on load, so it's entirely
possible that a single core runs faster than each one core in a group of
4; also, hyper-threading reuses some CPU resources within each core so
its speedup is rarely linear.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that &lt;tt class="docutils literal"&gt;pipeline&lt;/tt&gt; spins up go-blocks by default, so the cautions
explored in this article apply. There's also &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pipeline-blocking&lt;/span&gt;&lt;/tt&gt; if you
need blocking operations. Looking at the &lt;a class="reference external" href="https://github.com/clojure/core.async/blob/2afc2dc5102f60713135ffca6fab993fb35809f0/src/main/clojure/clojure/core/async.clj#L475"&gt;implementation if pipeline&lt;/a&gt;
is actually pretty illuminating, and should be easy to understand given
what we discuss here.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category><category term="Programming"></category><category term="Concurrency"></category></entry><entry><title>Notes on debugging Clojure code</title><link href="https://eli.thegreenplace.net/2017/notes-on-debugging-clojure-code/" rel="alternate"></link><published>2017-05-23T20:02:00-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-05-23:/2017/notes-on-debugging-clojure-code/</id><summary type="html">&lt;p&gt;Clojure is a great programming language, but a recurring complaint one keeps
hearing from developers hacking on Clojure code is that debugging can be
unpleasant. First of all, I agree! Debugging Clojure code &lt;em&gt;can&lt;/em&gt; be more daunting
on average than, say, debugging Python code. This is mainly due to two â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;Clojure is a great programming language, but a recurring complaint one keeps
hearing from developers hacking on Clojure code is that debugging can be
unpleasant. First of all, I agree! Debugging Clojure code &lt;em&gt;can&lt;/em&gt; be more daunting
on average than, say, debugging Python code. This is mainly due to two reasons:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Clojure's Java legacy. Clojure is compiled to Java bytecode, which has some
terminology and idiosyncracies Clojure programmers aren't always familiar
with. These terms tend to pop up in stack traces and cause confusion (e.g.
&lt;tt class="docutils literal"&gt;IFN&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;Clojure - being a Lisp - has a certain code structure which is different
from, say, a more common imperative coding style. Rather than being a
sequence of statements, Clojure programs tend to involve long call chains of
nested expressions. Where only part of an expression fails, it's often
non-trivial to figure out why.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this post I want to share some notes from my own experience debugging Clojure
programs.&lt;/p&gt;
&lt;div class="section" id="dealing-with-clojure-s-cryptic-exceptions"&gt;
&lt;h2&gt;Dealing with Clojure's cryptic exceptions&lt;/h2&gt;
&lt;p&gt;The first problem with Clojure's runtime exceptions is that we usually don't get
to see the full stack trace &lt;em&gt;by default&lt;/em&gt;. Let's say we have this silly,
nonsensical, function in a file called &lt;tt class="docutils literal"&gt;sample.clj&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then to try how it works, we load the file into the REPL and type the following
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (foo 24)
IllegalArgumentException Don&amp;#39;t know how to create ISeq from: java.lang.Long
  clojure.lang.RT.seqFrom (RT.java:542)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Uh oh. There are two problems here. First, what does this error message mean?
What's &lt;tt class="docutils literal"&gt;ISeq&lt;/tt&gt; and what's &lt;tt class="docutils literal"&gt;java.lang.Long&lt;/tt&gt;? Second, it's not clear where it
is actually failing (thanks for that pointer to &lt;tt class="docutils literal"&gt;RT.java&lt;/tt&gt; though, Clojure!)
Let's address the second problem first. The magic incantation to show the stack
trace of the last exception is calling the &lt;tt class="docutils literal"&gt;pst&lt;/tt&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (pst)
IllegalArgumentException Don&amp;#39;t know how to create ISeq from: java.lang.Long
  clojure.lang.RT.seqFrom (RT.java:542)
  clojure.lang.RT.seq (RT.java:523)
  clojure.lang.RT.first (RT.java:668)
  clojure.core/first--4339 (core.clj:55)
  clojure.core/first--4339 (core.clj:55)
  debugging.sample/foo (sample.clj:10)
  debugging.sample/foo (sample.clj:7)
  debugging.core/eval13715 (form-init6539101589609174055.clj:1)
  debugging.core/eval13715 (form-init6539101589609174055.clj:1)
  clojure.lang.Compiler.eval (Compiler.java:6927)
  clojure.lang.Compiler.eval (Compiler.java:6890)
  clojure.core/eval (core.clj:3105)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is much better because at least &lt;em&gt;some&lt;/em&gt; files in this trace are familiar.
&lt;tt class="docutils literal"&gt;core.clj&lt;/tt&gt; is not &lt;em&gt;our&lt;/em&gt; &lt;tt class="docutils literal"&gt;core.clj&lt;/tt&gt;, it's Clojure's core library. But
&lt;tt class="docutils literal"&gt;sample.clj&lt;/tt&gt; &lt;em&gt;is&lt;/em&gt; our file, and we can infer that on line 10 we call
&lt;tt class="docutils literal"&gt;clojure,core/first&lt;/tt&gt; and something goes wrong. Line 10 happens to be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now things become more clear. The call &lt;tt class="docutils literal"&gt;(first n)&lt;/tt&gt; must be bad, and bad in
a way that tries to coerce clojure into creating an &lt;tt class="docutils literal"&gt;ISeq&lt;/tt&gt; from a &lt;tt class="docutils literal"&gt;Long&lt;/tt&gt;.
In other words, we're passing a number into a function that expects a sequence,
and this is, indeed, bad. Learning to map from Clojure values and types to the
JVM's expectations will take time and grit - especially if you (like me) don't
have much Java experience. I suggest doing a bit of reading on Clojure/Java
interoperability, and about other Java-isms Clojure inherits; it ain't pretty,
and you may not always want to use it, but being familiar with the terms can go
a long way in deciphering cryptic stack traces.&lt;/p&gt;
&lt;p&gt;For a more detailed treatment of this debugging issue I highly recommend
&lt;a class="reference external" href="https://aphyr.com/posts/319-clojure-from-the-ground-up-debugging"&gt;Aphyr's article on debugging Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="finding-which-form-an-exception-comes-from"&gt;
&lt;h2&gt;Finding which form an exception comes from&lt;/h2&gt;
&lt;p&gt;Let's invoke the &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; function in a different way that demonstrates another
issue with debugging Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (foo nil)

NullPointerException   clojure.lang.Numbers.ops (Numbers.java:1013)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK, we know what to do next:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (pst)
NullPointerException
  clojure.lang.Numbers.ops (Numbers.java:1013)
  clojure.lang.Numbers.gt (Numbers.java:229)
  clojure.lang.Numbers.gt (Numbers.java:3864)
  debugging.sample/foo (sample.clj:9)
  debugging.sample/foo (sample.clj:7)
  debugging.core/eval14693 (form-init6539101589609174055.clj:1)
  debugging.core/eval14693 (form-init6539101589609174055.clj:1)
  clojure.lang.Compiler.eval (Compiler.java:6927)
  clojure.lang.Compiler.eval (Compiler.java:6890)
  clojure.core/eval (core.clj:3105)
  clojure.core/eval (core.clj:3101)
  clojure.main/repl/read-eval-print--7408/fn--7411 (main.clj:240)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the exception comes from line 9, which is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This exception also tells us it comes from &lt;tt class="docutils literal"&gt;clojure.lang.Numbers.gt&lt;/tt&gt; from
which we can infer it's the &lt;tt class="docutils literal"&gt;&amp;gt;&lt;/tt&gt; operator that is complaining. But imagine for
a second that we had two forms with the same operator on that line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we got a &lt;tt class="docutils literal"&gt;NullPointerException&lt;/tt&gt; about an addition, we wouldn't know which
one fails. Luckily, Clojure comes with a very useful module that helps
debugging - &lt;a class="reference external" href="https://github.com/clojure/tools.trace"&gt;tools.trace&lt;/a&gt;. In this
particular case, we'd use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt; macro  which tells us which
nested form (expression) is failing. We can modify our function to be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;trace-forms&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now when called with &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;, we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (foo nil)
NullPointerException : No message attached to throwable java.lang.NullPointerException
  Form failed: (&amp;gt; n 40)
  Form failed: (if
 (&amp;gt; n 40)
 (+ n 20)
 (clojure.core/cond (&amp;gt; n 20) (- (first n) 20) :else 0))
  Form failed: (cond (&amp;gt; n 40) (+ n 20) (&amp;gt; n 20) (- (first n) 20) :else 0)
  clojure.lang.Numbers.ops (Numbers.java:1013)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat, huh? &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt; breaks the form it traces to all the nested forms
and reports precisely which one failed - propagating this information upwards
towards the top form &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt; is &lt;em&gt;very&lt;/em&gt; useful when errors manifest
as exceptions.&lt;/p&gt;
&lt;p&gt;Unfortunately, this isn't sufficient for all cases. Our &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; wasn't designed
to handle &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;s, and the bug here is in the place where the &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; came
from. This may be quite a bit removed - and not on the same stack trace - from
where &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is invoked. We'll get an exception when &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is called, but the
&lt;em&gt;real&lt;/em&gt; challenge is to find where the &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; came from. More generally, bugs
that manifest as thrown exceptions are the easier kind of bugs. The more
insidious bugs hide in programs that run just fine end-to-end but compute
slightly incorrect results.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tracing-and-logging"&gt;
&lt;h2&gt;Tracing and logging&lt;/h2&gt;
&lt;p&gt;This gets us into the more general domain of debugging, where the tricks and
tools programmers use are as varied as the bugs hiding in our programs. When it
comes to debugging, I'm firmly in the &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; camp; I rarely prefer debuggers
over &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt;-based debugging &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;, and Clojure is no exception. In fact, due
to the way Clojure programs look (nested forms), I find that debuggers are even
less useful in Clojure than in other languages. On the other hand, Clojure's
macros make it possible to trace / print stuff in a very nice way.&lt;/p&gt;
&lt;p&gt;For example, I find that it's useful to be able to turn debugging printouts on
and off frequently. So I have this trusty code in my utilities:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="ss"&gt;:dynamic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;*verbose*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;printfv&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;fmt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;*verbose*&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;fmt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="nv"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Calls to &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt; can be freely scattered around the code; by default,
they will not print anything. When I do want to see what these &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt;s
have to say, another macro comes useful:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;with-verbose&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;binding &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;*verbose*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's how it works; Suppose we've written this factorial function, with a
debugging printout:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;printfv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;factorial: %d%n&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, if we just call it as usual from the REPL, we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (factorial 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But if we want to actually see the debugging output, we call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (with-verbose (factorial 6))
factorial: 6
factorial: 5
factorial: 4
factorial: 3
factorial: 2
factorial: 1
factorial: 0
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This optional verbosity is perfect when you're in the middle of a furious bug
hunt, adding &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt;s in many places in your code. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;with-verbose&lt;/span&gt;&lt;/tt&gt; can
turn verbose logging on selectively and control the amount of debugging spew
&lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This example brings us back to the &lt;tt class="docutils literal"&gt;tools.trace&lt;/tt&gt; library, which provides
another awesome tool that helps trace function calls (the bread and butter of
Clojure programs). Enter &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-vars&lt;/span&gt;&lt;/tt&gt;. After importing it, all we need to do
is invoke it on any functions we want traced; for example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (trace-vars factorial)
#&amp;#39;debugging.core/factorial
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now invoking our &lt;tt class="docutils literal"&gt;factorial&lt;/tt&gt; produces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (factorial 6)
TRACE t16315: (debugging.core/factorial 6)
TRACE t16316: | (debugging.core/factorial 5)
TRACE t16317: | | (debugging.core/factorial 4)
TRACE t16318: | | | (debugging.core/factorial 3)
TRACE t16319: | | | | (debugging.core/factorial 2)
TRACE t16320: | | | | | (debugging.core/factorial 1)
TRACE t16321: | | | | | | (debugging.core/factorial 0)
TRACE t16321: | | | | | | =&amp;gt; 1
TRACE t16320: | | | | | =&amp;gt; 1
TRACE t16319: | | | | =&amp;gt; 2
TRACE t16318: | | | =&amp;gt; 6
TRACE t16317: | | =&amp;gt; 24
TRACE t16316: | =&amp;gt; 120
TRACE t16315: =&amp;gt; 720
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get to see the full call tree, including values of parameters and what each
call returns. It even works for mutually-recursive functions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;iseven?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;isodd?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;isodd?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;iseven?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's try it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (trace-vars iseven? isodd?)
#&amp;#39;debugging.core/isodd?
debugging.core=&amp;gt; (iseven? 7)
TRACE t16332: (debugging.core/iseven? 7)
TRACE t16333: | (debugging.core/isodd? 6)
TRACE t16334: | | (debugging.core/iseven? 5)
TRACE t16335: | | | (debugging.core/isodd? 4)
TRACE t16336: | | | | (debugging.core/iseven? 3)
TRACE t16337: | | | | | (debugging.core/isodd? 2)
TRACE t16338: | | | | | | (debugging.core/iseven? 1)
TRACE t16339: | | | | | | | (debugging.core/isodd? 0)
TRACE t16339: | | | | | | | =&amp;gt; false
TRACE t16338: | | | | | | =&amp;gt; false
TRACE t16337: | | | | | =&amp;gt; false
TRACE t16336: | | | | =&amp;gt; false
TRACE t16335: | | | =&amp;gt; false
TRACE t16334: | | =&amp;gt; false
TRACE t16333: | =&amp;gt; false
TRACE t16332: =&amp;gt; false
false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how easy it to see what calls what. Quite often, bugs are uncovered simply
by carefully studying the chain of function calls some input tickles in our
code, and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-vars&lt;/span&gt;&lt;/tt&gt; is a very low-effort method to enable this kind of
debugging.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="deeper-tracing-inside-cond-forms"&gt;
&lt;h2&gt;Deeper tracing inside &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; forms&lt;/h2&gt;
&lt;p&gt;Tracing function calls is great, but sometimes insufficient. It's not uncommon
to have &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; forms in functions, and sometimes it's pretty hard to know
which condition was actually &amp;quot;taken&amp;quot; (this isn't always easy to infer from the
return value of the function). We've seen how to explore where exceptions come
from with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt;, but exceptions are just one kind of problem. The more
difficul problem arises when the code throws no exceptions but still produces a
wrong value.&lt;/p&gt;
&lt;p&gt;I've mentioned how Clojure's macro superpowers let us write very powerful
debugging tools. What follows is another example.&lt;/p&gt;
&lt;p&gt;Consider this toy code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It happens to return 10 since the second condition fires. But suppose it stands
for a much more complicated &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; where it's not obvious which condition was
taken and where the return value came from. How do we go about debugging this?&lt;/p&gt;
&lt;p&gt;Well, we can always add a &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt; into every result expression (possibly
wrapping in a &lt;tt class="docutils literal"&gt;do&lt;/tt&gt; form) and see what fires. This would work, but it's quite
tiresome, especially for large &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt;s. To do this automatically, we can
write the following macro:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;condv&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;if&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;next &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condv &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;second &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;throw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;IllegalArgumentException.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cond requires an even number of forms&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;condv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;next &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;next &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It behaves just like &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt;, while also printing out the condition that fired.
If we replace the &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; in the original example with &lt;tt class="docutils literal"&gt;condv&lt;/tt&gt; and evaluate
it, we'll get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (condv (&amp;gt; 10 20) (+ 10 20)
            #_=&amp;gt;        (&amp;gt; 20 10) (- 20 10)
            #_=&amp;gt;        :else 200)
condv (&amp;gt; 20 10)
10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the printout before the return value of 10: &lt;tt class="docutils literal"&gt;condv (&amp;gt; 20 10)&lt;/tt&gt; - it shows
us exactly which condition was taken.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;While beginning Clojure programmers may find the debugging experience
challenging, I believe that with some effort and perseverance it's possible to
get used to the unusual environment and even reach new levels of productivity
by developing a set of debugging tools and techniques.&lt;/p&gt;
&lt;p&gt;In this endeavor, Clojure's macro capabilities are an extremely powerful ally.
Coupled with a fast edit-rerun cycle in the REPL, such tools can turn Clojure
debugging into a much less painful activity.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Alternatively, we can evaluate the same expression somewhere in our
editor using a Clojure plugin (such as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;vim-fireplace&lt;/span&gt;&lt;/tt&gt; for Vim).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The astute reader will notice a slight discrepancy between our code and
the output of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-form&lt;/span&gt;&lt;/tt&gt;. We don't have an &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; form, or do we?
Quiz: what does &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; expand to? Complex interactions between macros
and functions is yet another reason debugging Clojure code is sometimes
hard...&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In my professional life I spent far more time writing debuggers than
actually using them.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This method is only recommended when the debugging prinouts are destined
to be eventually eliminated from the code. For more permanent logging
with more verbosity controls, consider using a proper logging library
like &lt;a class="reference external" href="https://github.com/clojure/tools.logging"&gt;tools.logging&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category></entry><entry><title>Book review: "Essentials of Programming Languages" by D. Friedman and M. Wand</title><link href="https://eli.thegreenplace.net/2017/book-review-essentials-of-programming-languages-by-d-friedman-and-m-wand/" rel="alternate"></link><published>2017-05-08T05:28:00-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-05-08:/2017/book-review-essentials-of-programming-languages-by-d-friedman-and-m-wand/</id><summary type="html">&lt;p&gt;[Note: this review is about the 3rd edition of the book]&lt;/p&gt;
&lt;p&gt;This book is a detailed overview of some fundamental ideas in the design of
programming languages. It teaches by presenting toy languages that demonstrate
these ideas, with a full interpreter for every language (implemented in
Scheme). After discussing some â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;[Note: this review is about the 3rd edition of the book]&lt;/p&gt;
&lt;p&gt;This book is a detailed overview of some fundamental ideas in the design of
programming languages. It teaches by presenting toy languages that demonstrate
these ideas, with a full interpreter for every language (implemented in
Scheme). After discussing some basic concepts like scoping, it gets into the
ways state can exist in a language; then a whole chapter deals with
continuation-passing style. This chapter also describes exceptions, coroutines
and threads (all implemented with continuations). Other chapters discuss module
systems and object-oriented programming.&lt;/p&gt;
&lt;p&gt;The book was created as a companion/summary of a university course. When read
stand-alone, it's not very easy to get through due to the huge number of
concepts presented and discussed in fairly limited space (~350 pages). IMHO
the authors could spend more time explaining and demonstrating the concepts
before jumping into implementation - but maybe as a companion to lectures it's
not really necessary. This is definitely something to take into account if
you're just reading the book; it's not for beginners.&lt;/p&gt;
&lt;p&gt;I went through this book in a fairly detailed way (not quite like my &lt;a class="reference external" href="https://eli.thegreenplace.net/2008/04/18/sicp-conclusion"&gt;SICP
journey&lt;/a&gt;, but not
very far from it). It took me several months of spending a couple of hours a
week on it, and I wrote almost 10,000 lines of Clojure code implementing most of
the interpreters (and some of the exercises) described in it. Clojure was a good
choice. It's sufficiently similar to Scheme that the concepts translate without
too much trouble; on the other hand, it &lt;em&gt;is&lt;/em&gt; a different language so mindless
copy-pasting doesn't work. I ran out of steam somewhere in the middle of the
penultimate chapter (on Modules) and stopped implementing, since the concepts
of Modules and OOP seemed more familiar and less interesting.&lt;/p&gt;
&lt;p&gt;My favorite part was, no doubt, the chapter on continuations. It helped me
understand concepts like &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/on-recursion-continuations-and-trampolines/"&gt;CPS and trampolines&lt;/a&gt;
to a deeper extent than ever before. For this, I'm forever thankful to the
authors.&lt;/p&gt;
&lt;p&gt;It's hard to say how beneficial a lighter skimming of this book can be. Without
implementing the interpreters, the discussion is fairly weak. Implementing them
takes time and code in advanced chapters builds on top of more code in earlier
chapters.&lt;/p&gt;
</content><category term="misc"></category><category term="Book reviews"></category><category term="Programming"></category><category term="Lisp"></category></entry><entry><title>Common Lisp's consp and listp in Clojure</title><link href="https://eli.thegreenplace.net/2016/common-lisps-consp-and-listp-in-clojure/" rel="alternate"></link><published>2016-12-26T08:15:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-12-26:/2016/common-lisps-consp-and-listp-in-clojure/</id><summary type="html">&lt;p&gt;The list is a very central data structure in Common Lisp, especially when
looking at educational content (such as classic books). In Clojure, lists exist
and are used quite a bit, but their place is less central since their inherent
inefficiency compared to other data structures is acknowledged. This often â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;The list is a very central data structure in Common Lisp, especially when
looking at educational content (such as classic books). In Clojure, lists exist
and are used quite a bit, but their place is less central since their inherent
inefficiency compared to other data structures is acknowledged. This often
leaves us with a need to translate a lot of list-oriented idioms from Common
Lisp to equivalent Clojure code.&lt;/p&gt;
&lt;p&gt;When working with lists, Common Lisp often uses the predicates &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;; it turns out that neither of these has a direct equivalent in
Clojure, and we must think carefully when translating code using &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;.&lt;/p&gt;
&lt;img alt="cons cell list" class="align-center" src="https://eli.thegreenplace.net/images/2016/cons-cell-1-2.gif" /&gt;
&lt;p&gt;Throughout this post I assume cons cells are only used to construct proper
lists, such as &lt;tt class="docutils literal"&gt;(cons 'a (cons 'b nil))&lt;/tt&gt;. Other uses of &lt;tt class="docutils literal"&gt;cons&lt;/tt&gt; in Common
Lisp are fairly rare; this fact is acknowledged by the language specification.
For example, &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; returns true on a non-list cons cell, since it's assumed
that cons cells are used mostly for lists:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[6]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[7]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;listp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; predicate simply checks if its argument is a cons cell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[8]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[9]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="c1"&gt;;; list using cons&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[10]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;                         &lt;/span&gt;&lt;span class="c1"&gt;;; nicer way make the same list&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It will reject anything that's &lt;em&gt;not&lt;/em&gt; a cons cell, most notably symbols and
numbers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[12]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[13]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; also rejects &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;; but &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; is used to mean an &amp;quot;empty list&amp;quot; in
Common Lisp (it's equivalent to &lt;tt class="docutils literal"&gt;'()&lt;/tt&gt;), so &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; is not a convenient
function to use to check whether something &amp;quot;is a list&amp;quot;. That's what &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; is
for. &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; is simply an &lt;tt class="docutils literal"&gt;or&lt;/tt&gt; between the &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;null&lt;/tt&gt;
predicates:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[14]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[15]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;listp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[16]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[17]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;listp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As mentioned above, &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; simplistically accepts non-list cons cells as
lists as well, but that's rarely a problem in practice.&lt;/p&gt;
&lt;p&gt;Now, if you're reading some book or article that uses Common Lisp as its
demonstration language, there's a good chance calls to &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;
are nonchalantly scattered all over the code; the difference bewteen these two,
as we've just seen, is quite subtle, and authors use one or the other based on
the nature of the problem faced. For example if you see a &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, it's most
likely there because the author wants to explicitly reject empty lists.&lt;/p&gt;
&lt;p&gt;In Clojure, our first attempt would be to use &lt;tt class="docutils literal"&gt;seq&lt;/tt&gt;. It returns a truthy value
for sequences, and can be used within conditions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (if (seq (cons 1 (cons 2 nil))) &amp;#39;yes &amp;#39;no)
yes
cl-in-clj.core=&amp;gt; (if (seq &amp;#39;(1 2)) &amp;#39;yes &amp;#39;no)
yes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This appears to be a reasonable replacement for &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, until we try it with
a symbol:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (if (seq &amp;#39;foo) &amp;#39;yes &amp;#39;no)

IllegalArgumentException Don&amp;#39;t know how to create ISeq from: [...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oops, that's not good. We need a better way to detect lists that won't blow up
on us. An alternative is &lt;tt class="docutils literal"&gt;list?&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (list? &amp;#39;(1 2))
true
cl-in-clj.core=&amp;gt; (list? &amp;#39;foo)
false
cl-in-clj.core=&amp;gt; (list? &amp;#39;())
true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But wait, this returns &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;'()&lt;/tt&gt;; so it's more like an equivalent for
&lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; than for &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;. For &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, we'd need to make sure we return
&lt;tt class="docutils literal"&gt;false&lt;/tt&gt; for an empty list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (defn my-consp [obj] (and (list? obj) (not (empty? obj))))
#&amp;#39;cl-in-clj.core/my-consp
cl-in-clj.core=&amp;gt; (my-consp &amp;#39;(1 2))
true
cl-in-clj.core=&amp;gt; (my-consp &amp;#39;foo)
false
cl-in-clj.core=&amp;gt; (my-consp &amp;#39;())
false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I'm using &lt;tt class="docutils literal"&gt;(not (empty? &lt;span class="pre"&gt;...))&lt;/span&gt;&lt;/tt&gt; rather than the more idiomatic &lt;tt class="docutils literal"&gt;(seq
&lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;; this is on purpose. If the object is a sequence, &lt;tt class="docutils literal"&gt;seq&lt;/tt&gt; will return it
and that will be the value of the &lt;tt class="docutils literal"&gt;and&lt;/tt&gt;. Sometimes, I really only want a
boolean, so &lt;tt class="docutils literal"&gt;(not (empty? &lt;span class="pre"&gt;...))&lt;/span&gt;&lt;/tt&gt; is more accurate.&lt;/p&gt;
&lt;p&gt;There's another issue here, having to do with &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;. In Common Lisp, &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;
is just the empty list. In Clojure, they're different. The &lt;tt class="docutils literal"&gt;list?&lt;/tt&gt; defined
above will return &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;, unlike its Common Lisp counterpart. The
real solution to this in Clojure is to avoid using &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; to mean the empty
list; instead just use the empty list &lt;tt class="docutils literal"&gt;'()&lt;/tt&gt;. This means we have to be careful
when calling &lt;tt class="docutils literal"&gt;first&lt;/tt&gt; on an empty list, since it returns &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;While on the topic of &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;, Common Lisp's &lt;tt class="docutils literal"&gt;null&lt;/tt&gt; is true on the empty list
while Clojure's &lt;tt class="docutils literal"&gt;(nil? &lt;span class="pre"&gt;'())&lt;/span&gt;&lt;/tt&gt; is false. To approximate the behavior of
&lt;tt class="docutils literal"&gt;null&lt;/tt&gt;, we could do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (defn my-null [obj] (or (nil? obj) (empty? obj)))
#&amp;#39;cl-in-clj.core/my-null
cl-in-clj.core=&amp;gt; (my-null nil)
true
cl-in-clj.core=&amp;gt; (my-null &amp;#39;())
true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To conclude, if you need Common Lisp's &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;, use Clojure's &lt;tt class="docutils literal"&gt;list?&lt;/tt&gt; but be
aware of &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;s. It's best to avoid &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;s in Clojure list processing, but
this isn't always trivial since &lt;tt class="docutils literal"&gt;(first &lt;span class="pre"&gt;'())&lt;/span&gt;&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;If you need &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, you'll have to define something like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;my-consp&lt;/span&gt;&lt;/tt&gt;, unless
you are OK with an exception being thrown on symbols and numbers, in which case
&lt;tt class="docutils literal"&gt;seq&lt;/tt&gt; should do.&lt;/p&gt;
</content><category term="misc"></category><category term="Lisp"></category><category term="Clojure"></category></entry><entry><title>Some notes on the Y combinator</title><link href="https://eli.thegreenplace.net/2016/some-notes-on-the-y-combinator/" rel="alternate"></link><published>2016-11-28T05:25:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-11-28:/2016/some-notes-on-the-y-combinator/</id><summary type="html">&lt;p&gt;The goal of this post is to jot down a few notes about the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Fixed-point_combinator"&gt;Y combinator&lt;/a&gt;, explaining how it
works without getting too much into lambda-calculus theory. I'll be using
Clojure and Python as the demonstration languages.&lt;/p&gt;
&lt;p&gt;The idea is to build up intuition for the Y combinator from simple â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;The goal of this post is to jot down a few notes about the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Fixed-point_combinator"&gt;Y combinator&lt;/a&gt;, explaining how it
works without getting too much into lambda-calculus theory. I'll be using
Clojure and Python as the demonstration languages.&lt;/p&gt;
&lt;p&gt;The idea is to build up intuition for the Y combinator from simple examples in
a way that makes understanding it a sequences of small mental leaps rather than
one large one.&lt;/p&gt;
&lt;div class="section" id="recursion-with-named-functions"&gt;
&lt;h2&gt;Recursion with named functions&lt;/h2&gt;
&lt;p&gt;It wouldn't be a proper article about recursion if it didn't start with a
factorial. Here's a fairly run-of-the-mill implementation in Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;factorial-rec&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recursion is accomplished by invoking the function, by name, within itself.
Herein begins the thought experiment that will lead us to the Y combinator.
Imagine that we're using a language where functions have no names - they're all
anonymous. We can assign anonymous functions to symbols, but those symbols
aren't visible or usable from within the function's body.&lt;/p&gt;
&lt;p&gt;As an example of what I'm talking about, here is a non-recursive implementation
of factorial in Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;factorial-loop&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;answer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;answer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;answer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how this is defined: we assign an anonymous function (&lt;tt class="docutils literal"&gt;lambda&lt;/tt&gt; in
Lisp/Scheme/Python parlance, &lt;tt class="docutils literal"&gt;fn&lt;/tt&gt; in Clojure) to the symbol
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-loop&lt;/span&gt;&lt;/tt&gt;. This anonymous function computes the factorial of its
parameter, and we can call it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; (factorial-loop 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To emphasize that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-loop&lt;/span&gt;&lt;/tt&gt; is just a convenience symbol and plays no
role in the implementation, we can forego it for a slightly more convoluted
invocation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((fn [n]
              #_=&amp;gt;     (loop [i n answer 1]
              #_=&amp;gt;       (if (zero? i)
              #_=&amp;gt;         answer
              #_=&amp;gt;         (recur (- i 1) (* answer i))))) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No names in sight - we just invoke the anonymous function directly. But this
implementation of factorial isn't recursive, so we don't really &lt;em&gt;need&lt;/em&gt; to refer
to the function's name from within its body. What if we do want to use
recursion? This brings us back to the thought experiment.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="recursion-with-anonymous-functions"&gt;
&lt;h2&gt;Recursion with anonymous functions&lt;/h2&gt;
&lt;p&gt;It turns out this is absolutely possible by using some ingenuity and cranking
the abstraction level up one notch. In our original &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt;, at the
point where the function invokes itself all we need is an object that implements
factorial, right? In &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt; we're using the fact that the symbol
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt; is bound to such an object (by the nature of &lt;tt class="docutils literal"&gt;defn&lt;/tt&gt;). But
we can't rely on that in our thought experiment. How else can we get access to
such an object? Well, we can take it as a parameter... Here's how:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;factorial-maker&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can compute factorials as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((factorial-maker factorial-maker) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A few things to note:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; is not computing a factorial. It creates an (anonymous)
function that computes a factorial. It expects to be passed &lt;em&gt;itself&lt;/em&gt; as a
parameter.&lt;/li&gt;
&lt;li&gt;The expression &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-maker&lt;/span&gt; &lt;span class="pre"&gt;factorial-maker)&lt;/span&gt;&lt;/tt&gt; does precisely that. It
invokes &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; and passes it itself as a parameter. The result
of that is a function that computes a factorial, which we then apply to 6.&lt;/li&gt;
&lt;li&gt;The recursion inside the factorial is replaced by &lt;tt class="docutils literal"&gt;(self self)&lt;/tt&gt;; when the
function created by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-maker&lt;/span&gt; &lt;span class="pre"&gt;factorial-maker)&lt;/span&gt;&lt;/tt&gt; runs for the first
time, &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; is assigned to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;, so &lt;tt class="docutils literal"&gt;(self self)&lt;/tt&gt;
is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-maker&lt;/span&gt; factorial maker)&lt;/tt&gt;. This is equivalent to the first
call - recursion!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You may still feel uncomfortable about the &lt;tt class="docutils literal"&gt;def&lt;/tt&gt; and the name
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;. Aren't we just cheating? Nope, because we can do the same
expansion as we did with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-loop&lt;/span&gt;&lt;/tt&gt;; we don't need that &lt;tt class="docutils literal"&gt;def&lt;/tt&gt;. Here's
how it would look:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; (((fn [self]
              #_=&amp;gt;     (fn [n]
              #_=&amp;gt;       (if (zero? n)
              #_=&amp;gt;         1
              #_=&amp;gt;         (* n ((self self) (- n 1))))))
              #_=&amp;gt;   (fn [self]
              #_=&amp;gt;     (fn [n]
              #_=&amp;gt;       (if (zero? n)
              #_=&amp;gt;         1
              #_=&amp;gt;         (* n ((self self) (- n 1))))))) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pretty it is not... But hey, we've now implemented a recursive factorial
function, without a single name in sight. How cool is that?&lt;/p&gt;
&lt;p&gt;Understanding the example above is about 80% of the way to understanding the Y
combinator, so make sure to spend the time required to thoroughly grok how it
works. Tracing through the execution for 2-3 calls while drawing the
&amp;quot;environments&amp;quot; (call frames) in action helps a lot.&lt;/p&gt;
&lt;p&gt;To get a better feel of the direction we're taking, here's another recursive
function that's slightly more complex than the factorial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;tree-sum-rec&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil? &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;left &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-sum-rec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-sum-rec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given a binary tree represented as a list-of-lists with numbers for node deta,
this function computes the sum of all the nodes in the tree. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; (def t1 &amp;#39;(1 (2) (4 (3) (7))))
#&amp;#39;ycombinator.core/t1
ycombinator.core=&amp;gt; (tree-sum-rec t1)
17
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can rewrite it without using any symbol names within the function as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;tree-sum-maker&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil? &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;left &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And invoke it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((tree-sum-maker tree-sum-maker) t1)
17
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the similarities between &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-sum-maker&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;. They
are transformed very similarly to synthesize the unnamed from the
named-recursion variant. The recipe seems to be:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Instead of a function taking a parameter, create a function factory that
accepts itself as the &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; parameter, and returns the actual computation
function.&lt;/li&gt;
&lt;li&gt;In every place where we'd previously call ourselves, call &lt;tt class="docutils literal"&gt;(self self)&lt;/tt&gt;
instead.&lt;/li&gt;
&lt;li&gt;The initial invocation of &lt;tt class="docutils literal"&gt;(foo param)&lt;/tt&gt; is replaced by
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;((foo-maker&lt;/span&gt; &lt;span class="pre"&gt;foo-maker)&lt;/span&gt; param)&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="y-combinator-a-tool-for-making-anonymous-functions-recursive"&gt;
&lt;h2&gt;Y combinator - a tool for making anonymous functions recursive&lt;/h2&gt;
&lt;p&gt;Since there is a clear pattern here, we should be able to abstract it away and
provide some method that transforms a given named-recursive function into an
unnamed variant. This is precisely what the Y combinator does, though the nature
of the problem makes it somewhat obscure at first sight:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;Ycombinator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I'll explain how it works shortly, but first let's see how we use it. We have
to write our &lt;tt class="docutils literal"&gt;factorial&lt;/tt&gt; as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the superficial similarity to the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; version.
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt; also takes a function and returns the actual function
computing the factorial, though in this case I don't call the function parameter
&lt;tt class="docutils literal"&gt;self&lt;/tt&gt; (it's not &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; in the strict sense, as we'll soon see). We can
convert this function to a recursive computation of the factorial by invoking
the Y combinator on it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((Ycombinator factorial-rec*) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's easiest to understand how &lt;tt class="docutils literal"&gt;Ycombinator&lt;/tt&gt; does its magic by unraveling this
invocation step by step. Similarly to how we did earlier, we can get rid of the
&lt;tt class="docutils literal"&gt;Ycombinator&lt;/tt&gt; name and just apply the object it's defined to be directly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;factorial-rec*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As before, this does two things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Call the Y combinator (just a scary-looking anonymous function)
on &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Call the result of (1) on 6.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you look carefully at step 1, it invokes the following anonymous function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On itself, with &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; bound to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;. So what we get is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if we actually perform the call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;, passing it an anonymous function as &lt;tt class="docutils literal"&gt;recurse&lt;/tt&gt;
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt; returns a factorial-computing function. This is where
the first step ends. Invoking this factorial-computing function on 6 is the
second step.&lt;/p&gt;
&lt;p&gt;It should now be obvious what's going on. When the invocation with 6 happens and
the program gets to calling &lt;tt class="docutils literal"&gt;recurse&lt;/tt&gt;, it calls the parameter of
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt; as shown above. But we've already unwrapped this call before
- it... recurses into &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;, while propagating itself forward
so that the &lt;tt class="docutils literal"&gt;recurse&lt;/tt&gt; parameter is always bound properly. It's just the same
trick as was employed by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; earlier in the post.&lt;/p&gt;
&lt;p&gt;So, the Y combinator is the magic sauce that lets us take code like
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt; and convert it into code like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;. Here's
how we can implement an unnamed version of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-sum-rec&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;tree-sum-rec*&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil? &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;left &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And using it with the Y combinator:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((Ycombinator tree-sum-rec*) t1)
17
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is an alternative formulation of the Y combinator that can make it a bit
easier to understand. In this version I'm using named Clojure functions for
further simplification (since many folks find the syntax of anonymous functions
applied to other anonymous functions too cryptic):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;apply-to-self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;Ycombinator-alt&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply-to-self&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-y-combinator-in-python"&gt;
&lt;h2&gt;The Y combinator in Python&lt;/h2&gt;
&lt;p&gt;Finally, just to show that the Y combinator isn't something unique to the Lisp
family of languages, here's a Python implementation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ycombinator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; \
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))(&lt;/span&gt;
                        &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; \
                   &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; \
                     &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can invoke it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ycombinator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;720&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's no real difference between the Python and the Clojure versions. As long
as the language supports creating anonymous functions and treats them as
first-class citizens, all is good.&lt;/p&gt;
&lt;p&gt;It's even possible to create the Y combinator in C++. Static typing makes it
somewhat less elegant than in the more dynamic languages, but C++14's generic
lambdas help a lot. Take a look at &lt;a class="reference external" href="https://rosettacode.org/wiki/Y_combinator#C.2B.2B"&gt;Rosetta Code&lt;/a&gt; for an example.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;Incidentally, note that by starting with &lt;tt class="docutils literal"&gt;(Ycombinator &lt;span class="pre"&gt;factorial-rec*)&lt;/span&gt;&lt;/tt&gt;,
we now got to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-rec*&lt;/span&gt; (Ycombinator &lt;span class="pre"&gt;factorial-rec*))&lt;/span&gt;&lt;/tt&gt;. For
this reason, the Y combinator is a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Fixed-point_combinator"&gt;fixed-point combinator&lt;/a&gt;
in lambda calculus.&lt;/p&gt;
&lt;p&gt;There's another interesting thing to note here - the equivalence
mentioned above is imperfect. The call &lt;tt class="docutils literal"&gt;(Ycombinator &lt;span class="pre"&gt;factorial-rec*)&lt;/span&gt;&lt;/tt&gt;
results in a &lt;em&gt;delayed&lt;/em&gt; fixed point equivalence (the delay achieved by
means of wrapping the result in a &lt;tt class="docutils literal"&gt;fn&lt;/tt&gt;). This is because we're
using Clojure - an eagerly evaluated language. This version of the Y
combinator is called the &lt;em&gt;applicative-order&lt;/em&gt; Y combinator. Without the
delay, we'd get an infinite loop. In lazily evaluated languages, it's
possible to define the Y combinator somewhat more succinctly.&lt;/p&gt;
&lt;p class="last"&gt;All of this is very interesting, but I'm deliberately avoiding getting
too deep into lambda calculus and programming language theory in this
post; I may write more about it some time in the future.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Lisp"></category><category term="Clojure"></category><category term="Python"></category></entry><entry><title>EOPL define-datatype and cases in Clojure</title><link href="https://eli.thegreenplace.net/2016/eopl-define-datatype-and-cases-in-clojure/" rel="alternate"></link><published>2016-11-14T06:12:00-08:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-11-14:/2016/eopl-define-datatype-and-cases-in-clojure/</id><summary type="html">&lt;p&gt;I'm going through the &lt;a class="reference external" href="http://www.eopl3.com/"&gt;Essentials of Programming Languages (3rd ed.)&lt;/a&gt; book and it's been pretty good so far. In chapter 2,
the authors use a pair of macros - &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; - to make
it easy to define data-driven programs, where objects belong to types, each of
which has several &amp;quot;variants â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'm going through the &lt;a class="reference external" href="http://www.eopl3.com/"&gt;Essentials of Programming Languages (3rd ed.)&lt;/a&gt; book and it's been pretty good so far. In chapter 2,
the authors use a pair of macros - &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; - to make
it easy to define data-driven programs, where objects belong to types, each of
which has several &amp;quot;variants&amp;quot; with custom fields (this is essentially a
macro-driven implementation of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_data_type"&gt;algebraic data types&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The canonical example used chapter 2 is the &amp;quot;Lambda calculus expression&amp;quot;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(define-datatype lc-exp lc-exp?
  (var-exp
   (var symbol?))
  (lambda-exp
   (bound-var symbol?)
   (body lc-exp?))
  (app-exp
   (rator lc-exp?)
   (rand lc-exp?)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means we create a type named &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;, with three variants:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;var-exp&lt;/span&gt;&lt;/tt&gt; which has a field named &lt;tt class="docutils literal"&gt;var&lt;/tt&gt;, a symbol.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lambda-exp&lt;/span&gt;&lt;/tt&gt; which has two fields: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;bound-var&lt;/span&gt;&lt;/tt&gt; is a symbol, and &lt;tt class="docutils literal"&gt;body&lt;/tt&gt;
is a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;app-exp&lt;/span&gt;&lt;/tt&gt; which has two fields: &lt;tt class="docutils literal"&gt;rator&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;rand&lt;/tt&gt;, both a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; invocation creates multiple helper functions; for
example, the predicate &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp?&lt;/span&gt;&lt;/tt&gt; that tests whether the object it's given is a
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;. It can also optionally create accessors such as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;app-exp-&amp;gt;rand&lt;/span&gt;&lt;/tt&gt;,
that will extract a field from a given variant.&lt;/p&gt;
&lt;p&gt;The companion &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; macro lets us organize code that operates on types
created with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; succinctly. For example, a function that checks
whether some symbol occurs as a free variable in a given &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cases&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;lc-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;exp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;var-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;variable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;lambda-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bound-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;and &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bound-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;app-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[Note: this is actual Clojure code from my implementation; the book uses Scheme,
so it has slightly different syntax.]&lt;/p&gt;
&lt;p&gt;Alas, while the book explains how this pair of macros works and uses them all
over the place, it provides no definition. The definitions found online are
either hard to hunt down or very verbose (which may be due to &lt;a class="reference external" href="https://eli.thegreenplace.net/2007/09/16/common-lisp-vs-scheme-macros"&gt;Scheme's use of
hygienic macros&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Therefore I rolled my own, in Clojure, and the full code is
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/define-datatype/src/define_datatype/define_datatype.clj"&gt;available here&lt;/a&gt;.
The code comes with a large number of unit tests, many of which are
taken from the exercises in chapter 2 of the book.&lt;/p&gt;
&lt;p&gt;It's been quite a while since I last did any serious Lispy macro hacking, so my
implementation is fairly cautious in its use of macros. One cool thing about
the way Clojure's (Common Lisp-like) macros work is that writing them is very
close to just manipulating lists of symbols (representing code) in regular
functions. Here's my &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;define-datatype-aux&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Creates a datatype from the specification. This is a function, so all its&lt;/span&gt;
&lt;span class="s"&gt;  arguments are symbols or quoted lists. In particular, variant-descriptors is a&lt;/span&gt;
&lt;span class="s"&gt;  quoted list of all the descriptors.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;predicate-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-descriptors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;define-datatype&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Simple macro wrapper around define-datatype-aux, so that the type name,&lt;/span&gt;
&lt;span class="s"&gt;  predicate name and variant descriptors don&amp;#39;t have to be quoted but rather can&lt;/span&gt;
&lt;span class="s"&gt;  be regular Clojure symbols.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;predicate-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-descriptors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-datatype-aux&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;predicate-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-descriptors&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the macro does here is to do the thing only macros can do - change the
evaluation rules of expressions, by not actually evaluating the arguments passed
to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt;; rather passing them as lists of symbols (code) to a
function. The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype-aux&lt;/span&gt;&lt;/tt&gt; function can then manipulate these lists
of symbols. The only problem with this approach is that while macros can simply
inject &lt;tt class="docutils literal"&gt;defn&lt;/tt&gt;s into the namespace, functions have to work a bit harder for
that; what I use instead is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;internfunc&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Helper for interning a function with the given name (as a string) in the&lt;/span&gt;
&lt;span class="s"&gt;  current namespace.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;strname&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;intern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;*ns*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol &lt;/span&gt;&lt;span class="nv"&gt;strname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I'm sure the code could be made much shorter by doing more work in the macro,
but writing it this way made it possible to break the implementation into a
number of small and simple functions, each of which is easy to test and
understand without peering into the output of &lt;tt class="docutils literal"&gt;macroexpand&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;In the implementation of &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; I was a bit more brave and left more work
in the macro itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;make-cond-case&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Helper function for cases that generates a single case for the variant cond.&lt;/span&gt;

&lt;span class="s"&gt;  variant-case is one variant case as given to the cases macro.&lt;/span&gt;
&lt;span class="s"&gt;  obj-variant is the actual object variant (a symbol) as taken from the object.&lt;/span&gt;
&lt;span class="s"&gt;  obj-fields is the list of the actual object&amp;#39;s fields.&lt;/span&gt;

&lt;span class="s"&gt;  Produces the code for &amp;#39;(cond-case cond-action).&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-variant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-fields&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-variant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;second &lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;last &lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-fields&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;cases&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-cases&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;obj-type-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;obj-variant-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;variant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;obj-fields-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;fields&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-type-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-variant-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-fields-sym&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;assert &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-type-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Unexpected type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cond&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcat &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;vc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-cond-case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;vc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-variant-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-fields-sym&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="nv"&gt;variant-cases&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;assert &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Unsupported variant&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, I still deferred some of the work to a function -
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;make-cond-case&lt;/span&gt;&lt;/tt&gt; - to avoid complex nested quoting within the macro.&lt;/p&gt;
&lt;p&gt;The full code is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/define-datatype/src/define_datatype/define_datatype.clj"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category></entry></feed>