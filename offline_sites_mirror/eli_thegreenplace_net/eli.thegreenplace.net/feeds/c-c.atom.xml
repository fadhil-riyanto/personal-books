<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - C &amp; C++</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/c-c.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2024-05-04T19:46:23-07:00</updated><entry><title>Plugins case study: Envoy WASM extensions</title><link href="https://eli.thegreenplace.net/2023/plugins-case-study-envoy-wasm-extensions/" rel="alternate"></link><published>2023-06-03T15:14:00-07:00</published><updated>2024-02-29T13:32:33-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2023-06-03:/2023/plugins-case-study-envoy-wasm-extensions/</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="https://www.envoyproxy.io/"&gt;Envoy&lt;/a&gt; is a configurable proxy that serves
a prominent role in modern cloud-native projects; for example, it's
used in many k8s deployments to provide inter-service communication (through
Istio). In this post, I'd like to describe Envoy's extension mechanism as a case
study of using WebAssembly for plugins.&lt;/p&gt;
&lt;div class="section" id="some-background"&gt;
&lt;h2&gt;Some background&lt;/h2&gt;
&lt;p&gt;Imagine …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="https://www.envoyproxy.io/"&gt;Envoy&lt;/a&gt; is a configurable proxy that serves
a prominent role in modern cloud-native projects; for example, it's
used in many k8s deployments to provide inter-service communication (through
Istio). In this post, I'd like to describe Envoy's extension mechanism as a case
study of using WebAssembly for plugins.&lt;/p&gt;
&lt;div class="section" id="some-background"&gt;
&lt;h2&gt;Some background&lt;/h2&gt;
&lt;p&gt;Imagine a complex service-based infrastructure, in which service A has to
communicate with service B. This is typically done via HTTP/REST or some RPC
mechanism, but there are a lot of complex networking details to deal with:
service discovery (I just want to send a message to an instance of service B,
but which address/port is it on?), load balancing, retries, etc. Instead of
having each service deal with this complexity, we can set up Envoy to run as a
sidecar, and ask it to handle all of it. Then the actual services can focus on
our business logic.&lt;/p&gt;
&lt;p&gt;Here's a handy diagram from &lt;a class="reference external" href="https://istio.io"&gt;https://istio.io&lt;/a&gt; that demonstrates this (Envoy is
the &lt;em&gt;Proxy&lt;/em&gt; boxes):&lt;/p&gt;
&lt;object class="align-center" data="https://eli.thegreenplace.net/images/2023/envoyarch.svg" style="width: 600px;" type="image/svg+xml"&gt;System diagram of envoy proxies communicating for microservices&lt;/object&gt;
&lt;p&gt;As expected - for such a sophisticated piece of software - Envoy users
frequently need to customize it in various ways for their projects. For example,
we may want to define &lt;a class="reference external" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/listeners/listener_filters#arch-overview-network-filters"&gt;custom filters&lt;/a&gt;;
this is a kind of middleware.&lt;/p&gt;
&lt;p&gt;Envoy's original approach to extensions was to support writing C++ to link
custom filters with Envoy itself. This, of course, is awkward for many reasons -
such as having to distribute your own Envoy binaries instead of using the
standard ones. Also, the filter API was not really designed to be stable so
keeping up with changes was an issue; and finally, few people like writing C++
these days.&lt;/p&gt;
&lt;p&gt;So the Envoy team came up with an alternative approach:
&lt;a class="reference external" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/lua_filter"&gt;Lua extensions&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="Lua programming language logo" class="align-center" src="https://eli.thegreenplace.net/images/2023/lua-logo.png" style="width: 200px;" /&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Lua_(programming_language)"&gt;Lua programming language&lt;/a&gt; was designed
for extensions and plugins; it's a small and simple language, and its
implementation is also small and simple - making it easy to embed. You can write
some Lua code either directly in your configuration file or a separate file it
points to, and there's an API exposed to Lua that the extension can interact
with.&lt;/p&gt;
&lt;p&gt;The Lua extension method is fully supported in Envoy and is currently in
a &lt;em&gt;stable&lt;/em&gt; state, but some folks weren't too keen on learning yet another
programming language just for the sake of writing filters for their proxy. Lua
is not particularly prominent in the Cloud world (which is mostly dominated
by Go, Python, Java and some other languages). Therefore, the Envoy maintainers
have created yet another way to extend it &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; - with WebAssembly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wasm-extensions"&gt;
&lt;h2&gt;WASM extensions&lt;/h2&gt;
&lt;p&gt;WASM extensions are still experimental in Envoy at the time of writing, but
it's an intriguing approach and the main subject of this post. WASM elegantly
solves the problems of the other extension methods as follows:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The WASM extension is compiled into a &lt;tt class="docutils literal"&gt;.wasm&lt;/tt&gt; file that the Envoy config
can point at, and is loaded dynamically at runtime. It doesn't require
recompiling and distributing a custom version of Envoy.&lt;/li&gt;
&lt;li&gt;The extension can use any programming language that compiles down to WASM,
and that covers &lt;em&gt;a lot&lt;/em&gt; of languages these days.
Your entire service infrastructure is written in Go and you don't want to
wrangle C++ or learn Lua just for the proxy filters? No problem - Go compiles
to WASM and there's even &lt;a class="reference external" href="https://github.com/tetratelabs/proxy-wasm-go-sdk"&gt;an SDK&lt;/a&gt;
to help writing Envoy filters in it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To this end, Envoy embeds &lt;a class="reference external" href="https://v8.dev/"&gt;v8&lt;/a&gt; as a WASM VM. All that
remains is to define the interface between these WASM extension modules and
Envoy itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-proxy-wasm-abi"&gt;
&lt;h2&gt;The Proxy-Wasm ABI&lt;/h2&gt;
&lt;p&gt;WebAssembly itself defines:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A bytecode format (with an equivalent &lt;a class="reference external" href="https://eli.thegreenplace.net/2023/webassembly-text-code-samples/"&gt;text format&lt;/a&gt;)
and its execution semantics&lt;/li&gt;
&lt;li&gt;A way for WASM modules to export functions and data to the host environment&lt;/li&gt;
&lt;li&gt;A way for WASM modules to import functions and data from the host environment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that's about it. Everything else is left to the specific system implementer
to figure out. Moreover, the data types WASM supports are very limited -
essentially fixed-width integers and floats; users are expected to build
their own higher-level data structures on top of these using addresses into
WASM's linear heap memory, if needed.&lt;/p&gt;
&lt;p&gt;In a &lt;a class="reference external" href="https://eli.thegreenplace.net/2023/faas-in-go-with-wasm-wasi-and-rust/"&gt;previous post&lt;/a&gt; I've
talked about WASI - an API and ABI that enables OS-like functionality in WASM
code. While WASI is useful for exposing WASM modules to the outside world in
a vetted way, it's somewhat limited for complex host-wasm interactions, because
at the moment the only way for this to happen is via interfaces like
stdin/stdout &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Therefore, systems that require sophisticated interactions between the host
and WASM extensions are left to define their own interfaces. Which is exactly
what the Envoy developers ended up creating: the &lt;a class="reference external" href="https://github.com/proxy-wasm/spec"&gt;Proxy-Wasm
ABI&lt;/a&gt; &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The ABI is fairly low level, and it has two parts. One is
&lt;strong&gt;Functions implemented in the WASM module&lt;/strong&gt;. These are functions exported from
WASM (the custom extension) and imported by the host (Envoy or another proxy).
For example, &lt;tt class="docutils literal"&gt;proxy_on_request_headers&lt;/tt&gt; is exported by the WASM module as
a callback to handle headers for HTTP requests sailing through the proxy.&lt;/p&gt;
&lt;p&gt;This is the signature of &lt;tt class="docutils literal"&gt;proxy_on_request_headers&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;params:
    i32 (uint32_t) context_id
    i32 (size_t) num_headers
    i32 (bool) end_of_stream
returns:
    i32 (proxy_action_t) next_action
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The import is done in the &lt;a class="reference external" href="https://github.com/proxy-wasm/proxy-wasm-cpp-host/"&gt;proxy-wasm-cpp-host&lt;/a&gt; project
which is a dependency of Envoy. This project implements the host side of
Proxy-wasm for C++ hosts.&lt;/p&gt;
&lt;p&gt;What should the extension do within &lt;tt class="docutils literal"&gt;proxy_on_request_headers&lt;/tt&gt;, though? It
can do things like ask Envoy about the actual HTTP headers it sees with
&lt;tt class="docutils literal"&gt;proxy_get_header_map_value&lt;/tt&gt;. This is in the second part of the ABI,
&lt;strong&gt;Functions implemented in the host environment&lt;/strong&gt;. Its signature is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;params:
    i32 (proxy_map_type_t) map_type
    i32 (const char*) key_data
    i32 (size_t) key_size
    i32 (const char**) return_value_data
    i32 (size_t*) return_value_size
returns:
    i32 (proxy_result_t) call_result
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see this is &lt;em&gt;a very low level ABI&lt;/em&gt;; all parameters are either
pointers (addresses in WASM's linear memory) or constants of predefined types.
Since WASM severely restricts the types of function parameters and return
values, and both the WASM module and the host can be implemented in very diverse
programming languages, there's not much choice here. Writing the glue code on
the WASM-host interface is tedious and low-level.&lt;/p&gt;
&lt;p&gt;This is where the high-level SDKs come in.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-go-sdk-for-proxy-wasm"&gt;
&lt;h2&gt;The Go SDK for Proxy-wasm&lt;/h2&gt;
&lt;p&gt;Suppose we're writing our Envoy extension module in Go (a reasonable choice
given the dominance of Go in the Cloud Native / k8s / Istio ecosystem). It
seems like hooking up a simple extension to snoop on all the HTTP traffic
going through the proxy and logging the HTTP headers is quite a bit of work.&lt;/p&gt;
&lt;p&gt;Luckily, the good folks at Tetrate created the &lt;a class="reference external" href="https://github.com/tetratelabs/proxy-wasm-go-sdk/"&gt;Go SDK for Proxy-Wasm&lt;/a&gt;. This SDK handles all
the Proxy-Wasm ABI mechanics and presents a clean, pure Go API to extension
writers that won't have to worry about low level WASM details.&lt;/p&gt;
&lt;p&gt;Here's how the task of &amp;quot;snoop on HTTP traffic and log headers&amp;quot;
&lt;a class="reference external" href="https://github.com/tetratelabs/proxy-wasm-go-sdk/blob/main/examples/http_headers/main.go"&gt;looks using the Go SDK&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;httpHeaders&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;OnHttpRequestHeaders&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;numHeaders&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;endOfStream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;types&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Action&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;hs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;proxywasm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;GetHttpRequestHeaders&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;proxywasm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LogCriticalf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to get request headers: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;hs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;proxywasm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LogInfof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;request header --&amp;gt; %s: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;types&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ActionContinue&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's explore how both sides of the ABI (host-implemented and
module-implemented) are handled by the Go SDK. Starting with the WASM-calls-host
side, this is &lt;tt class="docutils literal"&gt;proxywasm.GetHttpRequestHeaders&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GetHttpRequestHeaders&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;([][&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;getMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;MapTypeHttpRequestHeaders&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's just a wrapper around a more general &lt;tt class="docutils literal"&gt;getMap&lt;/tt&gt; function with a map type
that the ABI defines. The return type is a slice of 2-element arrays
(key/value).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;getMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;mapType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;MapType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;([][&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;rvs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;raw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;st&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ProxyGetHeaderMapPairs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;mapType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;rvs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;st&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;StatusOK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;StatusToError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;st&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;raw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;types&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ErrorStatusNotFound&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;bs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RawBytePtrToByteSlice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;raw&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;rvs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DeserializeMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;bs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;internal.ProxyGetHeaderMapPairs&lt;/tt&gt; is actually an ABI-defined function that's
imported from the host (as &lt;tt class="docutils literal"&gt;proxy_get_header_map_pairs&lt;/tt&gt;). It writes raw
pointers to its output parameters, so the rest of &lt;tt class="docutils literal"&gt;getMap&lt;/tt&gt; deals with
converting those into Go data types.&lt;/p&gt;
&lt;p&gt;On the host side, &lt;tt class="docutils literal"&gt;proxy_get_header_map_pairs&lt;/tt&gt; is mapped to a
C++ function &lt;a class="reference external" href="https://github.com/proxy-wasm/proxy-wasm-cpp-host/blob/e1fe5e99eedfb517bea92aee3f13f442d4bfa3b4/src/exports.cc#L1"&gt;in this file&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now the host-calls-WASM side. The Go SDK has the following function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//export proxy_on_request_headers&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;proxyOnRequestHeaders&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;contextID&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;numHeaders&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;endOfStream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;types&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Action&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;recordTiming&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;defer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;logTiming&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;proxyOnRequestHeaders&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Now&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;ok&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;currentState&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;httpContexts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;contextID&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;ok&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;invalid context on proxy_on_request_headers&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;currentState&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;setActiveContextID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;contextID&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;OnHttpRequestHeaders&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;numHeaders&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;endOfStream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the &lt;tt class="docutils literal"&gt;//export&lt;/tt&gt; annotation that tells the compiler to export this function
from the WASM module. To be clear, the entire SDK - along with our custom code -
gets compiled into a &lt;tt class="docutils literal"&gt;.wasm&lt;/tt&gt; file that the host loads, and the &lt;tt class="docutils literal"&gt;//export&lt;/tt&gt;
tag makes the Go compiler place this function in the WASM function export
table that the host has access to.&lt;/p&gt;
&lt;p&gt;Once the host invokes it, it calls the &lt;tt class="docutils literal"&gt;OnHttpRequestHeaders&lt;/tt&gt; method on the
context, which is user-defined as shown above. Hopefully this example gives a
taste of what the SDK does for us - it provides a higher-level,
language-idiomatic API on top of a low-level, language-agnostic ABI.&lt;/p&gt;
&lt;p&gt;The Go SDK is just an example; there are other SDKs that exist for developing
WASM extensions for Envoy - for example in Rust or in C++.&lt;/p&gt;
&lt;p&gt;One small wrinkle in this story is that the Go SDK only supports the &lt;a class="reference external" href="https://tinygo.org/"&gt;TinyGo&lt;/a&gt; compiler at this time, not the default Go toolchain.
This is because the default toolchain doesn't have sufficient WASM support yet,
but this situation is changing; in Go 1.21 it has added WASI support and work
is ongoing on additional features that should make it possible to develop
Envoy extensions using the standard toolchain.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fundamental-plugin-concepts-in-this-case-study"&gt;
&lt;h2&gt;Fundamental plugin concepts in this case study&lt;/h2&gt;
&lt;p&gt;Let's see how this case study of Envoy extensions with WASM measures against the
&lt;a class="reference external" href="https://eli.thegreenplace.net/2012/08/07/fundamental-concepts-of-plugin-infrastructures"&gt;Fundamental plugin concepts&lt;/a&gt;
that were covered &lt;a class="reference external" href="https://eli.thegreenplace.net/tag/plugins"&gt;several times on this blog&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="discovery"&gt;
&lt;h3&gt;Discovery&lt;/h3&gt;
&lt;p&gt;Envoy &amp;quot;discovers&amp;quot; available extensions trivially, because they have to be
explicitly specified in its configuration file. The config file lists the
extensions and where to find them; for WASM, this could be either a local
&lt;tt class="docutils literal"&gt;.wasm&lt;/tt&gt; file or a URL pointing to a file stored remotely (e.g. some
cloud storage bucket).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="registration"&gt;
&lt;h3&gt;Registration&lt;/h3&gt;
&lt;p&gt;The WASM extension registers functionality with Envoy by exporting certain
functions from the WASM module. When Envoy loads an extension, it scans the list
of exported functions for known names. For example, if the extension exports
&lt;tt class="docutils literal"&gt;proxy_on_request_headers&lt;/tt&gt;, Envoy will call it for HTTP headers. If the
extension doesn't export such a function, Envoy will assume it's not interested
in this particular callback.&lt;/p&gt;
&lt;p&gt;Another interesting example of how this functionality is used is the
&lt;tt class="docutils literal"&gt;proxy_abi_version_X_Y_Z&lt;/tt&gt; function. An extension will
export this function with an actual ABI version replacing X, Y an Z. Envoy
will look for a function with the &lt;tt class="docutils literal"&gt;proxy_abi_version_*&lt;/tt&gt; prefix, and from its
name will determine which version of the ABI the WASM module was compiled
against.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hooks"&gt;
&lt;h3&gt;Hooks&lt;/h3&gt;
&lt;p&gt;This is mostly covered in the previous section. There are multiple callbacks
a WASM extension can register by exporting them from the WASM module;
&lt;tt class="docutils literal"&gt;proxy_on_request_headers&lt;/tt&gt; is one example out of many defined in the ABI.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exposing-an-application-api-to-plugins"&gt;
&lt;h3&gt;Exposing an application API to plugins&lt;/h3&gt;
&lt;p&gt;This is the &lt;strong&gt;Functions implemented in the host environment&lt;/strong&gt; part of the
Proxy-Wasm ABI; we've seen an example of one of them -
&lt;tt class="docutils literal"&gt;proxy_get_header_map_pairs&lt;/tt&gt;. The ABI defines others, like &lt;tt class="docutils literal"&gt;proxy_log&lt;/tt&gt; for
emitting log messages to Envoy's log. These functions let extensions call
into Envoy.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;As you can see from the string of posts this year, I'm pretty excited about
the non-browser uses of WASM, particularly in the area of plugins.
The &lt;a class="reference external" href="https://eli.thegreenplace.net/2023/faas-in-go-with-wasm-wasi-and-rust/"&gt;FAAS post&lt;/a&gt; presented one interesting
possibility - using the current (limited but functional) WASI for the
host/plugin interface.&lt;/p&gt;
&lt;p&gt;What this post shows is a case study of a much more advanced extension system;
the capabilities and performance requirements of custom network filter plugins
are just way beyond what WASI can provide, so the Envoy developers ended up
creating their own ABI. It's fascinating to study how such an ABI affects plugin
development and what kind of ecosystem it spawns.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that I'm not trying to criticize the existing extension mechanisms
in Envoy in any way. Both work, and are used to solve real business
problems. As a project like Envoy grows in popularity and usage, it's
inevitable that it will spawn more options for different people to
accomplish their tasks with it. Such is the way of software.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The WASI folks are working on extensions to allow sockets and also
more complex data to be shared between WASM and hosts in an RPC-like
manner; this may enable greatly improved wasm-host interfaces in the
future.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;This all sounds great - the way things should be - until reality kicks
in. While doing research for this post I discovered that the Proxy-wasm
ABI, while clearly and carefully specified, is in-fact
&lt;a class="reference external" href="https://github.com/proxy-wasm/spec/issues/36"&gt;out of date&lt;/a&gt; and
the &amp;quot;real&amp;quot; definition lives within the Envoy source code. It's yet
another case of &amp;quot;the ABI is whatever its main implementation does&amp;quot;, even
though other proxies implement it already
(&lt;a class="reference external" href="https://github.com/mosn/mosn"&gt;MOSN&lt;/a&gt; for example).&lt;/p&gt;
&lt;p&gt;This is especially often the case in my favorite domain - systems
programming. &lt;em&gt;Sigh&lt;/em&gt;, such is life. The rest of the post talks about
the &lt;em&gt;de-facto&lt;/em&gt; specification, relying on the Envoy source code more
than the written down ABI. Hopefully at some future point the ABI is
updated and I can rewrite this footnote.&lt;/p&gt;
&lt;p class="last"&gt;A shout out to &lt;a class="reference external" href="https://github.com/codefromthecrypt"&gt;Adrian Cole&lt;/a&gt;
and &lt;a class="reference external" href="https://github.com/mathetake"&gt;Takeshi Yoneda&lt;/a&gt; for
confirming these findings, and the useful chats about all things WASM,
WASI and Go in general.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Go"></category><category term="Plugins"></category><category term="WebAssembly"></category><category term="C &amp; C++"></category></entry><entry><title>"Beating" C with 400 lines of unoptimized assembly</title><link href="https://eli.thegreenplace.net/2019/beating-c-with-400-lines-of-unoptimized-assembly/" rel="alternate"></link><published>2019-11-23T09:46:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2019-11-23:/2019/beating-c-with-400-lines-of-unoptimized-assembly/</id><summary type="html">&lt;p&gt;Earlier this week I ran into a fun quick blog post named
&lt;a class="reference external" href="https://ajeetdsouza.github.io/blog/posts/beating-c-with-70-lines-of-go/"&gt;Beating C with 70 lines of Go&lt;/a&gt;,
which reimplements the basic functionality of &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; in Go using various
approaches and compares their performance. Apparently it's inspired by an
earlier &lt;a class="reference external" href="https://chrispenner.ca/posts/wc"&gt;Haskell-based post&lt;/a&gt; and several
other offshoots.&lt;/p&gt;
&lt;p&gt;This reminded me …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Earlier this week I ran into a fun quick blog post named
&lt;a class="reference external" href="https://ajeetdsouza.github.io/blog/posts/beating-c-with-70-lines-of-go/"&gt;Beating C with 70 lines of Go&lt;/a&gt;,
which reimplements the basic functionality of &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; in Go using various
approaches and compares their performance. Apparently it's inspired by an
earlier &lt;a class="reference external" href="https://chrispenner.ca/posts/wc"&gt;Haskell-based post&lt;/a&gt; and several
other offshoots.&lt;/p&gt;
&lt;p&gt;This reminded me of my earlier post about &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/wc-in-x64-assembly/"&gt;reimplementing wc in pure x64
assembly&lt;/a&gt;, where I
also measured the performance of my program against &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The optimized approach taken in the Go implementation is very similar to what I
did in assembly, so it seemed like an interesting comparison. I started by
generating a ~580 MiB file using &lt;a class="reference external" href="https://github.com/eliben/xmlgen"&gt;xmlgen&lt;/a&gt;
and ran the various versions against each other:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_TYPE=POSIX wc&lt;/tt&gt;: 2.13 sec&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;wc-naive.go&lt;/span&gt;&lt;/tt&gt;: 3.53 sec&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;wc-chunks.go&lt;/span&gt;&lt;/tt&gt;: 1.37 sec&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt;: 1.2 sec&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note the &lt;tt class="docutils literal"&gt;LC_TYPE&lt;/tt&gt; setting for the system's &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt;. This is important for a
fair comparison, because without this &lt;tt class="docutils literal"&gt;wc&lt;/tt&gt; will attempt to do &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;utf-8&lt;/span&gt;&lt;/tt&gt;
decoding on all bytes in the file, which results in significant slowdowns. Since
the Go versions use byte-counts and so does my &lt;tt class="docutils literal"&gt;wcx64&lt;/tt&gt;, I force the comparison
to be fair. In fact, this isn't a bad result for Go - the straightforward
solution is almost as fast as the same approach direct-coded in assembly!&lt;/p&gt;
&lt;p&gt;The Go blog post follows with parallelized versions which are much faster than
the serial one, but I'm excluding it here because all the other competitors are
single-threaded. This is not a serious benchmark anyway. If you prefer to
be serious, &lt;a class="reference external" href="https://github.com/expr-fi/fastlwc/"&gt;this response using SIMD-optimized C&lt;/a&gt; blows everything out of the water:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;fastlwc&lt;/tt&gt;: 0.11 sec&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The conclusion? Well, there's no real conclusion here, beyond that coding
exercises like this are fun in any language :-)&lt;/p&gt;
</content><category term="misc"></category><category term="Assembly"></category><category term="C &amp; C++"></category><category term="Go"></category></entry><entry><title>Faster XML stream processing in Go</title><link href="https://eli.thegreenplace.net/2019/faster-xml-stream-processing-in-go/" rel="alternate"></link><published>2019-07-22T05:37:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2019-07-22:/2019/faster-xml-stream-processing-in-go/</id><summary type="html">&lt;p&gt;XML processing was all the rage 15 years ago; while it's less
prominent these days, it's still an important task in some application domains.
In this post I'm going to compare the speed of stream-processing huge XML files
in Go, Python and C and finish up with a new, minimal …&lt;/p&gt;</summary><content type="html">&lt;p&gt;XML processing was all the rage 15 years ago; while it's less
prominent these days, it's still an important task in some application domains.
In this post I'm going to compare the speed of stream-processing huge XML files
in Go, Python and C and finish up with a new, minimal module that uses C to
accelerate this task for Go. All the code shown throughout this post is
available &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2019/xml-stream"&gt;in this GitHub repository&lt;/a&gt; the new
Go module &lt;a class="reference external" href="https://github.com/eliben/gosax"&gt;is here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="what-does-xml-stream-processing-mean"&gt;
&lt;h2&gt;What does XML stream processing mean?&lt;/h2&gt;
&lt;p&gt;First, let's define the problem at hand in more detail. Roughly speaking, there
are two ways we can process data from a file:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Read the whole file into memory at once, and then proces the data in
memory.&lt;/li&gt;
&lt;li&gt;Read the file in chunks, process each chuck, without having the whole data
in memory at any given time.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In many ways, (1) is more convenient because we can easily go back to any part
of the file. However, in some situations (2) is essential; specifically, when
the file is very large. This is where &lt;em&gt;stream&lt;/em&gt; processing comes in. If our input
file is 500 GiB, we're unlikely to be able to read it into memory and have to
process it in parts. Even for smaller files that would theoretically fit into
RAM, it's not always a good idea to read them wholly; this dramatically
increases the active heap size and can cause performance issues in
garbage-collected languages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-task"&gt;
&lt;h2&gt;The task&lt;/h2&gt;
&lt;p&gt;For this benchmark, I'm using &lt;a class="reference external" href="https://github.com/eliben/xmlgen"&gt;xmlgen&lt;/a&gt; to
create a 230 MiB XML file &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. A tiny fragment of the file may look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; standalone=&amp;quot;yes&amp;quot;?&amp;gt;
&amp;lt;site&amp;gt;
  &amp;lt;regions&amp;gt;
    &amp;lt;asia&amp;gt;
      &amp;lt;item id=&amp;quot;item0&amp;quot;&amp;gt;
        &amp;lt;location&amp;gt;United States&amp;lt;/location&amp;gt;
        &amp;lt;quantity&amp;gt;1&amp;lt;/quantity&amp;gt;
        &amp;lt;name&amp;gt;duteous nine eighteen &amp;lt;/name&amp;gt;
        &amp;lt;payment&amp;gt;Creditcard&amp;lt;/payment&amp;gt;
        ...
      &amp;lt;/item&amp;gt;
    &amp;lt;/asia&amp;gt;
  &amp;lt;/regions&amp;gt;
&amp;lt;/site&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The task is to find how many times &amp;quot;Africa&amp;quot; appears in the data of the
&lt;tt class="docutils literal"&gt;&amp;lt;location&amp;gt;&lt;/tt&gt; tag throughout the document.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="baseline-using-the-go-standard-library"&gt;
&lt;h2&gt;Baseline - using the Go standard library&lt;/h2&gt;
&lt;p&gt;Let's start with a baseline implementation - using the standard library's
&lt;tt class="docutils literal"&gt;encoding/xml&lt;/tt&gt; package. While the package's &lt;tt class="docutils literal"&gt;Unmarshal&lt;/tt&gt; mode will parse the
whole file in one go, it can also be used to process XML token by token and
selectively parse interesting elements. Here is the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;encoding/xml&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;io&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;log&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;os&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;strings&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;location&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;Data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;`xml:&amp;quot;,chardata&amp;quot;`&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Fatal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;defer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;xml&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewDecoder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;tok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;tok&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;io&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;EOF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// EOF means we&amp;#39;re done.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Fatalf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error decoding token: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;ty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;tok&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;xml&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;StartElement&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Local&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;location&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// If this is a start element named &amp;quot;location&amp;quot;, parse this element&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// fully.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;location&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DecodeElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Fatalf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error decoding item: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Africa&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nx"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count =&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I made sure to double check that the memory usage of this program stays bounded
and low while processing a large file - the maximum RSS was under 7 MiB while
processing our 230 MiB input file. I'm verifying this for all the programs
presented in this post using &lt;tt class="docutils literal"&gt;/usr/bin/time &lt;span class="pre"&gt;-v&lt;/span&gt;&lt;/tt&gt; on Linux.&lt;/p&gt;
&lt;p&gt;This program takes 6.24 seconds to process the whole file and print out the
result.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-implementation"&gt;
&lt;h2&gt;Python implementation&lt;/h2&gt;
&lt;p&gt;The first Python implementation uses the &lt;tt class="docutils literal"&gt;xml.etree.ElementTree&lt;/tt&gt; module from
the standard library:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;xml.etree.ElementTree&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ET&lt;/span&gt;

&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ET&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterparse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;end&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,)):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;end&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;location&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Africa&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;count =&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key here is the &lt;tt class="docutils literal"&gt;elem.clear()&lt;/tt&gt; call. It ensures that each element gets
discarded afer parsing it fully, so the memory usage won't grow linearly with
the size of the file (unless the file is pathological). This program takes 3.7
seconds to process the whole file - much faster than our Go program. Why is
that?&lt;/p&gt;
&lt;p&gt;While the Go program uses 100% Go code for the task (&lt;tt class="docutils literal"&gt;encoding/xml&lt;/tt&gt; is
implemented entirely in Go), the Python program is using a C extension (most of
&lt;tt class="docutils literal"&gt;ElementTree&lt;/tt&gt; is written in C) wrapping a fast XML parser in C - &lt;a class="reference external" href="https://github.com/libexpat/libexpat"&gt;libexpat&lt;/a&gt;. The bulk of the work here is done in
C, which is faster than Go.
The performance of &lt;tt class="docutils literal"&gt;encoding/xml&lt;/tt&gt; is further discussed in
&lt;a class="reference external" href="https://github.com/golang/go/issues/21823"&gt;this issue&lt;/a&gt;, though it's an
old one and the performance has been somewhat optimized since then.&lt;/p&gt;
&lt;p&gt;An alternative XML parsing library for Python is &lt;a class="reference external" href="https://github.com/lxml/lxml"&gt;lxml&lt;/a&gt;,
which uses &lt;a class="reference external" href="https://www.xmlsoft.org/"&gt;libxml&lt;/a&gt; underneath. Here's a Python
version using lxml:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lxml&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;etree&lt;/span&gt;

&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;etree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterparse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;end&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,)):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;end&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;location&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Africa&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;count =&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This looks very similar to the previous version, and that's on purpose. lxml
has an &lt;tt class="docutils literal"&gt;etree&lt;/tt&gt;-compatible API to make transition from the standard library
smoother. This version also takes around 3.7 seconds for our 230 MiB file.&lt;/p&gt;
&lt;p&gt;The reason I'm including lxml here is that it will run faster than
&lt;tt class="docutils literal"&gt;xml.etree.ElementTree&lt;/tt&gt; when slurping the whole file, for our particular file
size. I want to highlight that this is outside of the scope for my experiment,
because I only care about streaming processing. The only way (that I'm aware
of!) to successfully process a 500 GiB file with lxml would be by using
&lt;tt class="docutils literal"&gt;iterparse&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-fast-can-it-run"&gt;
&lt;h2&gt;How fast can it run?&lt;/h2&gt;
&lt;p&gt;Based on the measurements presented here, Go is about 68% slower than Python for
parsing a large XML file in a streaming fashion. While Go usually compiles to
a much faster code than pure Python, the Python implementations have the backing
of efficient C libraries with which it's difficult to compete. I was curious
to know how fast it could be, in theory &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To answer this question, I implemented the same program using pure C with
libxml, which has a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Simple_API_for_XML"&gt;SAX API&lt;/a&gt;. I won't paste it wholly
here because it's longer, but you can find the &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2019/xml-stream/c-libxmlsax-count"&gt;full source code on GitHub&lt;/a&gt;.
It takes just 0.56 seconds to process our 230 MiB input file, which is very
impressive given the other results, but also not very surprising. This is C,
after all.&lt;/p&gt;
&lt;p&gt;You may wonder - if lxml uses libxml underneath, why is it so much slower than
the pure C version? The answer is Python call overhead. The lxml version calls
back into Python &lt;em&gt;for every parsed element&lt;/em&gt;, which incurs a significant
cost &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;. Another reason is that my C implementation doesn't actually parse an
element - it's just a simple event-based state machine, so there's less extra
work being done.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-libxml-from-go"&gt;
&lt;h2&gt;Using libxml from Go&lt;/h2&gt;
&lt;p&gt;To recap where we are so far:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Python libraries based on underlying C implementations are faster than
pure Go.&lt;/li&gt;
&lt;li&gt;Pure C is much faster still.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have two options: we can either try to optimize Go's &lt;tt class="docutils literal"&gt;encoding/xml&lt;/tt&gt;
package, or we can try to wrap a fast C library with Go. While the former is a
worthy goal, it involves a large effort and should be a topic for a separate
post. Here, I'll go for the latter.&lt;/p&gt;
&lt;p&gt;Seaching around the web, I found a few wrappers around libxml. Two that seemed
moderately popular and maintained are &lt;a class="reference external" href="https://github.com/lestrrat-go/libxml2"&gt;https://github.com/lestrrat-go/libxml2&lt;/a&gt;
and &lt;a class="reference external" href="https://github.com/moovweb/gokogiri"&gt;https://github.com/moovweb/gokogiri&lt;/a&gt;. Unfortunately, neither of these (or
the other bindings I found) are exposing the SAX API of libxml; instead, they
focus on the DOM API, where the whole document is parsed by the underlying
library and a tree is returned. As mentioned above, we need the SAX interface
to process huge files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="gosax"&gt;
&lt;h2&gt;gosax&lt;/h2&gt;
&lt;p&gt;It's time to roll our own :-) I wrote the &lt;a class="reference external" href="https://github.com/eliben/gosax"&gt;gosax&lt;/a&gt; module, which uses Cgo to call into libxml
and exposes a SAX interface &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;. Implementing it was an interesting exercise
in Cgo, because it requires some non-trivial concepts like
&lt;a class="reference external" href="https://eli.thegreenplace.net/2019/passing-callbacks-and-pointers-to-cgo/"&gt;registering Go callbacks with C&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's a version of our program using gosax:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;os&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;strings&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;github.com/eliben/gosax&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;inLocation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;scb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gosax&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SaxCallbacks&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;StartElement&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;attrs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;location&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;inLocation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;inLocation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;EndElement&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nx"&gt;inLocation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;Characters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;contents&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;inLocation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Africa&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;counter&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gosax&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ParseFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;scb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter =&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, it implements a state machine that remembers being inside
a &lt;tt class="docutils literal"&gt;location&lt;/tt&gt; element, where the character data is checked. This program
takes 4.03 seconds to process our input file. Not bad! But we can do a bit
better, and &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2019/xml-stream/gosax-count/gosax-count.go"&gt;with a couple of optimizations&lt;/a&gt;
I managed to bring it down to 3.68 seconds - about the same speed as the Python
implementations!&lt;/p&gt;
&lt;p&gt;IMHO the roughly similar run times here are a coincidence, because the Python
programs are different from my approach in that they expose a higher-level API
than pure SAX. Recall that &lt;tt class="docutils literal"&gt;iterparse&lt;/tt&gt; returns a parsed element, and we
can access its &lt;tt class="docutils literal"&gt;text&lt;/tt&gt; attribute, etc. In gosax, we have to do this much more
manually. Since the the &lt;a class="reference external" href="https://about.sourcegraph.com/go/gophercon-2018-adventures-in-cgo-performance"&gt;cost of calls between Cgo and Go is rather high&lt;/a&gt;,
there is an optimization opportunity here for gosax. We could do more work in
C - parsing a full element, and returning it wholly to Go. This would move work
from the Go side to the C side, as well as reduce the number of cross-language
calls. But this is a task for another day.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Well, this was fun :-) There are 5 different implementations of the same simple
task described here, in 3 different programming languages. Here is a summary
of the speed measurements we got:&lt;/p&gt;
&lt;img alt="Performance comparison chart" class="align-center" src="https://eli.thegreenplace.net/images/2019/xml-sax-comparison.png" /&gt;
&lt;p&gt;Python's performance story has always been - &amp;quot;it's probably fast enough, and in
the rare cases where it isn't, use a C extension&amp;quot;. In Go the narrative is
somewhat different: in most cases, the Go compiler produces fairly fast code.
Pure Go code is significantly faster than Python and often faster than Java.
Even so, every once in a while it may be useful to dip into C or C++ for
performance, and in these cases Cgo is a good approach.&lt;/p&gt;
&lt;p&gt;It's obvious that &lt;tt class="docutils literal"&gt;encoding/xml&lt;/tt&gt; &lt;a class="reference external" href="https://github.com/golang/go/issues/21823"&gt;needs some work w.r.t. performance&lt;/a&gt;, but until that happens - there
are good alternatives! Leveraging the speed of libxml has been possible for the
DOM API, and now is possible for the SAX API as well. In the long run, I believe
that serious performance work on &lt;tt class="docutils literal"&gt;encoding/xml&lt;/tt&gt; can make it go faster than
the libxml wrappers because it would elimitate the high cost of C-to-Go calls.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This size will easily fit in RAM, but it's good enough to provide a
meaningful benchmarking duration.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;When working on optimizations, it's often useful to know &amp;quot;the speed
of light&amp;quot; of some computation. Say we want to optimize some function in
our program. It's worth asking - how much faster will the program be if
this function takes 0 time? If the overall change is tiny, the function
is not worth optimizing, most likely. This is just a practical
application of Amdahl's law.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;We can test this hypothesis by timing how long it takes the non-streaming
API in lxml to parse the same file. Since it parses the whole XML file
in C before returning the parsed structure to Python, we expect the
Python call overhead to be much smaller. Indeed, for files that fit into
memory this is faster. But once again, in this post we return our
attention to streaming APIs - assuming this is our only choice for
gigantic files.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;gosax is very minimal, only providing the most common SAX callbacks.
The decision to create a new module was just for convenience and speed;
the more correct thing would have likely been to contribute to one of
the existing libxml wrappers. I don't see gosax as production-quality
at this stage - I just hacked it together to be able to experiment for
this post.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Go"></category><category term="C &amp; C++"></category><category term="Python"></category></entry><entry><title>Passing callbacks and pointers to Cgo</title><link href="https://eli.thegreenplace.net/2019/passing-callbacks-and-pointers-to-cgo/" rel="alternate"></link><published>2019-07-15T05:39:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2019-07-15:/2019/passing-callbacks-and-pointers-to-cgo/</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="https://blog.golang.org/c-go-cgo"&gt;Cgo&lt;/a&gt; enables Go programs to invoke C
libraries or any other library that exposes a C API. As such, it's a important
part of a Go programmer's toolbox.&lt;/p&gt;
&lt;p&gt;Using Cgo can be tricky, however, especially when passing pointers and callback
functions between Go and C code. This post discusses an …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="https://blog.golang.org/c-go-cgo"&gt;Cgo&lt;/a&gt; enables Go programs to invoke C
libraries or any other library that exposes a C API. As such, it's a important
part of a Go programmer's toolbox.&lt;/p&gt;
&lt;p&gt;Using Cgo can be tricky, however, especially when passing pointers and callback
functions between Go and C code. This post discusses an end-to-end
example that covers:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Basic usage of Cgo, including linking a custom C library into the Go binary.&lt;/li&gt;
&lt;li&gt;Passing structs from Go to C.&lt;/li&gt;
&lt;li&gt;Passing Go functions to C and arranging C to call them back later.&lt;/li&gt;
&lt;li&gt;Safely passing arbitrary Go data to C code, which can later
pass it back to the Go callbacks it invokes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is not a tutorial for Cgo - before reading, you're expected to have some
familiarity with its simpler use cases. Several useful tutorials and reference
pages are listed at the end of the post. The full source code for this example
is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2019/cgo-callback"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="the-problem-a-c-library-that-invokes-multiple-go-callbacks"&gt;
&lt;h2&gt;The problem - a C library that invokes multiple Go callbacks&lt;/h2&gt;
&lt;p&gt;Here is the header file of a fictional C library that works through some data
and invokes callbacks based on events:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;StartCallbackFn&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;EndCallbackFn&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;StartCallbackFn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;EndCallbackFn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Callbacks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;


&lt;span class="c1"&gt;// Processes the file and invokes callbacks from cbs on events found in the&lt;/span&gt;
&lt;span class="c1"&gt;// file, each with its own relevant data. user_data is passed through to the&lt;/span&gt;
&lt;span class="c1"&gt;// callbacks.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Callbacks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cbs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The callback signatures are made up, but demonstrate several important patterns
that are common in reality:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Every callback has its own type signature; here we're using &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; parameters
for simplicity, but it could be anything else.&lt;/li&gt;
&lt;li&gt;When only a small number of callbacks is involved, they could be passed into
&lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt; as separate parameters; however, often the number of callbacks
is large (say, more than 3) and then almost always a &lt;tt class="docutils literal"&gt;struct&lt;/tt&gt; collecting
them is passed along. It's common to allow the user to set some of the
callbacks to &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; to convey to the library that this particular event is
not interesting and no user code should be invoked for it.&lt;/li&gt;
&lt;li&gt;Every callback gets an opaque &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt; pointer passed through from
the call to &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt;. It's used to distinguish different traversals from
each other, and pass along user-specific state. &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt; typically
passes &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt; through without even trying to access it; since it's
&lt;tt class="docutils literal"&gt;void*&lt;/tt&gt;, it's completely opaque to the library and the user code will cast
it to some concrete type inside the callback.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our implementation of &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt; is just a trivial simulation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Callbacks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cbs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Simulate some traversal that calls the start callback and then the end&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// callback, if they are defined.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cbs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cbs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cbs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cbs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our task is to wrap this library for usage from Go code. We'll want to invoke Go
callbacks on traversal, without having to write any additional C code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-go-interface"&gt;
&lt;h2&gt;The Go interface&lt;/h2&gt;
&lt;p&gt;Let's start by sketching how our interface would look like in Go. Here is
one way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Visitor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;End&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GoTraverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;filename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Visitor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// ... implementation&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rest of the post shows a complete implementation using this approach.
However, it has some drawbacks:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;When the number of callbacks we need to provide is large, writing
implementations of &lt;tt class="docutils literal"&gt;Visitor&lt;/tt&gt; may be tedious if we're only interested
in a couple of callbacks. This can be mitigated by providing a struct to
implement the complete interface with some defaults (say, no-ops) and user
structs can then embed this default struct and not have to implement every
single method. Still, interfaces with many methods are often not a good Go
practice.&lt;/li&gt;
&lt;li&gt;A more serious limitation is that it's hard to convey to the C &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt;
that we're not interested in some callback. The object implementing
&lt;tt class="docutils literal"&gt;Visitor&lt;/tt&gt; will - by definition - have an implementation for all the methods,
so there's no easy way to tell if we're not interested in invoking some of
them. This can have serious performance implications.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An alternative approach is to mimic what we have in C; that is, create a struct
collecting function objects:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GoStartCallback&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GoEndCallback&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GoCallbacks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;startCb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GoStartCallback&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;endCb&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nx"&gt;GoEndCallback&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GoTraverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;filename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cbs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;GoCallbacks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// ... implementation&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This solves both drawbacks immediately: the default value of a function object
is &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;, which can be interpreted by &lt;tt class="docutils literal"&gt;GoTraverse&lt;/tt&gt; as &amp;quot;not interested in
this event&amp;quot;, wherein it can set the corresponding C callback to &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt;. Since
Go function objects can be closures or bound methods, there's no difficulty in
preserving state between the different callbacks.&lt;/p&gt;
&lt;p&gt;The accompanying code sample has this alternative implementation available in a
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2019/cgo-callback/alt-interface"&gt;separate directory&lt;/a&gt;,
but in the rest of the post we're going to proceed with the more idiomatic
approach that uses a Go &lt;tt class="docutils literal"&gt;interface&lt;/tt&gt;. For the implementation, it doesn't really
matter which approach is chosen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="implementing-the-cgo-wrapper"&gt;
&lt;h2&gt;Implementing the Cgo wrapper&lt;/h2&gt;
&lt;p&gt;Cgo &lt;a class="reference external" href="https://golang.org/cmd/cgo/#hdr-Passing_pointers"&gt;pointer passing rules&lt;/a&gt;
disallow passing Go function values directly to C, so to register callbacks we
need to create wrapper functions in C.&lt;/p&gt;
&lt;p&gt;Moreover, we also can't pass pointers allocated in Go to C directly, because the
Go concurrent garbage collector may move data around. The &lt;a class="reference external" href="https://github.com/golang/go/wiki/cgo#function-variables"&gt;Cgo Wiki page&lt;/a&gt; offers a workaround
using indirection. Here I'm going to use the
&lt;a class="reference external" href="https://github.com/mattn/go-pointer"&gt;go-pointer package&lt;/a&gt; which
accomplishes the same in a slightly more convenient and general way.&lt;/p&gt;
&lt;p&gt;With this in mind, let's get straight to the implementation. The code may appear
obscure at first, but it will all make sense soon. Here's the code for
&lt;tt class="docutils literal"&gt;GoTraverse&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gopointer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;github.com/mattn/go-pointer&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GoTraverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;filename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Visitor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;cCallbacks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Callbacks&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;cCallbacks&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;StartCallbackFn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;startCgo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;cCallbacks&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;EndCallbackFn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;endCgo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cfilename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;defer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cfilename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gopointer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;defer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gopointer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Unref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cfilename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cCallbacks&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We start by creating the C &lt;tt class="docutils literal"&gt;Callbacks&lt;/tt&gt; struct in Go code, and populating it.
Since we can't assign Go functions to C function pointers, we'll have these
wrappers, defined in a separate Go file &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;extern void goStart(void*, int);&lt;/span&gt;
&lt;span class="cm"&gt;extern void goEnd(void*, int, int);&lt;/span&gt;

&lt;span class="cm"&gt;void startCgo(void* user_data, int i) {&lt;/span&gt;
&lt;span class="cm"&gt;  goStart(user_data, i);&lt;/span&gt;
&lt;span class="cm"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;void endCgo(void* user_data, int a, int b) {&lt;/span&gt;
&lt;span class="cm"&gt;  goEnd(user_data, a, b);&lt;/span&gt;
&lt;span class="cm"&gt;}&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These are very thin wrappers that invoke Go functions - and we'll have to write
one such C function per callback kind. We'll see the Go functions &lt;tt class="docutils literal"&gt;goStart&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;goEnd&lt;/tt&gt; shortly.&lt;/p&gt;
&lt;p&gt;After populating the C callback struct, &lt;tt class="docutils literal"&gt;GoTraverse&lt;/tt&gt; converts the file name
from a Go string to a C string (&lt;a class="reference external" href="https://github.com/golang/go/wiki/cgo#go-strings-and-c-strings"&gt;the wiki&lt;/a&gt; has the
details). It then creates a value representing the Go visitor and that we
can pass to C using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-pointer&lt;/span&gt;&lt;/tt&gt; package. Finally, it calls &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;To complete the implementation, the code for &lt;tt class="docutils literal"&gt;goStart&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;goEnd&lt;/tt&gt; is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//export goStart&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;goStart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gopointer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Restore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;).(&lt;/span&gt;&lt;span class="nx"&gt;Visitor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;//export goEnd&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;goEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gopointer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Restore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user_data&lt;/span&gt;&lt;span class="p"&gt;).(&lt;/span&gt;&lt;span class="nx"&gt;Visitor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;End&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;export&lt;/tt&gt; directives means these functions are visible to C code; their
signature should have C types or types convertible to C types. They act
similarly:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Unpack the visitor object from &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Invoke the appropriate method on the visitor&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="callback-flow-in-detail"&gt;
&lt;h2&gt;Callback flow in detail&lt;/h2&gt;
&lt;p&gt;Let's examine the flow of callback calls for a &amp;quot;start&amp;quot; event to get a better
understanding of how the pieces are connected together.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;GoTraverse&lt;/tt&gt; assigns &lt;tt class="docutils literal"&gt;startCgo&lt;/tt&gt; to the &lt;tt class="docutils literal"&gt;start&lt;/tt&gt; pointer in the
&lt;tt class="docutils literal"&gt;Callbacks&lt;/tt&gt; structure passed to &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt;. Therefore, when &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt;
encounteres a start event, it will invoke &lt;tt class="docutils literal"&gt;startCgo&lt;/tt&gt;. The parameters are
the &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt; pointer passed in to &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt; and the event-specific
parameters (a single &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; in this case).&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;startCgo&lt;/tt&gt; is a shim around &lt;tt class="docutils literal"&gt;goStart&lt;/tt&gt;, and calls it with the same
parameters.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;goStart&lt;/tt&gt; unpacks the &lt;tt class="docutils literal"&gt;Visitor&lt;/tt&gt; implementation that was packed into
&lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt; by &lt;tt class="docutils literal"&gt;GoTraverse&lt;/tt&gt; and calls the &lt;tt class="docutils literal"&gt;Start&lt;/tt&gt; method from there,
passing it the event-specific parameters. All the code until this point is
provided by the Go library wrapping &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt;; from here, we get to the
custom code written by the user of the API.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tunneling-go-pointers-through-c-code"&gt;
&lt;h2&gt;Tunneling Go pointers through C code&lt;/h2&gt;
&lt;p&gt;Another critical detail of this implementation is the trick we used to pack
a &lt;tt class="docutils literal"&gt;Visitor&lt;/tt&gt; inside a &lt;tt class="docutils literal"&gt;void* user_data&lt;/tt&gt; passed around to and from C
callbacks.&lt;/p&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://golang.org/cmd/cgo/#hdr-Passing_pointers"&gt;Cgo documentation&lt;/a&gt;
states that:&lt;/p&gt;
&lt;blockquote&gt;
Go code may pass a Go pointer to C provided the Go memory to which it points
does not contain any Go pointers.&lt;/blockquote&gt;
&lt;p&gt;But of course we can't guarantee that arbitrary Go objects don't contain any
pointers. Besides the obvious uses of pointers, function values, slices,
strings, interfaces and many other objects contain implicit pointers.&lt;/p&gt;
&lt;p&gt;The limitation stems from the nature of the Go garbage collector, which runs
concurrently to other code and is allowed to move data around, invalidating
pointers from the point of view of C.&lt;/p&gt;
&lt;p&gt;So what can we do? As mentioned above, the solution is indirection and the Cgo
Wiki offers a simple example. Instead of passing a pointer to C directly, we
keep the pointer in Go-land and find a way to refer to it indirectly; we could
use some numeric index, for example. This guarantees that all pointers remain
visible to the Go GC, yet we can keep some unique identifier in C-land that will
let us access them later.&lt;/p&gt;
&lt;p&gt;This is what the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-pointer&lt;/span&gt;&lt;/tt&gt; package does, by creating a map between
&lt;tt class="docutils literal"&gt;unsafe.Pointer&lt;/tt&gt; (which maps to directly &lt;tt class="docutils literal"&gt;void*&lt;/tt&gt; in Cgo calls to C) and
&lt;tt class="docutils literal"&gt;interface{}&lt;/tt&gt;, essentially letting us store arbitrary Go data and providing a
unique ID (the &lt;tt class="docutils literal"&gt;unsafe.Pointer&lt;/tt&gt;) to refer to it later. Why is
&lt;tt class="docutils literal"&gt;unsafe.Pointer&lt;/tt&gt; used instead of an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; as in the Wiki example? Because
opaque data is often represented with &lt;tt class="docutils literal"&gt;void*&lt;/tt&gt; in C, so &lt;tt class="docutils literal"&gt;unsafe.Pointer&lt;/tt&gt; is
something that maps to it naturally. With an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; we'd have to worry about
casting in several additional places.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-if-there-is-no-user-data"&gt;
&lt;h2&gt;What if there is no &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt;?&lt;/h2&gt;
&lt;p&gt;Seeing how we use &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt; to tunnel the user-specific &lt;tt class="docutils literal"&gt;Visitor&lt;/tt&gt;
implementation through C code back to our generic callback, one may wonder -
what if there's no &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt; available?&lt;/p&gt;
&lt;p&gt;It turns out, in most cases there &lt;em&gt;is&lt;/em&gt; something like &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt;, because
without it the original C API is flawed. Consider our &lt;tt class="docutils literal"&gt;traverse&lt;/tt&gt; example
again, but this itme without &lt;tt class="docutils literal"&gt;user_data&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;StartCallbackFn&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;EndCallbackFn&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;StartCallbackFn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;EndCallbackFn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Callbacks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Callbacks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cbs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Suppose we provide a callback as &lt;tt class="docutils literal"&gt;start&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;myStart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Within &lt;tt class="docutils literal"&gt;myStart&lt;/tt&gt;, we're somewhat lost. We don't know &lt;em&gt;which&lt;/em&gt; traversal we
were invoked for - there could be many different traversals of different files
and data structures for different needs. We also don't know where to record
the results of the event. The only recourse here is using global data; this
is a bad API!&lt;/p&gt;
&lt;p&gt;Given such an API, we're not really much worse off in Go-land. We can also rely
on global data to find the information relevant to &lt;em&gt;this specific&lt;/em&gt; traversal,
and we can use the same &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-pointer&lt;/span&gt;&lt;/tt&gt; trick to store arbitrary Go objects in
this global data. But again, this situation is unlikely because the C API is
unlikely to omit this critical detail.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="links-to-additional-resources"&gt;
&lt;h2&gt;Links to additional resources&lt;/h2&gt;
&lt;p&gt;There's a lot of information about using Cgo out there, some of it dated (before
the &lt;a class="reference external" href="https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md"&gt;rules for passing pointers&lt;/a&gt;
were defined explicitly). Here's a collection of links I found particularly
useful in preparing this post:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://golang.org/cmd/cgo/"&gt;The official Cgo documentation&lt;/a&gt; is the source
of truth.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/golang/go/wiki/cgo"&gt;The Cgo page on the Wiki&lt;/a&gt; is
extremely useful.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.golang.org/go15gc"&gt;Some details about the concurrent GC in Go&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Yasuhiro Matsumoto's &lt;a class="reference external" href="https://dev.to/mattn/call-go-function-from-c-function-1n3"&gt;post on calling Go from C&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md"&gt;More details&lt;/a&gt;
on the pointer passing rules.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;They are in a separate file because of a peculiarity of how Cgo
generates and compiles C code - more details &lt;a class="reference external" href="https://github.com/golang/go/wiki/cgo#export-and-definition-in-preamble"&gt;on the Wiki&lt;/a&gt;.
The reason I'm not using the &lt;tt class="docutils literal"&gt;static inline&lt;/tt&gt; trick for these functions
is that we have to take their address.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Go"></category><category term="C &amp; C++"></category></entry><entry><title>Type erasure and reification</title><link href="https://eli.thegreenplace.net/2018/type-erasure-and-reification/" rel="alternate"></link><published>2018-12-05T05:10:00-08:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2018-12-05:/2018/type-erasure-and-reification/</id><summary type="html">&lt;p&gt;In this post I'd like to discuss the concepts of &lt;em&gt;type erasure&lt;/em&gt; and
&lt;em&gt;reification&lt;/em&gt; in programming languages. I don't intend to dive very deeply into
the specific rules of any particular language; rather, the post is going to
present several simple examples in multiple languages, hoping to provide enough
intuition …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I'd like to discuss the concepts of &lt;em&gt;type erasure&lt;/em&gt; and
&lt;em&gt;reification&lt;/em&gt; in programming languages. I don't intend to dive very deeply into
the specific rules of any particular language; rather, the post is going to
present several simple examples in multiple languages, hoping to provide enough
intuition and background for a more serious study, if necessary. As you'll
see, the actual concepts are very simple and familiar. Deeper details of
specific languages pertain more to the idiosyncrasies of those languages'
semantics and implementations.&lt;/p&gt;
&lt;p&gt;Important note: in C++ there is a programming pattern called &lt;em&gt;type erasure&lt;/em&gt;,
which is quite distinct from what I'm trying to describe here &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. I'll be
using C++ examples here, but that's to demonstrate how the original concepts
apply in C++. The programming pattern will be covered in a separate post.&lt;/p&gt;
&lt;div class="section" id="types-at-compile-time-no-types-at-run-time"&gt;
&lt;h2&gt;Types at compile time, no types at run-time&lt;/h2&gt;
&lt;p&gt;The title of this section is a &amp;quot;one short sentence&amp;quot; explanation of what type
erasure means. With few exceptions, it only applies to languages with some
degree of compile time (a.k.a. &lt;em&gt;static&lt;/em&gt;) type checking. The basic principle
should be immediately familiar to folks who have some idea of what machine code
generated from low-level languages like C looks like. While C has static typing,
this only matters in the compiler - the generated code is completely oblivious
to types.&lt;/p&gt;
&lt;p&gt;For example, consider the following C snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Frob_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Frob&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;extract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Frob&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;frob&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;frob&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;frob&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When compiling the function &lt;tt class="docutils literal"&gt;extract&lt;/tt&gt;, the compiler will perform type
checking. It won't let us access fields that were not declared in the struct,
for example. Neither will it let us pass a pointer to a different struct (or to
a &lt;tt class="docutils literal"&gt;float&lt;/tt&gt;) into &lt;tt class="docutils literal"&gt;extract&lt;/tt&gt;. But once it's done helping us, the compiler
generates code which is completely type-free:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:   8b 47 04                mov    0x4(%rdi),%eax
3:   0f af 47 24             imul   0x24(%rdi),%eax
7:   c3                      retq
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The compiler is familiar with the &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/"&gt;stack frame layout&lt;/a&gt; and
other specifics of the ABI, and generates code that assumes a correct type of
structure was passed in. If the actual type is not what this function expects,
there will be trouble (either accessing unmapped memory, or accessing wrong
data).&lt;/p&gt;
&lt;p&gt;A slightly adjusted example will clarify this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;extract_cast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Frob&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;frob&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;frob&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;frob&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The compiler will generate exactly identical code from this function, which in
itself a good indication of when the types matter and when they don't. What's
more interesting is that &lt;tt class="docutils literal"&gt;extract_cast&lt;/tt&gt; makes it extremely easy for
programmers to shoot themselves in the foot:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SomeOtherStruct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;extract_cast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// oops&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In general, &lt;em&gt;type erasure&lt;/em&gt; is a concept that descibes these semantics of a
language. Types matter to the compiler, which uses them to generate code and
help the programmer avoid errors. Once everything is type-checked, however, the
types are simply &lt;em&gt;erased&lt;/em&gt; and the code the compiler generates is oblivious to
them. The next section will put this in context by comparing to the opposite
approach.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reification-retaining-types-at-run-time"&gt;
&lt;h2&gt;Reification - retaining types at run-time&lt;/h2&gt;
&lt;p&gt;While erasure means the compiler discards all type information for the actual
generated code, &lt;em&gt;reification&lt;/em&gt; is the other way to go - types are retained at
run-time and used for perform various checks. A classical example from Java will
help demonstrate this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code creates an array of &lt;tt class="docutils literal"&gt;String&lt;/tt&gt;, and converts it to a generic array of
&lt;tt class="docutils literal"&gt;Object&lt;/tt&gt;. This is valid because arrays in Java
&lt;a class="reference external" href="https://eli.thegreenplace.net/2018/covariance-and-contravariance-in-subtyping/"&gt;are covariant&lt;/a&gt;,
so the compiler doesn't complain. However, in the next line we try to assign
an integer into the array. This happens to fail with an exception &lt;em&gt;at run-time&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.ArrayStoreException: java.lang.Integer
    at Main.main(Main.java:5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A type check was inserted into the generated code, and it fired when an
incorrect assignment was attempted. In other words, the type of &lt;tt class="docutils literal"&gt;objects&lt;/tt&gt; is
&lt;em&gt;reified&lt;/em&gt;. Reification is defined roughly as &amp;quot;taking something abstract and
making it real/concrete&amp;quot;, which when applied to types means &amp;quot;compile-time types
are converted to actual run-time entities&amp;quot;.&lt;/p&gt;
&lt;p&gt;C++ has some type reification support as well, e.g. with &lt;tt class="docutils literal"&gt;dynamic_cast&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;basefunc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;basefunc&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;derivedfunc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;derived&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;call_derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;derivedfunc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cast failed&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can call &lt;tt class="docutils literal"&gt;call_derived&lt;/tt&gt; thus:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;call_derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;call_derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first call will successfully invoke &lt;tt class="docutils literal"&gt;derivedfunc&lt;/tt&gt;; the second will not,
because the &lt;tt class="docutils literal"&gt;dynamic_cast&lt;/tt&gt; will return &lt;tt class="docutils literal"&gt;nullptr&lt;/tt&gt; at run-time. This is
because we're using C++'s &lt;em&gt;run-time type information&lt;/em&gt; (RTTI) capabilities here,
where an actual representation of the type is stored in the generated code (most
likely attached to the vtable which every polymorphic object points to). C++
also has the &lt;tt class="docutils literal"&gt;typeid&lt;/tt&gt; feature, but I'm showing &lt;tt class="docutils literal"&gt;dynamic_cast&lt;/tt&gt; since it's the
one most commonly used.&lt;/p&gt;
&lt;p&gt;Note particularly the differences between this sample and the C sample in the
beginning of the post. Conceptually, it's similar - we use a pointer to a
general type (in C that's &lt;tt class="docutils literal"&gt;void*&lt;/tt&gt;, in the C++ example we use a base type) to
interact with concrete types. Whereas in C there is no built-in run-time type
feature, in C++ we can use RTTI in some cases. With RTTI enabled,
&lt;tt class="docutils literal"&gt;dynamic_cast&lt;/tt&gt; can be used to interact with the run-time (reified)
representation of types in a limited but useful way.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="type-erasure-and-java-generics"&gt;
&lt;h2&gt;Type erasure and Java generics&lt;/h2&gt;
&lt;p&gt;One place where folks not necessarily familiar with programming language type
theory encounter erasure is Java generics, which were bolted onto the language
after a large amount of code has already been written. The designers of Java
faced the binary compatibility challenge, wherein they wanted code compiled with
newer Java compilers to run on older VMs.&lt;/p&gt;
&lt;p&gt;The solution was to use type erasure to implement generics entirely in the
compiler. Here's a quote from the &lt;a class="reference external" href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html"&gt;official Java generics tutorial&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Generics were introduced to the Java language to provide tighter type checks
at compile time and to support generic programming. To implement generics, the
Java compiler applies type erasure to:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Replace all type parameters in generic types with their bounds or Object if
the type parameters are unbounded. The produced bytecode, therefore,
contains only ordinary classes, interfaces, and methods.&lt;/li&gt;
&lt;li&gt;Insert type casts if necessary to preserve type safety.&lt;/li&gt;
&lt;li&gt;Generate bridge methods to preserve polymorphism in extended generic types.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here's a very simple example to demonstrate what's going on, taken from
&lt;a class="reference external" href="https://stackoverflow.com/a/339708/8206"&gt;a Stack Overflow answer&lt;/a&gt;. This code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.List&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.ArrayList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Uses a generic &lt;tt class="docutils literal"&gt;List&lt;/tt&gt;. However, what the compiler creates prior to emitting
bytecode is equivalent to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.List&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.ArrayList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here &lt;tt class="docutils literal"&gt;List&lt;/tt&gt; is a container of &lt;tt class="docutils literal"&gt;Object&lt;/tt&gt;, so we can assign any element to it
(similarly to the reification example shown in the previous section). The
compiler then inserts a cast when accessing that element as a string. In this
case the compiler will adamantly preserve type safety and won't let us do
&lt;tt class="docutils literal"&gt;list.add(5)&lt;/tt&gt; in the original snippet, because it sees that &lt;tt class="docutils literal"&gt;list&lt;/tt&gt; is a
&lt;tt class="docutils literal"&gt;List&amp;lt;String&amp;gt;&lt;/tt&gt;. Therefore, the cast to &lt;tt class="docutils literal"&gt;(String)&lt;/tt&gt; should be safe.&lt;/p&gt;
&lt;p&gt;Using type erasure to implement generics with backwards compatibility is a neat
idea, but it has its issues. Some folks complain that not having the types
available at runtime is a limitation (e.g. not being able to use &lt;tt class="docutils literal"&gt;instanceof&lt;/tt&gt;
and other reflection capabilities). Other languages, like C# and Dart 2, have
&lt;em&gt;reified generics&lt;/em&gt; which do preserve the type information at run-time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reification-in-dynamically-typed-languages"&gt;
&lt;h2&gt;Reification in dynamically typed languages&lt;/h2&gt;
&lt;p&gt;I hope it's obvious that the theory and techniques described above only apply
to statically-typed languages. In dynamically-typed languages, like Python,
there is almost no concept of types at compile-time, and types are a fully
reified concept. Even trivial errors like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;joe&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;         &lt;span class="c1"&gt;# &amp;lt;--- calling non-existent method&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fire at run-time, because there's no static type checking &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. Types obviously
exist at run-time, with functions like &lt;tt class="docutils literal"&gt;type()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;isinstance()&lt;/tt&gt; providing
complete reflection capabilities. The &lt;tt class="docutils literal"&gt;type()&lt;/tt&gt; function can even create new
types &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence"&gt;entirely at run-time&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;But it's most likely what you'll get to if you google for
&amp;quot;c++ type erasure&amp;quot;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;To be clear - this is not a bug; it's a feature of Python. A new method
can be added to classes dynamically at runtime (here, some code could
have defined a &lt;tt class="docutils literal"&gt;joe&lt;/tt&gt; method for &lt;tt class="docutils literal"&gt;Foo&lt;/tt&gt; before the &lt;tt class="docutils literal"&gt;f.joe()&lt;/tt&gt;
invocation), and the compiler has absolutely no way of knowing this could
or couldn't happen. So it has to assume such invocations are valid and
rely on run-time checking to avoid serious errors like memory corruption.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Programming"></category><category term="C &amp; C++"></category><category term="Python"></category></entry><entry><title>Covariance and contravariance in subtyping</title><link href="https://eli.thegreenplace.net/2018/covariance-and-contravariance-in-subtyping/" rel="alternate"></link><published>2018-10-17T05:35:00-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2018-10-17:/2018/covariance-and-contravariance-in-subtyping/</id><summary type="html">&lt;p&gt;Many programming languages support &lt;em&gt;subtyping&lt;/em&gt;, a kind of polymorphism that lets
us define hierarchical relations on types, with specific types being subtypes of
more generic types. For example, a Cat could be a subtype of Mammal, which
itself is a subtype of Vertebrate.&lt;/p&gt;
&lt;p&gt;Intuitively, functions that accept any Mammal would …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Many programming languages support &lt;em&gt;subtyping&lt;/em&gt;, a kind of polymorphism that lets
us define hierarchical relations on types, with specific types being subtypes of
more generic types. For example, a Cat could be a subtype of Mammal, which
itself is a subtype of Vertebrate.&lt;/p&gt;
&lt;p&gt;Intuitively, functions that accept any Mammal would accept a Cat too. More
formally, this is known as the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"&gt;Liskov substitution principle&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Let &lt;object class="valign-m4" data="https://eli.thegreenplace.net/images/math/981767307c6c4e0961591f103d7a2afbd4310648.svg" style="height: 18px;" type="image/svg+xml"&gt;\phi (x)&lt;/object&gt; be a property
provable about objects &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; of type &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;. Then &lt;object class="valign-m4" data="https://eli.thegreenplace.net/images/math/870ca38dfa9cd9a0f364eadfd23b9ec3722953c2.svg" style="height: 18px;" type="image/svg+xml"&gt;\phi (y)&lt;/object&gt;
should be true for objects &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; of type &lt;tt class="docutils literal"&gt;S&lt;/tt&gt; where &lt;tt class="docutils literal"&gt;S&lt;/tt&gt; is a subtype
of &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;.&lt;/blockquote&gt;
&lt;p&gt;A shorter way to say &lt;em&gt;S is a subtype of T&lt;/em&gt; is &lt;tt class="docutils literal"&gt;S &amp;lt;: T&lt;/tt&gt;. The relation &lt;tt class="docutils literal"&gt;&amp;lt;:&lt;/tt&gt;
is also sometimes expressed as &lt;object class="valign-m3" data="https://eli.thegreenplace.net/images/math/60fd4c42f3956e697cf94397160a51086fbb6f5b.svg" style="height: 15px;" type="image/svg+xml"&gt;\le&lt;/object&gt;, and can be thought of as &amp;quot;is less
general than&amp;quot;. So &lt;tt class="docutils literal"&gt;Cat &amp;lt;: Mammal&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Mammal &amp;lt;: Vertebrate&lt;/tt&gt;. Naturally,
&lt;tt class="docutils literal"&gt;&amp;lt;:&lt;/tt&gt; is transitive, so &lt;tt class="docutils literal"&gt;Cat &amp;lt;: Vertebrate&lt;/tt&gt;; it's also reflexive, as &lt;tt class="docutils literal"&gt;T
&amp;lt;: T&lt;/tt&gt; for any type T &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="kinds-of-variance-in-subtyping"&gt;
&lt;h2&gt;Kinds of variance in subtyping&lt;/h2&gt;
&lt;p&gt;Variance refers to how subtyping between composite types (e.g. list of Cats
versus list of Mammals) relates to subtyping between their components (e.g. Cats
and Mammals). Let's use the general &lt;tt class="docutils literal"&gt;Composite&amp;lt;T&amp;gt;&lt;/tt&gt; to refer to some composite
type with components of type &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Given types &lt;tt class="docutils literal"&gt;S&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; with the relation &lt;tt class="docutils literal"&gt;S &amp;lt;: T&lt;/tt&gt;, &lt;em&gt;variance&lt;/em&gt; is a way
to describe the relation between the composite types:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;em&gt;Covariant&lt;/em&gt; means the ordering of component types is preserved:
&lt;tt class="docutils literal"&gt;Composite&amp;lt;S&amp;gt; &amp;lt;: Composite&amp;lt;T&amp;gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Contravariant&lt;/em&gt; means the ordering is reversed: &lt;tt class="docutils literal"&gt;Composite&amp;lt;T&amp;gt; &amp;lt;:
Composite&amp;lt;S&amp;gt;&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Bivariant&lt;/em&gt; means both covariant and contravariant.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Invariant&lt;/em&gt; means neither covariant nor contravariant.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's a lot of theory and rules right in the beginning; the
following examples should help clarify all of this.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="covariance-in-return-types-of-overriding-methods-in-c"&gt;
&lt;h2&gt;Covariance in return types of overriding methods in C++&lt;/h2&gt;
&lt;p&gt;In C++, when a subclass method overrides a similarly named method in a
superclass, their signatures have to match. There is an important exception to
this rule, however. When the original return type is &lt;tt class="docutils literal"&gt;B*&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;B&amp;amp;&lt;/tt&gt;, the
return type of the overriding function is allowed to be &lt;tt class="docutils literal"&gt;D*&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;D&amp;amp;&lt;/tt&gt;
respectively, provided that &lt;tt class="docutils literal"&gt;D&lt;/tt&gt; is a public subclass of &lt;tt class="docutils literal"&gt;B&lt;/tt&gt;. This rule is
important to implement methods like &lt;tt class="docutils literal"&gt;Clone&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Mammal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Clone&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Cat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Clone&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Dog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Dog&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Clone&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can write functions like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;DoSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cloned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Do something with cloned&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cloned&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No matter what the concrete run-time class of &lt;tt class="docutils literal"&gt;m&lt;/tt&gt; is, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;m-&amp;gt;Clone()&lt;/span&gt;&lt;/tt&gt; will
return the right kind of object.&lt;/p&gt;
&lt;p&gt;Armed with our new terminology, we can say that the return type rule for
overriding methods is &lt;em&gt;covariant&lt;/em&gt; for pointer and reference types. In other
words, given &lt;tt class="docutils literal"&gt;Cat &amp;lt;: Mammal&lt;/tt&gt; we have &lt;tt class="docutils literal"&gt;Cat* &amp;lt;: Mammal*&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Being able to replace &lt;tt class="docutils literal"&gt;Mammal*&lt;/tt&gt; by &lt;tt class="docutils literal"&gt;Cat*&lt;/tt&gt; seems like a natural thing to
do in C++, but not all typing rules are covariant. Consider this code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;MammalClinic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;CatClinic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MammalClinic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looks legit? We have general &lt;tt class="docutils literal"&gt;MammalClinic&lt;/tt&gt;s that accept all mammals, and
more specialized &lt;tt class="docutils literal"&gt;CatClinic&lt;/tt&gt;s that only accept cats. Given a
&lt;tt class="docutils literal"&gt;MammalClinic*&lt;/tt&gt;, we should be able to call &lt;tt class="docutils literal"&gt;Accept&lt;/tt&gt; and the right one will
be invoked at run-time, right? Wrong. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CatClinic::Accept&lt;/span&gt;&lt;/tt&gt; does not actually
override &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;MammalClinic::Accept&lt;/span&gt;&lt;/tt&gt;; it simply overloads it. If we try to add
the &lt;tt class="docutils literal"&gt;override&lt;/tt&gt; keyword (as we should always do starting with C++11):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;CatClinic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MammalClinic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We'll get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;error: ‘virtual void CatClinic::Accept(Cat*)’ marked ‘override’, but does not override
   virtual void Accept(Cat* c) override;
                ^
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is precisely what the &lt;tt class="docutils literal"&gt;override&lt;/tt&gt; keyword was created for - help us find
erroneous assumptions about methods overriding other methods. The reality is
that function overrides are not covariant for pointer types. They are
&lt;em&gt;invariant&lt;/em&gt;. In fact, the vast majority of typing rules in C++ are invariant;
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::vector&amp;lt;Cat&amp;gt;&lt;/span&gt;&lt;/tt&gt; is not a subclass of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::vector&amp;lt;Mammal&amp;gt;&lt;/span&gt;&lt;/tt&gt;, even though
&lt;tt class="docutils literal"&gt;Cat &amp;lt;: Mammal&lt;/tt&gt;. As the next section demonstrates, there's a good reason for
that.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="covariant-arrays-in-java"&gt;
&lt;h2&gt;Covariant arrays in Java&lt;/h2&gt;
&lt;p&gt;Suppose we have &lt;tt class="docutils literal"&gt;PersianCat &amp;lt;: Cat&lt;/tt&gt;, and some class representing a list of
cats. Does it make sense for lists to be covariant? On initial thought, yes. Say
we have this (pseudocode) function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MakeThemMeow(List&amp;lt;Cat&amp;gt; lst) {
    for each cat in lst {
        cat-&amp;gt;Meow()
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why shouldn't we be able to pass a &lt;tt class="docutils literal"&gt;List&amp;lt;PersianCat&amp;gt;&lt;/tt&gt; into it? After all,
all persian cats are cats, so they can all meow! As long as lists are immutable,
this is actually safe. The problem appears when lists can be modified. The
best example of this problem can be demonstrated with actual Java code, since
in Java array constructors are covariant:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;house&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;daisy&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// covariant&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cauliflower&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// works fine&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;// throws exception&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Java, &lt;tt class="docutils literal"&gt;String &amp;lt;: Object&lt;/tt&gt;, and since arrays are covariant, it means that
&lt;tt class="docutils literal"&gt;String[] &amp;lt;: Object[]&lt;/tt&gt;, which makes the assignment on the line marked with
&amp;quot;covariant&amp;quot; type-check successfully. From that point on, &lt;tt class="docutils literal"&gt;objects&lt;/tt&gt; is an
array of &lt;tt class="docutils literal"&gt;Object&lt;/tt&gt; as far as the compiler is concerned, so assigning anything
that's a subclass of &lt;tt class="docutils literal"&gt;Object&lt;/tt&gt; to its elements is kosher, including integers
&lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;. Therefore the last line in &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; throws an exception &lt;em&gt;at run-time&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.ArrayStoreException: java.lang.Integer
    at Main.main(Main.java:7)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Assigning an integer fails because at run-time it's known that &lt;tt class="docutils literal"&gt;objects&lt;/tt&gt; is
actually an array of &lt;em&gt;strings&lt;/em&gt;. Thus, covariance together with mutability makes
array types unsound. Note, however, that this is not just a mistake - it's a
deliberate historical decision made when Java didn't have generics and
polymorphism was still desired; the same problem exists in C# - &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29#Covariant_arrays_in_Java_and_C.23"&gt;read this for
more details&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Other languages have immutable containers, which can then be made covariant
without jeopardizing the soundness of the type system. For example in OCaml
lists are immutable and covariant.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="contravariance-for-function-types"&gt;
&lt;h2&gt;Contravariance for function types&lt;/h2&gt;
&lt;p&gt;Covariance seems like a pretty intuitive concept, but what about contravariance?
When does it make sense to reverse the subtyping relation for composite types
to get &lt;tt class="docutils literal"&gt;Composite&amp;lt;T&amp;gt; &amp;lt;: Composite&amp;lt;S&amp;gt;&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;S &amp;lt;: T&lt;/tt&gt;?&lt;/p&gt;
&lt;p&gt;An important use case is &lt;em&gt;function types&lt;/em&gt;. Consider a function that takes a
&lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt; and returns a &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt;; in functional programming the type of this
function is commonly referred to as &lt;tt class="docutils literal"&gt;Mammal &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Mammal&lt;/tt&gt;. Which function types
are valid subtypes of this type?&lt;/p&gt;
&lt;p&gt;Here's a pseudo-code definition that makes it easier to discuss:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;func user(f : Mammal -&amp;gt; Mammal) {
  // do stuff with &amp;#39;f&amp;#39;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Can we call &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; providing it a function of type &lt;tt class="docutils literal"&gt;Mammal &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Cat&lt;/tt&gt; as &lt;tt class="docutils literal"&gt;f&lt;/tt&gt;?
Inside its body, &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; may invoke &lt;tt class="docutils literal"&gt;f&lt;/tt&gt; and expect its return value to be
a &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt;. Since &lt;tt class="docutils literal"&gt;Mammal &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Cat&lt;/tt&gt; returns cats, that's fine, so this usage
is safe. It aligns with our earlier intuition that covariance makes sense for
function return types.&lt;/p&gt;
&lt;p&gt;Note that passing a &lt;tt class="docutils literal"&gt;Mammal &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Vertebrate&lt;/tt&gt; function as &lt;tt class="docutils literal"&gt;f&lt;/tt&gt; doesn't work as
well, because &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; expects &lt;tt class="docutils literal"&gt;f&lt;/tt&gt; to return &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt;s, but our function
may return a &lt;tt class="docutils literal"&gt;Vertebrate&lt;/tt&gt; that's not a &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt; (maybe a &lt;tt class="docutils literal"&gt;Bird&lt;/tt&gt;).
Therefore, function return types are not contravariant.&lt;/p&gt;
&lt;p&gt;But what about function parameters? So far we've been looking at function types
that take &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt; - an exact match for the expected signature of &lt;tt class="docutils literal"&gt;f&lt;/tt&gt;. Can
we call &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; with a function of type &lt;tt class="docutils literal"&gt;Cat &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Mammal&lt;/tt&gt;? No, because &lt;tt class="docutils literal"&gt;user&lt;/tt&gt;
expects to be able to pass any kind of &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt; into &lt;tt class="docutils literal"&gt;f&lt;/tt&gt;, not just
&lt;tt class="docutils literal"&gt;Cat&lt;/tt&gt;s. So function parameters are not covariant. On the other hand, it
should be safe to pass a function of type &lt;tt class="docutils literal"&gt;Vertebrate &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Mammal&lt;/tt&gt; as &lt;tt class="docutils literal"&gt;f&lt;/tt&gt;,
because it can take any &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt;, and that's what &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; is going to pass to
it. So contravariance makes sense for function parameters.&lt;/p&gt;
&lt;p&gt;Most generally, we can say that &lt;tt class="docutils literal"&gt;Vertebrate &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Cat&lt;/tt&gt; is a subtype of &lt;tt class="docutils literal"&gt;Mammal
&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Mammal&lt;/tt&gt;, because parameters types are contravariant and return types are
covariant. A nice quote that can help remember these rules is: &lt;em&gt;be liberal in
what you accept and conservative in what you produce&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is not just theory; if we go back to C++, this is exactly how function
types with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::function&lt;/span&gt;&lt;/tt&gt; behave:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vertebrate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Mammal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Vertebrate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Cat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Vertebrate&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;Vertebrate&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Vertebrate&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// do stuff with &amp;#39;f&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;// works&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The invocation &lt;tt class="docutils literal"&gt;User(f1)&lt;/tt&gt; compiles, because &lt;tt class="docutils literal"&gt;f1&lt;/tt&gt; is convertible to the type
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::function&amp;lt;Mammal*(Mammal*)&amp;gt;&lt;/span&gt;&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;. Had we tried to invoke &lt;tt class="docutils literal"&gt;User(f2)&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;User(f3)&lt;/tt&gt;, they would fail because neither &lt;tt class="docutils literal"&gt;f2&lt;/tt&gt; nor &lt;tt class="docutils literal"&gt;f3&lt;/tt&gt; are proper
subtypes of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::function&amp;lt;Mammal*(Mammal*)&amp;gt;&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bivariance"&gt;
&lt;h2&gt;Bivariance&lt;/h2&gt;
&lt;p&gt;So far we've seen examples of invariance, covariance and contravariance. What
about bivariance? Recall, bivariance means that given &lt;tt class="docutils literal"&gt;S &amp;lt;: T&lt;/tt&gt;, both
&lt;tt class="docutils literal"&gt;Composite&amp;lt;S&amp;gt; &amp;lt;: Composite&amp;lt;T&amp;gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Composite&amp;lt;T&amp;gt; &amp;lt;: Composite&amp;lt;S&amp;gt;&lt;/tt&gt; are true.
When is this useful? Not often at all, it turns out.&lt;/p&gt;
&lt;p&gt;In TypeScript, function parameters are bivariant. The following code compiles
correctly but fails at run-time:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;trainDog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cloneAnimal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;source&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;done&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Runtime error here occurs because we end up invoking &amp;#39;trainDog&amp;#39; with a &amp;#39;Cat&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nx"&gt;cloneAnimal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;trainDog&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, this is not because the TypeScript designers are incompetent. The
reason is fairly intricate and explained &lt;a class="reference external" href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant"&gt;on this page&lt;/a&gt;;
the summary is that it's needed to help the type-checker treat functions that
don't mutate their arguments as covariant for arrays.&lt;/p&gt;
&lt;p&gt;That said, in &lt;a class="reference external" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html"&gt;TypeScript 2.6 this is being changed&lt;/a&gt;
with a new strictness flag that treats parameters only contravariantly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="explicit-variance-specification-in-python-type-checking"&gt;
&lt;h2&gt;Explicit variance specification in Python type-checking&lt;/h2&gt;
&lt;p&gt;If you had to guess which of the mainstream languages has the most advanced
support for variance in their type system, Python probably wouldn't be your
first guess, right? I admit it wasn't mine either, because Python is dynamically
(duck) typed. But the new type hinting support (described in &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0484/"&gt;PEP 484&lt;/a&gt; with more details in &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0483/"&gt;PEP 483&lt;/a&gt;) is actually fairly advanced.&lt;/p&gt;
&lt;p&gt;Here's an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Mammal&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;count_mammals_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;mlst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count_mammals_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mlst&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we run &lt;tt class="docutils literal"&gt;mypy&lt;/tt&gt; type-checking on this code, it will succeed.
&lt;tt class="docutils literal"&gt;count_mammals_list&lt;/tt&gt; takes a list of &lt;tt class="docutils literal"&gt;Mammal&lt;/tt&gt;s, and this is what we passed
in; so far, so good. However, the following will fail:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;clst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count_mammals_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clst&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because &lt;tt class="docutils literal"&gt;List&lt;/tt&gt; is not covariant. Python doesn't know whether
&lt;tt class="docutils literal"&gt;count_mammals_list&lt;/tt&gt; will modify the list, so allowing calls with a list of
&lt;tt class="docutils literal"&gt;Cat&lt;/tt&gt;s is potentially unsafe.&lt;/p&gt;
&lt;p&gt;It turns out that the &lt;tt class="docutils literal"&gt;typing&lt;/tt&gt; module lets us express the variance of types
explicitly. Here's a very minimal &amp;quot;immutable list&amp;quot; implementation that only
supports counting elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;T_co&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TypeVar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;T_co&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;covariant&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ImmutableList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Generic&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;T_co&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;T_co&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__len__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now if we define:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;count_mammals_ilist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ImmutableList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Mammal&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can actually invoke it with a &lt;tt class="docutils literal"&gt;ImmutableList&lt;/tt&gt; of &lt;tt class="docutils literal"&gt;Cat&lt;/tt&gt;s, and this will
pass type checking:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cimmlst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImmutableList&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Cat&lt;/span&gt;&lt;span class="p"&gt;()])&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count_mammals_ilist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cimmlst&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Similarly, we can support contravariant types, etc. The &lt;tt class="docutils literal"&gt;typing&lt;/tt&gt; module also
provides a number of useful built-ins; for example, it's not really necessary
to create an &lt;tt class="docutils literal"&gt;ImmutableList&lt;/tt&gt; type, as there's already a &lt;tt class="docutils literal"&gt;Sequence&lt;/tt&gt; type that
is covariant.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In most cases &lt;tt class="docutils literal"&gt;&amp;lt;:&lt;/tt&gt; is also antisymmetric, making it a
&lt;a class="reference external" href="https://eli.thegreenplace.net/2018/partial-and-total-orders/"&gt;partial order&lt;/a&gt;,
but in some cases it isn't; for example, structs with permuted fields can
be considered subtypes of each other (in most languages they aren't!) but
such subtyping is not antisymmetric.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;These terms come from math, and a good
rule of thumb to remember how they apply is: &lt;em&gt;co&lt;/em&gt; means together, while
&lt;em&gt;contra&lt;/em&gt; means against. As long as the composite types vary together (in
the same direction) as their component types, they are &lt;em&gt;co&lt;/em&gt;-variant. When
they vary against their component types (in the reverse direction), they
are &lt;em&gt;contra&lt;/em&gt;-variant.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Strictly speaking, integer literals like &lt;tt class="docutils literal"&gt;5&lt;/tt&gt; are primitives in Java
and not objects at all. However, due to &lt;a class="reference external" href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html"&gt;autoboxing&lt;/a&gt;,
this is equivalent to wrapping the &lt;tt class="docutils literal"&gt;5&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;Integer&lt;/tt&gt; prior to the
assignment.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that we're using pointer types here. The same example would work
with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::function&amp;lt;Mammal(Mammal)&amp;gt;&lt;/span&gt;&lt;/tt&gt; and corresponding &lt;tt class="docutils literal"&gt;f1&lt;/tt&gt; taking
and returning value types. It's just that in C++ value types are not
very useful for polymorphism, so pointer (or reference) values are much
more commonly used.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Programming"></category><category term="Python"></category><category term="C &amp; C++"></category></entry><entry><title>Measuring context switching and memory overheads for Linux threads</title><link href="https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/" rel="alternate"></link><published>2018-09-04T05:35:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2018-09-04:/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/</id><summary type="html">&lt;p&gt;In this post I want to explore the costs of threads on modern Linux machines,
both in terms of time and space. The background context is designing high-load
concurrent servers, where &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-2-threads/"&gt;using threads is one of the common schemes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Important disclaimer: it's not my goal here to provide an opinion …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I want to explore the costs of threads on modern Linux machines,
both in terms of time and space. The background context is designing high-load
concurrent servers, where &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-2-threads/"&gt;using threads is one of the common schemes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Important disclaimer: it's not my goal here to provide an opinion in the threads
vs. event-driven models debate. Ultimately, both are tools that work well in
some scenarios and less well in others. That said, one of the major criticisms
of a thread-based model is the cost - comments like &amp;quot;but context switches are
expensive!&amp;quot; or &amp;quot;but a thousand threads will eat up all your RAM!&amp;quot;, and I do
intend to study the data underlying such claims in more detail here. I'll do
this by presenting multiple code samples and programs that make it easy to
explore and experiment with these measurements.&lt;/p&gt;
&lt;div class="section" id="linux-threads-and-nptl"&gt;
&lt;h2&gt;Linux threads and NPTL&lt;/h2&gt;
&lt;p&gt;In the dark, old ages before version 2.6, the Linux kernel didn't have much
specific support for threads, and they were more-or-less hacked on top of
process support. Before &lt;a class="reference external" href="https://eli.thegreenplace.net/2018/basics-of-futexes/"&gt;futexes&lt;/a&gt; there was no dedicated
low-latency synchronization solution (it was done using signals); neither was
there much good use of the capabilities of multi-core systems &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The Native POSIX Thread Library (NPTL) was proposed by Ulrich Drepper and Ingo
Molnar from Red Hat, and integrated into the kernel in version 2.6, circa 2005.
I warmly recommend reading its &lt;a class="reference external" href="https://www.akkadia.org/drepper/nptl-design.pdf"&gt;design paper&lt;/a&gt;. With NPTL, thread creation
time became about 7x faster, and synchronization became much faster as well due
to the use of futexes. Threads and processes became more lightweight, with
strong emphasis on making good use of multi-core processors. This roughly
coincided with a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/O(1)_scheduler"&gt;much more efficient scheduler&lt;/a&gt;, which made juggling many
threads in the Linux kernel even more efficient.&lt;/p&gt;
&lt;p&gt;Even though all of this happened 13 years ago, the spirit of NPTL is still
easily observable in some system programming code. For example, many thread and
synchronization-related paths in &lt;tt class="docutils literal"&gt;glibc&lt;/tt&gt; have &lt;tt class="docutils literal"&gt;nptl&lt;/tt&gt; in their name.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="threads-processes-and-the-clone-system-call"&gt;
&lt;h2&gt;Threads, processes and the clone system call&lt;/h2&gt;
&lt;p&gt;This was originally meant to be a part of this larger article, but it was
getting too long so I split off a separate post on &lt;a class="reference external" href="https://eli.thegreenplace.net/2018/launching-linux-threads-and-processes-with-clone/"&gt;launching Linux processes
and threads with clone&lt;/a&gt;,
where you can learn about the &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; system call and some measurements of how
expensive it is to launch new processes and threads.&lt;/p&gt;
&lt;p&gt;The rest of this post will assume this is familiar information and will focus
on context switching and memory usage.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-happens-in-a-context-switch"&gt;
&lt;h2&gt;What happens in a context switch?&lt;/h2&gt;
&lt;p&gt;In the Linux kernel, this question has two important parts:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;em&gt;When&lt;/em&gt; does a kernel switch happen&lt;/li&gt;
&lt;li&gt;&lt;em&gt;How&lt;/em&gt; it happens&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The following deals mostly with (2), assuming the kernel has already decided to
switch to a different user thread (for example because the currently running
thread went to sleep waiting for I/O).&lt;/p&gt;
&lt;p&gt;The first thing that happens during a context switch is a switch to kernel mode,
either through an explicit system call (such as &lt;tt class="docutils literal"&gt;write&lt;/tt&gt; to some file or pipe)
or a timer interrupt (when the kernel preempts a user thread whose time slice
has expired). This requires saving the user space thread's registers and
jumping into kernel code.&lt;/p&gt;
&lt;p&gt;Next, the scheduler kicks in to figure out which thread should run next. When
we know which thread runs next, there's the important bookkeeping of virtual
memory to take care of; the page tables of the new thread have to be loaded into
memory, etc.&lt;/p&gt;
&lt;p&gt;Finally, the kernel restores the new thread's registers and cedes control back
to user space.&lt;/p&gt;
&lt;p&gt;All of this takes time, but how much time, exactly? I encourage you to read some
additional online resources that deal with this question, and try to run
benchmarks like &lt;a class="reference external" href="http://www.bitmover.com/lmbench/"&gt;lm_bench&lt;/a&gt;; what follows is
my attempt to quantify thread switching time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-expensive-are-context-switches"&gt;
&lt;h2&gt;How expensive are context switches?&lt;/h2&gt;
&lt;p&gt;To measure how long it takes to switch between two threads, we need a benchmark
that deliberatly triggers a context switch and avoids doing too much work in
addition to that. This would be measuring just the &lt;em&gt;direct&lt;/em&gt; cost of the switch,
when in reality there is another cost - the &lt;em&gt;indirect&lt;/em&gt; one, which could even
be larger. Every thread has some working set of memory, all or some of which
is in the cache; when we switch to another thread, all this cache data becomes
unneeded and is slowly flushed out, replaced by the new thread's data. Frequent
switches back and forth between the two threads will cause a lot of such
thrashing.&lt;/p&gt;
&lt;p&gt;In my benchmarks I am not measuring this indirect cost, because it's pretty
difficult to avoid in any form of multi-tasking. Even if we &amp;quot;switch&amp;quot; between
different asynchronous event handlers within the same thread, they will likely
have different memory working sets and will interfere with each other's cache
usage if those sets are large enough. I strongly recommend watching &lt;a class="reference external" href="https://youtu.be/KXuZi9aeGTw"&gt;this
talk on fibers&lt;/a&gt; where a Google engineer explains
their measurement methodology and also how to avoid too much indirect switch
costs by making sure closely related tasks run with temporal locality.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2018/threadoverhead"&gt;These code samples&lt;/a&gt;
measure context switching overheads using two different techniques:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;A pipe which is used by two threads to ping-pong a tiny amount of data.
Every &lt;tt class="docutils literal"&gt;read&lt;/tt&gt; on the pipe blocks the reading thread, and the kernel switches
to the writing thread, and so on.&lt;/li&gt;
&lt;li&gt;A condition variable used by two threads to signal an event to each other.&lt;/li&gt;
&lt;/ol&gt;
&lt;img alt="Ping pong paddles and ball" class="align-center" src="https://eli.thegreenplace.net/images/2018/ping-pong.png" /&gt;
&lt;p&gt;There are additional factors context switching time depends on; for example,
on a multi-core CPU, the kernel can occasionally migrate a thread between cores
because the core a thread has been previously using is occupied. While this
helps utilize more cores, such switches cost more than staying on the same core
(again, due to cache effects). Benchmarks can try to restrict this by running
with &lt;tt class="docutils literal"&gt;taskset&lt;/tt&gt; pinning affinity to one core, but it's important to keep in
mind this only models a lower bound.&lt;/p&gt;
&lt;p&gt;Using the two techniques I'm getting fairly similar results: somewhere between
1.2 and 1.5 microseconds per context switch, accounting only for the direct
cost, and pinning to a single core to avoid migration costs. Without pinning,
the switch time goes up to ~2.2 microseconds &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. These numbers are largely
consistent with the reports in the fibers talk mentioned above, and also with
other benchmarks found online (like &lt;tt class="docutils literal"&gt;lat_ctx&lt;/tt&gt; from &lt;tt class="docutils literal"&gt;lmbench&lt;/tt&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-does-this-mean-in-practice"&gt;
&lt;h2&gt;What does this mean in practice?&lt;/h2&gt;
&lt;p&gt;So we have the numbers now, but what do they mean? Is 1-2 us a long time? As I
have mentioned in &lt;a class="reference external" href="https://eli.thegreenplace.net/2018/launching-linux-threads-and-processes-with-clone/"&gt;the post on launch overheads&lt;/a&gt;,
a good comparison is &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt;, which takes 3 us for 64 KiB on the same
machine. In other words, a context switch is a bit quicker than copying 64 KiB
of memory from one location to another.&lt;/p&gt;
&lt;img alt="Plot of thread/process launch and context switch" class="align-center" src="https://eli.thegreenplace.net/images/2018/plot-launch-switch.png" /&gt;
&lt;p&gt;1-2 us is not a long time by any measure, except when you're really trying to
optimize for extremely low latencies or high loads.&lt;/p&gt;
&lt;p&gt;As an example of an artificially high load, &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/threadoverhead/thread-pipe-msgpersec.c"&gt;here is another benchmark&lt;/a&gt;
which writes a short message into a pipe and expects to read it from another
pipe. On the other end of the two pipes is a thread that echoes one into the
other.&lt;/p&gt;
&lt;p&gt;Running the benchmark on the same machine I used to measure the context switch
times, I get ~400,000 iterations per second (this is with &lt;tt class="docutils literal"&gt;taskset&lt;/tt&gt; to pin
to a single core). This makes perfect sense given the earlier measurements,
because each iteration of this test performs two context switches, and at 1.2 us
per switch this is 2.4 us per iteration.&lt;/p&gt;
&lt;p&gt;You could claim that the two threads compete for the same CPU, but if I don't
pin the benchmark to a single core, the number of iterations per second
&lt;em&gt;halves&lt;/em&gt;. This is because the vast majority of time in this benchmark is spent
in the kernel switching from one thread to the other, and the core migrations
that occur when it's not pinned greatly ouweigh the loss of (the very minimal)
parallelism.&lt;/p&gt;
&lt;p&gt;Just for fun, I rewrote the &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/threadoverhead/channel-msgpersec.go"&gt;same benchmark in Go&lt;/a&gt;;
two goroutines ping-ponging short message between themselves over a channel. The
throughput this achieves is &lt;em&gt;dramatically&lt;/em&gt; higher - around 2.8 million
iterations per second, which leads to an estimate of ~170 ns switching between
goroutines &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;. Since switching between goroutines doesn't require an actual
kernel context switch (or even a system call), this isn't too surprising. For
comparison, &lt;a class="reference external" href="https://youtu.be/KXuZi9aeGTw"&gt;Google's fibers&lt;/a&gt; use a new Linux
system call that can switch between two tasks in about the same time,
&lt;em&gt;including&lt;/em&gt; the kernel time.&lt;/p&gt;
&lt;p&gt;A word of caution: benchmarks tend to be taken too seriously. Please take this
one only for what it demonstrates - a largely synthetical workload used to
poke into the cost of some fundamental concurrency primitives.&lt;/p&gt;
&lt;p&gt;Remember - it's quite unlikely that the actual workload of your task will be
negligible compared to the 1-2 us context switch; as we've seen, even a modest
&lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt; takes longer. Any sort of server logic such as parsing headers,
updating state, etc. is likely to take orders of magnitude longer. If there's
one takeaway to remember from these sections is that context switching on modern
Linux systems is &lt;em&gt;super fast&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-usage-of-threads"&gt;
&lt;h2&gt;Memory usage of threads&lt;/h2&gt;
&lt;p&gt;Now it's time to discuss the other overhead of a large number of threads -
memory. Even though all threads in a process share their, there are
still areas of memory that aren't shared. In the &lt;a class="reference external" href="https://eli.thegreenplace.net/2018/launching-linux-threads-and-processes-with-clone/"&gt;post about clone&lt;/a&gt;
we've mentioned &lt;em&gt;page tables&lt;/em&gt; in the kernel, but these are comparatively small.
A much larger memory area that it private to each thread is the &lt;em&gt;stack&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The default per-thread stack size on Linux is usually 8 MiB, and we can check
what it is by invoking &lt;tt class="docutils literal"&gt;ulimit&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ulimit -s
8192
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To see this in action, let's start a large number of threads and observe the
process's memory usage. &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/threadoverhead/threadspammer.c"&gt;This sample&lt;/a&gt;
launches 10,000 threads and sleeps for a bit to let us observe its memory usage
with external tools. Using tools like &lt;tt class="docutils literal"&gt;top&lt;/tt&gt; (or preferably &lt;tt class="docutils literal"&gt;htop&lt;/tt&gt;) we see
that the process uses ~80 GiB of &lt;em&gt;virtual&lt;/em&gt; memory, with about 80 MiB of
&lt;em&gt;resident&lt;/em&gt; memory. What is the difference, and how can it use 80 GiB of memory
on a machine that only has 16 available?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="virtual-vs-resident-memory"&gt;
&lt;h2&gt;Virtual vs. Resident memory&lt;/h2&gt;
&lt;p&gt;A short interlude on what virtual memory means. When a Linux program allocates
memory (with &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt;) or otherwise, this memory initially doesn't really
exist - it's just an entry in a table the OS keeps. Only when the program
actually accesses the memory is the backing RAM for it found; this is what
virtual memory is all about.&lt;/p&gt;
&lt;p&gt;Therefore, the &amp;quot;memory usage&amp;quot; of a process can mean two things - how much
&lt;em&gt;virtual&lt;/em&gt; memory it uses overall, and how much &lt;em&gt;actual&lt;/em&gt; memory it uses. While
the former can grow almost without bounds - the latter is obviously limited to
the system's RAM capacity (with swapping to disk being the other mechanism of
virtual memory to assist here if usage grows above the side of physical memory).
The actual physical memory on Linux is called &amp;quot;resident&amp;quot; memory, because it's
actually resident in RAM.&lt;/p&gt;
&lt;p&gt;There's a &lt;a class="reference external" href="https://stackoverflow.com/q/7880784"&gt;good StackOverflow discussion&lt;/a&gt;
of this topic; here I'll just limit myself to a simple example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;report_memory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;started&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;escape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;report_memory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after malloc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;report_memory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after touch&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;press ENTER&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;fgetc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This program starts by allocating 400 MiB of memory (assuming an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; size of
4) with &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt;, and later &amp;quot;touches&amp;quot; this memory by writing a number into
every element of the allocated array. It reports its own memory usage at every
step - see &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/threadoverhead/malloc-memusage.c"&gt;the full code sample&lt;/a&gt;
for the reporting code &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;. Here's the output from a sample run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./malloc-memusage
started: max RSS = 4780 kB; vm size = 6524 kB
after malloc: max RSS = 4780 kB; vm size = 416128 kB
after touch: max RSS = 410916 kB; vm size = 416128 kB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most interesting thing to note is how &lt;tt class="docutils literal"&gt;vm size&lt;/tt&gt; remains the same between
the second and third steps, while &lt;tt class="docutils literal"&gt;max RSS&lt;/tt&gt; grows from the initial value to
400 MiB. This is precisely because until we touch the memory, it's fully
&amp;quot;virtual&amp;quot; and isn't actually counted for the process's RAM usage.&lt;/p&gt;
&lt;p&gt;Therefore, distinguishing between virtual memory and RSS in realistic usage is
very important - this is why the thread launching sample from the previous section
could &amp;quot;allocate&amp;quot; 80 GiB of virtual memory while having only 80 MiB of resident
memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="back-to-memory-overhead-for-threads"&gt;
&lt;h2&gt;Back to memory overhead for threads&lt;/h2&gt;
&lt;p&gt;As we've seen, a new thread on Linux is created with 8 MiB of stack space, but
this is virtual memory until the thread actually uses it. If the thread actually
uses its stack, resident memory usage goes up dramatically for a large number of
threads. I've added a configuration option to the sample program that launches a
large number of threads; with it enabled, the thread function actually &lt;em&gt;uses&lt;/em&gt;
stack memory and from the RSS report it is easy to observe the effects.
Curiously, if I make each of 10,000 threads use 400 KiB of memory, the total RSS
is not 4 GiB but around 2.6 GiB &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;How to we control the stack size of threads? One option is using the &lt;tt class="docutils literal"&gt;ulimit&lt;/tt&gt;
command, but a better option is with the &lt;tt class="docutils literal"&gt;pthread_attr_setstacksize&lt;/tt&gt; API. The
latter is invoked programatically and populates a &lt;tt class="docutils literal"&gt;pthread_attr_t&lt;/tt&gt; structure
that's passed to thread creation. The more interesting question is - what should
the stack size be set to?&lt;/p&gt;
&lt;p&gt;As we have seen above, just creating a large stack for a thread doesn't
automatically eat up all the machine's memory - not before the stack is
being used. If our threads actually &lt;em&gt;use&lt;/em&gt; large amounts of stack memory, this is
a problem, because this severely limits the number of threads we can run
concurrently. Note that this is not really a problem with threads - but with
concurrency; if our program uses some event-driven approach to concurrency and
each handler uses a large amount of memory, we'd still have the same problem.&lt;/p&gt;
&lt;p&gt;If the task doesn't actually use a lot of memory, what should we set the stack
size to? Small stacks keep the OS safe - a deviant program may get into an
infinite recursion and a small stack will make sure it's killed early. Moreover,
virtual memory is large but not unlimited; especially on 32-bit OSes, we might
not have 80 GiB of virtual address space for the process, so a 8 MiB stack for
10,000 threads makes no sense. There's a tradeoff here, and the default chosen
by 32-bit Linux is 2 MiB; the maximal virtual address space available is 3 GiB,
so this imposes a limit of ~1500 threads with the default settings. On 64-bit
Linux the virtual address space is vastly larger, so this limitation is less
serious (though other limits kick in - on my machine the maximal number of
threads the OS lets one process start is about 32K).&lt;/p&gt;
&lt;p&gt;Therefore I think it's more important to focus on how much actual memory each
concurrent task is using than on the OS stack size limit, as the latter is
simply a safety measure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The numbers reported here paint an interesting picture on the state of Linux
multi-threaded performance in 2018. I would say that the limits still
exist - running a million threads is probably not going to make sense; however,
the limits have definitely shifted since the past, and a lot of folklore from
the early 2000s doesn't apply today. On a beefy multi-core machine with lots
of RAM we can easily run 10,000 threads in a single process today, in
production. As I've mentioned above, it's highly recommended to watch Google's
&lt;a class="reference external" href="https://youtu.be/KXuZi9aeGTw"&gt;talk on fibers&lt;/a&gt;; through careful tuning of
the kernel (and setting smaller default stacks) Google is able to run an order
of magnitude more threads in parallel.&lt;/p&gt;
&lt;p&gt;Whether this is sufficient concurrency for your application is very obviously
project-specific, but I'd say that for higher concurrencies you'd probably want
to mix in some asynchronous processing. If 10,000 threads can provide sufficient
concurrency - you're in luck, as this is a much simpler model - all the code
within the threads is serial, there are no issues with blocking, etc.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;For example, in order to implement POSIX semantics properly, a
single thread was designated as a &amp;quot;manager&amp;quot; and managed operations like
&amp;quot;create a new thread&amp;quot;. This created an unfortunate serialization point
and a bottleneck.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;These numbers also vary greatly between CPUs. The numbers reported herein
are on my Haswell i7-4771. On a different contemporary machine (a low-end
Xeon) I measured switch times that were about 50-75% longer.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Curiously, pinning the Go program to a single core (by means of
setting &lt;tt class="docutils literal"&gt;GOMAXPROCS=1&lt;/tt&gt; and running with &lt;tt class="docutils literal"&gt;taskset&lt;/tt&gt;) increases the
throughput by only by 10% or so. The Go scheduler is not optimized for
this strange use case of endless hammering between two goroutine, but it
performs very well regardless.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that while for resident memory there's a convenient &lt;tt class="docutils literal"&gt;getrusage&lt;/tt&gt;
API, to report virtual memory size we have to parse &lt;tt class="docutils literal"&gt;/proc/PID/status&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;According to Tom Dryer, recent Linux version only approximate this usage,
which could explain the discrepancy - see &lt;a class="reference external" href="https://gist.github.com/tdryer/7ef02a89169252552978b6773c731109"&gt;this explanation&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Concurrency"></category><category term="C &amp; C++"></category><category term="Linux"></category></entry><entry><title>Launching Linux threads and processes with clone</title><link href="https://eli.thegreenplace.net/2018/launching-linux-threads-and-processes-with-clone/" rel="alternate"></link><published>2018-08-01T06:14:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2018-08-01:/2018/launching-linux-threads-and-processes-with-clone/</id><summary type="html">&lt;p&gt;Due to variation between operating systems and the way OS courses are taught,
some programmers may have an outdated mental model about the difference between
processes and threads in Linux. Even the name &amp;quot;thread&amp;quot; suggests something
extremely lightweight compared to a heavy &amp;quot;process&amp;quot; - a mostly wrong intuition.&lt;/p&gt;
&lt;p&gt;In fact, for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Due to variation between operating systems and the way OS courses are taught,
some programmers may have an outdated mental model about the difference between
processes and threads in Linux. Even the name &amp;quot;thread&amp;quot; suggests something
extremely lightweight compared to a heavy &amp;quot;process&amp;quot; - a mostly wrong intuition.&lt;/p&gt;
&lt;p&gt;In fact, for the Linux kernel itself there's absolutely no difference between
what userspace sees as processes (the result of &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt;) and as threads (the
result of &lt;tt class="docutils literal"&gt;pthread_create&lt;/tt&gt;). Both are represented by the same data structures
and scheduled similarly. In kernel nomenclature this is called &lt;em&gt;tasks&lt;/em&gt; (the
main structure representing a task in the kernel is
&lt;a class="reference external" href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h"&gt;task_struct&lt;/a&gt;),
and I'll be using this term from now on.&lt;/p&gt;
&lt;p&gt;In Linux, threads are just tasks that share some resources, most notably their
memory space; processes, on the other hand, are tasks that don't share
resources. For application programmers, proceses and threads are created and
managed in very different ways. For processes there's a slew of
process-management APIs like &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;wait&lt;/tt&gt; and so on. For threads there's
the &lt;tt class="docutils literal"&gt;pthread&lt;/tt&gt; library. However, deep in the guts of these APIs and libraries,
both processes and threads come into existence through a single Linux system
call - &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="section" id="the-clone-system-call"&gt;
&lt;h2&gt;The &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; system call&lt;/h2&gt;
&lt;p&gt;We can think of &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; as the unifying implementation shared between
processes and threads. Whatever perceived difference there is between
processes and threads on Linux is achieved through passing different flags to
&lt;tt class="docutils literal"&gt;clone&lt;/tt&gt;. Therefore, it's most useful to think of processes and threads not
as two completely different concepts, but rather as two variants of the same
concept - starting a concurrent task. The differences are mostly about what is
shared between this new task and the task that started it.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/clone/clone-vm-sample.c"&gt;Here is a code sample&lt;/a&gt;
demonstrating the most important sharing aspect of threads - memory. It uses
&lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; in two ways, once with the &lt;tt class="docutils literal"&gt;CLONE_VM&lt;/tt&gt; flag and once without.
&lt;tt class="docutils literal"&gt;CLONE_VM&lt;/tt&gt; tells &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; to share the virtual memory between the calling
task and the new task &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; is about to create &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. As we'll see later on,
this is the flag used by &lt;tt class="docutils literal"&gt;pthread_create&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;child_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Child sees buf = &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello from child&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Allocate stack for child task.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;STACK_SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;65536&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STACK_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;malloc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// When called with the command-line argument &amp;quot;vm&amp;quot;, set the CLONE_VM flag on.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;vm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_VM&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello from parent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child_func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;STACK_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SIGCHLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;clone&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wait&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Child exited with status %d. buf = &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some things to note when &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; is invoked:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;It takes a function pointer to the code the new task will run, similarly
to threading APIs, and unlike the &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt; API. This is the glibc
wrapper for &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt;. There's also a raw system call which is discussed
below.&lt;/li&gt;
&lt;li&gt;The stack for the new task has to be allocated by the parent and passed into
&lt;tt class="docutils literal"&gt;clone&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;tt class="docutils literal"&gt;SIGCHLD&lt;/tt&gt; flag tells the kernel to send the &lt;tt class="docutils literal"&gt;SIGCHLD&lt;/tt&gt; to the parent
when the child terminates, which lets the parent use the plain &lt;tt class="docutils literal"&gt;wait&lt;/tt&gt; call
to wait for the child to exit. This is the only flag the sample passes into
&lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; by default.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This code sample passes a buffer into the child, and the child writes a string
into it. When called without the &lt;tt class="docutils literal"&gt;vm&lt;/tt&gt; command-line argument, the &lt;tt class="docutils literal"&gt;CLONE_VM&lt;/tt&gt;
flag is off, and the parent's virtual memory is copied into the child. The child
sees the message the parent placed in &lt;tt class="docutils literal"&gt;buf&lt;/tt&gt;, but whatever it writes into
&lt;tt class="docutils literal"&gt;buf&lt;/tt&gt; goes into its own copy and the parent can't see it. Here's the output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./clone-vm-sample
Child sees buf = &amp;quot;hello from parent&amp;quot;
Child exited with status 0. buf = &amp;quot;hello from parent&amp;quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But when the &lt;tt class="docutils literal"&gt;vm&lt;/tt&gt; argument is passed, &lt;tt class="docutils literal"&gt;CLONE_VM&lt;/tt&gt; is set and the child
task shares the parent's memory. Its writing into &lt;tt class="docutils literal"&gt;buf&lt;/tt&gt; will now be observable
from the parent:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./clone-vm-sample vm
Child sees buf = &amp;quot;hello from parent&amp;quot;
Child exited with status 0. buf = &amp;quot;hello from child&amp;quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A bunch of other &lt;tt class="docutils literal"&gt;CLONE_*&lt;/tt&gt; flags can specify other things that will be shared
with the parent: &lt;tt class="docutils literal"&gt;CLONE_FILES&lt;/tt&gt; will share the open file descriptors,
&lt;tt class="docutils literal"&gt;CLONE_SIGHAND&lt;/tt&gt; will share the signal dispositions, and so on.&lt;/p&gt;
&lt;p&gt;Other flags are there to implement the semantics required by POSIX threads. For
example, &lt;tt class="docutils literal"&gt;CLONE_THREAD&lt;/tt&gt; asks the kernel to assign the same &lt;em&gt;thread group id&lt;/em&gt;
to the child as to the parent, in order to comply with POSIX's requirement of
all threads in a process sharing a single process ID &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="calling-clone-in-process-and-thread-creation"&gt;
&lt;h2&gt;Calling &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; in process and thread creation&lt;/h2&gt;
&lt;p&gt;Let's dig through some code in glibc to see how &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; is invoked, starting
with &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt;, which is routed to &lt;tt class="docutils literal"&gt;__libc_fork&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;sysdeps/nptl/fork.c&lt;/tt&gt;. The
actual implementation is specific to the threading library, hence the location
in the &lt;tt class="docutils literal"&gt;nptl&lt;/tt&gt; folder. The first thing &lt;tt class="docutils literal"&gt;__libc_fork&lt;/tt&gt; does is invoke the
&lt;em&gt;fork handlers&lt;/em&gt; potentially registered beforehead with &lt;tt class="docutils literal"&gt;pthread_atfork&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The actual cloning happens with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ARCH_FORK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;tt class="docutils literal"&gt;ARCH_FORK&lt;/tt&gt; is a macro defined per architecture (exact syscall ABIs are
architecture-specific). For &lt;tt class="docutils literal"&gt;x86_64&lt;/tt&gt; it maps to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#define ARCH_FORK() \
  INLINE_SYSCALL (clone, 4,                                                   \
                  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD, 0,     \
                  NULL, &amp;amp;THREAD_SELF-&amp;gt;tid)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;CLONE_CHILD_*&lt;/tt&gt; flags are useful for some threading libraries (though not
the default on Linux today - NPTL). Otherwise, the invocation is very similar
to the &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; code sample shown in the previous section.&lt;/p&gt;
&lt;p&gt;You may wonder where is the function pointer in this call. Nice catch! This is
the &lt;em&gt;raw call&lt;/em&gt; version of &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt;, where execution continues from the point
of the call in both parent and child - close to the usual semantics of &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Now let's turn to &lt;tt class="docutils literal"&gt;pthread_create&lt;/tt&gt;. Through a dizzying chain of macros it
reaches a function named &lt;tt class="docutils literal"&gt;create_thread&lt;/tt&gt; (defined in
&lt;tt class="docutils literal"&gt;sysdeps/unix/sysv/linux/createthread.c&lt;/tt&gt;) that calls &lt;tt class="docutils literal"&gt;clone&lt;/tt&gt; with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clone_flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLONE_VM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_FS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_FILES&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_SYSVSEM&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_SIGHAND&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_THREAD&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_SETTLS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_PARENT_SETTID&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLONE_CHILD_CLEARTID&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;ARCH_CLONE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;start_thread&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;STACK_VARIABLES_ARGS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;clone_flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Browse through &lt;tt class="docutils literal"&gt;man 2 clone&lt;/tt&gt; to understand the flags passed into the call.
Briefly, it is asked to share the virtual memory, file system, open files,
shared memory and signal handlers with the parent thread/process. Additional
flags are passed to implement proper identification - all threads launched from
a single process have to share its &lt;em&gt;process ID&lt;/em&gt; to be POSIX compliant.&lt;/p&gt;
&lt;p&gt;Reading the glibc source code is quite an exercise in mental resilience, but
it's really interesting to see how everything fits together &amp;quot;in the real world&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="benchmarking-process-vs-thread-creation"&gt;
&lt;h2&gt;Benchmarking process vs. thread creation&lt;/h2&gt;
&lt;p&gt;Given the information presented earlier in the post, I would expect process
creation to be somewhat more expensive than thread creation, but not
dramatically so. Since &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;pthread_create&lt;/tt&gt; route to the same system
call in Linux, the difference would come from the different
flags they pass in. When &lt;tt class="docutils literal"&gt;pthread_create&lt;/tt&gt; passes all these &lt;tt class="docutils literal"&gt;CLONE_*&lt;/tt&gt; flags,
it tells the kernel there's no need to copy the virtual memory image, the open
files, the signal handlers, and so on. Obviously, this saves time.&lt;/p&gt;
&lt;p&gt;For processes, there's a bit of copying to be done when &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt; is invoked,
which costs time. The biggest chunk of time probably goes to copying the memory
image due to the lack of &lt;tt class="docutils literal"&gt;CLONE_VM&lt;/tt&gt;. Note, however, that it's not just copying
the whole memory; Linux has an important optimization by using COW (Copy On
Write) pages. The child's memory pages are initially mapped to the same pages
shared by the parent, and only when we modify them the copy happens. This is
very important because processes will often use a lot of shared read-only memory
(think of the global structures used by the standard library, for example).&lt;/p&gt;
&lt;p&gt;That said, the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Page_table"&gt;page tables&lt;/a&gt; still
have to be copied. The size of a process's page tables can be observed by
looking in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/proc/&amp;lt;pid&amp;gt;/status&lt;/span&gt;&lt;/tt&gt; - the &lt;tt class="docutils literal"&gt;VmPTE&lt;/tt&gt; indicator. These can be around
tens of kilobytes for small processes, and higher for larger processes. Not a
lot of data to copy, but definitely some extra work for the CPU.&lt;/p&gt;
&lt;p&gt;I wrote a &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/clone/launch-benchmark.c"&gt;benchmark&lt;/a&gt;
that times process and threads launches, as a function of the virtual memory
allocated before &lt;tt class="docutils literal"&gt;fork&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;pthread_create&lt;/tt&gt;. The launch is averaged over
10,000 instances to remove warm-up effects and jitter:&lt;/p&gt;
&lt;img alt="Launch time for fork/thread as function of memory image" class="align-center" src="https://eli.thegreenplace.net/images/2018/launch-fork-thread.png" /&gt;
&lt;p&gt;Several things to note:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Indeed, launching processes is slower than threads, 35 vs. 5 microseconds for
a 2-MB heap. But it's still very fast! 35 &lt;em&gt;micro&lt;/em&gt;-seconds is not a lot of
time at all. If your latency budget is willing to tolerate a 5 us overhead,
it will almost certainly be fine with a 35 us overhead, unless you're working
on some super-tight hard realtime system (in which case you shouldn't be
using Linux!)&lt;/li&gt;
&lt;li&gt;As expected, the time to launch a process when the heap is larger grows. The
time delta is the time needed to copy the extra page table entries. For
threads, on the other hand, there is absolutely no difference since the
memory is completely shared.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Interestingly, it's easy to observe from these numbers that not the whole memory
image is being copied. On the same machine this benchmark was run on, just a
simple &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt; of 2 MB takes over 60 us, so it couldn't have copied 2 MB of
heap to the child in the 30 us difference. Copying 64K (a reasonable size for a
page table) takes 3 us, which makes sense because the cloning involves more than
a simple &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt;. To me this is another sign of how fast these launches are,
since we're in the same ballpark of performance with modestly sized memory
copies.&lt;/p&gt;
&lt;p&gt;Creation time is not the only performance benchmark of importance. It's also
interesting to measure how long it takes to switch context between tasks when
using threads or processes. &lt;a class="reference external" href="https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/"&gt;This is covered in another post&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;It may be just me, but I find this terminology a bit confusing. In my
mind the word &lt;em&gt;clone&lt;/em&gt; is synonymous to &lt;em&gt;copy&lt;/em&gt;, so when we turn on
a flag named &amp;quot;clone the VM&amp;quot; I'd expect the VM to be copied rather than
shared. IMHO it would be clearer if this flag was named &lt;tt class="docutils literal"&gt;SHARE_VM&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;It's certainly interesting to see this evolution of concepts over time.
Thread APIs were defined in times where there was a real difference
between processes and threads and their design reflects that. In modern
Linux the kernel has to bend over backwards to provide the &lt;em&gt;illusion&lt;/em&gt;
of the difference although very little of it exists.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Concurrency"></category><category term="C &amp; C++"></category><category term="Linux"></category></entry><entry><title>Basics of Futexes</title><link href="https://eli.thegreenplace.net/2018/basics-of-futexes/" rel="alternate"></link><published>2018-07-13T05:53:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2018-07-13:/2018/basics-of-futexes/</id><summary type="html">&lt;p&gt;The futex (short for &amp;quot;Fast userspace mutex&amp;quot;) mechanism was proposed by Linux
contributors from IBM in 2002 &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;; it was integrated into the kernel in late 2003.
The main idea is to enable a more efficient way for userspace code to
synchronize multiple threads, with minimal kernel involvement.&lt;/p&gt;
&lt;p&gt;In this …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The futex (short for &amp;quot;Fast userspace mutex&amp;quot;) mechanism was proposed by Linux
contributors from IBM in 2002 &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;; it was integrated into the kernel in late 2003.
The main idea is to enable a more efficient way for userspace code to
synchronize multiple threads, with minimal kernel involvement.&lt;/p&gt;
&lt;p&gt;In this post I want to provide a basic overview of futexes, how they work, and
how they're used to implement the more familiar synchronization primitives in
higher-level APIs and languages.&lt;/p&gt;
&lt;p&gt;An important disclaimer: futexes are a very low-level feature of the Linux
kernel, suitable for use in foundational runtime components like the C/C++
standard libraries. It is extremely unlikely that you will ever need to
use them in application code.&lt;/p&gt;
&lt;div class="section" id="motivation"&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Before the introduction of futexes, system calls were required for locking and
unlocking shared resources (for example &lt;tt class="docutils literal"&gt;semop&lt;/tt&gt;). System calls are relatively
expensive, however, requiring a context switch from userspace to kernel space;
as programs became increasingly concurrent, locks started showing up on
profiles as a significant percentage of the run time. This is very unfortunate,
given that locks accomplish no real work (&amp;quot;business logic&amp;quot;) but are only there
to guarantee that access to shared resources is safe.&lt;/p&gt;
&lt;p&gt;The futex proposal is based on a clever observation: in most cases, locks are
actually not contended. If a thread comes upon a free lock, locking it
can be cheap because most likely no other thread is trying to lock it &lt;em&gt;at the
exact same time&lt;/em&gt;. So we can get by without a system call, attemping much cheaper
atomic operations first &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. There's a very high chance that the atomic
instruction will succeed.&lt;/p&gt;
&lt;p&gt;However, in the unlikely event that another thread &lt;em&gt;did&lt;/em&gt; try to take the lock at
the same time, the atomic approach may fail. In this case there are two options.
We can busy-loop using the atomic until the lock is cleared; while this is 100%
userspace, it can also be extremely wasteful since looping can significantly
occupy a core, and the lock can be held for a long time. The alternative is to
&amp;quot;sleep&amp;quot; until the lock is free (or at least there's a high chance that it's
free); we need the kernel to help with that, and this is where futexes come in.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-futex-use-waiting-and-waking"&gt;
&lt;h2&gt;Simple futex use - waiting and waking&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="http://man7.org/linux/man-pages/man2/futex.2.html"&gt;futex(2) system call&lt;/a&gt;
multiplexes a lot of functionality on top of a single interface. I will not
discuss any of the advanced options here (some of them are so esoteric they're
not even officially documented) but will focus on just &lt;tt class="docutils literal"&gt;FUTEX_WAIT&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;FUTEX_WAKE&lt;/tt&gt;. The man page description starts with a good introduction:&lt;/p&gt;
&lt;blockquote&gt;
The &lt;tt class="docutils literal"&gt;futex()&lt;/tt&gt; system call provides a method for waiting until a certain
condition becomes true.  It is typically used as a blocking construct
in the context of shared-memory synchronization.  When using futexes,
the majority of the synchronization operations are performed in user
space.  A user-space program employs the &lt;tt class="docutils literal"&gt;futex()&lt;/tt&gt; system call only
when it is likely that the program has to block for a longer time
until the condition becomes true.  Other &lt;tt class="docutils literal"&gt;futex()&lt;/tt&gt; operations can be
used to wake any processes or threads waiting for a particular
condition.&lt;/blockquote&gt;
&lt;p&gt;Simply stated, a futex is a kernel construct that helps userspace code
synchronize on shared events. Some userspace processes (or threads) can wait on
an event (&lt;tt class="docutils literal"&gt;FUTEX_WAIT&lt;/tt&gt;), while another userspace process can signal the event
(&lt;tt class="docutils literal"&gt;FUTEX_WAKE&lt;/tt&gt;) to notify waiters. The waiting is efficient - the waiters are
suspended by the kernel and are only scheduled anew when there's a wake-up
signal.&lt;/p&gt;
&lt;p&gt;Be sure to read the &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; man page beyond the introduction; blog posts
are not a substitute for documentation! At the very least read about the
&lt;tt class="docutils literal"&gt;FUTEX_WAIT&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;FUTEX_WAKE&lt;/tt&gt; calls, the arguments they take, their return
values and possible errors.&lt;/p&gt;
&lt;p&gt;Let's study a &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/futex-basics/futex-basic-process.c"&gt;simple example&lt;/a&gt;
demonstrating basic usage of futexes to coordinate two processes. The &lt;tt class="docutils literal"&gt;main&lt;/tt&gt;
function sets up the machinery and launches a child process that:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Waits for &lt;tt class="docutils literal"&gt;0xA&lt;/tt&gt; to be written into a shared memory slot.&lt;/li&gt;
&lt;li&gt;Writes &lt;tt class="docutils literal"&gt;0xB&lt;/tt&gt; into the same memory slot.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Meanwhile, the parent:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Writes &lt;tt class="docutils literal"&gt;0xA&lt;/tt&gt; into the shared memory slot.&lt;/li&gt;
&lt;li&gt;Waits for &lt;tt class="docutils literal"&gt;0xB&lt;/tt&gt; to be written into the slot.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a simple handshake between two processes. Here's the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shm_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shmget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IPC_PRIVATE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4096&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IPC_CREAT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mo"&gt;0666&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shm_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shmget&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shmat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shm_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forkstatus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forkstatus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fork&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forkstatus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Child process&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;child waiting for A&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;wait_on_futex_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;child writing B&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Write 0xB to the shared data and wake up parent.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;wake_futex_blocking&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Parent process.&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parent writing A&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Write 0xA to the shared data and wake up child.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;wake_futex_blocking&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parent waiting for B&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;wait_on_futex_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xB&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Wait for the child to terminate.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;shmdt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we use POSIX shared memory APIs to create a memory location mapped
into both processes. We can't just use a regular pointer here, because the
address spaces of the two processes will be different &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that this is not a canonical usage of &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt;, which would be better
employed to wait until a value changes &lt;em&gt;from&lt;/em&gt; something rather than &lt;em&gt;to&lt;/em&gt;
something. It's just here to show the various possibilities in return values
from &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt;. Later in the post a more canonical usage is demonstrated when we
implement a mutex.&lt;/p&gt;
&lt;p&gt;Here is &lt;tt class="docutils literal"&gt;wait_on_futex_value&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;wait_on_futex_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futex_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FUTEX_WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;EAGAIN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;futex&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;futex_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// This is a real wakeup.&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;abort&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function's main added value on top of the &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; system call is looping
around when the wakeup is spurious. This can happen when &lt;tt class="docutils literal"&gt;val&lt;/tt&gt; is not the
expected value (yet) and also when another process was woken up before this one
(can't really happen in this code sample, but is a real possibility in other
scenarios).&lt;/p&gt;
&lt;p&gt;Futex semantics are tricky &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;! &lt;tt class="docutils literal"&gt;FUTEX_WAIT&lt;/tt&gt; will immediately return if the
value at the futex address is not equal to &lt;tt class="docutils literal"&gt;val&lt;/tt&gt;. In our case this can happen
if the child issued a wait before the parent wrote &lt;tt class="docutils literal"&gt;0xA&lt;/tt&gt;, for example. The
&lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; call will return an error with &lt;tt class="docutils literal"&gt;EAGAIN&lt;/tt&gt; in this case.&lt;/p&gt;
&lt;p&gt;Here is &lt;tt class="docutils literal"&gt;wake_futex_blocking&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;wake_futex_blocking&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex_addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futex_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FUTEX_WAKE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;futex wake&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's a blocking wrapper around &lt;tt class="docutils literal"&gt;FUTEX_WAKE&lt;/tt&gt;, which will normally return
quickly regardless of how many waiters it has woken up. In our sample, this
waiting is part of the handshake, but in many cases you won't see it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="futexes-are-kernel-queues-for-userspace-code"&gt;
&lt;h2&gt;Futexes are kernel queues for userspace code&lt;/h2&gt;
&lt;p&gt;Simply stated, a futex is a queue the kernel manages for userspace convenience.
It lets userspace code ask the kernel to suspend until a certain condition is
satisfied, and lets other userspace code signal that condition and wake up
waiting processes. Earlier we've menioned busy-looping as one approach to wait
on success of atomic operations; a kernel-managed queue is the much more
efficient alternative, absolving userspace code from the need to burn billions
of CPU cycles on pointless spinning.&lt;/p&gt;
&lt;p&gt;Here's a diagram from LWN's &lt;a class="reference external" href="https://lwn.net/Articles/360699/"&gt;&amp;quot;A futex overview and update&amp;quot;&lt;/a&gt;:&lt;/p&gt;
&lt;img alt="Futex implementation diagram from LWN" class="align-center" src="https://eli.thegreenplace.net/images/2018/futex-lwn-diagram.png" /&gt;
&lt;p&gt;In the Linux kernel, futexes are implemented in &lt;tt class="docutils literal"&gt;kernel/futex.c&lt;/tt&gt;. The kernel
keeps a hash table keyed by the address to quickly find the proper queue data
structure and adds the calling process to the wait queue. There's quite a bit of
complication, of course, due to using fine-grained locking within the kernel
itself and the various advanced options of futexes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="timed-blocking-with-futex-wait"&gt;
&lt;h2&gt;Timed blocking with FUTEX_WAIT&lt;/h2&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; system call has a &lt;tt class="docutils literal"&gt;timeout&lt;/tt&gt; parameter which lets user code
implement waiting with a time-out.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;futex-wait-timeout&lt;/span&gt;&lt;/tt&gt; &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/futex-basics/futex-wait-timeout.c"&gt;sample&lt;/a&gt;
shows this in action. Here is the relevant part of the child process which waits
on a futex:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;child waiting for A&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;timespec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{.&lt;/span&gt;&lt;span class="n"&gt;tv_sec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tv_nsec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;500000000&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;time_ns&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FUTEX_WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;child woken up rc=%d errno=%s, elapsed=%llu&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strerror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;time_ns&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;futex_rc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shared_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If the wait takes longer than 500 ms, the process will loop and wait again. The
sample lets you configure the length of time the parent process keeps the child
waiting and observe the effects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-a-futex-to-implement-a-simple-mutex"&gt;
&lt;h2&gt;Using a futex to implement a simple mutex&lt;/h2&gt;
&lt;p&gt;In the motivation section that started this post, I explained how futexes help
implement efficient locking in the common low-contention case. It's time to show
a realistic implementation of a mutex using futexes and atomics. This is based
on the second implementation in Ulrich Drepper's &amp;quot;&lt;em&gt;Futexes are Tricky&lt;/em&gt;&amp;quot; paper.&lt;/p&gt;
&lt;p&gt;For this sample I'm switching to C++, to use its standardized atomics (available
since C++11). The full code &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2018/futex-basics/mutex-using-futex.cpp"&gt;is here&lt;/a&gt;;
here is the important part:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Mutex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmpxchg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// If the lock was previously unlocked, there&amp;#39;s nothing else for us to do.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Otherwise, we&amp;#39;ll probably have to wait.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// If the mutex is locked, we signal that we&amp;#39;re waiting by setting the&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// atom to 2. A shortcut checks is it&amp;#39;s 2 already and avoids the atomic&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// operation in this case.&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmpxchg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="c1"&gt;// Here we have to actually sleep, because the mutex is actually&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="c1"&gt;// locked. Note that it&amp;#39;s not necessary to loop around this syscall;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="c1"&gt;// a spurious wakeup will do no harm since we only exit the do...while&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="c1"&gt;// loop when atom_ is indeed 0.&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;syscall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SYS_futex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FUTEX_WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// We&amp;#39;re here when either:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// (a) the mutex was in fact unlocked (by an intervening thread).&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// (b) we slept waiting for the atom and were awoken.&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// So we try to lock the atom again. We set teh state to 2 because we&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// can&amp;#39;t be certain there&amp;#39;s no other thread at this exact point. So we&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// prefer to err on the safe side.&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmpxchg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;store&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;syscall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SYS_futex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FUTEX_WAKE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 0 means unlocked&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 1 means locked, no waiters&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 2 means locked, there are waiters in lock()&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;atomic&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atom_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;tt class="docutils literal"&gt;cmpxhg&lt;/tt&gt; is a simple wrapper to subdue C++'s atomic primitive to the
expected interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// An atomic_compare_exchange wrapper with semantics expected by the paper&amp;#39;s&lt;/span&gt;
&lt;span class="c1"&gt;// mutex - return the old value stored in the atom.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;cmpxchg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;atomic&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atom&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;desired&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;atomic_compare_exchange_strong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atom&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ep&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;desired&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code snippet is heavily commented to explain how it works; reading Drepper's
paper is recommended in any case, as it builds up to this implementation by
first examining a simpler one which is subtly incorrect. One slightly non-kosher
thing this code does is access the internal representation of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::atomic&lt;/span&gt;&lt;/tt&gt; by
casting the address of &lt;tt class="docutils literal"&gt;atom_&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;int*&lt;/tt&gt; when passing it to the &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt;
syscall. This is because &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; expects a simple address, while C++ atomics
wrap their actual data in opaque types. This works on Linux on x64, but isn't
generally portable. To make &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::atomic&lt;/span&gt;&lt;/tt&gt; play well with &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; in a
portable we'd have to add a portability layer. But it's not a need that comes up
in practice - mixing &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; with C++11 is not something anyone should do -
these snippets are just demonstrational!&lt;/p&gt;
&lt;p&gt;An interesting observation is about the meaning of the value sitting in the
&lt;tt class="docutils literal"&gt;atom_&lt;/tt&gt; member. Recall that the &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; syscall doesn't assign any
meaning to the value - it's up to the user to do that. The 0,1,2 convention is
useful for mutexes, and also the one used by the &lt;em&gt;glibc&lt;/em&gt; implementation for
low-level locks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="glibc-mutex-and-low-level-lock"&gt;
&lt;h2&gt;glibc mutex and low-level lock&lt;/h2&gt;
&lt;p&gt;This brings us to the &lt;em&gt;glibc&lt;/em&gt; implementation of POSIX threads, which have the
&lt;tt class="docutils literal"&gt;pthread_mutex_t&lt;/tt&gt; type. As I've mentioned in the beginning of the post,
futexes are not really for regular user code; rather, they are used by low-level
runtimes and libraries to implement other, higher-level primitives. In this
context, it's interesting to see how a mutex is implemented for &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library"&gt;NPTL&lt;/a&gt;. In the &lt;em&gt;glibc&lt;/em&gt;
source tree, this code is in &lt;tt class="docutils literal"&gt;nptl/pthread_mutex_lock.c&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;The code is significantly complicated by all the different types of mutexes it
has to support, but we can discover some familiar building blocks if we dig
deep enough. In addition to the file mentioned above, other files to look at
(for x86) are &lt;tt class="docutils literal"&gt;sysdeps/unix/sysv/linux/x86_64/lowlevellock.h&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;nptl/lowlevellock.c&lt;/tt&gt;. The code is dense, but the combination of atomic
compare-and-exchange operations and &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; invocations is apparent.
The low-level lock machinery (&lt;tt class="docutils literal"&gt;lll_&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;LLL_&lt;/tt&gt; prefixes) is used throughout
the &lt;em&gt;glibc&lt;/em&gt; code-base, not just in the implementation of POSIX threads.&lt;/p&gt;
&lt;p&gt;The beginning of the comment at the top of &lt;tt class="docutils literal"&gt;sysdeps/nptl/lowlevellock.h&lt;/tt&gt;
should be familiar by now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* Low-level locks use a combination of atomic operations (to acquire and&lt;/span&gt;
&lt;span class="cm"&gt;   release lock ownership) and futex operations (to block until the state&lt;/span&gt;
&lt;span class="cm"&gt;   of a lock changes).  A lock can be in one of three states:&lt;/span&gt;
&lt;span class="cm"&gt;   0:  not acquired,&lt;/span&gt;
&lt;span class="cm"&gt;   1:  acquired with no waiters; no other threads are blocked or about to block&lt;/span&gt;
&lt;span class="cm"&gt;       for changes to the lock state,&lt;/span&gt;
&lt;span class="cm"&gt;   &amp;gt;1: acquired, possibly with waiters; there may be other threads blocked or&lt;/span&gt;
&lt;span class="cm"&gt;       about to block for changes to the lock state.&lt;/span&gt;

&lt;span class="cm"&gt;   We expect that the common case is an uncontended lock, so we just need&lt;/span&gt;
&lt;span class="cm"&gt;   to transition the lock between states 0 and 1; releasing the lock does&lt;/span&gt;
&lt;span class="cm"&gt;   not need to wake any other blocked threads.  If the lock is contended&lt;/span&gt;
&lt;span class="cm"&gt;   and a thread decides to block using a futex operation, then this thread&lt;/span&gt;
&lt;span class="cm"&gt;   needs to first change the state to &amp;gt;1; if this state is observed during&lt;/span&gt;
&lt;span class="cm"&gt;   lock release, the releasing thread will wake one of the potentially&lt;/span&gt;
&lt;span class="cm"&gt;   blocked threads.&lt;/span&gt;
&lt;span class="cm"&gt; ..&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="futexes-in-the-go-runtime"&gt;
&lt;h2&gt;Futexes in the Go runtime&lt;/h2&gt;
&lt;p&gt;The Go runtime does not use libc, in most cases. Therefore, it cannot rely on
the POSIX thread implementation in its own code. It invokes the underlying OS's
system calls directly instead.&lt;/p&gt;
&lt;p&gt;That makes it a good alternative candidate to study for its use of futexes.
Since it can't just use a &lt;tt class="docutils literal"&gt;pthread_mutex_t&lt;/tt&gt; for its locking, it has to roll
its own lock. Let's see how this is done, by starting with the user-visible
&lt;tt class="docutils literal"&gt;sync.Mutex&lt;/tt&gt; type (in &lt;tt class="docutils literal"&gt;src/sync/mutex.go&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;Lock&lt;/tt&gt; method of &lt;tt class="docutils literal"&gt;sync.Mutex&lt;/tt&gt; is quite involved, as you might imagine.
It first tries to use an atomic swap to quickly acquire a lock. If it turns out
it has to wait, it defers to &lt;tt class="docutils literal"&gt;runtime_SemacquireMutex&lt;/tt&gt;, which in turn calls
&lt;tt class="docutils literal"&gt;runtime.lock&lt;/tt&gt;. That function is defined in &lt;tt class="docutils literal"&gt;src/runtime/lock_futex.go&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;,
and defines some constants that will appear familiar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;mutex_unlocked&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;mutex_locked&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;mutex_sleeping&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// mutex_sleeping means that there is presumably at least one sleeping thread.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;runtime.lock&lt;/tt&gt; also tries to speculatively grab a lock with an atomic; this
function is used in a bunch of places in the Go runtime, so that makes sense,
but I wonder if they couldn't have optimized the two consecutive atomics that
occur when it's called by &lt;tt class="docutils literal"&gt;Mutex.lock&lt;/tt&gt;, somehow.&lt;/p&gt;
&lt;p&gt;If it discovers it has to sleep, it defers to &lt;tt class="docutils literal"&gt;futexsleep&lt;/tt&gt;, which is
OS-specific and lives in &lt;tt class="docutils literal"&gt;src/runtime/os_linux.go&lt;/tt&gt;. This function calls
invokes the &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; system call directly with &lt;tt class="docutils literal"&gt;FUTEX_WAIT_PRIVATE&lt;/tt&gt;
(recall that this is sufficient for a single process, which the Go runtime
fulfills).&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;See &amp;quot;Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux&amp;quot; by
Franke, Russell, Kirkwood. Published in 2002 for the Ottawa Linux
Symposium.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Most modern processors have built-in atomic instructions implemented in
HW. For example on Intel architectures &lt;tt class="docutils literal"&gt;cmpxhg&lt;/tt&gt; is an instruction.
While it's not as cheap as non-atomic instructions (especially in
multi-core systems), it's significantly cheaper than system calls.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2018/futex-basics"&gt;The code repository for this post&lt;/a&gt;
also contains an equivalent sample using threads instead of processes.
There we don't need to use shared memory but can instead use the address
of a stack variable.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There's a paper written by Ulrich Drepper named &lt;em&gt;&amp;quot;Futexes are Tricky&amp;quot;&lt;/em&gt;
that explores some of the nuances. I'll be using it later on for the
mutex discussion. It's a very good paper - please read it if you're
interested in the topic.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;For OSes that expose the &lt;tt class="docutils literal"&gt;futex(2)&lt;/tt&gt; system call. The Go runtime has
a fallback onto the semaphore system calls if &lt;tt class="docutils literal"&gt;futex&lt;/tt&gt; is not
supported.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Concurrency"></category><category term="C &amp; C++"></category><category term="Linux"></category></entry><entry><title>Concurrent Servers: Part 5 - Redis case study</title><link href="https://eli.thegreenplace.net/2017/concurrent-servers-part-5-redis-case-study/" rel="alternate"></link><published>2017-12-07T05:44:00-08:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-12-07:/2017/concurrent-servers-part-5-redis-case-study/</id><summary type="html">&lt;p&gt;This is part 5 in a series of posts on writing concurrent network servers. After
discussing techniques for constructing concurrent servers in parts 1-4, this
time we're going to do a case study of an existing production-quality server -
&lt;a class="reference external" href="https://redis.io/"&gt;Redis&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="Redis logo" class="align-center" src="https://eli.thegreenplace.net/images/2017/redis_logo.png" style="width: 320px;" /&gt;
&lt;p&gt;Redis is a fascinating project and I've been following it with …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is part 5 in a series of posts on writing concurrent network servers. After
discussing techniques for constructing concurrent servers in parts 1-4, this
time we're going to do a case study of an existing production-quality server -
&lt;a class="reference external" href="https://redis.io/"&gt;Redis&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="Redis logo" class="align-center" src="https://eli.thegreenplace.net/images/2017/redis_logo.png" style="width: 320px;" /&gt;
&lt;p&gt;Redis is a fascinating project and I've been following it with interest for a
while now. One of the things I admire most about Redis is the clarity of its C
source code. It also happens to be a great example of a high-performance
concurrent in-memory database server, so the opportunity to use it as a case
study for this series was too good to ignore.&lt;/p&gt;
&lt;p&gt;Let's see how the ideas discussed in parts 1-4 apply to a real-world
application.&lt;/p&gt;
&lt;p&gt;All posts in the series:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/"&gt;Part 1 - Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-2-threads/"&gt;Part 2 - Threads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-3-event-driven/"&gt;Part 3 - Event-driven&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-4-libuv/"&gt;Part 4 - libuv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-5-redis-case-study/"&gt;Part 5 - Redis case study&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2018/concurrent-servers-part-6-callbacks-promises-and-asyncawait/"&gt;Part 6 - Callbacks, Promises and async/await&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="event-handling-library"&gt;
&lt;h2&gt;Event-handling library&lt;/h2&gt;
&lt;p&gt;One of Redis's main claims to fame around the time of its original release in
2009 was its &lt;em&gt;speed&lt;/em&gt; - the sheer number of concurrent client connections the
server could handle. It was especially notable that Redis did this all &lt;em&gt;in a
single thread&lt;/em&gt;, without any complex locking and synchronization schemes on the
data stored in memory.&lt;/p&gt;
&lt;p&gt;This feat was achieved by Redis's own implementation of an event-driven library
which is wrapping the fastest event loop available on a system (&lt;tt class="docutils literal"&gt;epoll&lt;/tt&gt; for
Linux, &lt;tt class="docutils literal"&gt;kqueue&lt;/tt&gt; for BSD and so on). This library is called &lt;a class="reference external" href="https://redis.io/topics/internals-rediseventlib"&gt;ae&lt;/a&gt;. &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt; makes it possible to
write a fast server as long as none of the internals are blocking, which Redis
goes to great lengths to guarantee &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What mainly interests us here is &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt;'s support of &lt;em&gt;file events&lt;/em&gt; - registering
callbacks to be invoked when file descriptors (like network sockets) have
something interesting pending. Like &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt; supports multiple event
loops and - having read parts 3 and 4 in this series - the signature of
&lt;tt class="docutils literal"&gt;aeCreateFileEvent&lt;/tt&gt; shouldn't be surprising:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;aeCreateFileEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aeEventLoop&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;eventLoop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;aeFileProc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;clientData&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It registers a callback (&lt;tt class="docutils literal"&gt;proc&lt;/tt&gt;) for new file events on &lt;tt class="docutils literal"&gt;fd&lt;/tt&gt;, with the given
event loop. When using &lt;tt class="docutils literal"&gt;epoll&lt;/tt&gt;, it will call &lt;tt class="docutils literal"&gt;epoll_ctl&lt;/tt&gt; to add an event on
the file descriptor (either &lt;tt class="docutils literal"&gt;EPOLLIN&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;EPOLLOUT&lt;/tt&gt; or both, depending on the
&lt;tt class="docutils literal"&gt;mask&lt;/tt&gt; parameter). &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt;'s &lt;tt class="docutils literal"&gt;aeProcessEvents&lt;/tt&gt; is the &amp;quot;run the event loop and
dispatch callbacks&amp;quot; function, and it calls &lt;tt class="docutils literal"&gt;epoll_wait&lt;/tt&gt; under the hood.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="handling-client-requests"&gt;
&lt;h2&gt;Handling client requests&lt;/h2&gt;
&lt;p&gt;Let's trace through the Redis server code to see how &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt; is used to register
callbacks for client events. &lt;tt class="docutils literal"&gt;initServer&lt;/tt&gt; starts it by registering a callback
for read events on the socket(s) being listened to, by calling
&lt;tt class="docutils literal"&gt;aeCreateFileEvent&lt;/tt&gt; with the callback &lt;tt class="docutils literal"&gt;acceptTcpHandler&lt;/tt&gt;. This callback is
invoked when new client connections are available. It calls &lt;tt class="docutils literal"&gt;accept&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt; and
then &lt;tt class="docutils literal"&gt;acceptCommonHandler&lt;/tt&gt;, which in turn calls &lt;tt class="docutils literal"&gt;createClient&lt;/tt&gt; to initialize
the data structures required to track a new client connection.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;createClient&lt;/tt&gt;'s job is to start listening for data coming in from the client.
It sets the socket to non-blocking mode (a key ingredient in an asynchronous
event loop) and registers another file event callback with &lt;tt class="docutils literal"&gt;aeCreateFileEvent&lt;/tt&gt;
- for read events - &lt;tt class="docutils literal"&gt;readQueryFromClient&lt;/tt&gt;. This function will be invoked by
the event loop every time the client sends some data.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;readQueryFromClient&lt;/tt&gt; does just what we'd expect - parses the client's command
and acts on it by querying and/or manipulating data and sending a reply back.
Since the client socket is non-blocking, this function has to be able to handle
&lt;tt class="docutils literal"&gt;EAGAIN&lt;/tt&gt;, as well as partial data; data read from the client is accumulated in
a client-specific buffer, and the full query may be split across multiple
invocations of the callback.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sending-data-back-to-clients"&gt;
&lt;h2&gt;Sending data back to clients&lt;/h2&gt;
&lt;p&gt;In the previous paragraph I said that &lt;tt class="docutils literal"&gt;readQueryFromClient&lt;/tt&gt; ends up sending
replies back to clients. This is logically true, because &lt;tt class="docutils literal"&gt;readQueryFromClient&lt;/tt&gt;
&lt;em&gt;prepares&lt;/em&gt; the reply to be sent, but it doesn't actually do the physical sending
- since there's no guarantee the client socket is ready for writing/sending
data. We have to use the event loop machinery for that.&lt;/p&gt;
&lt;p&gt;The way Redis does this is by registering a &lt;tt class="docutils literal"&gt;beforeSleep&lt;/tt&gt; function to be
called every time the event loop is about to go sleeping waiting for sockets to
become available for reading/writing. One of the things &lt;tt class="docutils literal"&gt;beforeSleep&lt;/tt&gt; does is
call &lt;tt class="docutils literal"&gt;handleClientsWithPendingWrites&lt;/tt&gt;. This function tries to send all
available replies immediately by calling &lt;tt class="docutils literal"&gt;writeToClient&lt;/tt&gt;; if some of the
sockets are unavailable, it registers an event-loop callback to invoke
&lt;tt class="docutils literal"&gt;sendReplyToClient&lt;/tt&gt; when the socket &lt;em&gt;is&lt;/em&gt; ready. This can be seen as a kind of
optimization - if the socket is immediately ready for sending (which often is
the case for TCP sockets), there's no need to register the event - just send the
data. Since sockets are non-blocking, this never actually blocks the loop.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="why-does-redis-roll-its-own-event-library"&gt;
&lt;h2&gt;Why does Redis roll its own event library?&lt;/h2&gt;
&lt;p&gt;In &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-4-libuv/"&gt;part 4&lt;/a&gt; we've
discussed building asynchronous concurrent servers using &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt;. It's
interesting to ponder the fact that Redis doesn't use &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt;, or any similar
event library, and instead implements its own - &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt;, including wrappers for
&lt;tt class="docutils literal"&gt;epoll&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;kqueue&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;select&lt;/tt&gt;. In fact, antirez (Redis's creator)
answered precisely this question &lt;a class="reference external" href="http://oldblog.antirez.com/post/redis-win32-msft-patch.html"&gt;in a blog post in 2011&lt;/a&gt;. The gist of
his answer: &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt; is ~770 lines of code he intimately understands; &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt; is
huge, without providing additional functionality Redis needs.&lt;/p&gt;
&lt;p&gt;Today, &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt; has grown to ~1300 lines, which is still trivial compared to
&lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt;'s 26K (this is &lt;em&gt;without&lt;/em&gt; Windows, test, samples, docs). &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt; is a
far more general library, which makes it more complex and more difficult to
adapt to the particular needs of another project; &lt;tt class="docutils literal"&gt;ae&lt;/tt&gt;, on the other hand, was
designed for Redis, co-evolved with Redis and contains only what Redis needs.&lt;/p&gt;
&lt;p&gt;This is another great example of the dependencies in software projects formula I
mentioned &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/benefits-of-dependencies-in-software-projects-as-a-function-of-effort/"&gt;in a post earlier this year&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
The benefit of dependencies is inversely proportional to the amount of
effort spent on a software project.&lt;/blockquote&gt;
&lt;p&gt;antirez referred to this, to some extent, in his post. He mentioned that
dependencies that provide a lot of added value (&amp;quot;foundational&amp;quot; dependencies in
my post) make more sense (&lt;tt class="docutils literal"&gt;jemalloc&lt;/tt&gt; and Lua are his examples) than
dependencies like &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt;, whose functionality is fairly easy to implement for
the particular needs of Redis.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="multi-threading-in-redis"&gt;
&lt;h2&gt;Multi-threading in Redis&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://antirez.com/news/93"&gt;For the vast majority of its history&lt;/a&gt;, Redis has
been a purely single-threaded affair. Some people find this surprising, but it
makes total sense with a bit of thought. Redis is inherently network-bound - as
long as the database size is reasonable, for any given client request, much more
time is spent waiting on the network than inside Redis's data structures.&lt;/p&gt;
&lt;p&gt;These days, however, things are not quite that simple. There are several new
capabilities in Redis that use threads:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&amp;quot;Lazy&amp;quot; &lt;a class="reference external" href="http://antirez.com/news/93"&gt;freeing of memory&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Writing a &lt;a class="reference external" href="https://redis.io/topics/persistence"&gt;persistence journal&lt;/a&gt; with
&lt;tt class="docutils literal"&gt;fsync&lt;/tt&gt; calls in a background thread.&lt;/li&gt;
&lt;li&gt;Running user-defined modules that need to perform a long-running operation.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the first two features, Redis uses its own simple &lt;tt class="docutils literal"&gt;bio&lt;/tt&gt; library (the
acronym stands for &amp;quot;Background I/O&amp;quot;). The library is hard-coded for Redis's
needs and can't be used outside it - it runs a pre-set number of threads, one
per background job type Redis needs.&lt;/p&gt;
&lt;p&gt;For the third feature, &lt;a class="reference external" href="https://redis.io/topics/modules-intro"&gt;Redis modules&lt;/a&gt;
could define new Redis commands, and thus are held to the same standards as
regular Redis commands, including not blocking the main thread. If a custom
Redis command defined in a module wants to perform a long-running operation, it
has to spin up a thread to run it in the background.
&lt;tt class="docutils literal"&gt;src/modules/helloblock.c&lt;/tt&gt; in the Redis tree provides an example.&lt;/p&gt;
&lt;p&gt;With these features, Redis combines an event loop with threading to get both
speed in the common case and flexibility in the general case, similarly to the
work queue discussion in &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-4-libuv/"&gt;part 4&lt;/a&gt; of this
series.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A core aspect of Redis is its being an &lt;em&gt;in-memory&lt;/em&gt; database; therefore,
queries should never take too long to execute. There are all kinds of
complications, however. In case of partitioning, a server may end up
routing the request to another instance; in this case async I/O is used
to avoid blocking other clients.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Through &lt;tt class="docutils literal"&gt;anetAccept&lt;/tt&gt;; &lt;tt class="docutils literal"&gt;anet&lt;/tt&gt; is Redis's wrapper for TCP socket code.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Concurrency"></category><category term="C &amp; C++"></category><category term="Network Programming"></category></entry></feed>