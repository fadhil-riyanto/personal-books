<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - Ruby</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/ruby.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2024-05-04T19:46:23-07:00</updated><entry><title>A subjective comparison between Perl and Ruby</title><link href="https://eli.thegreenplace.net/2008/02/01/a-subjective-comparison-between-perl-and-ruby" rel="alternate"></link><published>2008-02-01T17:36:24-08:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-02-01:/2008/02/01/a-subjective-comparison-between-perl-and-ruby</id><summary type="html">
        	&lt;p&gt;The goal of this article is to examine whether it's worth for me to switch to Ruby as my main programming language, a position currently taken by Perl. As the title states, it is &lt;em&gt;subjective&lt;/em&gt; &amp;#8211; in that it presents my personal opinions and targets my specific needs.&lt;/p&gt;


	&lt;h4&gt;Introduction&lt;/h4&gt;


	&lt;p&gt;First, some â€¦&lt;/p&gt;</summary><content type="html">
        	&lt;p&gt;The goal of this article is to examine whether it's worth for me to switch to Ruby as my main programming language, a position currently taken by Perl. As the title states, it is &lt;em&gt;subjective&lt;/em&gt; &amp;#8211; in that it presents my personal opinions and targets my specific needs.&lt;/p&gt;


	&lt;h4&gt;Introduction&lt;/h4&gt;


	&lt;p&gt;First, some background. For many years now, Perl is my main go-to guy for programming tasks. As a hardware engineer, my "programming tasks" are not enterprise-level apps distributed for the use of thousands of customers, but rather support programs and scripts whose main customers are myself and my colleagues. Sometimes these programs have GUIs, sometimes they're even web-based, a lot of times they interact with other (mainly C++ for performance) programs, but most of them are scripts. Whenever some script has to be written for text manipulation, or a simple program for controlling some piece of embedded hardware, I turn to Perl. In size, these programs range from one-liners to several thousand lines of code (KLOCs).&lt;/p&gt;


	&lt;p&gt;Also, I must add that my platform at the time being is 100% MS Windows. In my previous job, I worked on UNIXes (Linux, &lt;span class="caps"&gt;AIX&lt;/span&gt;, Solaris), where Perl blends much better in the environment. But now I have to work with what I've got, and Windows is the platform. This means that I use ActiveState as the Perl distribution and have a keen interest in GUIs.&lt;/p&gt;


	&lt;p&gt;I'm always on the lookout for new tools and technologies to learn. Around two years ago, I decided to give Ruby a try, since I began hearing more and more about how cool it is. As I'm constantly lurking in the Perl community, so what gave me the push was seeing how several Perl hackers whom I respect recommend Ruby as a good future direction.&lt;/p&gt;


	&lt;p&gt;Anyway, in my last attempt, after a brief flirtation Ruby I decided to go back to Perl, as I found Ruby still not mature enough to be my go-to guy, mainly because of the lack of documentation, suitable libraries and the much smaller community.&lt;/p&gt;


	&lt;p&gt;Today, I decided to examine Ruby again, by first publishing a thorough comparison between it and Perl, in order to help myself make a learned choice.&lt;/p&gt;


	&lt;h4&gt;First things first &amp;#8211; the language core&lt;/h4&gt;


	&lt;p&gt;In my opinion, Ruby's core is superior to Perl. Not much to think of here. And I'm definitely not one to be called a "Perl basher". I like Perl, I like its syntax, I like programming in Perl. But Ruby is better.&lt;/p&gt;


	&lt;p&gt;Ruby is everything Perl is, and more. You can write any Perl code in Ruby, in a very similar way, but Ruby offers several definite improvements. Here are a few I deem most important:&lt;/p&gt;


	&lt;ul&gt;
	&lt;li&gt;Object-orientation from the ground-up. Personally, I feel that while &lt;span class="caps"&gt;OOP&lt;/span&gt; is not the silver bullet, it helps in keeping large bodies of code maintainable. Writing OO code in Perl is painful, in Ruby a pleasure.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;Convenient, built-in exception handling.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;The support for functional features is better than in Perl. Blocks, procs, lambdas, and all that. I feel very grateful to Ruby for providing convenient means of replacing several of the things I previously thought require the power of Lisp macros.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;Metaprogramming, better support for code generation and embedded DSLs.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;p&gt;So there's no question here, at least for me. Had everything else been equal, I would certainly pick Ruby. Alas, things are never so simple.&lt;/p&gt;


	&lt;h4&gt;Performance&lt;/h4&gt;


	&lt;p&gt;According to the &lt;a href="http://shootout.alioth.debian.org/gp4/ruby.php"&gt;shootout&lt;/a&gt;, Ruby is 4-5x slower than Perl on average. This is not a major difference &amp;#8211; I wouldn't use Perl for heavy number crunching anyway. Besides, Ruby has an alternative virtual machine named &lt;span class="caps"&gt;YARV&lt;/span&gt; that should enter service any time now&amp;#8482;, and is expected to &lt;a href="http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&amp;amp;lang=yarv&amp;amp;lang2=perl"&gt;improve the performance&lt;/a&gt; by at least a few 10s of %s.&lt;/p&gt;


	&lt;p&gt;When you need high performance, you'll have to resort to C/C++, and both Perl and Ruby have good bindings for these languages.&lt;/p&gt;


	&lt;h4&gt;Documentation and libraries&lt;/h4&gt;


	&lt;p&gt;I place these two together, because I think they're very much related. The sample people who spare the time to write useful modules, also write good documentation for their and others' modules.&lt;/p&gt;


	&lt;p&gt;In this section, Perl wins big. Perl's library of code, the mighty &lt;span class="caps"&gt;CPAN&lt;/span&gt;, is incomparable.  Maybe Ruby is not far from Perl in popularity today, but this is a recent event. For many years, Perl was more popular by orders of magnitude, and accumulated a huge library of shared knowledge.&lt;/p&gt;


	&lt;p&gt;Documentation in the Perl world is also better. Funny, because I find the RDoc to be much better than &lt;span class="caps"&gt;POD&lt;/span&gt;. Documenting Ruby code in a standard way is far simpler and more pleasant than with Perl &amp;#8211; where embedding &lt;span class="caps"&gt;POD&lt;/span&gt; feels like programming in the 80s. But yet again, Perl's huge lead over a long time ensured that most of the libraries are quite well documented and there are tons of examples and snippets to be found online. Ruby is catching up, but this will take time.&lt;/p&gt;


	&lt;p&gt;Just one example: &lt;span class="caps"&gt;XML&lt;/span&gt; handling. Ruby's canonical solution is &lt;span class="caps"&gt;REXML&lt;/span&gt; &amp;#8211; a slow, unconvenient &lt;span class="caps"&gt;API&lt;/span&gt; with appalling error handling. I was so disgusted by &lt;span class="caps"&gt;REXML&lt;/span&gt; when writing a Ruby app a year ago that I switched my data format to &lt;span class="caps"&gt;YAML&lt;/span&gt;. Perl has numerous excellent solutions for &lt;span class="caps"&gt;XML&lt;/span&gt; parsing and generation, right in the standard distribution. Rubyists ported &lt;span class="caps"&gt;XML&lt;/span&gt;::Simple, but it's based on &lt;span class="caps"&gt;REXML&lt;/span&gt;, which leaves it with all the deficiencies.&lt;/p&gt;


	&lt;p&gt;A disclaimer must be made here, which also applies to the "community" section. I'm concerned mainly with the English-speaking community. For Perl, there is no other. But for Ruby, there is. Ruby is an immigrant from Japan, and has a large and vibrant Japanese community behind it. It means that there are a lot of Ruby modules without any English documentation, which is a real pity. Even if these modules are terrific, there's no way for those of us who don't understand Japanese to enjoy them.&lt;/p&gt;


	&lt;h4&gt;Community&lt;/h4&gt;


	&lt;p&gt;A community is extremely important in our connected age. A large, smart community means quicker answers to questions, more libraries and documentation, and just a place to share wisdom and learn new tricks.&lt;/p&gt;


	&lt;p&gt;The Perl community is just amazing. In football&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt;, it is often said that the home crowd is the team's 12th player. The Perl community is something like that. &lt;a href="http://perlmonks.org/"&gt;Perlmonks&lt;/a&gt; is the best programming language community on the Internet, period. Any question you have will be promptly answered by super-smart Perl hackers, some of whom seem to have little other interest in life than in providing detailed, well researched answers on Perlmonks. It's also one of the best places I know of to discuss general "meaning of life" questions in relation to programming, i.e. comparing paradigms, discussing future directions, and so on.&lt;/p&gt;


	&lt;p&gt;Ruby doesn't have anything of the kind. What it does have is a mailing list / forum / Google group&lt;sup&gt;&lt;a href="#fn2"&gt;2&lt;/a&gt;&lt;/sup&gt;. When I tried Ruby the previous time, the situation was worse &amp;#8211; the group was less active and the connection between the various channels wasn't working well, creating fragmentation. Now, however, things seem to be better. The folks in the list are friendly and questions get answered quite quickly.&lt;/p&gt;


	&lt;p&gt;And still, Perl wins here. Someone should really create a Rubymonks &amp;#8211; I think it would give a great boost to the community.&lt;/p&gt;


	&lt;h4&gt;Momentum and future directions&lt;/h4&gt;


	&lt;p&gt;This issue is difficult to define exactly, and hence I will digress to a little philosophizing. A metaphor might help. Consider two employees. One is 45, very smart, been-there done-that kind of guy. Everything he's ever done, he can do again easily, quickly and soundly. However, he's reluctant to learn new technologies, and sometime hints that he might retire early. Another is a whizzy 25 year-old. He doesn't have so much knowledge accumulated, but he's an excellent hacker and can learn very quickly. He's eager to enter any new area and signals that he'll stay in the company for a long time.&lt;/p&gt;


	&lt;p&gt;Lately, I feel that Perl is the old guy and Ruby the young guy. I will try to defend my point:&lt;/p&gt;


	&lt;p&gt;Ruby seems to be having much more momentum behind it now than Perl. New technologies are more likely to be implemented in Ruby than in Perl. New books on programming are more likely to be written with Ruby than with Perl, and most importantly, fresh hackers are much more likely to join the world of Ruby than the world of Perl.&lt;/p&gt;


	&lt;p&gt;The last point is crucial. Perl has several excellent people working with it, who are well known throughout the community. The problem is, it's pretty much the same people of years ago. In Ruby, on the other hand, names of prolific and talented hackers constantly pop up &amp;#8211; they push the language, with its libraries and community fast forward.&lt;/p&gt;


	&lt;p&gt;For example, take the Textile markup language&lt;sup&gt;&lt;a href="#fn3"&gt;3&lt;/a&gt;&lt;/sup&gt;. It's quite new, and it doesn't surprise me that Ruby has a better library for translating it than Perl. &lt;a href="http://whytheluckystiff.net/ruby/redcloth/"&gt;RedCloth&lt;/a&gt;, written by the amazingly prolific Ruby hacker &lt;a href="http://hackety.org/"&gt;_why&lt;/a&gt; supports Textile better than the best Perl library out there, and no one seems to be fixing the situation in the Perl world.&lt;/p&gt;


	&lt;p&gt;The same can be said for &lt;span class="caps"&gt;YAML&lt;/span&gt; &amp;#8211; the parser for which was also written by _why, first for Ruby, and only later ported to Perl.&lt;/p&gt;


	&lt;p&gt;Take the bindings to Wx and Qt &amp;#8211; the two most popular cross-platform native-looks &lt;span class="caps"&gt;GUI&lt;/span&gt; frameworks. Ruby has the better bindings for both. True, Perl's integration with Tk is unrivaled in the Ruby world, but this only proves my point &amp;#8211; Perl is excellent in everything &lt;em&gt;old&lt;/em&gt;, but Ruby is quickly gaining in the &lt;em&gt;newer&lt;/em&gt; technologies. While for a &lt;span class="caps"&gt;GUI I&lt;/span&gt;'d still use Perl/Tk, I'm watching wxRuby, drooling at its pretty native widgets and controls.&lt;/p&gt;


	&lt;p&gt;I can only mention Ruby's strongest card &amp;#8211; the Rails framework, in passing, because I have never used it.&lt;/p&gt;


	&lt;p&gt;Take alternative implementations as another example. Ruby has Rubinius, JRuby, IronRuby, Ruby.NET, what does Perl have ? JRuby and IronRuby are particularly interesting ventures, since they are backed by the enterprise. JRuby's developers were hired by Sun to create a natural binding to Java on the &lt;span class="caps"&gt;JVM&lt;/span&gt;, and IronRuby is being deveoped by, no less, Microsoft's Dynamic Language Runtime team, to bind it to the .NET framework. At last, the big two enterprise solutions &amp;#8211; Java and .NET realized the importance of dynamic scripting languages, and did they choose Perl ? No, they chose Ruby&lt;sup&gt;&lt;a href="#fn4"&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;


	&lt;p&gt;So why does this happen ? Why is Perl stagnant while Ruby is stronly moving forward&lt;sup&gt;&lt;a href="#fn5"&gt;5&lt;/a&gt;&lt;/sup&gt;. Is it only because Ruby's core is better ? Is it because of Rails ? &lt;span class="caps"&gt;IMHO&lt;/span&gt; there's another reason, and that is Perl 6. With it hovering around, no one &lt;em&gt;really&lt;/em&gt; wants to improve Perl 5 any more. Perl 5.5 was released one year after 5.4, 5.6 was released 20 months after that, 5.8 took 28 months, 5.10 &amp;#8211; more than 5 years. Do you notice the tendency ?&lt;/p&gt;


	&lt;p&gt;Recall the old vs. new employee metaphor. Is Perl 6 the reason for Perl 5's stagnation &amp;#8211; I doubt it is, but it is definitely a factor. Just how much motivation would you have working hard on somethinig you know will be thrown out &lt;em&gt;soon&lt;/em&gt;. And now imagine this &lt;em&gt;soon&lt;/em&gt; lasts for years and years&lt;sup&gt;&lt;a href="#fn6"&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;


	&lt;h4&gt;Conclusion&lt;/h4&gt;


	&lt;p&gt;It's about time to conclude this rant. Which should I choose ? Should I replace Perl as my go-to guy with Ruby ?&lt;/p&gt;


	&lt;p&gt;The answer to this question is still no, but this time with a reservation. I enjoy writing Ruby code more than writing Perl code, at least until I ran into a piece of horrible documentation or a missing library which Perl has since 1995. But at the core, Ruby is better. And while the core is practically impossible to change (see how long Perl 6 is taking) all the peripherials are easier. In the past two years, Ruby has closed many gaps on Perl in terms of documentation, libraries and community. I think that with the current trends continuing for another two or three years, Ruby will overtake Perl in popularity and will become an all around better solution.&lt;/p&gt;


&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;

	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; Real football (i.e. soccer in the US).&lt;/p&gt;


	&lt;p id="fn2"&gt;&lt;sup&gt;2&lt;/sup&gt; They're all linked. I use the Google Group interface because I find it the most convenient.&lt;/p&gt;


	&lt;p id="fn3"&gt;&lt;sup&gt;3&lt;/sup&gt; The one I'm using for writing this article.&lt;/p&gt;


	&lt;p id="fn4"&gt;&lt;sup&gt;4&lt;/sup&gt; Well, there's also Jython (not backed by Sun, &lt;span class="caps"&gt;AFAIK&lt;/span&gt;) and IronPython (backed by MS). But this article compares Perl and Ruby, which &lt;span class="caps"&gt;IMHO&lt;/span&gt; have a somewhat similar philosophy that is a bit different from Python.&lt;/p&gt;


	&lt;p id="fn5"&gt;&lt;sup&gt;5&lt;/sup&gt; According to the &lt;a href="http://www.tiobe.com/tpci.htm"&gt;&lt;span class="caps"&gt;TIOBE&lt;/span&gt; index&lt;/a&gt;, Perl is currently at 5.4%, down from 8% 5 years ago, while Ruby is 2.3%, up from 0.25% 5 years ago.&lt;/p&gt;


	&lt;p id="fn6"&gt;&lt;sup&gt;6&lt;/sup&gt; Perl 6 was announced on July 19th, 2000.&lt;/p&gt;

    </content><category term="misc"></category><category term="Perl"></category><category term="Ruby"></category></entry><entry><title>DSL = Metalinguistic Abstraction</title><link href="https://eli.thegreenplace.net/2007/07/27/dsl-metalinguistic-abstraction" rel="alternate"></link><published>2007-07-27T14:23:26-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2007-07-27:/2007/07/27/dsl-metalinguistic-abstraction</id><summary type="html">
    &lt;p&gt;
        The idea of Domain Specific Languages (&lt;a href="http://en.wikipedia.org/wiki/Domain-specific_programming_language"&gt;DSL&lt;/a&gt;)
        has been lately brought into attention by the freshly popular
        programming language &lt;a href="http://en.wikipedia.org/wiki/Ruby_%28programming_language%29"&gt;Ruby&lt;/a&gt;.
    In particular, the famed web framework &lt;a href="http://en.wikipedia.org/wiki/Ruby_on_Rails"&gt;Ruby On Rails&lt;/a&gt;, which
is built as a DSL on top of Ruby has been a prime example. 
    &lt;/p&gt;&lt;p&gt;

What most people are not aware â€¦&lt;/p&gt;</summary><content type="html">
    &lt;p&gt;
        The idea of Domain Specific Languages (&lt;a href="http://en.wikipedia.org/wiki/Domain-specific_programming_language"&gt;DSL&lt;/a&gt;)
        has been lately brought into attention by the freshly popular
        programming language &lt;a href="http://en.wikipedia.org/wiki/Ruby_%28programming_language%29"&gt;Ruby&lt;/a&gt;.
    In particular, the famed web framework &lt;a href="http://en.wikipedia.org/wiki/Ruby_on_Rails"&gt;Ruby On Rails&lt;/a&gt;, which
is built as a DSL on top of Ruby has been a prime example. 
    &lt;/p&gt;&lt;p&gt;

What most people are not aware of, however, is that DSLs is just a new
incarnation of the very old concept born in the world of Lisp called &lt;a href="http://en.wikipedia.org/wiki/Metalinguistic_abstraction"&gt;&lt;i&gt;Metalinguistic
Abstraction&lt;/i&gt;&lt;/a&gt;. It is a recurrent theme in the seminal MIT textbook, &lt;a href="http://en.wikipedia.org/wiki/SICP"&gt;Structure and Interpretation of
Computer Programs&lt;/a&gt; (SICP) that was written in 1985 to present general
computer programming concepts using the Scheme language (member of the Lisp
family).
    &lt;/p&gt;&lt;p&gt;

Metalinguistic Abstraction is the process of solving programming problems by
creating a new language  that is better suited to tackle these problems. Unlike
the traditional software engineering process of dividing problems to exactly
defined subproblems and solving those subproblems, metalinguistic abstraction
instructs the programmer to imagine a new programming language in which the
solution of these problems can be expressed most naturally, and then implement
this language.
    &lt;/p&gt;&lt;p&gt;

While this sounds a bit detached, Rails actually provides a good, modern example
of how such a concept can work. The designer of Rails asked himself "what
language do I need to write web applications more naturally". He then went
forward to implement this language on top of Ruby. Naturally, he could have
created a completely new programming language. However, building it on top of an
existing system provides several powerful benefits:
    &lt;/p&gt;&lt;p&gt;

&lt;ol&gt;
	&lt;li&gt;You don't need to craft a parser for the new language.&lt;/li&gt;
	&lt;li&gt;You don't have to make up new syntax, just use the existing syntax of the language you're building on top of.&lt;/li&gt;
	&lt;li&gt;Most importantly - since you are just building a layer on top of an existing programming language, all the facilities and power of this language are available to you, for free. This greatly enhances the immediate usefulness of the new DSL.&lt;/li&gt;
&lt;/ol&gt;
    &lt;/p&gt;&lt;p&gt;

Ruby is a good language to build DSLs in, and Rails is a prime example of this.
Ruby is better in this task than the other popular languages - Perl, Python,
C++, Java, C#, etc. However, it is much inferior to Lisp. This is in no way to
diminish Ruby's success or start a language war, I'm simply stating a fact. Lisp
has some unique concepts that make metalinguistic abstraction natural, namely
uniform syntax and macros. 
    &lt;/p&gt;&lt;p&gt;

Since metalinguistic abstraction is such a powerful programming technique, it is
highly recommended for any programmer to learn Lisp (whether it is &lt;a href="http://en.wikipedia.org/wiki/Common_lisp"&gt;Common Lisp&lt;/a&gt; or &lt;a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29"&gt;Scheme&lt;/a&gt;
doesn't really matter). Even if you'll never use it for any official project,
just the act of learning it and understanding the programming techniques
possible in it will surely expand your mind and make you a better programmer.
&lt;/p&gt;
    </content><category term="misc"></category><category term="Lisp"></category><category term="Programming"></category><category term="Ruby"></category></entry><entry><title>Logical operators in Perl and Ruby</title><link href="https://eli.thegreenplace.net/2007/06/02/logical-operators-in-perl-and-ruby" rel="alternate"></link><published>2007-06-02T20:06:28-07:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2007-06-02:/2007/06/02/logical-operators-in-perl-and-ruby</id><summary type="html">
        &lt;p&gt;Both Perl and Ruby provide two sets of logical operators: &lt;/p&gt;
	&lt;ul&gt;
	&lt;li&gt;!, &amp;#38;&amp;#38; and || (inherited from C) &lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;not&lt;/strong&gt;, &lt;strong&gt;and&lt;/strong&gt; and &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
	&lt;/ul&gt;


	&lt;p&gt;Unfortunately, these two sets of operators are not isomorphic &amp;#8211; due to differences in precedence, their semantics are different in subtle ways which make the whole issue of using them error prone. In â€¦&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;Both Perl and Ruby provide two sets of logical operators: &lt;/p&gt;
	&lt;ul&gt;
	&lt;li&gt;!, &amp;#38;&amp;#38; and || (inherited from C) &lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;not&lt;/strong&gt;, &lt;strong&gt;and&lt;/strong&gt; and &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
	&lt;/ul&gt;


	&lt;p&gt;Unfortunately, these two sets of operators are not isomorphic &amp;#8211; due to differences in precedence, their semantics are different in subtle ways which make the whole issue of using them error prone. In this article I will try to elucidate this topic.&lt;/p&gt;

&lt;h4&gt;So what&amp;#39;s the difference between them?&lt;/h4&gt;

&lt;p&gt;In order to be able to disambiguate complex expressions, parsers of programming languages assign precedence for all operators. The best known example is probably the precedence of &lt;b&gt;*&lt;/b&gt; being higher than that of &lt;b&gt;+&lt;/b&gt; to allow commonly understood mathematical expressions without forcing to use lots of parentheses. Another good example is the precedence of assignment being lower than the precedence of all mathematical operators. This allows statements like &lt;code&gt;$a = $b + $c;&lt;/code&gt; to be parsed correctly without parentheses&lt;sup class="footnote"&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;In Perl and in Ruby, the precedence of !, &amp;amp;&amp;amp; and || is higher than the precedence of assignment, while the precedence of &lt;strong&gt;not&lt;/strong&gt;, &lt;strong&gt;and&lt;/strong&gt; and &lt;strong&gt;or&lt;/strong&gt; is lower. &lt;/p&gt;

&lt;p&gt;For example, the following code in Perl:&lt;/p&gt;


&lt;pre&gt;
$a = $b || 5;
&lt;/pre&gt;



&lt;p&gt;Will assign the value of &lt;code&gt;$b&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt; when &lt;code&gt;$b&lt;/code&gt; evaluates to true, and 5 when &lt;code&gt;$b&lt;/code&gt; evaluates to false (&lt;code&gt;undef&lt;/code&gt;, 0 or an empty string). In short, it works as expected. However, the following code:&lt;/p&gt;


&lt;pre&gt;
$a = $b or 5;
&lt;/pre&gt;



&lt;p&gt;Is completely broken and will just generate a warning, because it is parsed as &lt;code&gt;($a = $b) or 5;&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;Why the low precedence ?&lt;/h4&gt;

&lt;p&gt;As the example above shows, the low precedence of &lt;strong&gt;or&lt;/strong&gt; is not such a good idea. So why was it made this way ? I think that Larry Wall wanted to make the following code legal Perl that behaves as expected:&lt;/p&gt;


&lt;pre&gt;
open my $fh, &amp;quot;&amp;lt;&amp;quot;, $filename or die $!;
&lt;/pre&gt;



&lt;p&gt;Perl allows to drop parentheses where the code is not ambiguous, and proponents of the language believe it makes some code more readable. The code section above will work correctly. With ||, on the other hand, it wouldn&amp;#39;t have worked since the precedence of || is higher than that of the comma, and the expression would be parsed as:&lt;/p&gt;


&lt;pre&gt;
open my $fh, &amp;quot;&amp;lt;&amp;quot;, ($filename || die $!);
&lt;/pre&gt;



&lt;p&gt;Which isn&amp;#39;t what we wanted. In Ruby, where code like the above is not written, this motivation plays no role. &lt;/p&gt;

&lt;h4&gt;Dealing with the confusion&lt;/h4&gt;

&lt;p&gt;So it appears Perl and Ruby have two sets of almost identical operators which behave differently sometimes. Isn&amp;#39;t this confusing ? &lt;/p&gt;

&lt;p&gt;It definitely is. In fact, many "good programming style" guides deal with this confusion in a very strict manner. For instance, Damian Conway&amp;#39;s excellent "Perl Best Practices" book advises to avoid the low precedence operators at all, except for the single case of:&lt;/p&gt;


&lt;pre&gt;
open my $fh, &amp;quot;&amp;lt;&amp;quot;, $filename or die $!;
&lt;/pre&gt;



&lt;p&gt;In Ruby this is irrelevant, so to extend his advice, it probably isn&amp;#39;t recommended to use these operators at all in Ruby, is it ? I personally hold a different view.&lt;/p&gt;

&lt;h4&gt;In defence of the low precedence operators&lt;/h4&gt;

&lt;p&gt;In my opinion, the low precedence operators are better, because of two main reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Not everyone came to Perl and Ruby from C and C++. On the contrary, as the time goes on, less and less people come with this background, and many start from other languages (in lots of cases, from Perl and Ruby themselves). But even for a seasoned C hacker, &lt;span class="caps"&gt;IMHO &lt;/span&gt;&lt;code&gt;if not client.done? or client.result &gt; 0&lt;/code&gt; is more intelligible than &lt;code&gt;if !client.done? || client.result &gt; 0&lt;/code&gt;, since it is more English-like.&lt;/li&gt;
&lt;li&gt;An important factor, at least for me, is the speed and comfort of typing on the keyboard. Typing too many punctuation characters is both slower and more stressful on the wrists. Using &lt;strong&gt;not&lt;/strong&gt;, &lt;strong&gt;and&lt;/strong&gt; and &lt;strong&gt;or&lt;/strong&gt; wherever possible instead of !, &amp;amp;&amp;amp; and || definitely helps me put as little stress as possible on my tendons.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;But...&lt;/h4&gt;

However, as we have seen, some things just can&amp;#8217;t be done with the low precedence operators without resorting to parentheses. So for the singular case of the short-circuit assignment perhaps using || is better than &lt;strong&gt;or&lt;/strong&gt; (Ruby code in this case, although it of course applies to Perl as well):
&lt;pre&gt;
a = b || 5;
&lt;/pre&gt;

Implementing the same functionality with &lt;strong&gt;or&lt;/strong&gt; feels a little superfluous:
&lt;pre&gt;
a = (b or 5);
&lt;/pre&gt;

And || can also be used in the occasionally useful idiom&lt;sup&gt;&lt;a href="#fn2"&gt;2&lt;/a&gt;&lt;/sup&gt;:
&lt;pre&gt;
var ||= 5;
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;or&lt;/strong&gt; has no answer in this case.&lt;/p&gt;


	&lt;p&gt;I&amp;#8217;m sure, however, that there is much more logical condition code that short-circuit assignment code, so the low precedence operators can be used most of the time.&lt;/p&gt;


	&lt;h4&gt;Another little gotcha&lt;/h4&gt;


There is another little gotcha about low precedence operators which is mostly relevant for people with C background. &lt;strong&gt;or&lt;/strong&gt; and &lt;strong&gt;and&lt;/strong&gt; have the same precedence (unlike ||, which has a lower precedence than &amp;#38;&amp;#38;), so writing code like:
&lt;pre&gt;
if cond1 and cond2 or cond3 and cond4
&lt;/pre&gt;

	&lt;p&gt;Won&amp;#8217;t do what you expected. However, it is a good practice to use parentheses in all complex conditions of this kind anyway, so I don&amp;#8217;t see it as a big problem.&lt;/p&gt;


	&lt;h4&gt;Conclusion&lt;/h4&gt;


	&lt;p&gt;Perl and Ruby have two sets of logical operators. These two sets have slightly different semantics, but the confusion can be avoided with a disciplined application of good programming practices. My advice is to use the low precedence operators (&lt;strong&gt;not&lt;/strong&gt;, &lt;strong&gt;and&lt;/strong&gt; and &lt;strong&gt;or&lt;/strong&gt;) all the time. The single exception can be made in the case of short-circuit assignment, where || can be used instead of &lt;strong&gt;or&lt;/strong&gt; (although &lt;strong&gt;or&lt;/strong&gt; can also be used, with help from a couple of parentheses).&lt;/p&gt;


	&lt;h4&gt;Footnotes&lt;/h4&gt;


	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; Had the precedence of assignment been higher than the precedence of addition, this statement would be understood as &lt;code&gt;($a = $b) + $c;&lt;/code&gt;.&lt;/p&gt;


	&lt;p id="fn2"&gt;&lt;sup&gt;2&lt;/sup&gt; This translates to &lt;code&gt;var = var || 5&lt;/code&gt;, or &amp;#8220;if &lt;code&gt;var&lt;/code&gt; is defined, let it keep its value, otherwise assign 5 to it&amp;#8221;.&lt;/p&gt;

    </content><category term="misc"></category><category term="Perl"></category><category term="Ruby"></category></entry><entry><title>irb tab completion</title><link href="https://eli.thegreenplace.net/2007/05/07/irb-tab-completion" rel="alternate"></link><published>2007-05-07T17:49:13-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2007-05-07:/2007/05/07/irb-tab-completion</id><summary type="html">
        irb is the interactive Ruby shell - an incredibly useful tool during development. Lisp folks are proud of the REPL (Read-Evaluate-Print Loop) - well, irb is REPL for Ruby.

What turns irb into an even more useful instrument, however, is tab completion. First, it makes coding quicker by completing known symbols (kind â€¦</summary><content type="html">
        irb is the interactive Ruby shell - an incredibly useful tool during development. Lisp folks are proud of the REPL (Read-Evaluate-Print Loop) - well, irb is REPL for Ruby.

What turns irb into an even more useful instrument, however, is tab completion. First, it makes coding quicker by completing known symbols (kind of an Intellisense, if you'd like). Second, and more importantly, it allows you to quickly see which methods are implemented for objects, by typing:

&lt;pre&gt;
irb(main):001:0&gt; some_object.
&lt;/pre&gt;

And pressing TAB twice, irb will list all the methods.

For some reason, however, irb doesn't come with tab completion out of the box. To set it up, you can create a batch file called irbb.bat, for instance, which calls:

&lt;pre&gt;
irb -r irb/completion
&lt;/pre&gt;

And call that instead of irb. A simpler method, IMHO, is directly edit the irb.bat file in the Ruby installation bin/ directory to &lt;i&gt;require&lt;/i&gt; irb/completion. 

P.S: I describe Windows solutions. It should be very similar for Linux.
    </content><category term="misc"></category><category term="Ruby"></category></entry><entry><title>Useful resources for using YAML in Ruby</title><link href="https://eli.thegreenplace.net/2007/04/13/useful-resources-for-using-yaml-in-ruby" rel="alternate"></link><published>2007-04-13T15:46:24-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2007-04-13:/2007/04/13/useful-resources-for-using-yaml-in-ruby</id><summary type="html">
        As I mentioned &lt;a href="https://eli.thegreenplace.net/2006/03/28/xml-or-yaml-for-configuration-files/"&gt;here&lt;/a&gt;, I had a choice of using either XML or YAML for the configuration files in the new version of ESMS. YAML won for two reasons:

&lt;ol&gt;
	&lt;li&gt;It is much more lightweight and looks natural. Big configuration files in XML become complex and cluttered, while YAML scales admirably â€¦&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">
        As I mentioned &lt;a href="https://eli.thegreenplace.net/2006/03/28/xml-or-yaml-for-configuration-files/"&gt;here&lt;/a&gt;, I had a choice of using either XML or YAML for the configuration files in the new version of ESMS. YAML won for two reasons:

&lt;ol&gt;
	&lt;li&gt;It is much more lightweight and looks natural. Big configuration files in XML become complex and cluttered, while YAML scales admirably in this respect.&lt;/li&gt;
	&lt;li&gt;The current de-facto XML implementation in Ruby is REXML, which I dislike. REXML is useful for employing XML as a serialization format, but is less good as a configuration file reader, because its error handling is very bad. On the other hand, &lt;a href="http://whytheluckystiff.net/syck/"&gt;Syck&lt;/a&gt; (the built-in YAML parser / emitter in Ruby) is easy to use, fast and has good error handling and reporting.&lt;/li&gt;
&lt;/ol&gt;

The following are good resources for YAML in Ruby:

&lt;ol&gt;
	&lt;li&gt;&lt;a href="http://yaml4r.sourceforge.net/cookbook/"&gt;Yaml cookbook&lt;/a&gt; - shows probably all you'll ever need to understand how Yaml entities map to Ruby code. Very useful.&lt;/li&gt;
	&lt;li&gt;&lt;a href="http://yaml4r.sourceforge.net/doc/"&gt;Yaml.rb docs&lt;/a&gt; - A reference manual with examples for the Yaml.rb library.&lt;/li&gt;
	&lt;li&gt;&lt;a href="http://yaml.org/spec/current.html"&gt;YAML specification&lt;/a&gt; - from the official YAML website (&lt;a href="http://www.yaml.org"&gt;yaml.org&lt;/a&gt;). A crisp yet well written reference to the YAML syntax and semantics.&lt;/li&gt;



&lt;/ol&gt;


    </content><category term="misc"></category><category term="Ruby"></category></entry><entry><title>Book review: "Best of Ruby Quiz" by James Gray</title><link href="https://eli.thegreenplace.net/2006/07/05/book-review-best-of-ruby-quiz-by-james-gray" rel="alternate"></link><published>2006-07-05T20:12:45-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2006-07-05:/2006/07/05/book-review-best-of-ruby-quiz-by-james-gray</id><summary type="html">
        James Gray is a seasoned Ruby veteran who has been adding value to the community for a long time. One of his major contributions is the &lt;a href="http://www.rubyquiz.com"&gt;Ruby Quiz&lt;/a&gt; - a competition modeled after the Perl Quiz - each week a new challenge is posted and people are encouraged to contribute solutions. In â€¦</summary><content type="html">
        James Gray is a seasoned Ruby veteran who has been adding value to the community for a long time. One of his major contributions is the &lt;a href="http://www.rubyquiz.com"&gt;Ruby Quiz&lt;/a&gt; - a competition modeled after the Perl Quiz - each week a new challenge is posted and people are encouraged to contribute solutions. In the end of the week, James analyzes the most interesting solutions and presents a summary on the website (and the mailing list).&lt;p&gt;

This book is a digest of the 25 most interesting quizzes and their solutions carefully collected by James and released in one volume (using some very pretty typesetting, I must add). It's basically a printed version of the website, with only very little content added - like additional exercises after each quiz.

And this is where the problem of this book lays, in my opinion. To experienced programmers it won't be particularly interesting, since looking at the quiz website itself and participating in the lively discussion on the maling list is much more interesting.

This book could be excellent for newbies, but unfortunately it's not meant for those unfamiliar with the language. So even here, the website is just far more useful. The only real advantage of this book is its dead-tree format, which may be nice for people who have difficulty reading from the computer screen, or for people temporarily without internet access.
    </content><category term="misc"></category><category term="Book reviews"></category><category term="Ruby"></category></entry><entry><title>Book review: "The Ruby way" by Hal Fulton</title><link href="https://eli.thegreenplace.net/2006/04/25/book-review-the-ruby-way-by-hal-fulton" rel="alternate"></link><published>2006-04-25T14:31:34-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2006-04-25:/2006/04/25/book-review-the-ruby-way-by-hal-fulton</id><summary type="html">
        This review refers to the first edition of "The Ruby way", published in 2001. With Ruby being quite a moving target (as an actively developed language), this book is dated. It seems that the author is about to release a 2nd edition in a couple of months, which will surely â€¦</summary><content type="html">
        This review refers to the first edition of "The Ruby way", published in 2001. With Ruby being quite a moving target (as an actively developed language), this book is dated. It seems that the author is about to release a 2nd edition in a couple of months, which will surely be much more up-to-date.

Having read "Programming Ruby", I haven't found anything new in "The Ruby way", as it basically treats the same topics. Judging by its name, I was kinda hoping of a deeper treatment of "the way", as in the correct approach to Ruby coding, explaining the mindset a programmer has to get into. But it's far from that, unfortunately. It is more of an intermediate-level reference, touching quite a lot of topics and not focusing too much on idiomatic Ruby.

I have no idea what the 2nd edition will be like, but I think it will be quite interchangeable with "Programming Ruby, 2nd edition". Reading both books doesn't really add anything in terms of Ruby knowledge.

    </content><category term="misc"></category><category term="Book reviews"></category><category term="Ruby"></category></entry><entry><title>Longest Increasing Subsequence</title><link href="https://eli.thegreenplace.net/2006/04/18/longest-increasing-subsequence" rel="alternate"></link><published>2006-04-18T09:16:35-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2006-04-18:/2006/04/18/longest-increasing-subsequence</id><summary type="html">
        I've posted a new code snippet:
        &lt;a href="https://github.com/eliben/code-for-blog/tree/main/2006/lis_algorithms.rb"&gt;
            lis_algorithms.rb
        &lt;/a&gt;
        - an implementation of 3 different algorithms for solving the &lt;a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem"&gt;Longest Increasing Subsequence problem&lt;/a&gt;. 

The implementations are:

&lt;ol&gt;
	&lt;li&gt;Using the the &lt;a href="http://en.wikipedia.org/wiki/Longest_common_subsequence"&gt;Longest Common Subsequence&lt;/a&gt; algorithm on a sequence with its sorted self: &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;Using a dynamic programming algorithm described &lt;a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem"&gt;here &lt;/a&gt;. It is â€¦&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">
        I've posted a new code snippet:
        &lt;a href="https://github.com/eliben/code-for-blog/tree/main/2006/lis_algorithms.rb"&gt;
            lis_algorithms.rb
        &lt;/a&gt;
        - an implementation of 3 different algorithms for solving the &lt;a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem"&gt;Longest Increasing Subsequence problem&lt;/a&gt;. 

The implementations are:

&lt;ol&gt;
	&lt;li&gt;Using the the &lt;a href="http://en.wikipedia.org/wiki/Longest_common_subsequence"&gt;Longest Common Subsequence&lt;/a&gt; algorithm on a sequence with its sorted self: &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;Using a dynamic programming algorithm described &lt;a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem"&gt;here &lt;/a&gt;. It is also &lt;code&gt;O(n^2)&lt;/code&gt;, but faster than (1) because of better constants and less generality.&lt;/li&gt;
	&lt;li&gt;Using a greedy algorithm described &lt;a href="http://home.tiac.net/~cri/2001/mlas.html"&gt;here&lt;/a&gt;, that runs in &lt;code&gt;O(n*log(n))&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;




    </content><category term="misc"></category><category term="Math"></category><category term="Ruby"></category></entry><entry><title>Understanding Ruby blocks, Procs and methods</title><link href="https://eli.thegreenplace.net/2006/04/18/understanding-ruby-blocks-procs-and-methods" rel="alternate"></link><published>2006-04-18T07:06:35-07:00</published><updated>2023-06-30T23:16:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2006-04-18:/2006/04/18/understanding-ruby-blocks-procs-and-methods</id><summary type="html">
        &lt;h3&gt;Introduction&lt;/h3&gt;

Ruby provides the programmer with a set of very powerful features borrowed from the domain of &lt;a href="http://en.wikipedia.org/wiki/Functional_programming"&gt;functional programming&lt;/a&gt;, namely &lt;a href="http://en.wikipedia.org/wiki/Closure_%28computer_science%29"&gt;closures&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Higher-order_functions"&gt;high-order functions&lt;/a&gt; and &lt;a href="http://en.wikipedia.org/wiki/First_class_function"&gt;first-class functions&lt;/a&gt; &lt;a href="#note1"&gt;[1]&lt;/a&gt;. These features are implemented in Ruby by means of code blocks, Proc objects and methods (that are also objects) - concepts that are closely â€¦</summary><content type="html">
        &lt;h3&gt;Introduction&lt;/h3&gt;

Ruby provides the programmer with a set of very powerful features borrowed from the domain of &lt;a href="http://en.wikipedia.org/wiki/Functional_programming"&gt;functional programming&lt;/a&gt;, namely &lt;a href="http://en.wikipedia.org/wiki/Closure_%28computer_science%29"&gt;closures&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Higher-order_functions"&gt;high-order functions&lt;/a&gt; and &lt;a href="http://en.wikipedia.org/wiki/First_class_function"&gt;first-class functions&lt;/a&gt; &lt;a href="#note1"&gt;[1]&lt;/a&gt;. These features are implemented in Ruby by means of code blocks, Proc objects and methods (that are also objects) - concepts that are closely related and yet differ in subtle ways. In fact I found myself quite confused about this topic, having a difficulty to understand the difference between blocks, procs and methods and unsure about the best practices of using them. Additionally, having some background in Lisp and years of Perl experience, I was unsure of how the Ruby concepts map to similar idioms from other programming languages, like Lisp's functions and Perl's subroutines. Sifting through hundreds of newsgroup posts, I saw that I'm not the only one with this problem, and in fact quite a lot of "Ruby Nubies" struggle with the same ideas.
&lt;p /&gt;
In this article I lay out my understanding of this facet of Ruby, which comes as a result of extensive research of Ruby books, documentation and comp.lang.ruby, in sincere hope that other people will find it useful as well. 

&lt;h3&gt;Procs&lt;/h3&gt;

Shamelessly ripping from the Ruby documentation, Procs are defined as follows: &lt;i&gt;Proc objects are blocks of code that have been bound to a set of local variables. Once bound, the code may be called in different contexts and still access those variables.&lt;/i&gt;
&lt;p /&gt;
A useful example is also provided:
&lt;pre&gt;&lt;code&gt;
def gen_times(factor)
    return Proc.new {|n| n*factor }
end

times3 = gen_times(3)
times5 = gen_times(5)

times3.call(12)               #=&gt; 36
times5.call(5)                #=&gt; 25
times3.call(times5.call(4))   #=&gt; 60
&lt;/code&gt;&lt;/pre&gt;

Procs play the role of functions in Ruby. It is more accurate to call them function objects, since like everything in Ruby they are objects. Such objects have a name in the folklore - functors. A functor is defined as &lt;i&gt;an object to be invoked or called as if it were an ordinary function, usually with the same syntax&lt;/i&gt;, which is exactly what a Proc is. 
&lt;p /&gt;
From the example and the definition above, it is obvious that Ruby Procs can also act as closures. On Wikipedia, a closure is defined as &lt;i&gt;a function that refers to free variables in its lexical context&lt;/i&gt;. Note how closely it maps to the Ruby definition &lt;i&gt;blocks of code that have been bound to a set of local variables&lt;/i&gt;. 

&lt;h3&gt;More on Procs&lt;/h3&gt;

Procs in Ruby are &lt;a href="http://en.wikipedia.org/wiki/First-class_object"&gt;first-class objects&lt;/a&gt;, since they can be created during runtime, stored in data structures, passed as arguments to other functions and returned as the value of other functions. Actually, the &lt;code&gt;gen_times&lt;/code&gt; example demonstrates all of these criteria, except for "passed as arguments to other functions". This one can be presented as follows:
&lt;pre&gt;&lt;code&gt;
def foo (a, b)
    a.call(b)
end

putser = Proc.new {|x| puts x}
foo(putser, 34)
&lt;/code&gt;&lt;/pre&gt;
There is also a shorthand notation for creating Procs - the Kernel method &lt;code&gt;lambda&lt;/code&gt; &lt;a href="#note2"&gt;[2]&lt;/a&gt; (we'll come to methods shortly, but for now assume that a Kernel method is something akin to a global function, which can be called from anywhere in the code). Using &lt;code&gt;lambda&lt;/code&gt; the Proc object creation from the previous example can be rewritten as:
&lt;pre&gt;&lt;code&gt;
putser = lambda {|x| puts x}
&lt;/code&gt;&lt;/pre&gt;
Actually, there are two slight differences between &lt;code&gt;lambda&lt;/code&gt; and &lt;code&gt;Proc.new&lt;/code&gt;. First, argument checking. The Ruby documentation for &lt;code&gt;lambda&lt;/code&gt; states: &lt;i&gt;Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called.&lt;/i&gt;. Here is an example to demonstrate this:
&lt;pre&gt;&lt;code&gt;
lamb = lambda {|x, y| puts x + y}
pnew = Proc.new {|x, y| puts x + y}

# works fine, printing 6
pnew.call(2, 4, 11)

# throws an ArgumentError
lamb.call(2, 4, 11)
&lt;/code&gt;&lt;/pre&gt;
Second, there is a difference in the way returns are handled from the Proc. A &lt;code&gt;return&lt;/code&gt; from &lt;code&gt;Proc.new&lt;/code&gt; returns from the enclosing method (acting just like a &lt;code&gt;return&lt;/code&gt; from a block, more on this later):
&lt;pre&gt;&lt;code&gt;
def try_ret_procnew
    ret = Proc.new { return "Baaam" }
    ret.call
    "This is not reached"
end

# prints "Baaam"
puts try_ret_procnew
&lt;/code&gt;&lt;/pre&gt;
While &lt;code&gt;return&lt;/code&gt; from &lt;code&gt;lambda&lt;/code&gt; acts more conventionally, returning to its caller:
&lt;pre&gt;&lt;code&gt;
def try_ret_lambda
    ret = lambda { return "Baaam" }
    ret.call
    "This is printed"
end

# prints "This is printed"
puts try_ret_lambda
&lt;/code&gt;&lt;/pre&gt;
With this in light, I would recommend using &lt;code&gt;lambda&lt;/code&gt; instead of &lt;code&gt;Proc.new&lt;/code&gt;, unless the behavior of the latter is strictly required. In addition to being way cooler a whopping two characters shorter, its behavior is less surprising.

&lt;h3&gt;Methods&lt;/h3&gt;

Simply put, a method is also a block of code. However, unlike Procs, methods are not bound to the local variables around them. Rather, they are bound to some object and have access to its instance variables &lt;a href="#note3"&gt;[3]&lt;/a&gt;:
&lt;pre&gt;&lt;code&gt;
class Boogy
    def initialize
        @dix = 15
    end

    def arbo
        puts "#{@dix} ha\n"
    end
end

# initializes an instance of Boogy
b = Boogy.new

# prints "15 ha"
b.arbo
&lt;/code&gt;&lt;/pre&gt;
A useful idiom when thinking about methods is &lt;i&gt;sending messages&lt;/i&gt;. Given a receiver - an object that has some method defined, we can send it a message - by calling the method, optionally providing some arguments. In the example above, calling &lt;code&gt;arbo&lt;/code&gt; is akin to sending a message "arbo", without arguments. Ruby supports the message sending idiom more directly, by including the &lt;code&gt;send&lt;/code&gt; method in class &lt;code&gt;Object&lt;/code&gt; (which is the parent of all objects in Ruby). So the following two lines are equivalent to the &lt;code&gt;arbo&lt;/code&gt; method call:
&lt;pre&gt;&lt;code&gt;
# method/message name is given as a string
b.send("arbo")

# method/message name is given as a symbol
b.send(:arbo)
&lt;/code&gt;&lt;/pre&gt;
Note that methods can also be defined in the "top-level" scope, not inside any class. For example:
&lt;pre&gt;&lt;code&gt;
def say (something)
    puts something
end

say "Hello"
&lt;/code&gt;&lt;/pre&gt;
While it seems that &lt;code&gt;say&lt;/code&gt; is "free-standing", it is not. When methods such as this are defined, Ruby silently tucks them into the Object class. But this doesn't really matter, and for all practical purposes &lt;code&gt;say&lt;/code&gt; can be seen as an independent method. Which is, by the way, just what's called a "function" in some languages (like C and Perl). The following Proc is, in many ways similar:
&lt;pre&gt;&lt;code&gt;
say = lambda {|something| puts something}

say.call("Hello")

# same effect
say["Hello"]
&lt;/code&gt;&lt;/pre&gt;
The &lt;code&gt;[]&lt;/code&gt; construct is a synonym to &lt;code&gt;call&lt;/code&gt; in the context of Proc &lt;a href="#note4"&gt;[4]&lt;/a&gt;. Methods, however, are more versatile than procs and support a very important feature of Ruby, which I will present right after explaining what blocks are.

&lt;h3&gt;Blocks&lt;/h3&gt;

Blocks are so powerfully related to Procs that it gives many newbies a headache trying to decipher how they actually differ. I will try to ease on comprehension with a (hopefully not too corny) metaphor. Blocks, as I see them, are unborn Procs. Blocks are the larvae, Procs are the insects. A block does not live on its own - it prepares the code for when it will actually become alive, and only when it is &lt;i&gt;bound&lt;/i&gt; and converted to a Proc, it starts living:
&lt;pre&gt;&lt;code&gt;
# a naked block can't live in Ruby
# this is a compilation error !
{puts "hello"}

# now it's alive, having been converted
# to a Proc !
pr = lambda {puts "hello"}

pr.call
&lt;/code&gt;&lt;/pre&gt;
Is that it, is that what all the fuss is about, then ? No, not at all. The designer of Ruby, Matz saw that while passing Procs to methods (and other Procs) is nice and allows high-level functions and all kinds of fancy functional stuff, there is one common case that stands high above all other cases - passing a single block of code to a method that makes something useful out of it, for example iteration. And as a very talented designer, Matz decided that it is worthwhile to emphasize this special case, and make it both simpler and more efficient. 

&lt;h3&gt;Passing a block to a method&lt;/h3&gt;

No doubt that any programmer who has spent at least a couple of hours with Ruby has been shown the following examples of Ruby glory (or something very similar):
&lt;pre&gt;&lt;code&gt;
10.times do |i|
    print "#{i} "
end

numbers = [1, 2, 5, 6, 9, 21]

numbers.each do |x|
    puts "#{x} is " + (x &gt;= 3 ? "many" : "few")
end

squares = numbers.map {|x| x * x}
&lt;/code&gt;&lt;/pre&gt;
(Note that &lt;code&gt;do |x| ... end&lt;/code&gt; is equivalent to &lt;code&gt;{ |x| ... }&lt;/code&gt; )
&lt;p /&gt;
Such code is IMHO part of what makes Ruby the clean, readable and wonderful language it is. What happens here behind the scenes is quite simple, or at least may be depicted in a very simple way. Perhaps Ruby doesn't implement it exactly the way I'm going to describe it, since there are optimization considerations surely playing their role - but it is definitely close enough to the truth to serve as a metaphor for understanding.
&lt;p /&gt;
Whenever a block is appended to a method call, Ruby automatically converts it to a Proc object, but one without an explicit name. The method, however, has a way to access this Proc, by means of the &lt;code&gt;yield&lt;/code&gt; statement. See the following example for clarification:
&lt;pre&gt;&lt;code&gt;
def do_twice
    yield 
    yield
end

do_twice {puts "Hola"}
&lt;/code&gt;&lt;/pre&gt;
The method &lt;code&gt;do_twice&lt;/code&gt; is defined and called with an attached block. Although the method didn't explicitly ask for the block in its arguments list, the &lt;code&gt;yield&lt;/code&gt; can call the block. This can be implemented in a more explicit way, using a Proc argument:
&lt;pre&gt;&lt;code&gt;
def do_twice(what)
    what.call
    what.call
end

do_twice lambda {puts "Hola"}
&lt;/code&gt;&lt;/pre&gt;
This is equivalent to the previous example, but using blocks with &lt;code&gt;yield&lt;/code&gt; is cleaner, and better optimized since only one block is passed to the method, for sure. Using the Proc approach, any amount of code blocks can be passed:
&lt;pre&gt;&lt;code&gt;
def do_twice(what1, what2, what3)
    2.times do
        what1.call
        what2.call
        what3.call
    end
end

do_twice(   lambda {print "Hola, "},
            lambda {print "querido "},
            lambda {print "amigo\n"})
&lt;/code&gt;&lt;/pre&gt;
It is important to note that many people frown at passing blocks, and prefer explicit Procs instead. Their rationale is that a block argument is implicit, and one has to look through the whole code of the method to see if there are any calls to &lt;code&gt;yield&lt;/code&gt; there, while a Proc is explicit and can be immediately spotted in the argument list. While it's simply a matter of taste, understanding both approaches is vital.

&lt;h3&gt;The ampersand (&amp;amp;)&lt;/h3&gt;
The ampersand operator can be used to explicitly convert between blocks and Procs in a couple of esoteric cases. It is worthy to understand how these work.
&lt;p /&gt;
Remember how I said that although an attached block is converted to a Proc under the hood, it is not acessible as a Proc from inside the method ? Well, if an ampersand is prepended to the last argument in the argument list of a method, the block attached to this method is converted to a Proc object and gets assigned to that last argument:
&lt;pre&gt;&lt;code&gt;
def contrived(a, &amp;f;)
    # the block can be accessed through f
    f.call(a)
    
    # but yield also works !
    yield(a)
end

# this works
contrived(25) {|x| puts x}

# this doesn't (ArgumentError), because &amp;f; 
# isn't really an argument - it's only there 
# to convert a block
contrived(25, lambda {|x| puts x})
&lt;/code&gt;&lt;/pre&gt;
Another (IMHO far more efficacious) use of the ampersand is the other-way conversion - converting a Proc into a block. This is very useful because many of Ruby's great built-ins, and especially the iterators, expect to receive a block as an argument, and sometimes it's much more convenient to pass them a Proc. The following example is taken right from the excellent "Programming Ruby" book by the pragmatic programmers:
&lt;pre&gt;&lt;code&gt;
print "(t)imes or (p)lus: "
times = gets
print "number: "
number = Integer(gets)
if times =~ /^t/
    calc = lambda {|n| n*number }
else
    calc = lambda {|n| n+number }
end
puts((1..10).collect(&amp;calc;).join(", "))
&lt;/code&gt;&lt;/pre&gt;
The &lt;code&gt;collect&lt;/code&gt; method expects a block, but in this case it is very convenient to provide it with a Proc, since the Proc is constructed using knowledge gained from the user. The ampersand preceding &lt;code&gt;calc&lt;/code&gt; makes sure that the Proc object calc is turned into a code block and is passed to &lt;code&gt;collect&lt;/code&gt; as an attached block.
&lt;p /&gt;
The ampersand also allows the implementation of a very common idiom among Ruby programmers: passing method names into iterators. Assume that I want to convert all words in an Array to upper case. I could do it like this:
&lt;pre&gt;&lt;code&gt;
words = %w(Jane, aara, multiko)
upcase_words = words.map {|x| x.upcase}

p upcase_words
&lt;/code&gt;&lt;/pre&gt;
This is nice, and it works, but I feel it's a little bit too verbose. The &lt;code&gt;upcase&lt;/code&gt; method itself should be given to &lt;code&gt;map&lt;/code&gt;, without the need for a separate block and the apparently superfluous &lt;code&gt;x&lt;/code&gt; argument. Fortunately, as we saw before, Ruby supports the idiom of sending messages to objects, and methods can be referred to by their names, which are implemented as Ruby &lt;i&gt;Symbols&lt;/i&gt;. For example:
&lt;pre&gt;&lt;code&gt;
p "Erik".send(:upcase)
&lt;/code&gt;&lt;/pre&gt;
This, quite literally, says &lt;i&gt;send the message/method upcase to the object "Erik"&lt;/i&gt;. This feature can be utilized to implement the &lt;code&gt;map {|x| x.upcase}&lt;/code&gt; in an elegant manner, and we're going to use the ampersand for this ! As I said, when the ampersand is prepended to some Proc in a method call, it converts the Proc to a block. But what if we prepend it not to a Proc, but to another object ? Then, Ruby's implicit type conversion rules kick in, and the &lt;code&gt;to_proc&lt;/code&gt; method is called on the object to try and make a Proc out of it. We can use this to implement &lt;code&gt;to_proc&lt;/code&gt; for &lt;code&gt;Symbol&lt;/code&gt; and achieve what we want:
&lt;pre&gt;&lt;code&gt;
class Symbol
    
    # A generalized conversion of a method name
    # to a proc that runs this method.
    #
    def to_proc
        lambda {|x, *args| x.send(self, *args)}
    end
    
end

# Viola !
words = %w(Jane, aara, multiko)
upcase_words = words.map(&amp;:upcase)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

Ruby doesn't really have functions. Rather, it has two slightly different concepts - methods and Procs (which are, as we have seen, simply what other languages call function objects, or functors). Both are blocks of code - methods are bound to Objects, and Procs are bound to the local variables in scope. Their uses are quite different.
&lt;p /&gt;
Methods are the cornerstone of object-oriented programming, and since Ruby is a pure-OO language (everything is an object), methods are inherent to the nature of Ruby. Methods are the actions Ruby objects &lt;i&gt;do&lt;/i&gt; - the messages they receive, if you prefer the &lt;i&gt;message sending&lt;/i&gt; idiom.
&lt;p /&gt;
Procs make powerful functional programming paradigms possible, turning code into a first-class object of Ruby allowing to implement high-order functions. They are very close kin to Lisp's &lt;code&gt;lambda&lt;/code&gt; forms (there's little doubt about the origin of Ruby's Proc constructor &lt;code&gt;lambda&lt;/code&gt;)
&lt;p /&gt;
The construct of a block may at first be confusing, but it turns out to be quite simple. A block is, as my metaphor goes, an unborn Proc - it is a Proc in an intermediate state, not bound to anything yet. I think that the simplest way to think about blocks in Ruby, without losing any comprehension, would be to think that blocks are really a form of Procs, and not a separate concept. The only time when we have to think of blocks as slighly different from Procs is the special case when they are passed as the last argument to a method which may then access them using &lt;code&gt;yield&lt;/code&gt;.
&lt;p /&gt;
That's about it, I guess. I know for sure that the research I conducted for this article cleared many misunderstandings I had about the concepts presented here. I hope others will learn from it as well. If you see anything you don't agree with - from glaring errors to nitpicky inaccuracies, feel free to comment - I'll be happy to discuss any remarks and fix my mistakes.





&lt;h3&gt;Notes&lt;/h3&gt;
&lt;a name="note1"&gt;[1]&lt;/a&gt; It seems that in the pure, theoretical interpretation what Ruby has isn't first-class functions per se. However, as this article demonstrates, Ruby is perfectly capable of fulfilling most of the requirements for first-class functions, namely that functions can be created during the execution of a program, stored in data structures, passed as arguments to other functions, and returned as the values of other functions.
&lt;p /&gt;
&lt;a name="note2"&gt;[2]&lt;/a&gt; &lt;code&gt;lambda&lt;/code&gt; has a synonym - &lt;code&gt;proc&lt;/code&gt;, which is considered 'mildly deprecated' (mainly because &lt;code&gt;proc&lt;/code&gt; and &lt;code&gt;Proc.new&lt;/code&gt; are slightly different, which is confusing). In other words, just use &lt;code&gt;lambda&lt;/code&gt;.
&lt;p /&gt;
&lt;a name="note3"&gt;[3]&lt;/a&gt; These are 'instance methods'. Ruby also supports 'class methods', and 'class variables', but that is not what this article is about.
&lt;p /&gt;
&lt;a name="note4"&gt;[4]&lt;/a&gt; Or more accurately, &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt; both refer to the same method of class Proc. Yes, Proc objects themselves have methods !


    </content><category term="misc"></category><category term="Ruby"></category></entry><entry><title>Ruby as both a functional and an OO language</title><link href="https://eli.thegreenplace.net/2006/03/25/ruby-as-both-a-functional-and-an-oo-language" rel="alternate"></link><published>2006-03-25T06:51:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2006-03-25:/2006/03/25/ruby-as-both-a-functional-and-an-oo-language</id><summary type="html">
        &lt;p&gt;Ruby is a functional language - which means that its functions are first-class objects - functions can be created in runtime, stored in data structures, passed as arguments to other functions and so on. Consider the following example:&lt;/p&gt;
&lt;pre&gt;
debts = [['Alex', 250], ['Mary', 244], ['George', 501]]
debts_after_tax = debts.map {|o| o[1] *= 1 â€¦&lt;/pre&gt;</summary><content type="html">
        &lt;p&gt;Ruby is a functional language - which means that its functions are first-class objects - functions can be created in runtime, stored in data structures, passed as arguments to other functions and so on. Consider the following example:&lt;/p&gt;
&lt;pre&gt;
debts = [['Alex', 250], ['Mary', 244], ['George', 501]]
debts_after_tax = debts.map {|o| o[1] *= 1.2; o}
&lt;/pre&gt;
&lt;p&gt;The block that follows map is a new function, constructed and evaluated at runtime - passed in as an argument to map. This is an 'anonymous function' - it has no name and is created only once to do some job.&lt;br /&gt;
Say we want to turn an array of strings into integers. Here's an example:&lt;/p&gt;
&lt;pre&gt;
 str = "1-800-50-50-68"
 ar = str.split(/-/).map {|o| o.to_i}
&lt;/pre&gt;
&lt;p&gt;Note that, once again, we use map to iterate over all values in an array (that is returned by split) and apply a function to each value. Here, however, we see an actual deficiency in standard Ruby. We simply call one function on each object, why should it go through another new, anonymous function ? In fact, this is easily fixable, and the fix displays Ruby's Object Oriented nature.&lt;/p&gt;
&lt;p&gt;In Ruby everything is an object, including of course arrays. Arrays are derived from Enumerable, which actually defines the map method (and its synonim collect). We can add another form of map right into Enumerable:&lt;/p&gt;
&lt;pre&gt;
module Enumerable

     def mapf(method, *args)
         map {|obj| obj.send(method, *args)}
     end

 end
&lt;/pre&gt;
&lt;p&gt;Now we can simplify the last example to:&lt;/p&gt;
&lt;pre&gt;
str = "1-800-50-50-68"
 ar = str.split(/-/).mapf(:to_i)
&lt;/pre&gt;
&lt;p&gt;mapf is a new mapping method that takes a function name as an argument (represented by a Symbol in Ruby - symbols are generally used to represent names of things), and applies this function to all the values it iterates on.&lt;/p&gt;
&lt;p&gt;Note how natural the new call looks. In some functional but non-OO languages, we would have probably done something like:&lt;/p&gt;
&lt;pre&gt;
ar = mapf(:to_i, split(/-/, str))
&lt;/pre&gt;
&lt;p&gt;But since Ruby is fully object oriented, its way is simpler and much easier to understand.
&lt;/p&gt;

    </content><category term="misc"></category><category term="Ruby"></category></entry></feed>