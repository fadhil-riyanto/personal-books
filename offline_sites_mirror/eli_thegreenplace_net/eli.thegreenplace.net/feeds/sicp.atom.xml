<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - SICP</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/sicp.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2023-02-04T15:35:51-08:00</updated><entry><title>Signed copy of SICP</title><link href="https://eli.thegreenplace.net/2008/06/06/signed-copy-of-sicp" rel="alternate"></link><published>2008-06-06T07:59:28-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-06-06:/2008/06/06/signed-copy-of-sicp</id><summary type="html">
    &lt;p&gt;
        A lot of people were impressed by my finishing the read-through of SICP,
        completing the vast majority of the exercises. I received a lot of warm
        comments on my &lt;a href="https://eli.thegreenplace.net/2008/04/18/sicp-conclusion/"&gt;conclusion
    post&lt;/a&gt; - in the blog, on email, and on the &lt;a href="http://www.reddit.com/info/6g9mq/comments/"&gt;Reddit link&lt;/a&gt; that
immediately took place #1 in the Programming section …&lt;/p&gt;</summary><content type="html">
    &lt;p&gt;
        A lot of people were impressed by my finishing the read-through of SICP,
        completing the vast majority of the exercises. I received a lot of warm
        comments on my &lt;a href="https://eli.thegreenplace.net/2008/04/18/sicp-conclusion/"&gt;conclusion
    post&lt;/a&gt; - in the blog, on email, and on the &lt;a href="http://www.reddit.com/info/6g9mq/comments/"&gt;Reddit link&lt;/a&gt; that
immediately took place #1 in the Programming section and held it for a day.
        &lt;/p&gt;&lt;p&gt;

The most interesting feedback was, however, from Geoffrey S. Knauth. He's
acquainted with the book authors, and when he told them about my project, they
agreed to sign a book for me, which Geoffrey then shipped to Israel on his own
expense.
        &lt;/p&gt;

&lt;p&gt;Here's the book and a slip of paper displaying the complex logistics behind
this shipment:&lt;/p&gt;

&lt;img class="align-center" src="https://eli.thegreenplace.net/images/2008/06/img_2182.thumbnail.jpg" /&gt;

&lt;p&gt;And this is the opening page, with the authors' signatures:&lt;/p&gt;

&lt;img class="align-center" src="https://eli.thegreenplace.net/images/2008/06/signed_copy.thumbnail.PNG" /&gt;&lt;/a&gt;

&lt;p&gt;I'm really happy about this, and want to thank Geoffrey again for his initiative.&lt;/p&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>Book review: "Structure and Interpretation of Computer Programs" by Harold Abelson, Gerald Jay Sussman</title><link href="https://eli.thegreenplace.net/2008/05/28/book-review-structure-and-interpretation-of-computer-programs-by-harold-abelson-gerald-jay-sussman" rel="alternate"></link><published>2008-05-28T07:38:56-07:00</published><updated>2023-02-04T15:35:51-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-05-28:/2008/05/28/book-review-structure-and-interpretation-of-computer-programs-by-harold-abelson-gerald-jay-sussman</id><summary type="html">
    &lt;p&gt;
        I have the habit of writing &lt;a href="https://eli.thegreenplace.net/tag/book-reviews"&gt;reviews&lt;/a&gt; for
        the books I've read, and recently I noticed that something is missing.
        SICP. I've definitely &lt;a href="https://eli.thegreenplace.net/tag/sicp"&gt;read&lt;/a&gt; it, so I should
        probably write a review, eh ?
    &lt;/p&gt;&lt;p&gt;

The real reason for my writing this review is, however, its Amazon entry.
Although the first page …&lt;/p&gt;</summary><content type="html">
    &lt;p&gt;
        I have the habit of writing &lt;a href="https://eli.thegreenplace.net/tag/book-reviews"&gt;reviews&lt;/a&gt; for
        the books I've read, and recently I noticed that something is missing.
        SICP. I've definitely &lt;a href="https://eli.thegreenplace.net/tag/sicp"&gt;read&lt;/a&gt; it, so I should
        probably write a review, eh ?
    &lt;/p&gt;&lt;p&gt;

The real reason for my writing this review is, however, its Amazon entry.
Although the first page shines with glimmering reviews by, no less, Peter Norvig
and Paul Graham, the book has a 3.5 star average, which is really inexplicable.
Many far inferior books have higher grades! So I want to make my small
contribution by writing SICP the review it deserves, give it the grade it
deserves (5!!!!), and post it to Amazon as well. Lets get started, then.
    &lt;/p&gt;&lt;p&gt;

My first encounter with SICP was in the second year of university, where I took
a course named "SICP 1". I already had working programming experience by that
time, so the course wasn't hard, but I was struck by the beauty of the subjects
it taught, by the Scheme language it used and by the long and interesting
homework assignments it had. This course woke my curiosity about functional
programming, and the Lisp family of languages in particular.
    &lt;/p&gt;&lt;p&gt;

A few years later, with much more experience behind my back, I've decided to
tackle SICP seriously and read the whole book, solving the vast majority of the
exercises. This endeavor took about 10 months, and I enjoyed it immensely. I
think SICP is a wonderful book, a seminal work in the field of programming. It
is one of those rare books every programmer should read. In this review I'll try
to explain why.
    &lt;/p&gt;&lt;p&gt;

In contrast with most introductory books about programming that just teach you a
language, SICP takes a far better approach. The main goal of the authors is not
to teach Scheme, it is to teach programming. From the beginning, the book takes
an integrative path, where the basic axioms of programming are presented, and
later are fortified with examples and exercises. SICP teaches about
computational processes - iterative and recursive. How to use them best in each
situation, and how to implement them. It also explains abstraction by functional
composition. These are topics rarely presented in programming books, but SICP
puts them rightly in the first chapter, because they are the real stuff
programming is based on. 
    &lt;/p&gt;&lt;p&gt;

The example programs developed in the book are real, large, and exciting. You'll
get to develop a powerful picture language, a generic object-oriented arithmetic
package including complex and polynomial arithmetic, a simulator for digital
circuits, a symbolic differentiation package, an interpreter for Scheme written
in Scheme, an interpreter for a logic programming language similar to Prolog, a
virtual machine for a simplified pseudo-assembly DSL, an interpreter for Scheme
written in this pseudo-assembly, and finally a compiler from Scheme to the
assembly language. All these examples are real, well-thought out exercises for
skill, taken from beginning to a very complete end. In no other book such a
wealth of topics is addressed in an accessible manner.
    &lt;/p&gt;&lt;p&gt;

A word about exercises in SICP. They are numerous, some of them are hard, but
the exercises are the best way to really understand what the book tries to
teach. In a manner, they're as integral part of the book as the text itself. The
exercises are very well prepared and lead the reader through the examples coded
by the authors into greater understanding of the topics taught. At times, it
feels like the exercises are specifically designed to force you to think about
the essence of the topics, and not just grasp them superficially.
    &lt;/p&gt;&lt;p&gt;

SICP commonly suffers from the criticism that it's too hard for beginners. Maybe
this criticism is rightful, and universities should give a simpler introductory
course to programming before SICP. But this is an aspect of the educational
systems, not pertaining to the book itself. I wouldn't know, I never read SICP
as a beginner. However it is being taught, SICP is an amazing book. It is by far
the best programming book I have ever laid by hands on, and I seriously doubt
that it will be surpassed any time soon. Reading SICP will enlighten you as a
programmer, and make you a better one. I can't imagine one programmer who won't
gain something important by reading SICP. 
    &lt;/p&gt;

    </content><category term="misc"></category><category term="Book reviews"></category><category term="SICP"></category></entry><entry><title>SICP - conclusion</title><link href="https://eli.thegreenplace.net/2008/04/18/sicp-conclusion" rel="alternate"></link><published>2008-04-18T16:54:27-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-04-18:/2008/04/18/sicp-conclusion</id><summary type="html">
        &lt;p&gt;I've completed the &lt;span class="caps"&gt;SICP&lt;/span&gt; reading project, which I began on &lt;a href="https://eli.thegreenplace.net/2007/06/19/introducing-the-sicp-reading-notes/"&gt;June 19th, 2007&lt;/a&gt;. In hindsight, it seems like a very long time (almost a year!), during which this was my main hacking project at home. So, in this conclusion I want to examine my progress, and compare the result with …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;I've completed the &lt;span class="caps"&gt;SICP&lt;/span&gt; reading project, which I began on &lt;a href="https://eli.thegreenplace.net/2007/06/19/introducing-the-sicp-reading-notes/"&gt;June 19th, 2007&lt;/a&gt;. In hindsight, it seems like a very long time (almost a year!), during which this was my main hacking project at home. So, in this conclusion I want to examine my progress, and compare the result with my initial goals.&lt;/p&gt;


	&lt;p&gt;&lt;a href="https://eli.thegreenplace.net/2007/06/19/introducing-the-sicp-reading-notes/"&gt;The original plan&lt;/a&gt; was:&lt;/p&gt;


	&lt;ol&gt;
	&lt;li&gt;Read the book&lt;/li&gt;
		&lt;li&gt;See all the video lectures by Sussman and Abelson themselves &lt;/li&gt;
		&lt;li&gt;Do most of the interesting exercises in the book&lt;/li&gt;
		&lt;li&gt;Do some of the larger projects listed &lt;a href="http://mitpress.mit.edu/sicp/psets/index.html"&gt;here&lt;/a&gt; and &lt;a href="http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-001Spring-2005/CourseHome/index.htm"&gt;here&lt;/a&gt;&lt;/li&gt;
	&lt;/ol&gt;


	&lt;p&gt;Let's see how I've managed:&lt;/p&gt;


	&lt;ol&gt;
	&lt;li&gt;Done&lt;/li&gt;
		&lt;li&gt;Done&lt;/li&gt;
		&lt;li&gt;This is the point I'm most happy with. I've completed the vast majority of the exercises in &lt;span class="caps"&gt;SICP&lt;/span&gt; and posted them online. Of the 356 exercises in the book, I've skipped about 20, so I've completed 94% of the exercises &amp;#8211; which is far above my initial plans.&lt;/li&gt;
		&lt;li&gt;I didn't do this, but there's no need, having completed so many of the exercises. I feel I gained a completely solid understanding of the material, and won't gain much by doing the projects.&lt;/li&gt;
	&lt;/ol&gt;


	&lt;p&gt;Also, I originally planned to reimplement all the code do all the exercises in Common Lisp. Later I changed my mind and decided to use &lt;span class="caps"&gt;PLT&lt;/span&gt; Scheme for some of them. Eventually, I've been using both languages interchangeably, which is a good thing, as I got some practice with both.&lt;/p&gt;


	&lt;p&gt;Here are some numerical statistics that emphasize the magnitude of this endeavor:&lt;/p&gt;


	&lt;ol&gt;
	&lt;li&gt;I've written 52 blog posts (not including this one) in the &lt;span class="caps"&gt;SICP&lt;/span&gt; category, spread over 10 months.&lt;/li&gt;
		&lt;li&gt;The combined total length of my posts (including code snippets) is 66,265 words. For comparison, Jack London's "Son of the Wolf" is 50K words long.&lt;/li&gt;
		&lt;li&gt;Some of the large projects from the book I've re-implemented in wholeness: a constraint propagation solver, an evaluator (interpreter) for Scheme, a generic object-oriented arithmetic package including complex and polynomial arithmetic, Huffman encoding, an interpreter for a logic programming language similar to Prolog (as a &lt;span class="caps"&gt;DSL&lt;/span&gt; on top of Lisp), a picture-language interpreter, a simulator for digital circuits, a symbolic differentiation package, a virtual machine for a simplified pseudo-assembly &lt;span class="caps"&gt;DSL&lt;/span&gt;, an interpreter for Scheme written in this pseudo-assembly, and finally, a compiler for Scheme that spits out pseudo-assembly code.&lt;/li&gt;
		&lt;li&gt;Counting with the &lt;a href="http://sourceforge.net/project/showfiles.php?group_id=174787"&gt;cloc&lt;/a&gt; tool (Count Lines Of Code), the total physical &lt;span class="caps"&gt;LOC&lt;/span&gt; count&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt; for the code I've written during this time: 7,300 &lt;span class="caps"&gt;LOC&lt;/span&gt; of Common Lisp, 4,100 &lt;span class="caps"&gt;LOC&lt;/span&gt; of Scheme. If you prefer raw LOCs&lt;sup&gt;&lt;a href="#fn2"&gt;2&lt;/a&gt;&lt;/sup&gt;, it's 10,800 &lt;span class="caps"&gt;LOC&lt;/span&gt; of Common Lisp, 5,600 &lt;span class="caps"&gt;LOC&lt;/span&gt; of Scheme. So this is more than 10 &lt;span class="caps"&gt;KLOC&lt;/span&gt; of Lisp code, any way you look at it, which is a lot, since Lisp is a very expressive high-level functional language.&lt;/li&gt;
	&lt;/ol&gt;


	&lt;p&gt;A word on &lt;span class="caps"&gt;SICP&lt;/span&gt; and its exercises. Abelson and Sussman have created a masterpiece, a book initially written in the 1980s, and that still hasn't lost one bit of relevance. Everything it contains must, &lt;strong&gt;must&lt;/strong&gt; be learned and understood by any aspiring programmer. It teaches algorithms and data structures, good programming style, provides some contact with large systems, experimenting with their implementation and modification. You will learn about functional programming, imperative programming, object-oriented programming in it. You will learn how to implement interpreters, compilers, arithmetic systems, simulators, a whole virtual machine in it, and much more.&lt;/p&gt;


	&lt;p&gt;The exercises of &lt;span class="caps"&gt;SICP&lt;/span&gt; are essential to understanding. Looking back at the work I've done on the book, I don't think I would have understood it near so well without doing a lot of the exercises. There's only so much material that can be gained from reading. Getting your hands dirty with code is essential to true understanding. And the authors of &lt;span class="caps"&gt;SICP&lt;/span&gt; brought this concept to perfection, with their excellent exercises, that are an unreplaceable companion to the book. Although they're not 100% perfect, for the most part the exercises are very well thought out and tuned to aid understanding and practice writing parts of large systems.&lt;/p&gt;


&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;

	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; Physical &lt;span class="caps"&gt;LOC&lt;/span&gt;: lines of code, excluding comments and blank lines. To test my Common Lisp and Scheme code counts with &lt;code&gt;cloc.pl&lt;/code&gt;, I used these commands:&lt;/p&gt;


&lt;pre&gt;
cloc.pl --force-lang="Lisp",lisp *.lisp
cloc.pl --force-lang="Lisp",scm *.scm
&lt;/pre&gt;

	&lt;p id="fn2"&gt;&lt;sup&gt;2&lt;/sup&gt; Including comments and blank lines, as output by &lt;code&gt;wc -l&lt;/code&gt;.&lt;/p&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>SICP section 5.5</title><link href="https://eli.thegreenplace.net/2008/04/18/sicp-section-55" rel="alternate"></link><published>2008-04-18T12:17:37-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-04-18:/2008/04/18/sicp-section-55</id><summary type="html">
        &lt;p&gt;It took me some effort to get the compiler code to work in conjunction with the explicit control evaluator, especially when it came to linking compiled and interpreted code. The prime problem was additions I've made to the register machine simulator in previous chapters, in answer to exercises, and that …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;It took me some effort to get the compiler code to work in conjunction with the explicit control evaluator, especially when it came to linking compiled and interpreted code. The prime problem was additions I've made to the register machine simulator in previous chapters, in answer to exercises, and that didn't work well with the needs of the compiler.&lt;/p&gt;


	&lt;p&gt;For example, in one of the exercises it was requested to test whether operations are being done on labels, and flag these cases as errors. However, in &lt;code&gt;compile-lambda&lt;/code&gt;, the compiler creates this assignment:&lt;/p&gt;


&lt;pre&gt;
`((assign ,target
    (op make-compiled-procedure)
    (label ,proc-entry)
    (reg env)))))
&lt;/pre&gt;

&lt;!--more--&gt;

	&lt;p&gt;Note that it acts upon a label. So, I had to modify &lt;code&gt;make-operation-exp&lt;/code&gt; and remove the error caused by operations on labels.&lt;/p&gt;


	&lt;p&gt;Another place where a change was needed is in &lt;code&gt;lookup-variable-value&lt;/code&gt;, which, to answer an exercise, was modified to prepend &lt;code&gt;bound&lt;/code&gt; or &lt;code&gt;unbound&lt;/code&gt; to variables that were looked up. So I modified the code of &lt;code&gt;compile-variable&lt;/code&gt; to:&lt;/p&gt;


&lt;pre&gt;
(define (compile-variable exp target linkage)
  (end-with-linkage linkage
    (make-instruction-sequence '(env) (list target)
      `((assign ,target
                (op lookup-variable-value)
                (const ,exp)
                (reg env))
        (assign ,target
                (op var-val-extract-value)
                (reg ,target))))))
&lt;/pre&gt;

	&lt;p&gt;The addition is another &lt;code&gt;assign&lt;/code&gt; which uses &lt;code&gt;var-val-extract-value&lt;/code&gt; to extract the bound symbol values. As before the exercise, this code assumes that all the looked up variables are actually bound, and does not signal an error&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;


	&lt;p&gt;All the code required to run the compiler and execute the compiled code together with the explicit control evaluator on the register machine simulator can be downloaded in this bundle&lt;/p&gt;


	&lt;p&gt;In case you've missed it, consider what we have here. We have a compiler for Scheme, written in Scheme. This compiler spits out custom assembly code that executes on a register machine simulator, also written in Scheme. Moreover, this code can coexist with an interpreter for Scheme, written in the same assembly code. Isn't this just awesome ?&lt;/p&gt;


	&lt;p&gt;Anyway, since we now have all the infrastructure running, we're ready to tackle the exercises.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.31&lt;/h4&gt;


	&lt;ul&gt;
	&lt;li&gt;&lt;code&gt;(f 'x 'y)&lt;/code&gt; &amp;#8211; all those saves and restores are superfluous, because looking up the operator and operands does not modify any registers.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;&lt;code&gt;((f) 'x 'y)&lt;/code&gt; &amp;#8211; again, all the saves are superfluous. At first sight it might seem that &lt;code&gt;(f)&lt;/code&gt; may modify the &lt;code&gt;env&lt;/code&gt; register, so &lt;code&gt;env&lt;/code&gt; must be saved. But note that &lt;code&gt;env&lt;/code&gt; is not needed to evaluate the operands, since they are constants. Had the expression been &lt;code&gt;((f) x 'y)&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt; should've been saved, because it's needed to evaluate the variable &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;&lt;code&gt;(f (g 'x) y)&lt;/code&gt; &amp;#8211; &lt;code&gt;proc&lt;/code&gt; must be saved around the evaluation of the first operand, because it involves an application, which modifies &lt;code&gt;proc&lt;/code&gt;. The application also modifies &lt;code&gt;argl&lt;/code&gt;, so that one has to be saved too. &lt;code&gt;env&lt;/code&gt;, however, needs not be saved. To understand why, recall that the compiler builds the argument list in reverse. So first it evaluates &lt;code&gt;y&lt;/code&gt;, and only then &lt;code&gt;(g 'x)&lt;/code&gt;. Evaluating &lt;code&gt;y&lt;/code&gt; does not modify &lt;code&gt;env&lt;/code&gt;, so saving it isn't required.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;&lt;code&gt;(f (g 'x) 'y)&lt;/code&gt; &amp;#8211; exactly similar to the previous case. Since the argument list is built in reverse, &lt;code&gt;(g 'x)&lt;/code&gt; is constructed last, and there's really no difference in the effects of looking up &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;'y&lt;/code&gt; on the registers.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;h4&gt;Exercise 5.32&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;The section beginning with &lt;code&gt;ev-application&lt;/code&gt; has to be modified to:&lt;/p&gt;


&lt;pre&gt;
ev-application
  (save continue)
  (assign unev (op operands) (reg exp))
  (assign exp (op operator) (reg exp))
  (test (op symbol?) (reg exp))
  (branch (label ev-appl-operator-symbol))
  (save env)
  (save unev)      
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
ev-appl-operator-symbol
  (assign continue (label ev-appl-did-operator-no-restore))
  (goto (label eval-dispatch))
ev-appl-did-operator
  (restore unev)              ; the operands
  (restore env)
ev-appl-did-operator-no-restore
  (assign argl (op empty-arglist))
  (assign proc (reg val))     ; the operator
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
&lt;/pre&gt;

	&lt;p&gt;Note the test for &lt;code&gt;symbol?&lt;/code&gt; that jumps over the saves, and assigns &lt;code&gt;continue&lt;/code&gt; to a label that skips the restores.&lt;/p&gt;


	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;Alyssa is wrong for two reasons.&lt;/p&gt;


	&lt;ol&gt;
	&lt;li&gt;Note that the test and branch inserted in the code of part &lt;strong&gt;a.&lt;/strong&gt; does not come for free &amp;#8211; it has to be executed for each operator, so the performance increase is less than expected. The compiler does its optimizations at compile-time, investing the time once but causing the code to run faster every time it's executed.&lt;/li&gt;
		&lt;li&gt;Another major reason for the compiler's speed advantage over the interpreter is "parsing" of expressions. The evaluator has to take the expression &lt;code&gt;(+ 1 2)&lt;/code&gt; apart each time, figuring out that &lt;code&gt;+&lt;/code&gt; is the operator and 1 and 2 the operands. The compiler does this step just once, and generates code that already knows where everything is located.&lt;/li&gt;
	&lt;/ol&gt;


	&lt;h4&gt;Exercise 5.33&lt;/h4&gt;


	&lt;p&gt;The difference in the compiled code of the alternative is that it handles the invocation of the recursive call before evaluating &lt;code&gt;n&lt;/code&gt; in the multiplication, while the original code first evaluates &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;


	&lt;p&gt;Since the amount of instruction executed by each version of the compiled code is the same, I would expect the runtimes to be close to identical.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.34&lt;/h4&gt;


	&lt;p&gt;Here's the compiled code, annotated with comments:&lt;/p&gt;


&lt;pre&gt;
;; Construct the procedure and skip over code for
;; the procedure body
;;
  (assign val (op make-compiled-procedure) (label entry1) (reg env))
  (goto (label after-lambda2))
;; Entry point for calls to factorial
;;
entry1
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
;; Construct the internal procedure 'iter'
;; 
  (assign val (op make-compiled-procedure) (label entry3) (reg env))
  (goto (label after-lambda4))
entry3
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (product counter)) (reg argl) (reg env))
  (save continue)
  (save env)
;; evaluate the 'if' predicate: (&amp;gt; counter n)
;;
  (assign proc (op lookup-variable-value) (const &amp;gt;) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const counter) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch9
  (assign continue (label after-call10))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call10
  (restore env)
  (restore continue)
;; Test the 'if' predicate
;;
  (test (op false?) (reg val))
  (branch (label false-branch6))
;; In the true branch, evaluate and return 'product'
;;
true-branch5
  (assign val (op lookup-variable-value) (const product) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (goto (reg continue))
;; In the false branch, evaluate the application
;; of iter.
;;
false-branch6
  (assign proc (op lookup-variable-value) (const iter) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (save continue)
  (save proc)
  (save env)
;; Evaluate (+ counter 1)
;;
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const counter) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch15
  (assign continue (label after-call16))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call16
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
;; Evaluate (* counter product)
;;
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (op lookup-variable-value) (const product) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const counter) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch12
  (assign continue (label after-call13))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call13
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
;; The "recursive" call is done here.
;;
compiled-branch18
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call19
after-if7
;; After the body of the internal procedure,
;; we can compile the rest of the body of 
;; 'factorial'
;;
after-lambda4
;; Assign the variable 'iter' its procedure body
;;
  (perform (op define-variable!) (const iter) (reg val) (reg env))
  (assign val (const ok))
;; Execute (iter 1 1)
;;
  (assign proc (op lookup-variable-value) (const iter) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (const 1))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch20))
compiled-branch21
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch20
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call22
;; Now assign 
;;
after-lambda2
  (perform (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok))
&lt;/pre&gt;

	&lt;p&gt;Note that nothing is saved before the recursive call to &lt;code&gt;iter&lt;/code&gt;, in order to be restored later. It just jumps back to &lt;code&gt;iter&lt;/code&gt; using &lt;code&gt;(goto (reg val))&lt;/code&gt;. Contrary to the recursive case, where &lt;code&gt;continue&lt;/code&gt; was assigned to just after the recursive call before executing it, here &lt;code&gt;continue&lt;/code&gt; is just restored from the stack to its pre-call value. This is the essence of tail-call optimization.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.35&lt;/h4&gt;


	&lt;p&gt;Following the code carefully, and remembering that the argument list is being built from right to left, it's not difficult to see that the Scheme code that compiled into this was:&lt;/p&gt;


&lt;pre&gt;
(define (f x)
  (+ x (g (+ x 2))))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.36&lt;/h4&gt;


	&lt;p&gt;The compiler produces right-to-left order of evaluation for operands of a combinations. This can be easily seen in the compiled code for &lt;code&gt;(+ x y)&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (op lookup-variable-value) (const y) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch1))
compiled-branch2
  (assign continue (label after-call3))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch1
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call3
&lt;/pre&gt;

	&lt;p&gt;Note the order of &lt;code&gt;lookup-variable-value&lt;/code&gt; calls. &lt;code&gt;y&lt;/code&gt; is first, &lt;code&gt;x&lt;/code&gt; second.&lt;/p&gt;


	&lt;p&gt;The reason for this is also clear and was thoroughly explained in section 5.5.3 &amp;#8211; "Compiling Combinations"&lt;/p&gt;


	&lt;blockquote&gt;
		&lt;p&gt;The code to construct the argument list will evaluate each operand into val and then cons that value onto the argument list being accumulated in argl. Since we cons the arguments onto argl in sequence, we must start with the last argument and end with the first, so that the arguments will appear in order from first to last in the resulting list.&lt;/p&gt;
	&lt;/blockquote&gt;


	&lt;p&gt;In the compiler code, the culprit is function &lt;code&gt;construct-arglist&lt;/code&gt;, which calls &lt;code&gt;reverse&lt;/code&gt; on the list of operand codes before generating the actual code for them.&lt;/p&gt;


	&lt;p&gt;In order to modify the order to left-to-right, we'll need to move the &lt;code&gt;reverse&lt;/code&gt; from compile-time to run-time. The instructions will be generated in left-to-right order, and &lt;code&gt;reverse&lt;/code&gt; will be called on &lt;code&gt;argl&lt;/code&gt; afterwards. Here's the modified &lt;code&gt;construct-arglist&lt;/code&gt; that does the job:&lt;/p&gt;


&lt;pre&gt;
(define (construct-arglist operand-codes)
  (let ((operand-codes operand-codes))
    (if (null? operand-codes)
      (make-instruction-sequence '() '(argl)
        `((assign argl (const ()))))
      (let ((code-to-get-last-arg
              (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                  `((assign argl (op list) (reg val)))))))
        (if (null? (cdr operand-codes))
          code-to-get-last-arg
          (tack-on-instruction-sequence 
            (preserving '(env)
              code-to-get-last-arg
              (code-to-get-rest-args
                (cdr operand-codes)))
            (make-instruction-sequence '() '()
              '((assign argl (op reverse) (reg argl))))))))))
&lt;/pre&gt;

	&lt;p&gt;Now the compiled code for &lt;code&gt;(+ x y)&lt;/code&gt; will be:&lt;/p&gt;


&lt;pre&gt;
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const y) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op cons) (reg val) (reg argl))
  (assign argl (op reverse) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch1))
compiled-branch2
  (assign continue (label after-call3))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch1
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call3
&lt;/pre&gt;

	&lt;p&gt;This version of the compiler generates slower code, because the &lt;code&gt;reverse&lt;/code&gt; now has to be performed at run-time, something that was spared before.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.37&lt;/h4&gt;


	&lt;p&gt;The function &lt;code&gt;preserving&lt;/code&gt; generates a &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;restore&lt;/code&gt; for a register only if the first statement modifies a register the second one needs. By removing this condition, we can make &lt;code&gt;preserving&lt;/code&gt; generate the instructions always:&lt;/p&gt;


&lt;pre&gt;
(define (preserving regs seq1 seq2)
  (if (null? regs)
    (append-instruction-sequences seq1 seq2)
    (let ((first-reg (car regs)))
      (preserving (cdr regs)
        (make-instruction-sequence
          (list-union (list first-reg) (registers-needed seq1))
          (list-difference
            (registers-modified seq1)
            (list first-reg))
          (append 
            `((save ,first-reg))
            (statements seq1)
            `((restore ,first-reg))))
        seq2))))
&lt;/pre&gt;

	&lt;p&gt;Here's the compiled code for &lt;code&gt;(f 1 2)&lt;/code&gt; with the original &lt;code&gt;preserving&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
  (assign proc (op lookup-variable-value) (const f) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (const 1))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch1))
compiled-branch2
  (assign continue (label after-call3))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch1
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call3
&lt;/pre&gt;

	&lt;p&gt;Note that no saves and restores are generated, because none are needed here (see solution for Exercise 5.31)&lt;/p&gt;


	&lt;p&gt;Now, the same expression with the modified &lt;code&gt;preserving&lt;/code&gt; is compiled to:&lt;/p&gt;


&lt;pre&gt;
  (save continue)
  (save env)
  (save continue)
  (assign proc (op lookup-variable-value) (const f) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (restore continue)
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (save env)
  (save continue)
  (assign val (const 2))
  (restore continue)
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
  (save continue)
  (assign val (const 1))
  (restore continue)
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch1))
compiled-branch2
  (assign continue (label after-call3))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch1
  (save continue)
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
after-call3
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.38&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a &amp;#38; b&lt;/strong&gt;.&lt;/p&gt;


	&lt;p&gt;I'll add this new dispatch to &lt;code&gt;compile&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
((memq (car exp) '(+ - * / =))
  (compile-open-binary-op exp target linkage))
&lt;/pre&gt;

	&lt;p&gt;And the extra code is:&lt;/p&gt;


&lt;pre&gt;
(define (spread-arguments a1 a2)
  (let ((ca1 (compile a1 'arg1 'next))
        (ca2 (compile a2 'arg2 'next)))
    (list ca1 ca2)))

(define (compile-open-binary-op exp target linkage)
  (if (= (length exp) 3)
    (let ((op (car exp))
          (args (spread-arguments (cadr exp) (caddr exp))))
      (end-with-linkage linkage
        (append-instruction-sequences
          (car args)
          (preserving '(arg1)
            (cadr args)
            (make-instruction-sequence '(arg1 arg2) (list target)
              `((assign ,target (op ,op) (reg arg1) (reg arg2))))))))
    (error "Expected a 3-element list -- COMPILE-OPEN-BINARY-OP" exp)))
&lt;/pre&gt;

	&lt;p&gt;Note that &lt;code&gt;spread-arguments&lt;/code&gt; accepts strictly two arguments, because it has to place them in &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;. Also, I made it return a normal list, rather than an instruction sequence. This is because the appropriate place what to preserve is &lt;code&gt;compile-open-binary-op&lt;/code&gt;, that has 3 instruction sequences to append:&lt;/p&gt;


	&lt;ol&gt;
	&lt;li&gt;The evaluation of the first argument into &lt;code&gt;arg1&lt;/code&gt;&lt;/li&gt;
		&lt;li&gt;The evaluation of the second argument into &lt;code&gt;arg2&lt;/code&gt;, preserving &lt;code&gt;arg1&lt;/code&gt; because it will be needed later&lt;/li&gt;
		&lt;li&gt;The application of the operator to &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;&lt;/li&gt;
	&lt;/ol&gt;


	&lt;p&gt;Here are a couple of examples of code generated with these functions:&lt;/p&gt;


&lt;pre&gt;
'(* 4 5)
=&amp;gt;
  (assign arg1 (const 4))
  (assign arg2 (const 5))
  (assign val (op *) (reg arg1) (reg arg2))
  (goto (reg continue))

(* 66 (+ 1 3))
=&amp;gt;
  (assign arg1 (const 66))
  (save arg1)
  (assign arg1 (const 1))
  (assign arg2 (const 3))
  (assign arg2 (op +) (reg arg1) (reg arg2))
  (restore arg1)
  (assign val (op *) (reg arg1) (reg arg2))
  (goto (reg continue))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.39&lt;/h4&gt;


&lt;pre&gt;
(define (make-lexaddr framenum displacement)
  (list framenum displacement))

(define (lexaddr-framenum lexaddr)
  (car lexaddr))

(define (lexaddr-displacement lexaddr)
  (cadr lexaddr))

; Note, the following two functions operate on the _runtime_
; environment, where each frame is a pair: list of variables 
; with a list of their values.
;
(define (lexical-address-lookup lexaddr rt-env)
  (let ((addr-frame (list-ref rt-env (lexaddr-framenum lexaddr))))
    (let ((addr-val (list-ref (frame-values addr-frame) (lexaddr-displacement lexaddr))))
      (if (eq? addr-val '*unassigned*)
        (error "Var is unassigned"))
        (cons 'bound addr-val))))

(define (lexical-address-set! lexaddr rt-env newval)
  (let ((addr-frame (list-ref rt-env (lexaddr-framenum lexaddr))))
    (define (iter vals count)
      (cond ((null? vals)
              (error "Invalid lexical address - bad displacement"))
            ((= count 0)
              (set-car! vals newval))
            (else (iter (cdr vals) (+ 1 count)))))
    (iter (frame-values addr-frame) (lexaddr-displacement lexaddr))))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.40&lt;/h4&gt;


	&lt;p&gt;The full code for this section, including the modified compiler, can be downloaded here&lt;/p&gt;


	&lt;p&gt;He're the code generator for &lt;code&gt;lambda&lt;/code&gt;, which extends the compile-time environment:&lt;/p&gt;


&lt;pre&gt;
(define (compile-lambda-body exp proc-entry ct-env)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
      (make-instruction-sequence '(env proc argl) '(env)
        `(,proc-entry
          (assign env (op compiled-procedure-env) (reg proc))
          (assign env
                  (op extend-environment)
                  (const ,formals)
                  (reg argl)
                  (reg env))))
      (compile-sequence 
        (lambda-body exp) 
        'val 'return 
        (extend-ct-env ct-env formals)))))
&lt;/pre&gt;

	&lt;p&gt;It uses this utility function:&lt;/p&gt;


&lt;pre&gt;
(define (extend-ct-env ct-env frame)
  (cons frame ct-env))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.41&lt;/h4&gt;


&lt;pre&gt;
(define (find-variable var ct-env)
  (define (frame-iter var frames count)
    (if (null? frames) 
      '()
      (let ((var-index (index-in-list 
                        (lambda (i) (eq? i var))
                        (car frames))))
        (if (null? var-index)
          (frame-iter var (cdr frames) (+ count 1))
          (make-lexaddr count var-index)))))
  (frame-iter var ct-env 0))

; Returns the numerical index (0-based) of the first 
; item from the list that satisfies the predicate.
; If no suitable item is found, returns '()
;
(define (index-in-list pred lst)
  (define (iter pred lst count)
    (cond
      ((null? lst) '())
      ((pred (car lst)) count)
      (else (iter pred (cdr lst) (+ count 1)))))
  (iter pred lst 0)) 
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.42&lt;/h4&gt;


	&lt;p&gt;To understand how this works, it's important to keep in mind that the structure of the compile-time environment follows the structure of the run-time environment. The compiler, by knowing where inside the stack of &lt;code&gt;lambda&lt;/code&gt; statements it's located, can figure out which value is referenced in the code.&lt;/p&gt;


&lt;pre&gt;
(define (compile-variable exp target linkage ct-env)
  (let ((lookup-instruction 
          (let ((lexaddr-of-var (find-variable exp ct-env)))
            (if (null? lexaddr-of-var)
              `(assign ,target
                        (op lookup-variable-value)
                        (const ,exp)
                        (reg env))
              `(assign ,target
                        (op lexical-address-lookup)
                        (const ,lexaddr-of-var)
                        (reg env))))))
    (end-with-linkage linkage
      (make-instruction-sequence '(env) (list target)
        (list
          lookup-instruction
          `(assign ,target
                  (op var-val-extract-value)
                  (reg ,target)))))))

(define (compile-assignment exp target linkage ct-env)
  (let ((var (assignment-variable exp))
        (get-value-code
          (compile (assignment-value exp) 'val 'next ct-env)))
    (end-with-linkage linkage
      (preserving '(env)
        get-value-code
        (make-instruction-sequence '(env val) (list target)
          (let ((lexaddr-of-var (find-variable var ct-env)))
            (if (null? lexaddr-of-var)
              `((perform 
                  (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
                (assign ,target (const ok)))
              `((perform
                  (op lexical-address-set!)
                  (const ,lexaddr-of-var)
                  (reg env)
                  (reg val))
                (assign ,target (const ok))))))))))
&lt;/pre&gt;

	&lt;p&gt;Here's an example that demonstrates how these modifications work. This code:&lt;/p&gt;


&lt;pre&gt;
(define code
  '((lambda (x y) 
      (lambda (u v w)
        (set! x 60)
        (+ v w x))
      10 20 30)
    1 2)
)
&lt;/pre&gt;

	&lt;p&gt;Is compiled into:&lt;/p&gt;


&lt;pre&gt;
  (assign proc (op make-compiled-procedure) (label entry1) (reg env))
  (goto (label after-lambda2))
entry1
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (x y)) (reg argl) (reg env))
  (assign val (op make-compiled-procedure) (label entry3) (reg env))
  (goto (label after-lambda4))
entry3
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (u v w)) (reg argl) (reg env))
  (assign val (const 60))
  (perform (op lexical-address-set!) (const (1 0)) (reg env) (reg val))
  (assign val (const ok))
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign proc (op var-val-extract-value) (reg proc))
  (assign val (op lexical-address-lookup) (const (1 0)) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op list) (reg val))
  (assign val (op lexical-address-lookup) (const (0 2)) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op cons) (reg val) (reg argl))
  (assign val (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign val (op var-val-extract-value) (reg val))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch5))
compiled-branch6
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch5
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call7
after-lambda4
  (assign val (const 10))
  (assign val (const 20))
  (assign val (const 30))
  (goto (reg continue))
after-lambda2
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (const 1))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch9
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call10
&lt;/pre&gt;

	&lt;p&gt;Note how the relevant variables are accessed using &lt;code&gt;lexical-address-lookup&lt;/code&gt;, where applicable.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.43&lt;/h4&gt;


	&lt;p&gt;The change required here is very simple. &lt;code&gt;compile-lambda-body&lt;/code&gt; is modified to execute &lt;code&gt;scan-out-defines&lt;/code&gt; on the lambda body before passing it on to compilation:&lt;/p&gt;


&lt;pre&gt;
(define (compile-lambda-body exp proc-entry ct-env)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
      (make-instruction-sequence '(env proc argl) '(env)
        `(,proc-entry
          (assign env (op compiled-procedure-env) (reg proc))
          (assign env
                  (op extend-environment)
                  (const ,formals)
                  (reg argl)
                  (reg env))))
      (compile-sequence 
        (scan-out-defines (lambda-body exp))  ;; change!
        'val 'return 
        (extend-ct-env ct-env formals)))))
&lt;/pre&gt;

	&lt;h4&gt;The rest of section 5.5&lt;/h4&gt;


	&lt;p&gt;I think I'll skip the rest of the exercises.&lt;/p&gt;


&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;

	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; Although such error signaling shouldn't be difficult to add.&lt;/p&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>SICP section 5.4</title><link href="https://eli.thegreenplace.net/2008/04/04/sicp-section-54" rel="alternate"></link><published>2008-04-04T08:39:25-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-04-04:/2008/04/04/sicp-section-54</id><summary type="html">
        &lt;p&gt;When I began writing the explicit-control evaluator code for this section, I ran into a minor language incompatibility. While I've used CL to implement the meta-circular evaluator of chapter 4, I've employed Scheme for the implementation of the register machine simulator earlier in this chapter. This means that I can't …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;When I began writing the explicit-control evaluator code for this section, I ran into a minor language incompatibility. While I've used CL to implement the meta-circular evaluator of chapter 4, I've employed Scheme for the implementation of the register machine simulator earlier in this chapter. This means that I can't use the meta-circular evaluator's primitive functions directly in my register-machine code.&lt;/p&gt;

&lt;!--more--&gt;
	&lt;p&gt;So I've downloaded the code from chapter 4 of the book from &lt;a href="http://mitpress.mit.edu/sicp/code/index.html"&gt;here&lt;/a&gt;. The specific file that is included in my code is this one &amp;#8211; I've cleaned it up and modified it a little to be compatible with &lt;span class="caps"&gt;PLT&lt;/span&gt; Scheme, and provide only the required functionality.&lt;/p&gt;


	&lt;p&gt;The explicit-control evaluator itself is available here. I've modified it a little, adding some functionality for non-interactive evaluation. Specifically, this code:&lt;/p&gt;


&lt;pre&gt;
non-interactive-eval
  (perform (op initialize-stack))
  (test (op null?) (reg machine-args))
  (branch (label machine-end))
  (assign exp (op car) (reg machine-args))
  (assign machine-args (op cdr) (reg machine-args))
  (assign env (op get-global-environment))
  (assign continue (label non-interactive-eval))
  (goto (label eval-dispatch))
&lt;/pre&gt;

	&lt;p&gt;Can be jumped to instead of &lt;code&gt;read-eval-print-loop&lt;/code&gt;. It assumes there is a list of expressions to be evaluated in the &lt;code&gt;machine-args&lt;/code&gt; register, and goes over them, evaluating them from left to right. This allows for convenient execution of the evaluator as follows:&lt;/p&gt;


&lt;pre&gt;
(define code
  '(
    (define (sumsq a b)
      (+ (* a a) (* b b)))
    (define x 5)
    (define y 7)
    (define ans (sumsq x y))
    (print ans)
    ))

(set-register-contents! ec-eval 'machine-args code)
(start ec-eval)
=&amp;gt;
74
&lt;/pre&gt;

	&lt;p&gt;You'll also see in the beginning of the controller code these two lines:&lt;/p&gt;


&lt;pre&gt;
  ; (goto (label read-eval-print-loop))
  (goto (label non-interactive-eval))
&lt;/pre&gt;

	&lt;p&gt;Currently the jump to &lt;code&gt;read-eval-print-loop&lt;/code&gt; is commented, but this can be easily changed.&lt;/p&gt;


	&lt;p&gt;Another change you'll note in the definition of the machine's operations. I got tired of writing each operator name twice (once quoted, and once plain), and wrote the macro&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;code&gt;qq&lt;/code&gt; to handle it for me:&lt;/p&gt;


&lt;pre&gt;
(define-macro (qq e)
  `(list ',e ,e))
&lt;/pre&gt;

	&lt;p&gt;For example, &lt;code&gt;(qq adjoin-arg)&lt;/code&gt; gets translated in "compile-time" into &lt;code&gt;(list 'adjoin-arg adjoin-arg)&lt;/code&gt; so I have less repetitive typing to do.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.23&lt;/h4&gt;


	&lt;p&gt;Adding support for &lt;code&gt;cond&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
ev-cond
  (assign exp (op cond-&amp;gt;if) (reg exp))
  (goto (label ev-if))
&lt;/pre&gt;

	&lt;p&gt;And the appropriate dispatch is:&lt;/p&gt;


&lt;pre&gt;
(test (op cond?) (reg exp))
(branch (label ev-cond))
&lt;/pre&gt;

	&lt;p&gt;Finally, to make it all work the operations &lt;code&gt;cond?&lt;/code&gt; and &lt;code&gt;cond-&amp;gt;if&lt;/code&gt; must be added to the machine.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.24&lt;/h4&gt;


	&lt;p&gt;Here's the code:&lt;/p&gt;


&lt;pre&gt;
  ;; Implemented explicitly as a basic special form, 
  ;; without converting to a nested if
  ;;
ev-cond-basic
  (assign unev (op cond-clauses) (reg exp))
ev-cond-ev-clause
  (assign exp (op first-exp) (reg unev))
  (test (op cond-else-clause?) (reg exp))
  (branch (label ev-cond-action))
  (save exp)
  (save env)
  (save unev)
  (save continue)
  ;; Setup an evaluation of the clause predicate
  (assign exp (op cond-predicate) (reg exp))
  (assign continue (label ev-cond-clause-decide))
  (goto (label eval-dispatch))

ev-cond-clause-decide
  (restore continue)
  (restore unev)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-cond-action))
ev-cond-next-clause
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-cond-ev-clause)) ; loop to next clause

  ;; We get here when the clause condition was found to
  ;; be true (or it was an 'else' clause), and we want
  ;; the actions to be evaluated. The clause is in exp.
  ;; We setup a call to ev-sequence and jump to it.
  ;;
ev-cond-action
  (assign unev (op cond-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
&lt;/pre&gt;

	&lt;p&gt;Now &lt;code&gt;eval-dispatch&lt;/code&gt; can jump to &lt;code&gt;ev-cond-basic&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
  (test (op cond?) (reg exp))
  (branch (label ev-cond-basic))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.25&lt;/h4&gt;


	&lt;p&gt;I'll pass.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.26&lt;/h4&gt;


	&lt;p&gt;To make this work, I've re-included the modified &lt;code&gt;make-new-machine&lt;/code&gt; and &lt;code&gt;make-stack&lt;/code&gt; from exercise 5.14, and removed the command to reinitialize the stack after each executed expression in &lt;code&gt;non-interactive-eval&lt;/code&gt;. The code I'm running is:&lt;/p&gt;


&lt;pre&gt;
(define code
  '(
    (define (factorial n)
      (define (iter product counter)
        (if (&amp;gt; counter n)
            product
            (iter (* counter product)
                  (+ counter 1))))
      (iter 1 1))

    (newline)
    (print (factorial 3))
    (newline)
  ))

(set-register-contents! ec-eval 'machine-args code)
(start ec-eval)

(newline)
(newline)
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt; The maximal depth required for this code is 13&lt;/p&gt;


	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


	&lt;table&gt;
		&lt;tr&gt;
			&lt;th&gt;n&lt;/th&gt;
			&lt;th&gt;pushes&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;2&lt;/td&gt;
			&lt;td&gt;113&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;3&lt;/td&gt;
			&lt;td&gt;148&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;4&lt;/td&gt;
			&lt;td&gt;183&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;5&lt;/td&gt;
			&lt;td&gt;218&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;




	&lt;p&gt;From this, the number of pushes is &lt;code&gt;35n + 43&lt;/code&gt;.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.27&lt;/h4&gt;


	&lt;table&gt;
		&lt;tr&gt;
			&lt;th&gt;Type&lt;/th&gt;
			&lt;th&gt;Maximal depth&lt;/th&gt;
			&lt;th&gt;Number of pushes&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Recursive&lt;/td&gt;
			&lt;td&gt;5n + 6&lt;/td&gt;
			&lt;td&gt;32n &amp;#8211; 2&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Iterative&lt;/td&gt;
			&lt;td&gt;13&lt;/td&gt;
			&lt;td&gt;35n + 43&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;




	&lt;h4&gt;Exercise 5.28&lt;/h4&gt;


	&lt;p&gt;After changing &lt;code&gt;ev-sequence&lt;/code&gt; to:&lt;/p&gt;


&lt;pre&gt;
ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
&lt;/pre&gt;

	&lt;p&gt;The table of exercise 5.27 turns into:&lt;/p&gt;


	&lt;table&gt;
		&lt;tr&gt;
			&lt;th&gt;Type&lt;/th&gt;
			&lt;th&gt;Maximal depth&lt;/th&gt;
			&lt;th&gt;Number of pushes&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Recursive&lt;/td&gt;
			&lt;td&gt;8n + 6&lt;/td&gt;
			&lt;td&gt;34n &amp;#8211; 2&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Iterative&lt;/td&gt;
			&lt;td&gt;3n + 17&lt;/td&gt;
			&lt;td&gt;37n + 47&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;




	&lt;h4&gt;Exercise 5.29&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


	&lt;table&gt;
		&lt;tr&gt;
			&lt;th&gt;n&lt;/th&gt;
			&lt;th&gt;depth&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;2&lt;/td&gt;
			&lt;td&gt;16&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;3&lt;/td&gt;
			&lt;td&gt;21&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;4&lt;/td&gt;
			&lt;td&gt;26&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;5&lt;/td&gt;
			&lt;td&gt;31&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;




	&lt;p&gt;From this, the formula for depth is &lt;code&gt;5n + 6&lt;/code&gt;.&lt;/p&gt;


	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;Let's collect some more data for this:&lt;/p&gt;


	&lt;table&gt;
		&lt;tr&gt;
			&lt;th&gt;n&lt;/th&gt;
			&lt;th&gt;pushes&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;2&lt;/td&gt;
			&lt;td&gt;86&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;3&lt;/td&gt;
			&lt;td&gt;142&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;4&lt;/td&gt;
			&lt;td&gt;254&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;5&lt;/td&gt;
			&lt;td&gt;422&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;6&lt;/td&gt;
			&lt;td&gt;702&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;7&lt;/td&gt;
			&lt;td&gt;1150&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;8&lt;/td&gt;
			&lt;td&gt;1878&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;




	&lt;p&gt;It can be easily seen that &lt;code&gt;S(n) = S(n-1) + S(n-2) + 26&lt;/code&gt;.&lt;/p&gt;


	&lt;p&gt;To find out &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, I'll subtract &lt;code&gt;S(n)&lt;/code&gt; from &lt;code&gt;S(n+1)&lt;/code&gt; to cancel out &lt;code&gt;b&lt;/code&gt;: &lt;code&gt;S(n+1)-S(n) = a*Fib(n+2) - a*Fib(n+1) = a*(Fib(n+2) - Fib(n+1))&lt;/code&gt;. But due to the property of the Fibonacci series, this means that: &lt;code&gt;S(n+1)-S(n) = a*Fib(n)&lt;/code&gt;. And since &lt;code&gt;S(n) = S(n-1) + S(n-2) + 26&lt;/code&gt;, we can rewrite it as &lt;code&gt;a*Fib(n-1) = S(n-2) + 26&lt;/code&gt;, or &lt;code&gt;S(n) = a*Fib(n+1) - 26&lt;/code&gt;.&lt;/p&gt;


	&lt;p&gt;Now we're ready to assign the various results into this to compute &lt;code&gt;a&lt;/code&gt;. Having the formula and &lt;code&gt;b&lt;/code&gt; in our hands, it's easy to see that &lt;code&gt;a = 56&lt;/code&gt;.&lt;/p&gt;


	&lt;p&gt;So, finally: &lt;code&gt;S(n) = 56Fib(n+1) - 26&lt;/code&gt;&lt;/p&gt;


	&lt;h4&gt;Exercise 5.30&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt; 
Maybe I'm missing something, but this doesn't seem to be so much work. After all, a variable is only handled in a single place in the &lt;code&gt;eval&lt;/code&gt; dispatch, so this is the place to make a modification. First of all, I'll change the supporting Scheme code to have special values for unbound variables:&lt;/p&gt;


&lt;pre&gt;
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
              (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
              (cons 'bound (car vals)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (cons 'unbound '())
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (var-val-bound? varval)
  (and 
    (pair? varval) 
    (eq? (car varval) 'bound)))

(define (var-val-extract-value varval)
  (cdr varval))
&lt;/pre&gt;

	&lt;p&gt;Now, changing &lt;code&gt;ev-variable&lt;/code&gt; in the evaluator code:&lt;/p&gt;


&lt;pre&gt;
ev-variable
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (test (op var-val-bound?) (reg val))
  (branch (label ev-variable-var-bound))
  (goto (label unbound-variable))
ev-variable-var-bound
  (assign val (op var-val-extract-value) (reg val))
  (goto (reg continue))
&lt;/pre&gt;

	&lt;p&gt;And finally, a new error type:&lt;/p&gt;


&lt;pre&gt;
unbound-variable
  (assign val (const unbound-variable-error))
  (goto (label signal-error))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;
Well, this indeed is a lot of work, and it's very repetitive, so I'm reluctant to do it. The basic model is identical to what I've written in part &lt;strong&gt;a&lt;/strong&gt; of this question.&lt;/p&gt;


	&lt;p&gt;Each primitive that can signal an error must be modified similarly to the way &lt;code&gt;lookup-variable-value&lt;/code&gt; was modified, to return a pair of &lt;code&gt;(error? value)&lt;/code&gt;, with the appropriate support procedures. The evaluator code in &lt;code&gt;primitive-apply&lt;/code&gt; must check for the error, similarly to the modified &lt;code&gt;ev-variable&lt;/code&gt; in the code above.&lt;/p&gt;


&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;

	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; Personally, I like the &lt;code&gt;define-macro&lt;/code&gt; utility more than the Scheme's &lt;code&gt;syntax-rules&lt;/code&gt; and &lt;code&gt;syntax-case&lt;/code&gt; macro tools. &lt;code&gt;define-macro&lt;/code&gt; is almost identical to Common Lisp's &lt;code&gt;defmacro&lt;/code&gt; and is natively supported by the most common Scheme implementations (Bigloo, Chicken, Gambit, Gauche and &lt;span class="caps"&gt;PLT&lt;/span&gt; Scheme). To use it in &lt;span class="caps"&gt;PLT&lt;/span&gt; Scheme you'll have to include the &lt;code&gt;defmacro.ss&lt;/code&gt; library:&lt;/p&gt;


&lt;pre&gt;
(require (lib "defmacro.ss"))
&lt;/pre&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>SICP section 5.3</title><link href="https://eli.thegreenplace.net/2008/03/07/sicp-section-53" rel="alternate"></link><published>2008-03-07T16:54:19-08:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-03-07:/2008/03/07/sicp-section-53</id><summary type="html">
        &lt;p&gt;I liked the way the authors used vectors to simply implement list structures. While cumbersome, the &lt;code&gt;car&lt;/code&gt;, &lt;code&gt;cdr&lt;/code&gt; and &lt;code&gt;cons&lt;/code&gt; they've defined actually work very well. Here's a simple example that builds a cons cell and prints it out:&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre&gt;
(define fib
  (make-machine
    '(n x y a b c val n1 …&lt;/pre&gt;</summary><content type="html">
        &lt;p&gt;I liked the way the authors used vectors to simply implement list structures. While cumbersome, the &lt;code&gt;car&lt;/code&gt;, &lt;code&gt;cdr&lt;/code&gt; and &lt;code&gt;cons&lt;/code&gt; they've defined actually work very well. Here's a simple example that builds a cons cell and prints it out:&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre&gt;
(define fib
  (make-machine
    '(n x y a b c val n1 the-cars the-cdrs free)
    `((= ,=) (+ ,+) (printf ,printf)
      (vector-ref ,vector-ref) 
      (vector-set! ,vector-set!) 
      (make-vector ,make-vector))
    '(
      ; create the-cars and the-cdrs vectors
      (assign the-cars (op make-vector) (const 100))
      (assign the-cdrs (op make-vector) (const 100))

      ; init the free pointer
      (assign free (const 0))

      ; n &amp;lt;- (cons x y)
      (perform (op vector-set!) (reg the-cars) (reg free) (reg x))
      (perform (op vector-set!) (reg the-cdrs) (reg free) (reg y))
      (assign n (reg free))
      (assign free (op +) (reg free) (const 1))

      ; print (car x)
      (assign val (op vector-ref) (reg the-cars) (reg n))
      (perform (op printf) (const "~a~%") (reg val))

      ; print (cdr y)
      (assign val (op vector-ref) (reg the-cdrs) (reg n))
      (perform (op printf) (const "~a~%") (reg val))      
    )))

(set-register-contents! fib 'x 100)
(set-register-contents! fib 'y 222)
(start fib)

=&amp;gt;

100
222
&lt;/pre&gt;

	&lt;p&gt;Unfortunately they don't go on implementing this system, and leave the &lt;em&gt;typed pointers&lt;/em&gt; out. Hence, predicates such as &lt;code&gt;pair?&lt;/code&gt; and &lt;code&gt;null?&lt;/code&gt; aren't available.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.20&lt;/h4&gt;


	&lt;p&gt;The box and pointer diagram created by:&lt;/p&gt;


&lt;pre&gt;
(define x (cons 1 2))
(define y (list x x))
&lt;/pre&gt;

	&lt;p&gt;Is:&lt;/p&gt;


	&lt;p&gt;&lt;img src="https://eli.thegreenplace.net/images/2008/02/env1.png" /&gt;&lt;/p&gt;


	&lt;p&gt;The numbers in orange circles are the cons-cell numbers that are referenced in the memory-vector representation, which is:&lt;/p&gt;


	&lt;p&gt;&lt;img src="https://eli.thegreenplace.net/images/2008/02/mem_vector.png" /&gt;&lt;/p&gt;


	&lt;p&gt;&lt;code&gt;free&lt;/code&gt; will contain &lt;code&gt;p4&lt;/code&gt; after these assignments, since the cell at index 4 is the next unallocated memory slot.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.21&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;The weirdest thing has just happened. I banged in the machine code for this computation and it worked the first time. No debugging, no tracing, nada. And this is a double-recursive function we're talking about ! I attribute this success to the structured way to write recursive procedures I've spoken about &lt;a href="https://eli.thegreenplace.net/2008/02/22/sicp-section-51/"&gt;here&lt;/a&gt;. Although that was for a single recursion, double recursion isn't really more difficult if you follow the same guidelines. So here is the code, note how well it adheres to the rules I've previously outlined:&lt;/p&gt;


&lt;pre&gt;
(define count-leaves-rec
  (make-machine
    '(tree n retval temp retaddr)
    `((= ,=) (+ ,+) (car ,car) (cdr ,cdr)
      (not ,not) (null? ,null?) (pair? ,pair?))
    '(
        (goto (label machine-start))

      ;;; procedure count-leaves-rec
      count-leaves-rec
        (restore retaddr)       ; return address
        (restore temp)          ; argument
        (save tree)             ; save caller's regs
        (save n)
        (save retaddr)
        (assign tree (reg temp)) ; working on 'tree'
        (test (op null?) (reg tree))
        (branch (label count-leaves-null))
        (test (op pair?) (reg tree))
        (branch (label count-leaves-pair))
        (goto (label count-leaves-atom))

      count-leaves-pair
        ; First recursive call, push arguments &amp;#38;
        ; return address, and execute call.
        ;
        (assign temp (op car) (reg tree))
        (save temp)
        (assign retaddr (label after-first-return))
        (save retaddr)
        (goto (label count-leaves-rec))

      after-first-return
        (assign n (reg retval))

        ; Second recursive call
        ;
        (assign temp (op cdr) (reg tree))
        (save temp)
        (assign retaddr (label after-second-return))
        (save retaddr)
        (goto (label count-leaves-rec))

      after-second-return
        (assign retval (op +) (reg n) (reg retval))
        (goto (label count-leaves-end))

      count-leaves-null
        (assign retval (const 0))
        (goto (label count-leaves-end))

      count-leaves-atom
        (assign retval (const 1))
        (goto (label count-leaves-end))

      count-leaves-end
        (restore retaddr)       ; restore caller's regs
        (restore n)
        (restore tree)
        (goto (reg retaddr))    ; return to caller
      ;;; end procedure count-leaves-rec

      machine-start
        (save tree)
        (assign retaddr (label machine-end))
        (save retaddr)
        (goto (label count-leaves-rec))

      machine-end
      )))
&lt;/pre&gt;

	&lt;p&gt;A small test shows that this works:&lt;/p&gt;


&lt;pre&gt;
(set-register-contents! count-leaves-rec 
  'tree '(1 (3 4) 5 (6 (7 3) 9)))
(set-register-contents! count-leaves-rec 'retval 0)

(start count-leaves-rec)

(printf ":~a~%" (get-register-contents count-leaves-rec 'retval))

=&amp;gt;

:8
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;In this version of &lt;code&gt;count-leaves&lt;/code&gt;, there are also two recursive calls, but one of them is &lt;em&gt;tail-recursive&lt;/em&gt; and can be replaced by a loop:&lt;/p&gt;


&lt;pre&gt;
(define count-leaves
  (make-machine
    '(tree n retval temp1 temp2 retaddr)
    `((= ,=) (+ ,+) (car ,car) (cdr ,cdr)
      (not ,not) (null? ,null?) (pair? ,pair?))
    '(
        (goto (label machine-start))

      ;;; procedure count-leaves-iter
      count-leaves-iter
        (restore retaddr)       ; return address
        (restore temp1)         ; argument 'tree'
        (restore temp2)         ; argument 'n'
        (save tree)             ; save caller's regs
        (save n)
        (save retaddr)
        (assign tree (reg temp1)) 
        (assign n (reg temp2))

      count-leaves-iter-loop
        (test (op null?) (reg tree))
        (branch (label count-leaves-null))
        (test (op pair?) (reg tree))
        (branch (label count-leaves-pair))
        (goto (label count-leaves-atom))

      count-leaves-pair
        ; Recursive call, push arguments &amp;#38;
        ; return address, and execute call.
        ;
        (save n)
        (assign temp1 (op car) (reg tree))
        (save temp1)
        (assign retaddr (label after-recursive-return))
        (save retaddr)
        (goto (label count-leaves-iter))

      after-recursive-return
        (assign n (reg retval))
        (assign tree (op cdr) (reg tree))
        (goto (label count-leaves-iter-loop))

      count-leaves-null
        (assign retval (reg n))
        (goto (label count-leaves-end))

      count-leaves-atom
        (assign retval (op +) (reg n) (const 1))
        (goto (label count-leaves-end))

      count-leaves-end
        (restore retaddr)       ; restore caller's regs
        (restore n)
        (restore tree)
        (goto (reg retaddr))    ; return to caller
      ;;; end procedure count-leaves-iter

      machine-start
        (assign n (const 0))
        (save n)
        (save tree)
        (assign retaddr (label machine-end))
        (save retaddr)
        (goto (label count-leaves-iter))

      machine-end
      )))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.22&lt;/h4&gt;


	&lt;p&gt;Here is &lt;code&gt;append&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(define append-rec
  (make-machine
    '(x y retval temp1 temp2 retaddr)
    `((car ,car) (cdr ,cdr) (cons ,cons)
      (not ,not) (null? ,null?) (pair? ,pair?))
    '(
        (goto (label machine-start))

      ;;; procedure append-rec
      append-rec
        (restore retaddr)       ; return address
        (restore temp2)         ; argument 'y'
        (restore temp1)         ; argument 'x'
        (save x)                ; save caller's regs
        (save y)
        (save retaddr)
        (assign x (reg temp1)) 
        (assign y (reg temp2))

        (test (op null?) (reg x))
        (branch (label append-null-x))
        (goto (label append-not-null-x))

      append-null-x
        (assign retval (reg y))
        (goto (label append-end))

      append-not-null-x 
        ; Execute recursive call
        (assign temp1 (op cdr) (reg x))
        (save temp1)
        (save y)
        (assign retaddr (label after-recursive-return))
        (save retaddr)
        (goto (label append-rec))

      after-recursive-return
        (assign temp1 (op car) (reg x))
        (assign retval (op cons) (reg temp1) (reg retval))

      append-end
        (restore retaddr)       ; restore caller's regs
        (restore y)
        (restore x)
        (goto (reg retaddr))    ; return to caller
      ;;; end procedure append-end

      machine-start
        (save x)
        (save y)
        (assign retaddr (label machine-end))
        (save retaddr)
        (goto (label append-rec))

      machine-end
      )))
&lt;/pre&gt;

	&lt;p&gt;And a test:&lt;/p&gt;


&lt;pre&gt;
(set-register-contents! append-rec 'x '(1 2 3))
(set-register-contents! append-rec 'y '(8 9))
(set-register-contents! append-rec 'retval '())

(start append-rec)
(printf ":~a~%" (get-register-contents append-rec 'retval))
=&amp;gt;
:(1 2 3 8 9)
&lt;/pre&gt;

	&lt;p&gt;And this is &lt;code&gt;append!&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(define append!
  (make-machine
    '(x y retval temp1 temp2 retaddr)
    `((car ,car) (cdr ,cdr) (cons ,cons)
      (set-cdr! ,set-cdr!)
      (not ,not) (null? ,null?) (pair? ,pair?))
    '(
        (goto (label machine-start))

      ;;; procedure append!
      append!
        (restore retaddr)
        (restore y)
        (restore x)

        ; Prepare arguments and call last-pair
        (save x)
        (assign temp2 (label after-last-pair))
        (save temp2)
        (goto (label last-pair))

      after-last-pair
        (assign temp2 (reg retval))
        (perform (op set-cdr!) (reg temp2) (reg y))
        (assign retval (reg x))
        (goto (reg retaddr))
      ;;; end procedure append!

      ;;; procedure last-pair
      last-pair
        (restore temp2)         ; argument 'retaddr'
        (restore temp1)         ; argument 'x'
        (save x)
        (save retaddr)
        (assign x (reg temp1))
        (assign retaddr (reg temp2))

      last-pair-loop
        (assign temp1 (op cdr) (reg x))
        (test (op null?) (reg temp1))
        (branch (label last-pair-null))
        (assign x (op cdr) (reg x))
        (goto (label last-pair-loop))

      last-pair-null
        (assign retval (reg x))
        (assign temp2 (reg retaddr))
        (restore retaddr)
        (restore x)
        (goto (reg temp2))    ; return
      ;;; end procedure last-pair

      machine-start
        (save x)
        (save y)
        (assign retaddr (label machine-end))
        (save retaddr)
        (goto (label append!))

      machine-end
      )))
&lt;/pre&gt;

	&lt;p&gt;And a test:&lt;/p&gt;


&lt;pre&gt;
(set-register-contents! append! 'x '(1 2 3))
(set-register-contents! append! 'y '(8 9))

(start append!)
(printf ":~a~%" (get-register-contents append! 'x))
=&amp;gt;
:(1 2 3 8 9)
&lt;/pre&gt;

	&lt;h4&gt;A word on programming style&lt;/h4&gt;


	&lt;p&gt;I wrote about this before, but I want to emphasize this point again: the programming style I'm using here for writing the register machine code is not optimized for speed or minimal space. Rather, its main aim is to be systematic and easily understandable. It's definitely possible to optimize away a few statements in each machine I wrote in this section, especially in the handling of stack data, but &lt;span class="caps"&gt;IMHO&lt;/span&gt; that would hurt the clarity of this code. And clarity is my preference, at least here.&lt;/p&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>SICP section 5.2</title><link href="https://eli.thegreenplace.net/2008/02/23/sicp-section-52" rel="alternate"></link><published>2008-02-23T18:04:14-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-02-23:/2008/02/23/sicp-section-52</id><summary type="html">
        The full implementation of the register-machine simulator is here.
	
	&lt;h4&gt;Exercise 5.7&lt;/h4&gt;

Done 

	&lt;h4&gt;Exercise 5.8&lt;/h4&gt;


	&lt;p&gt;When control reaches &lt;code&gt;there&lt;/code&gt;, the contents of &lt;code&gt;a&lt;/code&gt; are 3. This happens because:&lt;/p&gt;
&lt;!--more--&gt;

	&lt;ul&gt;
	&lt;li&gt;When the machine code is assembled, the function &lt;code&gt;extract-labels&lt;/code&gt; builds a list of all the labels in the code. When two …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">
        The full implementation of the register-machine simulator is here.
	
	&lt;h4&gt;Exercise 5.7&lt;/h4&gt;

Done 

	&lt;h4&gt;Exercise 5.8&lt;/h4&gt;


	&lt;p&gt;When control reaches &lt;code&gt;there&lt;/code&gt;, the contents of &lt;code&gt;a&lt;/code&gt; are 3. This happens because:&lt;/p&gt;
&lt;!--more--&gt;

	&lt;ul&gt;
	&lt;li&gt;When the machine code is assembled, the function &lt;code&gt;extract-labels&lt;/code&gt; builds a list of all the labels in the code. When two labels have the same name, this label name will appear twice in the list.&lt;/li&gt;
		&lt;li&gt;When the &lt;code&gt;goto&lt;/code&gt; instruction is executed, it finds the label to go to by calling &lt;code&gt;lookup-label&lt;/code&gt;, which uses &lt;code&gt;assoc&lt;/code&gt; on the list of labels. &lt;code&gt;assoc&lt;/code&gt; returns the first "hit", so the fist label of the duplicates is jumped to.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;p&gt;We'll modify &lt;code&gt;extract-labels&lt;/code&gt; to test whether a label already exists before adding it to the list:&lt;/p&gt;


&lt;pre&gt;
(define (extract-labels text)
  (if (null? text)
    (cons '() '())
    (let ((result (extract-labels (cdr text))))
      (let ((instructions (car result))
            (labels (cdr result)))
        (let ((next-instruction (car text)))
          (if (symbol? next-instruction) ; a label ?
            (if (label-exists labels next-instruction)
              (error "Label name is duplicated: " next-instruction)
              (cons instructions
                    (cons (make-label-entry next-instruction instructions) labels)))
            (cons (cons (make-instruction next-instruction) instructions)
                  labels)))))))
&lt;/pre&gt;

	&lt;p&gt;This auxiliary function is used to preserve the abstraction of &lt;code&gt;labels&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(define (label-exists labels label-name)
  (assoc label-name labels))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.9&lt;/h4&gt;


	&lt;p&gt;Adding a simple label test to &lt;code&gt;make-operation-exp&lt;/code&gt; does the trick:&lt;/p&gt;


&lt;pre&gt;
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (if (label-exp? e)
                  (error "Using operation on label: " e)
                  (make-primitive-exp e machine labels)))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.10&lt;/h4&gt;


	&lt;p&gt;At this point in the book, I don't find this exercise interesting enough to pursue.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.11&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;The change will be done after the label &lt;code&gt;afterfib-n-2&lt;/code&gt;. These lines:&lt;/p&gt;


&lt;pre&gt;
(assign n (reg val))    
(restore val)             
&lt;/pre&gt;

	&lt;p&gt;Place &lt;code&gt;Fib(n-2)&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;Fib(n-1)&lt;/code&gt; in &lt;code&gt;val&lt;/code&gt;. They can be replaced by the single line:&lt;/p&gt;


&lt;pre&gt;
(restore n)                   
&lt;/pre&gt;

	&lt;p&gt;Which places &lt;code&gt;Fib(n-1)&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt;, because &lt;code&gt;Fib(n-2)&lt;/code&gt; is already in &lt;code&gt;val&lt;/code&gt;, and we only use the values in an addition which is commutative, so it doesn't care about the order of its addends:&lt;/p&gt;


&lt;pre&gt;
(assign val (op +) (reg val) (reg n))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;I'll store a &lt;code&gt;(reg-name reg)&lt;/code&gt; pair on the stack instead of just the &lt;code&gt;reg&lt;/code&gt;. These are the new &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;restore&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(define (make-save inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
    (lambda ()
      (push stack (cons reg-name (get-contents reg)))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
    (lambda ()
      (let* ((stack-top (pop stack))
              (saved-reg-name (car stack-top))
              (saved-reg (cdr stack-top)))
        (if (equal? reg-name saved-reg-name)
          (begin
            (set-contents! reg saved-reg)    
            (advance-pc pc))
          (error (format "Restoring saved reg ~a into ~a~%" 
                          saved-reg-name reg-name)))))))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;First of all, I'll modify the stack data structure to make it manage several stacks, each with its own name. Now the state variable &lt;code&gt;s&lt;/code&gt; holds an association list of &lt;code&gt;(stack-name stack)&lt;/code&gt; which is accessed with &lt;code&gt;assoc&lt;/code&gt;. &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; will receive the stack name:&lt;/p&gt;


&lt;pre&gt;
(define (make-stack)
  (let ((s '()))
    (define (push reg-name x)
      (let ((reg-stack (assoc reg-name s)))
        (if reg-stack
          (set-cdr! reg-stack (cons x (cdr reg-stack)))
          (error "PUSH: No stack for register " reg-name))))
    (define (pop reg-name)
      (let ((reg-stack (assoc reg-name s)))
        (if reg-stack
          (if (null? (cdr reg-stack))
            (error "POP: Empty stack for register " reg-name)
            (let ((top (cadr reg-stack)))
              (set-cdr! reg-stack (cddr reg-stack))
              top))
          (error "POP: No stack for register " reg-name))))
    (define (add-reg-stack reg-name)
      (if (assoc reg-name s)
        (error "Stack already exists for " reg-name)
        (set! s (cons (cons reg-name '()) s))))
    (define (initialize)
      (for-each
        (lambda (stack)
          (set-cdr! stack '()))
        s)
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) pop)
            ((eq? message 'add-reg-stack) add-reg-stack)
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request -- STACK" message))))
    dispatch))

(define (pop stack reg-name)
  ((stack 'pop) reg-name))

(define (push stack reg-name value)
  ((stack 'push) reg-name value))
&lt;/pre&gt;

	&lt;p&gt;Now, the &lt;code&gt;allocate-register&lt;/code&gt; internal function in &lt;code&gt;make-new-machine&lt;/code&gt; must be rewritten. Each time the machine is asked to allocate a new register, it adds a stack for this register to the stack management object:&lt;/p&gt;


&lt;pre&gt;
(define (allocate-register name)
  (if (assoc name register-table)
    (error "Multiply defined register: " name)
    (begin
      (set! register-table 
            (cons (list name (make-register name))
                  register-table))
      ((stack 'add-reg-stack) name)
      'register-allocated)))
&lt;/pre&gt;

	&lt;p&gt;And finally, these are the new &lt;code&gt;make-save&lt;/code&gt; and &lt;code&gt;make-restore&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(define (make-save inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
    (lambda ()
      (push stack reg-name (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
    (lambda ()
      (set-contents! reg (pop stack reg-name))
      (advance-pc pc))))
&lt;/pre&gt;

	&lt;p&gt;Here's a demonstration of this feature:&lt;/p&gt;


&lt;pre&gt;
(define fib
  (make-machine
    '(n val n1)
    `((= ,=))
    '(
      (save n)
      (assign n (const 40))
      (save n)

      (save val)
      (assign val (const 10))
      (save val)

      (restore n)
      (assign n1 (reg n))
      (restore n)

      (assign val (const 1))
      (restore val)

      )))

(set-register-contents! fib 'n 8 )
(set-register-contents! fib 'val 3)
(start fib)
(printf ":~a~%" (get-register-contents fib 'n))
(printf ":~a~%" (get-register-contents fib 'n1))
(printf ":~a~%" (get-register-contents fib 'val))
=&amp;gt;
:8
:40
:10
&lt;/pre&gt;

	&lt;p&gt;Note how each register has its own stack, and a &lt;code&gt;save&lt;/code&gt; or &lt;code&gt;restore&lt;/code&gt; to another register don't affect it.&lt;/p&gt;


	&lt;h4&gt;Exercises 5.12 &amp;#8211; 5.13&lt;/h4&gt;


	&lt;p&gt;I'll pass. I understand the simulator well enough now and don't feel these exercises will add to my comprehension.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.14&lt;/h4&gt;


	&lt;p&gt;The factorial machine does all its &lt;code&gt;save&lt;/code&gt;-s first and only then its &lt;code&gt;restore&lt;/code&gt;-s. Hence, the maximal depth of the stack and the amount of &lt;code&gt;push&lt;/code&gt;-es are equal. Let's try to match a linear equation for &lt;code&gt;P&lt;/code&gt; &amp;#8211; the amount of pushes:&lt;/p&gt;


	&lt;table style="border:1px solid black;"&gt;
		&lt;tr&gt;
			&lt;th&gt;n&lt;/th&gt;
			&lt;th&gt;P&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;1&lt;/td&gt;
			&lt;td&gt;0&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;2&lt;/td&gt;
			&lt;td&gt;2&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;3&lt;/td&gt;
			&lt;td&gt;4&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;4&lt;/td&gt;
			&lt;td&gt;6&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;5&lt;/td&gt;
			&lt;td&gt;8&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;6&lt;/td&gt;
			&lt;td&gt;10&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;




	&lt;p&gt;From this it's quite obvious that for an input &lt;code&gt;n&lt;/code&gt; the amount of pushes is &lt;code&gt;2n-2&lt;/code&gt;.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.15&lt;/h4&gt;


	&lt;p&gt;This is the modified &lt;code&gt;make-new-machine&lt;/code&gt;. Changed and added lines are marked with a comment.&lt;/p&gt;


&lt;pre&gt;
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (instruction-count 0)           ;; **
        (the-instruction-sequence '()))
    (let ((the-ops
            (list (list 'initialize-stack
                        (lambda () (stack 'initialize)))))
          (register-table
            (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
          (error "Multiply defined register: " name)
          (set! register-table 
                (cons (list name (make-register name))
                      register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register: " name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
            'done
            (begin
              (set! instruction-count (+ 1 instruction-count)) ;; **
              ((instruction-execution-proc (car insts)))
              (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) 
                (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              ((eq? message 'get-instruction-count)  ;; **
                (let ((count instruction-count))   
                  (set! instruction-count 0)        
                  count))
              (else (error "Unknown request -- MACHINE" message))))
      dispatch)))
&lt;/pre&gt;

	&lt;p&gt;The instruction count is incremented in the &lt;code&gt;execute&lt;/code&gt; procedure, prior to executing a new instruction.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.16&lt;/h4&gt;


	&lt;p&gt;I'll add a state variable into the large &lt;code&gt;let&lt;/code&gt; at the top of &lt;code&gt;make-new-machine&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(instruction-trace-on #f)
&lt;/pre&gt;

	&lt;p&gt;The new messages the machine accepts are:&lt;/p&gt;


&lt;pre&gt;
((eq? message 'trace-on)
  (set! instruction-trace-on #t))
((eq? message 'trace-off)
  (set! instruction-trace-on #f))
&lt;/pre&gt;

	&lt;p&gt;And this is the new &lt;code&gt;execute&lt;/code&gt; procedure (it augments both instruction counting and tracing):&lt;/p&gt;


&lt;pre&gt;
(define (execute)
  (let ((insts (get-contents pc)))
    (if (null? insts)
      'done
      (begin
        (set! instruction-count (+ 1 instruction-count))
        (if instruction-trace-on
          (printf "trace: ~a~%" (instruction-text (car insts))))
        ((instruction-execution-proc (car insts)))
        (execute)))))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.17&lt;/h4&gt;


	&lt;p&gt;To make this work I'll change the way instructions are represented. Thankfully, the "instruction" abstraction is hidden behind a constructor and a set of accessors, so not too much code has to be modified:&lt;/p&gt;


&lt;pre&gt;
(define (make-instruction text)
  (list text '() '()))
(define (make-instruction-with-label text label)
  (list text label '()))
(define (instruction-text instruction)
  (car instruction))
(define (instruction-label instruction)
  (cadr instruction))
(define (instruction-execution-proc instruction)
  (caddr instruction))
(define (set-instruction-label! instruction label)
  "Sets the label that is tied to this instruction" 
  (set-cdr! instruction proc))
(define (set-instruction-execution-proc! instruction proc)
  (set-car! (cddr instruction) proc))
&lt;/pre&gt;

	&lt;p&gt;As you can see, an instruction is now implemented by a triplet: the instruction text, the label tied to it and its execution procedure.&lt;/p&gt;


	&lt;p&gt;Now, all that's left is to modify &lt;code&gt;extract-labels&lt;/code&gt; to attach labels to relevant instructions:&lt;/p&gt;


&lt;pre&gt;
(define (extract-labels text)
  (if (null? text)
    (cons '() '())
    (let ((result (extract-labels (cdr text))))
      (let ((instructions (car result))
            (labels (cdr result)))
        (let ((next-instruction (car text)))
          (if (symbol? next-instruction) ; a label ?
            (if (label-exists labels next-instruction)
              (error "Label name is duplicated: " next-instruction)
              (cons 
                (if (null? instructions)
                  '()
                  (cons
                    (make-instruction-with-label 
                      (instruction-text (car instructions))
                      next-instruction)
                    (cdr instructions)))
                (cons (make-label-entry next-instruction instructions) labels)))
            (cons (cons (make-instruction next-instruction) instructions)
                  labels)))))))
&lt;/pre&gt;

	&lt;p&gt;Here's a sample run:&lt;/p&gt;


&lt;pre&gt;
(define fib
  (make-machine
    '(n val n1)
    `((= ,=))
    '(
      (save n)
      (assign n (const 40))
      (save n)
    george
      (save val)
      (assign val (const 10))
    just-a-label
      (save val)
      )))

(set-register-contents! fib 'n 8)
(fib 'trace-on)
(start fib)

=&amp;gt;

trace: (save n)
trace: (assign n (const 40))
trace: (save n)
at label: george
trace: (save val)
trace: (assign val (const 10))
at label: just-a-label
trace: (save val)
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.18&lt;/h4&gt;


	&lt;p&gt;Here is the modified &lt;code&gt;make-register&lt;/code&gt;. I've added the required messages, and changed the &lt;code&gt;cond&lt;/code&gt; to a friendlier&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;code&gt;case&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(define (make-register name)
  (let ((contents '*unassigned*)
        (trace-on #f))
    (define (dispatch message)
      (case message
        ((get) contents)
        ((set)
          (lambda (value) 
            (when trace-on
              (printf "reg trace: ~a &amp;lt;- ~a (was ~a)~%" 
                name value contents))
            (set! contents value)))
        ((trace-on) (set! trace-on #t))
        ((trace-off) (set! trace-off #f))
        (else ((error "Unknown request -- REGISTER" message)))))
    dispatch))
&lt;/pre&gt;

	&lt;p&gt;The following procedure and messages were added to &lt;code&gt;make-new-machine&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
  ...
  (define (set-register-trace! name trace-msg)
    (let ((reg (assoc name register-table)))
      (if reg
        ((cadr reg) trace-msg)
        (error "Unknown register: " name))))
  ...
  ((eq? message 'reg-trace-on)
    (lambda (reg-name)
      (set-register-trace! reg-name 'trace-on)))
  ((eq? message 'reg-trace-off)
    (lambda (reg-name)
      (set-register-trace! reg-name 'trace-off)))
&lt;/pre&gt;

	&lt;p&gt;Here's a sample, with both instruction and register tracing on:&lt;/p&gt;


&lt;pre&gt;
(define fib
  (make-machine
    '(n val n1)
    `((= ,=))
    '(
      (assign n (const 40))
      (save n)
    george
      (save val)
      (assign val (const 10))
      (assign n (const 125))
      )))

=&amp;gt;

trace: (assign n (const 40))
reg trace: n &amp;lt;- 40 (was 8)
trace: (save n)
at label: george
trace: (save val)
trace: (assign val (const 10))
trace: (assign n (const 125))
reg trace: n &amp;lt;- 125 (was 40)
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.19&lt;/h4&gt;


	&lt;p&gt;I'll pass.&lt;/p&gt;


&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;

	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; I deem &lt;code&gt;case&lt;/code&gt; to be friendlier here because all the &lt;code&gt;cond&lt;/code&gt; clauses are comparing the same variable (&lt;code&gt;message&lt;/code&gt;) to different values. Using &lt;code&gt;case&lt;/code&gt; here saves quite a few keystrokes.&lt;/p&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>SICP section 5.1</title><link href="https://eli.thegreenplace.net/2008/02/22/sicp-section-51" rel="alternate"></link><published>2008-02-22T17:44:26-08:00</published><updated>2023-02-04T15:35:51-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-02-22:/2008/02/22/sicp-section-51</id><summary type="html">
        &lt;p&gt;The code for chapter 5 will be written in Scheme&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt; (using &lt;span class="caps"&gt;PLT&lt;/span&gt; Scheme).&lt;/p&gt;


	&lt;h4&gt;Introduction&lt;/h4&gt;


  &lt;p&gt;As usual, I've jumped forward and implemented the register machine
  simulator of section 5.2, in order to be able to test the solutions to the
  exercises of this section. The simulator is available for …&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;The code for chapter 5 will be written in Scheme&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt; (using &lt;span class="caps"&gt;PLT&lt;/span&gt; Scheme).&lt;/p&gt;


	&lt;h4&gt;Introduction&lt;/h4&gt;


  &lt;p&gt;As usual, I've jumped forward and implemented the register machine
  simulator of section 5.2, in order to be able to test the solutions to the
  exercises of this section. The simulator is available for download here&lt;/a&gt;,
  with a test suite (using the SchemeUnit package) here.
&lt;!--more--&gt;

	&lt;h4&gt;Exercises 5.1 &amp;#8211; 5.2&lt;/h4&gt;


	&lt;p&gt;I'll skip the drawings, and will present the code code the iterative factorial process with the register-machine language:&lt;/p&gt;


&lt;pre&gt;
(define iter-fact
  (make-machine
    '(n product counter)
    `((&amp;gt; ,&amp;gt;) (* ,*) (+ ,+))
    '(
      init
        (assign counter (const 1))
        (assign product (const 1))
      loop
        (test (op &amp;gt;) (reg counter) (reg n))
        (branch (label end-fib))
        (assign product (op *) (reg counter) (reg product))
        (assign counter (op +) (reg counter) (const 1))
        (goto (label loop))
      end-fib
    )))

(set-register-contents! iter-fact 'n 6)
(start iter-fact)
(get-register-contents iter-fact 'product)
=&amp;gt;
720
&lt;/pre&gt;

	&lt;p&gt;Note a convenience I'll be using throughout the chapter: instead of specifying the operations as a &lt;code&gt;list&lt;/code&gt; of &lt;code&gt;list&lt;/code&gt; explicitly, I'm using the backquote operator with commas. If this syntax is unfamiliar, consult &lt;a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.2.6"&gt;this section&lt;/a&gt; of the Scheme manual.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.3&lt;/h4&gt;


	&lt;p&gt;Once again, I'll skip the data path drawings and will get right to the register-machine code that can be simulated and tested. First, let's see the version that assumes &lt;code&gt;good-enough?&lt;/code&gt; and &lt;code&gt;improve&lt;/code&gt; are available as primitives:&lt;/p&gt;


&lt;pre&gt;
(define (good-enough? guess x)
  (&amp;lt; (abs (- (square guess) x)) 0.001))

(define (improve guess x)
  (average guess (/ x guess)))

(define newton-with-ops
  (make-machine
    '(x guess)
    `((good-enough? ,good-enough?) (improve ,improve))
    '(
      init
        (assign guess (const 1.0))
      sqrt-iter
        (test (op good-enough?) (reg guess) (reg x))
        (branch (label end-sqrt))
        (assign guess (op improve) (reg guess) (reg x))
        (goto (label sqrt-iter))
      end-sqrt
    )))
&lt;/pre&gt;

	&lt;p&gt;To actually make them work as primitives, I define them as Scheme functions and later pass them to the machine in the &lt;em&gt;operations list&lt;/em&gt;. Note that I made both functions accept &lt;code&gt;x&lt;/code&gt; explicitly as an argument in order to separate them from the main function.&lt;/p&gt;


	&lt;p&gt;Let's see how this works:&lt;/p&gt;


&lt;pre&gt;
(set-register-contents! newton-with-ops 'x 2)
(start newton-with-ops)
(printf "~a~%" (get-register-contents newton-with-ops 'guess))
=&amp;gt;
1.4142156862745097
&lt;/pre&gt;

	&lt;p&gt;Good. Now, let's implement these operations in the register-machine language and incorporate them into the machine:&lt;/p&gt;


&lt;pre&gt;
(define newton-full
  (make-machine
    '(x guess r1)
    `((&amp;lt; ,&amp;lt;) (abs ,abs) (- ,-) (/ ,/)
      (square ,square) (average ,average))
    '(
      init
        (assign guess (const 1.0))
      sqrt-iter
        ; good-enough?
        (assign r1 (op square) (reg guess))
        (assign r1 (op -) (reg r1) (reg x))
        (assign r1 (op abs) (reg r1))
        (test (op &amp;lt;) (reg r1) (const 0.001))
        (branch (label end-sqrt))
        ; not good-enough? then improve
        (assign r1 (op /) (reg x) (reg guess))
        (assign guess (op average) (reg guess) (reg r1))
        (goto (label sqrt-iter))
      end-sqrt
    )))

(set-register-contents! newton-full 'x 2)
(start newton-full)
(printf "~a~%" (get-register-contents newton-full 'guess))
=&amp;gt;
1.4142156862745097
&lt;/pre&gt;

	&lt;p&gt;I'm using &lt;code&gt;r1&lt;/code&gt; as a temporary register&lt;sup&gt;&lt;a href="#fn2"&gt;2&lt;/a&gt;&lt;/sup&gt;, and the bulding blocks of &lt;code&gt;improve&lt;/code&gt; and &lt;code&gt;good-enough?&lt;/code&gt; as primitives &amp;#8211; the operations &lt;code&gt;square&lt;/code&gt;, &lt;code&gt;average&lt;/code&gt; and &lt;code&gt;abs&lt;/code&gt;, which could be further broken down to register-machine language, of course.&lt;/p&gt;


	&lt;h4&gt;Recursive procedures&lt;/h4&gt;


	&lt;p&gt;Maybe it's just me, but I found the recursive implementation of the factorial procedure&lt;sup&gt;&lt;a href="#fn3"&gt;3&lt;/a&gt;&lt;/sup&gt; by the authors in section 5.1.4 hard to understand. The reason is that it's an &lt;em&gt;optimized&lt;/em&gt; hand-coded implementation, and I'm used to thinking in terms of compilers translating higher-order languages (like C) into assembly. So, I've decided to see how I would first think to implement this recursive factorial.&lt;/p&gt;


	&lt;p&gt;So, if you share my confusion, and aren't afraid of a little asembly code, you'll find this detour interesting.&lt;/p&gt;


	&lt;p&gt;So, how is recursion traditionally implemented in assembly ? Not much differently from the way normal procedures are implemented, it appears. Calling a procedure is just jumping to the procedure's label in some sense. Many assembly languages have the operations &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;ret&lt;/code&gt;.&lt;/p&gt;


	&lt;p&gt;&lt;code&gt;call&lt;/code&gt; does the following:&lt;/p&gt;


	&lt;ol&gt;
	&lt;li&gt;Saves the address of the next instruction on the stack &lt;/li&gt;
		&lt;li&gt;Jumps to the procedure&lt;/li&gt;
	&lt;/ol&gt;


	&lt;p&gt;&lt;code&gt;ret&lt;/code&gt; does the following:&lt;/p&gt;


	&lt;ol&gt;
	&lt;li&gt;Pops the return address from the stack&lt;/li&gt;
		&lt;li&gt;Jumps to the return address&lt;/li&gt;
	&lt;/ol&gt;


	&lt;p&gt;However, calling procedures isn't enough. To make them really useful, procedures have to be passed arguments and return values. For this, several conventions exist:&lt;/p&gt;


	&lt;ul&gt;
	&lt;li&gt;Registers can be used for arguments and return values. While this is the most efficient method, it is not generally applicable, because sometimes the call-sequences of procedures are long (proc1 calls proc2, which calls proc3 etc.) and there's not enough registers. Moreover, recursive procedures make this approach completely infeasible.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;The stack can be used for arguments and return values. This is the less efficient, but a much more general approach that works in all cases. The stack's &lt;span class="caps"&gt;LIFO&lt;/span&gt; nature guarantees the consistency of data, and arbitrary call-trees can be implemented, including recursive ones.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;Mixed approach: for example, arguments on stack, return value in a register. This is actually used by C compilers (recall that C can return only a single value&amp;#8230;), unless a large object like a &lt;code&gt;struct&lt;/code&gt; is returned.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;p&gt;Another important thing to keep in mind is that a well-behaving procedure must not ruin the data of its caller, and hence must leave all the registers intact. Usually, upon entry a procedure saves all the registers it's going to use on the stack, and before returning restores their value, thus preserving transparency.&lt;/p&gt;


	&lt;p&gt;So, let's use this approach to implement the recursive factorial procedure in our register-machine language:&lt;/p&gt;


	&lt;ul&gt;
	&lt;li&gt;Since we have no &lt;code&gt;call&lt;/code&gt; instruction, we'll explicitly push on the stack the label where we want to go after the procedure returns, and then jump to the procedure.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;Since we have no &lt;code&gt;ret&lt;/code&gt; instruction, we'll expicitly gather the return address from the stack and jump to it&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;We'll pass arguments (only &lt;code&gt;n&lt;/code&gt; in our case) on the stack, and the return value in a register called &lt;code&gt;retval&lt;/code&gt;.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;The factorial procedure will save all the registers it uses on the stack when it starts and restore them when it ends.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;ul&gt;
	&lt;li&gt;There's a minor difficuly in our language, presented by the fact that the access to the stack is only to and from its top. In x86 assembly, there's a comfortable addressing mode that allows us to read values from the stack without popping it&lt;sup&gt;&lt;a href="#fn4"&gt;4&lt;/a&gt;&lt;/sup&gt;, so much less pushing and popping is required.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;p&gt;Here's the code:&lt;/p&gt;


&lt;pre&gt;
(define factorial-rec
  (make-machine
    '(n temp retval retaddr)
    `((= ,=) (+ ,+) (- ,-) (* ,*) (printf ,printf))
    '(
        (goto (label machine-start))

        ;;; procedure fact
      fact
        (restore retaddr)       ; return address
        (restore temp)          ; argument
        (save n)                ; save caller's n and retaddr
        (save retaddr)
        (assign n (reg temp))   ; working on n
        (test (op =) (reg n) (const 1))
        (branch (label fact-base))
        (assign temp (op -) (reg n) (const 1))
        ; prepare for the recursive call:
        ;  push the argument and return value on stack
        (save temp)
        (assign retaddr (label fact-after-rec-return))
        (save retaddr)
        (goto (label fact))     ; the recursive call
      fact-after-rec-return
        (assign retval (op *) (reg retval) (reg n))
        (goto (label fact-end))

      fact-base
        (assign retval (const 1))

      fact-end
        ; restore the caller's registers we've saved
        ;
        (restore retaddr)
        (restore n)
        (goto (reg retaddr))    ; return to caller
        ;;; end procedure fact

      machine-start
        ; to call fact, push n and a return address on stack
        ; and jump to fact
        (save n)
        (assign retaddr (label machine-end))
        (save retaddr)
        (goto (label fact))

      machine-end
    )))
&lt;/pre&gt;

	&lt;p&gt;Although it's considerably longer than the authors' version, I find it easier to understand, because it has a very standard structure.&lt;/p&gt;


	&lt;p&gt;In the beginning, we jump to the &lt;code&gt;machine-start&lt;/code&gt; label which calls the factorial procedure. Note the call: first &lt;code&gt;n&lt;/code&gt; is pushed, then the return address. This is going to be the calling convention throughout the code. The procedure &lt;code&gt;fact&lt;/code&gt; itself is marked with a pair of comments.&lt;/p&gt;


	&lt;p&gt;&lt;code&gt;fact&lt;/code&gt; does some intensive stack work in the beginning. First, it fetches the return address into &lt;code&gt;retaddr&lt;/code&gt; and the argument into &lt;code&gt;temp&lt;/code&gt;. Then, it saves the return address back again, together with &lt;code&gt;n&lt;/code&gt; because it's going to use these registers in its work. If these steps seem unnecessary, think again. The procedure must have its argument and return value, and they're on the stack. The only way to get them is pop them from the stack. But then, as I said, in order to be transparent a procedure must save all the registers it's going to use and restore them before it returns.&lt;/p&gt;


	&lt;p&gt;Next it tests for &lt;code&gt;n = 0&lt;/code&gt;, and jumps to &lt;code&gt;fact-base&lt;/code&gt; if it is. If it isn't, it computes &lt;code&gt;n - 1&lt;/code&gt; and calls itself recursively (note that it's done in exactly the same way as the original call from &lt;code&gt;machine-start&lt;/code&gt;). &lt;code&gt;fact-end&lt;/code&gt; is a common return point that restores the registers the procedure corrupted and jumps to the return address.&lt;/p&gt;


	&lt;p&gt;Now if you look at the authors' version, you'll see all the same building blocks, but some of the things were optimized away because the procedure is written not in a general way, but fine-tuned to the factorial problem. While for real machine language programs this is the better way to go, I think that for educational purposes my approach would be better.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.4&lt;/h4&gt;


	&lt;p&gt;This is so similar to the factorial procedure that I don't think implementing it would teach us anything new. The only real difference is an additional argument &lt;code&gt;b&lt;/code&gt;. But note that it's not changed throughout the procedure, so it can just be left in a register of its own, making the rest of the code even more similar to factorial.&lt;/p&gt;


	&lt;h4&gt;Exercise 5.5&lt;/h4&gt;


	&lt;p&gt;I'll simulate my implementation of &lt;code&gt;factorial&lt;/code&gt; with the input &lt;code&gt;n = 2&lt;/code&gt;. The stack is shown with its top on the right hand side. I.e. pushing 1, then 5, then 7 into an empty stack results in:&lt;/p&gt;


&lt;pre&gt;
1 5 7
&lt;/pre&gt;

	&lt;p&gt;OK, so we're in &lt;code&gt;machine-start&lt;/code&gt; calling &lt;code&gt;fact&lt;/code&gt; with &lt;code&gt;n = 2&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
stack: 2 (label machine-end)
goto (label fact)
.
restoring retaddr and n
stack:
saving n and retaddr:
stack: 2 (label machine-end)
n != 1, hence a recursive call:
pushing new argument and return address on stack
stack: 2 (label machine-end) 1 (label fact-after-rec-return)
goto (label fact)
.
restoring retaddr and n
stack: 2 (label machine-end)
saving n and retaddr:
stack: 2 (label machine-end) 1 (label fact-after-rec-return)
n = 1, hence goto (label fact-base)
.
retval &amp;lt;- 1
restoring retaddr and n
stack: 2 (label machine-end)
goto retaddr, which is (label fact-after-rec-return)
.
retval &amp;lt;- 1 * 2
goto (label fact-end)
.
restoring retaddr and n
stack: 
goto retaddr, which is (label machine-end)
.
at (label machine-end)
retval = 2
&lt;/pre&gt;

	&lt;h4&gt;Exercise 5.6&lt;/h4&gt;


	&lt;p&gt;In &lt;code&gt;afterfib-n-1&lt;/code&gt;, &lt;code&gt;(restore continue)&lt;/code&gt; and &lt;code&gt;(save continue)&lt;/code&gt; can be safely removed, leaving us with:&lt;/p&gt;


&lt;pre&gt;
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op &amp;lt;) (reg n) (const 2))
   (branch (label immediate-answer))
   ;; set up to compute Fib(n - 1)
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                           ; save old value of n
   (assign n (op -) (reg n) (const 1)); clobber n to n - 1
   (goto (label fib-loop))            ; perform recursive call
 afterfib-n-1                         ; upon return, val contains Fib(n - 1)
   (restore n)
   ;; &amp;gt;&amp;gt; was: (restore continue)
   ;; set up to compute Fib(n - 2)
   (assign n (op -) (reg n) (const 2))
   ;; &amp;gt;&amp;gt; was: (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                         ; save Fib(n - 1)
   (goto (label fib-loop))
 afterfib-n-2                         ; upon return, val contains Fib(n - 2)
   (assign n (reg val))               ; n now contains Fib(n - 2)
   (restore val)                      ; val now contains Fib(n - 1)
   (restore continue)
   (assign val                        ;  Fib(n - 1) +  Fib(n - 2)
           (op +) (reg val) (reg n)) 
   (goto (reg continue))              ; return to caller, answer is in val
 immediate-answer
   (assign val (reg n))               ; base case:  Fib(n) = n
   (goto (reg continue))
&lt;/pre&gt;

	&lt;p&gt;Why is this safe ?&lt;/p&gt;


	&lt;p&gt;What it does is take out &lt;code&gt;continue&lt;/code&gt; from the stack and place it back again, so the stack isn't changed by these two instructions. But perhaps the value popped into the &lt;code&gt;continue&lt;/code&gt; register is used ?&lt;/p&gt;


	&lt;p&gt;It is not, because on the next line, the &lt;code&gt;continue&lt;/code&gt; register is assigned another value.&lt;/p&gt;


&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;

	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; I've decided to switch to Scheme because the register machine simulator is written in the &lt;em&gt;dispatch style&lt;/em&gt;, which is much less cumbersome in Scheme than in Common Lisp.&lt;/p&gt;


	&lt;p id="fn2"&gt;&lt;sup&gt;2&lt;/sup&gt; And following the convention of real machines where the &lt;em&gt;general purpose registers&lt;/em&gt; which are used for temporary computations are usually called r1, r2, r3, etc.&lt;/p&gt;


	&lt;p id="fn3"&gt;&lt;sup&gt;3&lt;/sup&gt; &lt;code&gt;factorial&lt;/code&gt; is a notorious example because implementing it recursively is very inefficient compared to the simple interative implementation. However, it serves as a good example of implementing recursion, because it contains, in a very simplified way, everything one needs to know about recursive functions.&lt;/p&gt;


	&lt;p id="fn4"&gt;&lt;sup&gt;4&lt;/sup&gt; In x86 there's a &lt;em&gt;base pointer&lt;/em&gt; register &lt;code&gt;bp&lt;/code&gt; which allows to access arguments, for example &lt;code&gt;add ax, 4[bp]&lt;/code&gt; adds to the register &lt;code&gt;ax&lt;/code&gt; the argument that was pushed last on the stack (before the return address).&lt;/p&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>SICP sections 4.4.2 - 4.4.4</title><link href="https://eli.thegreenplace.net/2008/02/09/sicp-sections-442-444" rel="alternate"></link><published>2008-02-09T08:11:27-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-02-09:/2008/02/09/sicp-sections-442-444</id><summary type="html">
        &lt;h4&gt;Exercise 4.64&lt;/h4&gt;


	&lt;p&gt;Let's follow the procedure for applying rules described in section 4.4.2, to see what happens when the badly rewritten rule &lt;code&gt;outranked-by&lt;/code&gt; is applied to the query issued by De Witt Aull:&lt;/p&gt;


	&lt;p&gt;First, we'll unify the query:&lt;/p&gt;


&lt;pre&gt;
(outranked-by (Bitdiddle Ben) ?who)
&lt;/pre&gt;

	&lt;p&gt;With the conclusion of the …&lt;/p&gt;</summary><content type="html">
        &lt;h4&gt;Exercise 4.64&lt;/h4&gt;


	&lt;p&gt;Let's follow the procedure for applying rules described in section 4.4.2, to see what happens when the badly rewritten rule &lt;code&gt;outranked-by&lt;/code&gt; is applied to the query issued by De Witt Aull:&lt;/p&gt;


	&lt;p&gt;First, we'll unify the query:&lt;/p&gt;


&lt;pre&gt;
(outranked-by (Bitdiddle Ben) ?who)
&lt;/pre&gt;

	&lt;p&gt;With the conclusion of the rule:&lt;/p&gt;


&lt;pre&gt;
(outranked-by ?staff-person ?boss)
&lt;/pre&gt;

&lt;!--more--&gt;

	&lt;p&gt;The unification succeeds with the bindings &lt;code&gt;?staff-person -&amp;gt; (Bitdiddle Ben)&lt;/code&gt; and &lt;code&gt;?boss -&amp;gt; ?who&lt;/code&gt;. Now, we will evaluate the query formed by the body of the rule:&lt;/p&gt;


&lt;pre&gt;
(or (supervisor ?staff-person ?boss)
    (and (outranked-by ?middle-manager ?boss)
         (supervisor ?staff-person ?middle-manager))))
&lt;/pre&gt;

	&lt;p&gt;Relative to the extended frame. Consider what happens when we come to evaluate the sub-query &lt;code&gt;(outranked-by ?middle-manager ?boss)&lt;/code&gt;. Again, this is a query that will match the &lt;code&gt;outranked-by&lt;/code&gt; rule. Unifying it with the rule's conclusion succeeds, producing the bindings &lt;code&gt;?staff-person -&amp;gt; ?middle-manager&lt;/code&gt; and &lt;code&gt;?boss -&amp;gt; ?who&lt;/code&gt;. So we once again evaluate the rule's body, now with these bindings. And again, and again &amp;#8211; this is an infinite loop.&lt;/p&gt;


	&lt;p&gt;Why didn't the original rule have this problem ?&lt;/p&gt;


	&lt;p&gt;Because the &lt;code&gt;(supervisor ?staff-person ?middle-manager)&lt;/code&gt; sub-query came first in the &lt;code&gt;and&lt;/code&gt;, and created bindings that narrowed the search when re-applying the &lt;code&gt;outranked-by&lt;/code&gt; rule.&lt;/p&gt;


	&lt;h4&gt;Exercise 4.65&lt;/h4&gt;


	&lt;p&gt;Oliver Warbucks is listed four times because the rule matches four times over the database. I.e., there are four middle-managers of whom Oliver Warbucks is a manager. To find out who these are, we can unroll the rule:&lt;/p&gt;


&lt;pre&gt;
(and (supervisor ?middle-manager ?person)
     (supervisor ?x ?middle-manager))
=&amp;gt;
(AND (SUPERVISOR (SCROOGE EBEN) (WARBUCKS OLIVER)) (SUPERVISOR (CRATCHET ROBERT) (SCROOGE EBEN)))
(AND (SUPERVISOR (BITDIDDLE BEN) (WARBUCKS OLIVER)) (SUPERVISOR (TWEAKIT LEM E) (BITDIDDLE BEN)))
(AND (SUPERVISOR (HACKER ALYSSA P) (BITDIDDLE BEN)) (SUPERVISOR (REASONER LOUIS) (HACKER ALYSSA P)))
(AND (SUPERVISOR (BITDIDDLE BEN) (WARBUCKS OLIVER)) (SUPERVISOR (FECT CY D) (BITDIDDLE BEN)))
(AND (SUPERVISOR (BITDIDDLE BEN) (WARBUCKS OLIVER)) (SUPERVISOR (HACKER ALYSSA P) (BITDIDDLE BEN)))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.66&lt;/h4&gt;


	&lt;p&gt;Suppose that Ben will try to compute the sum of the salaries of the wheels in the organization:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(and (wheel ?who)
        (salary ?who ?amount)))
=&amp;gt;
(AND (WHEEL (WARBUCKS OLIVER)) (SALARY (WARBUCKS OLIVER) 150000))
(AND (WHEEL (WARBUCKS OLIVER)) (SALARY (WARBUCKS OLIVER) 150000))
(AND (WHEEL (BITDIDDLE BEN)) (SALARY (BITDIDDLE BEN) 60000))
(AND (WHEEL (WARBUCKS OLIVER)) (SALARY (WARBUCKS OLIVER) 150000))
(AND (WHEEL (WARBUCKS OLIVER)) (SALARY (WARBUCKS OLIVER) 150000))
&lt;/pre&gt;

	&lt;p&gt;Obviously, if Ben tries to apply the &lt;code&gt;sum&lt;/code&gt; on &lt;code&gt;?amount&lt;/code&gt; over these results, he'll get too much because of the duplications.&lt;/p&gt;


	&lt;p&gt;One way to circumvent this problem is to install a &lt;em&gt;uniqueness filter&lt;/em&gt; that will filter out all the duplicates from the resulting frames produced by &lt;code&gt;qeval&lt;/code&gt;.&lt;/p&gt;


	&lt;h4&gt;Exercise 4.67&lt;/h4&gt;


	&lt;pre&gt;&lt;code&gt;???&lt;/code&gt;&lt;/pre&gt;


	&lt;h4&gt;Exercise 4.68&lt;/h4&gt;


&lt;pre&gt;
(qinterpret
  '(assert!
    (rule (reverse () ()))))
(qinterpret
  '(assert!
    (rule
      (reverse ?x ?y)
      (and 
        (append-to-form (?car) ?cdr ?x)
        (append-to-form ?rev-cdr (?car) ?y)
        (reverse ?cdr ?rev-cdr)))))
&lt;/pre&gt;

	&lt;p&gt;This rule answers:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(reverse ?x (1 2 3)))
=&amp;gt;
(REVERSE (3 2 1) (1 2 3))
&lt;/pre&gt;

	&lt;p&gt;But not:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(reverse (1 2 3) ?x))
=&amp;gt;
*** - Program stack overflow. RESET
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.69&lt;/h4&gt;


&lt;pre&gt;
(rule (ends-with-grandson ?x)
      (append-to-form ?head (grandson) ?x))

(rule ((great . ?rel) ?x ?y)
      (and
        (ends-with-grandson ?rel)
        (?rel ?sx ?y)
        (son ?x ?sx)))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.70&lt;/h4&gt;


	&lt;p&gt;The problem with this alternative implementation is that &lt;code&gt;cons-stream&lt;/code&gt; doesn't evaluate its second argument. Therefore, &lt;code&gt;THE-ASSERTIONS&lt;/code&gt; will point to itself. In the original implementation, the purpose of the &lt;code&gt;let&lt;/code&gt; was to force an evaluation of &lt;code&gt;THE-ASSERTIONS&lt;/code&gt;, storing its pre-&lt;code&gt;set!&lt;/code&gt; value in &lt;code&gt;old-assertions&lt;/code&gt;.&lt;/p&gt;


	&lt;p&gt;It took me much longer than expected to solve this, because of one fact that puzzled me. I wrote a few unit tests for the logic evaluator, and ran them with the modified version. Everything worked. This was a surprise because I expected the self reference in the stream of assertions to cause an infinite loop.&lt;/p&gt;


	&lt;p&gt;The solution of this problem can teach us a lesson: complex systems are difficult to understand, test and debug. What actually happened is that all the assertions in my tests were &lt;em&gt;indexable&lt;/em&gt;. Note that &lt;code&gt;store-assertion-in-index&lt;/code&gt; in the implementation of &lt;code&gt;add-assertion!&lt;/code&gt;, and the complementary &lt;code&gt;get-indexed-assertions&lt;/code&gt; in &lt;code&gt;fetch-assertions&lt;/code&gt; ? These do the actual job for most assertions, without ever getting to really searching in the big stream. To float this problem I wrote a few &lt;em&gt;unindexable&lt;/em&gt; assertions&lt;sup&gt;&lt;a href="#fn1"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;


&lt;pre&gt;
(assert! ((jay bird) sam 10))
(assert! ((jay bird) tom 12))
&lt;/pre&gt;

	&lt;p&gt;Indeed, these caused an infinite loop with the alternative implementation when searched. Phew. I'm rarely as glad to see a stack overflow in my program :-)&lt;/p&gt;


	&lt;h4&gt;Exercise 4.71&lt;/h4&gt;


	&lt;p&gt;These delays can postpone infinite looping in some cases, providing more meaningful answers to the user. Consider these assertions:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(assert! (dummy a))
  '(assert! (dummy b))
  '(assert! (dummy c))
  '(assert! (rule (dummy ?x) (dummy ?x))))
&lt;/pre&gt;

	&lt;p&gt;The last one asserts an infinitely-recursive rule. Now, if we issue the query:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(dummy ?who))
&lt;/pre&gt;

	&lt;p&gt;With the delays in place, we'll get:&lt;/p&gt;


&lt;pre&gt;
(DUMMY C)
(DUMMY B)
(DUMMY A)
(DUMMY C)
(DUMMY B)
(DUMMY A)
(DUMMY C)
(DUMMY B)
(DUMMY A)
...
...
&lt;/pre&gt;

	&lt;p&gt;To understand why, look at this portion of &lt;code&gt;simple-query&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
      (stream-append-delayed
        (find-assertions query-pattern frame)
        (delay (apply-rules query-pattern frame))))
&lt;/pre&gt;

	&lt;p&gt;Note that the application of rules is delayed. In our case, there are valid assertions answering the query, but the rule is invalid, since trying to apply it causes an infinite loop.&lt;/p&gt;


	&lt;p&gt;Without the delay we get:&lt;/p&gt;


&lt;pre&gt;
*** - Program stack overflow. RESET
&lt;/pre&gt;

	&lt;p&gt;Without any useful output, because &lt;code&gt;simple-query&lt;/code&gt; deepens more and more into the recursive rule without ever printing results.&lt;/p&gt;


	&lt;p&gt;&lt;sub&gt;Thanks to Flavio Cruz for suggesting this solution&lt;/sub&gt;&lt;/p&gt;


	&lt;h4&gt;Exercise 4.72&lt;/h4&gt;


	&lt;p&gt;As the hint suggests, this is done for exactly the same reason as the original &lt;code&gt;interleave&lt;/code&gt; in section 3.5.3 &amp;#8211; for handling infinite streams. Suppose that &lt;code&gt;stream-flatmap&lt;/code&gt; is called on two streams. The first is infinite, for some (maybe valid) reason. Without using &lt;code&gt;interleave&lt;/code&gt;, the elements of the second stream won't be reached, ever.&lt;/p&gt;


	&lt;h4&gt;Exercise 4.74&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;&lt;code&gt;simple-flatten&lt;/code&gt; assumes that it has a stream of streams, in which each stream is either the empty stream or a singleton stream. It has to do the following:&lt;/p&gt;


	&lt;p&gt;1. Filter out all the empty streams
2. Extract the elements from the singleton streams&lt;sup&gt;&lt;a href="#fn2"&gt;2&lt;/a&gt;&lt;/sup&gt;
3. Stitch all those elements together into a new stream&lt;/p&gt;


	&lt;p&gt;Therefore the implementation is as follows:&lt;/p&gt;


&lt;pre&gt;
(defun simple-stream-flatmap (proc s)
  (simple-flatten (stream-map proc s)))

(defun simple-flatten (stream)
  (stream-map 
    #'stream-car
    (stream-filter 
      (lambda (s)
        (not (stream-null? s)))
      stream)))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


	&lt;p&gt;I don't think this change will affect the system's behavior. It does not affect correctness, because the named functions indeed only generate either singleton or empty streams. Also, as far as I can see, all the tests pass.&lt;/p&gt;


	&lt;p&gt;I also don't see how it can change the order of assertions that are output from queries. &lt;code&gt;flatten-stream&lt;/code&gt; that uses &lt;code&gt;interleave&lt;/code&gt; creates the same elements as those created by &lt;code&gt;simple-flatten&lt;/code&gt;, in the same order.&lt;/p&gt;


	&lt;h4&gt;Exercise 4.75&lt;/h4&gt;


&lt;pre&gt;
(defun uniquely-asserted (query frame-stream)
  "Return only those frames for whom the query
  produces a single match in the database" 
  (simple-stream-flatmap
    (lambda (frame)
      (let ((eval-stream 
              (qeval 
                (query-of-unique query) 
                (singleton-stream frame))))
        (if (singleton-stream? eval-stream)
          eval-stream
          the-empty-stream)))
    frame-stream))

(defun singleton-stream? (stream)
  (and 
    (stream-car stream)
    (not (stream-cadr stream))))  

(defun query-of-unique (uniq) (car uniq))

(put-op 'unique 'qeval #'uniquely-asserted)
&lt;/pre&gt;

	&lt;p&gt;Some tests with the database:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(unique (job ?x (computer wizard))))
=&amp;gt;
(UNIQUE (JOB (BITDIDDLE BEN) (COMPUTER WIZARD)))

(qinterpret
  '(and (job ?x ?j) (unique (job ?anyone ?j))))
=&amp;gt;
(AND (JOB (AULL DEWITT) (ADMINISTRATION SECRETARY)) (UNIQUE (JOB (AULL DEWITT) (ADMINISTRATION SECRETARY))))
(AND (JOB (CRATCHET ROBERT) (ACCOUNTING SCRIVENER)) (UNIQUE (JOB (CRATCHET ROBERT) (ACCOUNTING SCRIVENER))))
(AND (JOB (SCROOGE EBEN) (ACCOUNTING CHIEF ACCOUNTANT))
 (UNIQUE (JOB (SCROOGE EBEN) (ACCOUNTING CHIEF ACCOUNTANT))))
(AND (JOB (WARBUCKS OLIVER) (ADMINISTRATION BIG WHEEL))
 (UNIQUE (JOB (WARBUCKS OLIVER) (ADMINISTRATION BIG WHEEL))))
(AND (JOB (REASONER LOUIS) (COMPUTER PROGRAMMER TRAINEE))
 (UNIQUE (JOB (REASONER LOUIS) (COMPUTER PROGRAMMER TRAINEE))))
(AND (JOB (TWEAKIT LEM E) (COMPUTER TECHNICIAN)) (UNIQUE (JOB (TWEAKIT LEM E) (COMPUTER TECHNICIAN))))
(AND (JOB (BITDIDDLE BEN) (COMPUTER WIZARD)) (UNIQUE (JOB (BITDIDDLE BEN) (COMPUTER WIZARD))))

(qinterpret
  '(and (supervisor ?peon ?boss)
        (unique (supervisor ?others ?boss))))
=&amp;gt;
(AND (SUPERVISOR (CRATCHET ROBERT) (SCROOGE EBEN)) (UNIQUE (SUPERVISOR (CRATCHET ROBERT) (SCROOGE EBEN))))
(AND (SUPERVISOR (REASONER LOUIS) (HACKER ALYSSA P))
 (UNIQUE (SUPERVISOR (REASONER LOUIS) (HACKER ALYSSA P))))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.76&lt;/h4&gt;


	&lt;p&gt;Here's &lt;code&gt;merge-frames&lt;/code&gt; that merges a pair of frames:&lt;/p&gt;


&lt;pre&gt;
(defun merge-frames (f1 f2)
  (if (null f1)
    f2
    (let ((var (caar f1))
          (val (cdar f1)))
      (let ((extension (extend-if-possible var val f2)))
        (if (equal extension 'failed)
          'failed
          (merge-frames (cdr f1) extension))))))
&lt;/pre&gt;

	&lt;p&gt;And this is &lt;code&gt;merge-frame-streams&lt;/code&gt; that merges two streams of frames, using &lt;code&gt;merge-frames&lt;/code&gt; for each pair:&lt;/p&gt;


&lt;pre&gt;
(defun merge-frame-streams (s1 s2)
  "Tries to merge each frame of s1 with each frame
  of s2. Returns the stream of successful merges." 
  (stream-flatmap
    (lambda (f1)
      (stream-filter
        (lambda (f) (not (equal f 'failed)))
        (stream-map
          (lambda (f2)
            (merge-frames f1 f2))
          s2)))
    s1))
&lt;/pre&gt;

	&lt;p&gt;&lt;code&gt;conjoin&lt;/code&gt; can then be written thus:&lt;/p&gt;


&lt;pre&gt;
(defun conjoin (conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
    frame-stream
    (merge-frame-streams
      (qeval (first-conjunct conjuncts) frame-stream)
      (conjoin (rest-conjuncts conjuncts) frame-stream))))
&lt;/pre&gt;

	&lt;p&gt;This works satisfactorily, in most cases. For example:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(and 
    (job ?x ?j) 
    (supervisor ?x (bitdiddle ben))
    (salary ?x 25000)))
=&amp;gt;
(AND (JOB (TWEAKIT LEM E) (COMPUTER TECHNICIAN)) (SUPERVISOR (TWEAKIT LEM E) (BITDIDDLE BEN))
 (SALARY (TWEAKIT LEM E) 25000))

; the 'grandson' rule uses /and/
(qinterpret
  '(grandson ?d ?w))
=&amp;gt;
(GRANDSON MEHUJAEL LAMECH)
(GRANDSON IRAD METHUSHAEL)
(GRANDSON ENOCH MEHUJAEL)
(GRANDSON CAIN IRAD)
(GRANDSON ADAM ENOCH)
&lt;/pre&gt;

	&lt;p&gt;However, there are also problems. For example, consider this:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(and 
    (job ?x ?j) 
    (not (supervisor ?x (bitdiddle ben)))))
=&amp;gt;
&lt;/pre&gt;

	&lt;p&gt;It should have printed out many items, but it doesn't. This is because of the problem with &lt;code&gt;not&lt;/code&gt; described in section 4.4.3; &lt;code&gt;not&lt;/code&gt; needs something to filter, and the new implementation of &lt;code&gt;conjoin&lt;/code&gt; simply runs it on the full input frame stream, and merges the result.&lt;/p&gt;


	&lt;p&gt;A more serious error with this approach happens when resursive rules are used. When this rule is added to the Biblical hierarchy database:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(assert!
    (rule (son ?m ?s)
          (and
            (wife ?m ?w)
            (son ?w ?s)))))
&lt;/pre&gt;

	&lt;p&gt;The evaluator goes into an infinite loop when matching &lt;code&gt;son&lt;/code&gt; rules. This is because the &lt;code&gt;son&lt;/code&gt; rule invokes another &lt;code&gt;son&lt;/code&gt; rule in the &lt;code&gt;and&lt;/code&gt; expression, and with the new implementation of &lt;code&gt;conjoin&lt;/code&gt; this call is not on a reduced set of frames.&lt;/p&gt;


	&lt;p&gt;I suppose the authors didn't make a mistake with their suggestion, but it's rather a problem with my implementation. I'll be glad if someone points me to it.&lt;/p&gt;


&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;

	&lt;p id="fn1"&gt;&lt;sup&gt;1&lt;/sup&gt; In the authors' implementation, an assertion is indexable if its first element is either a constant or a variable name, but not a list.&lt;/p&gt;


	&lt;p id="fn2"&gt;&lt;sup&gt;2&lt;/sup&gt; Recall that a singleton stream is simply an element wrapped up as a stream.&lt;/p&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry><entry><title>SICP section 4.4.1</title><link href="https://eli.thegreenplace.net/2008/02/08/sicp-section-441" rel="alternate"></link><published>2008-02-08T16:06:03-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2008-02-08:/2008/02/08/sicp-section-441</id><summary type="html">
        &lt;h4&gt;Exercise 4.55&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(supervisor ?x (Bitdiddle Ben))
=&amp;gt;
(SUPERVISOR (TWEAKIT LEM E) (BITDIDDLE BEN))
(SUPERVISOR (FECT CY D) (BITDIDDLE BEN))
(SUPERVISOR (HACKER ALYSSA P) (BITDIDDLE BEN))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(job ?name (accounting . ?a))
=&amp;gt;
(JOB (CRATCHET ROBERT) (ACCOUNTING SCRIVENER))
(JOB (SCROOGE EBEN) (ACCOUNTING CHIEF ACCOUNTANT))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(address ?name (Slumerville . ?a))
=&amp;gt;
(ADDRESS (AULL DEWITT …&lt;/pre&gt;</summary><content type="html">
        &lt;h4&gt;Exercise 4.55&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(supervisor ?x (Bitdiddle Ben))
=&amp;gt;
(SUPERVISOR (TWEAKIT LEM E) (BITDIDDLE BEN))
(SUPERVISOR (FECT CY D) (BITDIDDLE BEN))
(SUPERVISOR (HACKER ALYSSA P) (BITDIDDLE BEN))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(job ?name (accounting . ?a))
=&amp;gt;
(JOB (CRATCHET ROBERT) (ACCOUNTING SCRIVENER))
(JOB (SCROOGE EBEN) (ACCOUNTING CHIEF ACCOUNTANT))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(address ?name (Slumerville . ?a))
=&amp;gt;
(ADDRESS (AULL DEWITT) (SLUMERVILLE (ONION SQUARE) 5))
(ADDRESS (REASONER LOUIS) (SLUMERVILLE (PINE TREE ROAD) 80))
(ADDRESS (BITDIDDLE BEN) (SLUMERVILLE (RIDGE ROAD) 10))
&lt;/pre&gt;
&lt;!--more--&gt;
	&lt;h4&gt;Exercise 4.56&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(and 
  (supervisor ?name (Bitdiddle Ben))
  (address ?name ?addr))
=&amp;gt;
(AND (SUPERVISOR (TWEAKIT LEM E) (BITDIDDLE BEN)) (ADDRESS (TWEAKIT LEM E) (BOSTON (BAY STATE ROAD) 22)))
(AND (SUPERVISOR (FECT CY D) (BITDIDDLE BEN)) (ADDRESS (FECT CY D) (CAMBRIDGE (AMES STREET) 3)))
(AND (SUPERVISOR (HACKER ALYSSA P) (BITDIDDLE BEN)) (ADDRESS (HACKER ALYSSA P) (CAMBRIDGE (MASS AVE) 78)))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(and (salary (Bitdiddle Ben) ?bens)
     (salary ?who ?whos)
     (lisp-value #'&amp;gt; ?bens ?whos))
=&amp;gt;
(AND (SALARY (BITDIDDLE BEN) 60000) (SALARY (AULL DEWITT) 25000) (LISP-VALUE #'&amp;gt; 60000 25000))
(AND (SALARY (BITDIDDLE BEN) 60000) (SALARY (CRATCHET ROBERT) 18000) (LISP-VALUE #'&amp;gt; 60000 18000))
(AND (SALARY (BITDIDDLE BEN) 60000) (SALARY (REASONER LOUIS) 30000) (LISP-VALUE #'&amp;gt; 60000 30000))
(AND (SALARY (BITDIDDLE BEN) 60000) (SALARY (TWEAKIT LEM E) 25000) (LISP-VALUE #'&amp;gt; 60000 25000))
(AND (SALARY (BITDIDDLE BEN) 60000) (SALARY (FECT CY D) 35000) (LISP-VALUE #'&amp;gt; 60000 35000))
(AND (SALARY (BITDIDDLE BEN) 60000) (SALARY (HACKER ALYSSA P) 40000) (LISP-VALUE #'&amp;gt; 60000 40000))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(and (supervisor ?serf ?boss)
     (not (job ?boss (computer . ?c)))
     (job ?boss ?bossjob))
=&amp;gt;
(AND (SUPERVISOR (AULL DEWITT) (WARBUCKS OLIVER)) (NOT (JOB (WARBUCKS OLIVER) (COMPUTER . ?C)))
 (JOB (WARBUCKS OLIVER) (ADMINISTRATION BIG WHEEL)))
(AND (SUPERVISOR (CRATCHET ROBERT) (SCROOGE EBEN)) (NOT (JOB (SCROOGE EBEN) (COMPUTER . ?C)))
 (JOB (SCROOGE EBEN) (ACCOUNTING CHIEF ACCOUNTANT)))
(AND (SUPERVISOR (SCROOGE EBEN) (WARBUCKS OLIVER)) (NOT (JOB (WARBUCKS OLIVER) (COMPUTER . ?C)))
 (JOB (WARBUCKS OLIVER) (ADMINISTRATION BIG WHEEL)))
(AND (SUPERVISOR (BITDIDDLE BEN) (WARBUCKS OLIVER)) (NOT (JOB (WARBUCKS OLIVER) (COMPUTER . ?C)))
 (JOB (WARBUCKS OLIVER) (ADMINISTRATION BIG WHEEL)))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.57&lt;/h4&gt;


	&lt;p&gt;Here's the rule:&lt;/p&gt;


&lt;pre&gt;
(assert!
  (rule (can-replace ?1 ?2)
        (and (or (and (job ?1 ?job) (job ?2 ?job))
                 (and (job ?1 ?j1) 
                      (job ?2 ?j2)
                      (can-do-job ?j1 ?j2)))
             (not (same ?1 ?2)))))
&lt;/pre&gt;

	&lt;p&gt;I had a curious incident while writing it. I placed the &lt;code&gt;(not (same ?1 ?2))&lt;/code&gt; query first in the &lt;code&gt;and&lt;/code&gt; and wondered why nothing works. See "Problems with &lt;code&gt;not&lt;/code&gt;" in section 4.4.3 for an answer.&lt;/p&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(can-replace ?t (Fect Cy D))
=&amp;gt;
(CAN-REPLACE (BITDIDDLE BEN) (FECT CY D))
(CAN-REPLACE (HACKER ALYSSA P) (FECT CY D))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(and 
  (can-replace ?1 ?2)
  (salary ?1 ?s1)
  (salary ?2 ?s2)
  (lisp-value #'&amp;gt; ?s2 ?s1))
=&amp;gt;
(AND (CAN-REPLACE (AULL DEWITT) (WARBUCKS OLIVER)) (SALARY (AULL DEWITT) 25000)
 (SALARY (WARBUCKS OLIVER) 150000) (LISP-VALUE #'&amp;gt; 150000 25000))
(AND (CAN-REPLACE (FECT CY D) (HACKER ALYSSA P)) (SALARY (FECT CY D) 35000) (SALARY (HACKER ALYSSA P) 40000)
 (LISP-VALUE #'&amp;gt; 40000 35000))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.58&lt;/h4&gt;


&lt;pre&gt;
(assert!
  (rule (bigshot ?person ?division)
        (and
          (job ?person (?division . ?r))
          (or 
            (not (supervisor ?person ?boss))
            (and
              (supervisor ?person ?boss)
              (not (job ?boss (?division . ?q))))))))
&lt;/pre&gt;

	&lt;p&gt;Lets try it:&lt;/p&gt;


&lt;pre&gt;
(bigshot ?who ?where)
=&amp;gt;
(BIGSHOT (WARBUCKS OLIVER) ADMINISTRATION)
(BIGSHOT (SCROOGE EBEN) ACCOUNTING)
(BIGSHOT (BITDIDDLE BEN) COMPUTER)
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.59&lt;/h4&gt;


	&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(meeting ?dept (Friday . ?time))
=&amp;gt;
(MEETING ADMINISTRATION (FRIDAY 1PM))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(assert!
  (rule (meeting-time ?person ?day-and-time)
        (or (meeting whole-company ?day-and-time)
            (and 
              (job ?person (?div . ?r))
              (meeting ?div ?day-and-time)))))

(meeting-time (Hacker Alyssa P) ?time)
=&amp;gt;
(MEETING-TIME (HACKER ALYSSA P) (WEDNESDAY 4PM))
(MEETING-TIME (HACKER ALYSSA P) (WEDNESDAY 3PM))
&lt;/pre&gt;

	&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt;&lt;/p&gt;


&lt;pre&gt;
(and
  (meeting-time (Hacker Alyssa P) (Wednesday . ?time))
  (meeting ?div (Wednesday . ?time)))
=&amp;gt;
(AND (MEETING-TIME (HACKER ALYSSA P) (WEDNESDAY 4PM)) (MEETING WHOLE-COMPANY (WEDNESDAY 4PM)))
(AND (MEETING-TIME (HACKER ALYSSA P) (WEDNESDAY 3PM)) (MEETING COMPUTER (WEDNESDAY 3PM)))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.60&lt;/h4&gt;


	&lt;p&gt;To understand why this happens, we must recall how rules are matched. From "Applying rules" in section 4.4.2:&lt;/p&gt;


	&lt;p&gt;In general, the query evaluator uses the following method to apply a rule when trying to establish a query pattern in a frame that specifies bindings for some of the pattern variables:&lt;/p&gt;


	&lt;ul&gt;
	&lt;li&gt;Unify the query with the conclusion of the rule to form, if successful, an extension of the original frame.&lt;/li&gt;
		&lt;li&gt;Relative to the extended frame, evaluate the query formed by the body of the rule.&lt;/li&gt;
	&lt;/ul&gt;


	&lt;p&gt;When we execute the first step, we unify the query:&lt;/p&gt;


&lt;pre&gt;
(lives-near ?person-1 ?person-2)
&lt;/pre&gt;

	&lt;p&gt;With the conclusion of the rule:&lt;/p&gt;


&lt;pre&gt;
(lives-near ?p1 ?p2)
&lt;/pre&gt;

	&lt;p&gt;To form an extended frame, in which &lt;code&gt;?person-1&lt;/code&gt; is mapped to &lt;code&gt;?p1&lt;/code&gt; and &lt;code&gt;?person-2&lt;/code&gt; is mapped to &lt;code&gt;?p2&lt;/code&gt;. We next evaluate the query formed by the body of the rule relative to this extended frame. But since the extended frame doesn't really impose any restrictions on the &lt;code&gt;?p1&lt;/code&gt; and &lt;code&gt;?p2&lt;/code&gt; variables, it is equivalent to just evaluating the body of the rule as a query:&lt;/p&gt;


&lt;pre&gt;
(and 
  (address ?p1 (?town . ?rest1))
  (address ?p2 (?town . ?rest2))
  (not (same ?p1 ?p2)))
&lt;/pre&gt;

	&lt;p&gt;And when we do this, we indeed get all the pairs of people living near each other, twice.&lt;/p&gt;


	&lt;p&gt;We can ask for a list in which pairs appear only once by modifying the &lt;code&gt;lives-near&lt;/code&gt; rule. We'll do this by imposing some order on the names instead of using &lt;code&gt;not&lt;/code&gt;. The order must be an &lt;a href="http://en.wikipedia.org/wiki/Asymmetric_relation"&gt;asymmetric relation&lt;/a&gt; &amp;#8211; for example "greater than". But we didn't build such relations into our logic evaluator, so I'll write it as an ordinary Lisp function and invoke it using &lt;code&gt;lisp-value&lt;/code&gt;:&lt;/p&gt;


&lt;pre&gt;
(defun greater-as-string (obj1 obj2)
  (string&amp;gt; 
    (write-to-string obj1) 
    (write-to-string obj2)))

(qinterpret
  '(assert!
    (rule (lives-near ?p1 ?p2)
          (and 
            (address ?p1 (?town . ?rest1))
            (address ?p2 (?town . ?rest2))
            (lisp-value #'greater-as-string ?p1 ?p2)))))

(qinterpret
  '(lives-near ?person ?p2))
=&amp;gt;
(LIVES-NEAR (REASONER LOUIS) (AULL DEWITT))
(LIVES-NEAR (REASONER LOUIS) (BITDIDDLE BEN))
(LIVES-NEAR (HACKER ALYSSA P) (FECT CY D))
(LIVES-NEAR (BITDIDDLE BEN) (AULL DEWITT))
&lt;/pre&gt;

	&lt;p&gt;Note that the invocation of &lt;code&gt;lisp-value&lt;/code&gt; has replaced &lt;code&gt;(not (same ...&lt;/code&gt;, because the relation "greater than" subsumes the relation "not equal".&lt;/p&gt;


	&lt;h4&gt;Exercise 4.61&lt;/h4&gt;


	&lt;p&gt;I had a strange problem here, with the rules written the way they are. My Lisp (both &lt;span class="caps"&gt;CLISP&lt;/span&gt; and &lt;span class="caps"&gt;SBCL&lt;/span&gt;) kept reporting stack overflows. What solved the problem was rewriting the rules with "next-to" coming before the variables, like this:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(assert!
    (rule (next-to ?x ?y in (?x ?y . ?u)))))

(qinterpret
  '(assert!
    (rule (next-to ?x ?y in (?v . ?z))
          (next-to ?x ?y in ?z))))
&lt;/pre&gt;

	&lt;p&gt;I suspect this happens because of the rule indexing system that assumes that the first symbol in a rule conclusion is its name.&lt;/p&gt;


	&lt;p&gt;So, to answer the exercise:&lt;/p&gt;


&lt;pre&gt;
(next-to ?x ?y in (1 (2 3) 4))
=&amp;gt;
(NEXT-TO (2 3) 4 IN (1 (2 3) 4))
(NEXT-TO 1 (2 3) IN (1 (2 3) 4))

(next-to ?x ?y in (2 1 3 1))
=&amp;gt;
(NEXT-TO 3 1 IN (2 1 3 1))
(NEXT-TO 2 1 IN (2 1 3 1))
(NEXT-TO 1 3 IN (2 1 3 1))
&lt;/pre&gt;

	&lt;h4&gt;Exercise 4.62&lt;/h4&gt;


	&lt;p&gt;Since we're allowed to assume that the list is not empty, the rules can be written as follows:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(assert!
    (rule (last-pair (?elem) (?elem)))))

(qinterpret
  '(assert!
    (rule (last-pair (?v . ?u) (?l))
          (last-pair ?u (?l)))))
&lt;/pre&gt;

	&lt;p&gt;Tests:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(last-pair (3) ?x))
=&amp;gt;
(LAST-PAIR (3) (3))

(qinterpret
  '(last-pair (1 2 3) ?x))
=&amp;gt;
(LAST-PAIR (1 2 3) (3))

(qinterpret
  '(last-pair (2 ?x) (3)))
=&amp;gt;
(LAST-PAIR (2 3) (3))
&lt;/pre&gt;

	&lt;p&gt;Given the query &lt;code&gt;(last-pair ?x (3))&lt;/code&gt; my rule throws the interpreter into a stack overflow. I suppose the reason for this is the infinite amount of answers to such a rule.&lt;/p&gt;


	&lt;h4&gt;Exercise 4.63&lt;/h4&gt;


&lt;pre&gt;
(qinterpret
  '(assert!
    (rule (grandson ?g ?s)
          (and
            (son ?g ?f)
            (son ?f ?s)))))

(qinterpret
  '(assert!
    (rule (son ?m ?s)
          (and
            (wife ?m ?w)
            (son ?w ?s)))))
&lt;/pre&gt;

	&lt;p&gt;And now we can ask:&lt;/p&gt;


&lt;pre&gt;
(qinterpret
  '(grandson Cain ?s))
=&amp;gt;
(GRANDSON CAIN IRAD)

(qinterpret
  '(son Lamech ?s))
=&amp;gt;
(SON LAMECH JUBAL)
(SON LAMECH JABAL)

(qinterpret
  '(grandson Methushael ?s))
=&amp;gt;
(GRANDSON METHUSHAEL JUBAL)
(GRANDSON METHUSHAEL JABAL)
&lt;/pre&gt;

    </content><category term="misc"></category><category term="SICP"></category></entry></feed>