<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - Clojure</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/clojure.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2024-05-04T19:46:23-07:00</updated><entry><title>Building abstractions using higher-order functions</title><link href="https://eli.thegreenplace.net/2023/building-abstractions-using-higher-order-functions/" rel="alternate"></link><published>2023-02-04T05:40:00-08:00</published><updated>2023-03-06T13:26:10-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2023-02-04:/2023/building-abstractions-using-higher-order-functions/</id><summary type="html">&lt;p&gt;A &lt;em&gt;higher-order function&lt;/em&gt; is a function that takes other functions as arguments,
or returns a function as its result. Higher-order functions are an exceptionally
powerful software design tool because they can easily create new abstractions
and are composable. In this post I will present a case study - a set of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A &lt;em&gt;higher-order function&lt;/em&gt; is a function that takes other functions as arguments,
or returns a function as its result. Higher-order functions are an exceptionally
powerful software design tool because they can easily create new abstractions
and are composable. In this post I will present a case study - a set of
functions that defines an interesting problem domain. By reading and
understanding this code, hopefully anyone can appreciate the power and beauty of
higher-order functions and how they enable constructing powerful abstractions
from basic building blocks.&lt;/p&gt;
&lt;p&gt;One of my &lt;a class="reference external" href="https://eli.thegreenplace.net/2005/06/12/lessons-from-paip"&gt;all-time favorite&lt;/a&gt; programming
books is Peter Norvig's &lt;a class="reference external" href="https://norvig.github.io/paip-lisp/#/"&gt;PAIP&lt;/a&gt; . In
section &lt;em&gt;6.4 - A set of Searching Tools&lt;/em&gt;, it presents some code for defining
different variants of tree searching that I've always found very elegant.&lt;/p&gt;
&lt;p&gt;Here's a quick reimplementation of the main idea in Clojure (see &lt;a class="reference external" href="https://github.com/eliben/paip-in-clojure/tree/master/src/paip/6_tools"&gt;this
repository&lt;/a&gt; for
the full, runnable code); I'm using Clojure since it's a modern Lisp that &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/clojure-the-perfect-language-to-expand-your-brain/"&gt;I
enjoy learning and using&lt;/a&gt;
from time to time.&lt;/p&gt;
&lt;p&gt;First, some prerequisites. As is often the case in dynamically-typed Lisp,
entities can be described in a very abstract way. The code presented here
searches trees, but there is no tree data structure per-se; it's defined using
functions. Specifically, there's a notion of a &amp;quot;state&amp;quot; (tree node) and a way
to get from a given state to its children states (successors); a function maps
between the two.&lt;/p&gt;
&lt;p&gt;In our case let's have integers as states; then, an infinite binary tree can
be defined using the following successor function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;binary-tree&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A successors function representing a binary tree.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given a state (a number), it returns its children as a list. Simplistically, in
this tree, node N has the children 2N and 2N+1.&lt;/p&gt;
&lt;p&gt;Here are the first few layers of such a tree:&lt;/p&gt;
&lt;object class="align-center" data="https://eli.thegreenplace.net/images/2023/binary-tree-graph.svg" type="image/svg+xml"&gt;Binary tree with 15 nodes 1-15&lt;/object&gt;
&lt;p&gt;In one sense, the tree is infinite because &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;binary-tree&lt;/span&gt;&lt;/tt&gt; will happily return
the successors for any node we ask:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (binary-tree 9999)
(19998 19999)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But in another sense, &lt;em&gt;there is no tree&lt;/em&gt;. This is a beautiful implication
of using functions instead of concrete data - they easily enable &lt;em&gt;lazy
evaluation&lt;/em&gt;. We cannot materialize an infinite tree inside a
necessarily finite computer, but we can operate on it all the same because of
this abstraction. As far as the search algorithm is concerned, there exists an
abstract &lt;em&gt;state space&lt;/em&gt; and we tell it how to navigate and interpret it.&lt;/p&gt;
&lt;p&gt;Now we're ready to look at the generic search function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Finds a state that satisfies goal?-fn; Starts with states, and searches&lt;/span&gt;
&lt;span class="s"&gt;  according to successors and combiner. If successful, returns the state;&lt;/span&gt;
&lt;span class="s"&gt;  otherwise returns nil.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;combiner&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;empty?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;combiner&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest &lt;/span&gt;&lt;span class="nv"&gt;states&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="nv"&gt;combiner&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's dig in. The function accepts the following parameters:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;states&lt;/tt&gt;: a list of starting states for the search. When invoked by the
user, this list will typically have a single element; when &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt;
calls itself, this list is the states that it plans to explore next.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt;: a goal detection function. The search doesn't know anything
about states and what the goal of the search is, so this is parameterized
by a function. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt; is expected to return &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; for a goal
state (the state we were searching for) and &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; for all other states.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;: the search function also doesn't know anything about what
kind of tree it's searching through; what are the children of a given state?
Is it searching a binary tree? A N-nary tree? Something more exotic? All of
this is parameterized via the &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; function provided by the user.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt;: finally, the search strategy can be parameterized as well.
There are many different kinds of searches possible - BFS, DFS and others.
&lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; takes a list of successors for the current state the search is
looking at, as well as a list of all the other states the search still plans
to look at. It combines these into a single list &lt;em&gt;somehow&lt;/em&gt;, and thus guides
the order in which the search happens.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Even before we see how this function is used, it's already apparent that this
is quite a powerful abstraction. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt; defines the essence of what
it means to &amp;quot;search a tree&amp;quot;, while being oblivious to what the tree contains,
how it's structured and even what order it should be searched in; all of this
is supplied by functions passed in as parameters.&lt;/p&gt;
&lt;p&gt;Let's see an example, doing a BFS search on our infinite binary tree. First,
we define a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;breadth-first-search&lt;/span&gt;&lt;/tt&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;breadth-first-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search old states first until goal is reached.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;prepend&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function takes a start state (a single state, not a list), &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;, but it sets the &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; parameter to the &lt;tt class="docutils literal"&gt;prepend&lt;/tt&gt;
function, which is defined as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;prepend&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It defines the search strategy (BFS = first look at the rest of the states and
only then at successors of the current state), but still leaves the tree
structure and the notion of what a goal is to parameters. Let's see it in
action:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (breadth-first-search 1 #(= % 9) binary-tree)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we pass the anonymous function literal &lt;tt class="docutils literal"&gt;#(= % 9)&lt;/tt&gt; as the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;goal?-fn&lt;/span&gt;&lt;/tt&gt;
parameter. This function simply checks whether the state passed to it is the
number 9. We also pass &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;binary-tree&lt;/span&gt;&lt;/tt&gt; as the &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;, since we're going
to be searching in our infinite binary tree. BFS works layer by layer, so it
has no issue with that and finds the state quickly.&lt;/p&gt;
&lt;p&gt;We can turn on verbosity (refer to &lt;a class="reference external" href="https://github.com/eliben/paip-in-clojure/tree/master/src/paip/6_tools"&gt;the full code&lt;/a&gt; to
see how it works) to see what &lt;tt class="docutils literal"&gt;states&lt;/tt&gt; parameter &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt; gets called
with, observing the progression of the search:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (with-verbose (breadth-first-search 1 #(= % 9) binary-tree))
;; Search: (1)
;; Search: (2 3)
;; Search: (3 4 5)
;; Search: (4 5 6 7)
;; Search: (5 6 7 8 9)
;; Search: (6 7 8 9 10 11)
;; Search: (7 8 9 10 11 12 13)
;; Search: (8 9 10 11 12 13 14 15)
;; Search: (9 10 11 12 13 14 15 16 17)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the &lt;tt class="docutils literal"&gt;prepend&lt;/tt&gt; combiner in action; for example, after &lt;tt class="docutils literal"&gt;(3 4 5)&lt;/tt&gt;, the
combiner prepends &lt;tt class="docutils literal"&gt;(4 5)&lt;/tt&gt; to the successors of 3 (the list &lt;tt class="docutils literal"&gt;(6 7)&lt;/tt&gt;), getting
&lt;tt class="docutils literal"&gt;(4 5 6 7)&lt;/tt&gt; as the set of states to search through. Overall, observing the
first element in the &lt;tt class="docutils literal"&gt;states&lt;/tt&gt; list through the printed lines, it's clear this
is classical BFS where the tree is visited in &amp;quot;layers&amp;quot;.&lt;/p&gt;
&lt;p&gt;Implementing DFS using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-search&lt;/span&gt;&lt;/tt&gt; is similarly easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;depth-first-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search new states first until goal is reached.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only difference from BFS is the &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; parameter - here we use
&lt;tt class="docutils literal"&gt;concat&lt;/tt&gt; since we want to examine the successors of the first state &lt;em&gt;before&lt;/em&gt;
we examine the other states on the list. If we run &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;depth-first-search&lt;/span&gt;&lt;/tt&gt; on our
infinite binary tree we'll get a stack overflow (unless we're looking for a
state that's on the left-most path), so let's create a safer tree first. This
function can serve as a &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; to define a &amp;quot;finite&amp;quot; binary tree, with
the given maximal state value:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;finite-binary-tree&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Returns a successor function that generates a binary tree with n nodes.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;= &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;binary-tree&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the clever use of higher-order functions here. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;finite-binary-tree&lt;/span&gt;&lt;/tt&gt; is
not a &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; function itself - rather it's a generator of such
functions; given a value, it creates a new function that acts as &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt;
but limits the the states' value to &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(finite-binary-tree&lt;/span&gt; 15)&lt;/tt&gt; will create a &lt;tt class="docutils literal"&gt;successors&lt;/tt&gt; function
that represents exactly the binary tree on the diagram above; if we ask it about
successors of states on the fourth layer, it will say there are none:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (def f15 (finite-binary-tree 15))
#&amp;#39;paip.core/f15
paip.core=&amp;gt; (f15 4)
(8 9)
paip.core=&amp;gt; (f15 8)
()
paip.core=&amp;gt; (f15 7)
(14 15)
paip.core=&amp;gt; (f15 15)
()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As another test, let's try to look for a state that's not in our finite tree.
Out infinite tree theoretically has &lt;em&gt;all&lt;/em&gt; the states:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (breadth-first-search 1 #(= % 33) binary-tree)
33
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But not the finite tree:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (breadth-first-search 1 #(= % 33) (finite-binary-tree 15))
nil
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With our finite tree, we are ready to use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;depth-first-search&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (with-verbose (depth-first-search 1 #(= % 9) (finite-binary-tree 15)))
;; Search: (1)
;; Search: (2 3)
;; Search: (4 5 3)
;; Search: (8 9 5 3)
;; Search: (9 5 3)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the search order; when &lt;tt class="docutils literal"&gt;(2 3)&lt;/tt&gt; is explored, 2's successors &lt;tt class="docutils literal"&gt;(4 5)&lt;/tt&gt; then
come &lt;em&gt;before&lt;/em&gt; 3 in the next call; this is the definition of DFS.&lt;/p&gt;
&lt;p&gt;We can implement more advanced search strategies using this infrastructure. For
example, suppose we have a heuristic that tells us which states to prioritize in
order to get to the goal faster (akin to A* search on graphs). We can define
a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;best-first-search&lt;/span&gt;&lt;/tt&gt; that sorts the states according to our heuristic and
tries the most promising states first (&amp;quot;best&amp;quot; as in &amp;quot;best looking among the
current candidates&amp;quot;, not as in &amp;quot;globally best&amp;quot;).&lt;/p&gt;
&lt;p&gt;First, let's define a couple of helper higher-order functions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;diff&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Given n, returns a function that computes the distance of its argument from n.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Math/abs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;sorter&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Returns a combiner function that sorts according to cost-fn.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;new &lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sort-by &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="k"&gt;new &lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;diff&lt;/tt&gt; is a function generator like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;finite-binary-tree&lt;/span&gt;&lt;/tt&gt;; it takes a target
number &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; and returns a function that computes its parameter &lt;tt class="docutils literal"&gt;x&lt;/tt&gt;'s distance
from &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;sorter&lt;/tt&gt; returns a function that serves as the &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt; for our
search, based on a cost function. This is done by concatenating the two lists
(successors of first state and the rest of the states) first, and then sorting
them by the cost function. &lt;tt class="docutils literal"&gt;sorter&lt;/tt&gt; is a powerful example of modeling with
higher-order functions.&lt;/p&gt;
&lt;p&gt;With these building blocks in place, we can define &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;best-first-search&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;best-first-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search lowest cost states first until goal is reached.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sorter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, this is just like the earlier BFS and DFS - only the strategy
(&lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt;) changes. Let's use it to find 9 again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;paip.core=&amp;gt; (with-verbose (best-first-search 1 #(= % 9) (finite-binary-tree 15) (diff 9)))
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6 2)
;; Search: (6 14 15 2)
;; Search: (12 13 14 15 2)
;; Search: (13 14 15 2)
;; Search: (14 15 2)
;; Search: (15 2)
;; Search: (2)
;; Search: (5 4)
;; Search: (10 11 4)
;; Search: (11 4)
;; Search: (4)
;; Search: (9 8)
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it finds the state eventually, we discover that our heuristic is not a
great match for this problem, as it sends the search astray. The goal of this
post is to demonstrate the power of higher-order functions in building modular
code, not to discover an optimal heuristic for searching in binary trees, though
:-)&lt;/p&gt;
&lt;p&gt;One last search variant before we're ready to wrap up. As we've seen with the
infinite tree, sometimes the search space is too large and we have to compromise
on which states to look at and which to ignore. This technique works
particularly well if the target is not some single value that we must find, but
rather we want to get a &amp;quot;good enough&amp;quot; result in a sea of bad options. We can
use a technique called &lt;em&gt;beam search&lt;/em&gt;; think of a beam of light a flashlight
produces in a very dark room; we can see what the beam points at, but not much
else.&lt;/p&gt;
&lt;p&gt;Beam search is somewhat similar to our &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;best-first-search&lt;/span&gt;&lt;/tt&gt;, but after combining
and sorting the list of states to explore, it only keeps the first N, where
N is given by the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;beam-width&lt;/span&gt;&lt;/tt&gt; parameter:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;beam-search&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Search highest scoring states first until goal is reached, but never consider&lt;/span&gt;
&lt;span class="s"&gt;  more than beam-width states at a time.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;beam-width&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-search&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;goal?-fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;successors&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;new&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;sorted&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;sorter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cost-fn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;new&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take &lt;/span&gt;&lt;span class="nv"&gt;beam-width&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, higher-order functions at play: as its &lt;tt class="docutils literal"&gt;combiner&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;beam-search&lt;/span&gt;&lt;/tt&gt;
creates an anonymous function that sorts the list based on &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cost-fn&lt;/span&gt;&lt;/tt&gt;, and then
keeps only the first &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;beam-width&lt;/span&gt;&lt;/tt&gt; states on that list.&lt;/p&gt;
&lt;p&gt;Exercise: Try to run it - what beam width do you need to set in order to
successfully find 9 using our cost heuristic? How can this be improved?&lt;/p&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post attempts a code-walkthrough approach to demonstrating the power of
higher-order functions. I always found this particular example from PAIP very
elegant; a particularly powerful insight is the distilled difference between
DFS and BFS. While most programmers intuitively understand the difference and
could write down the pseudo-code for both search strategies, modeling the
problem with higher-order functions lets us really get to the essence of the
difference - &lt;tt class="docutils literal"&gt;concat&lt;/tt&gt; vs. &lt;tt class="docutils literal"&gt;prepend&lt;/tt&gt; as the combiner step.&lt;/p&gt;
&lt;p&gt;See also: &lt;a class="reference external" href="https://eli.thegreenplace.net/2023/higher-order-functions-in-go/"&gt;this code sample ported to Go&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category><category term="Programming"></category></entry><entry><title>Clojure - the perfect language to expand your brain?</title><link href="https://eli.thegreenplace.net/2017/clojure-the-perfect-language-to-expand-your-brain/" rel="alternate"></link><published>2017-08-04T05:25:00-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-08-04:/2017/clojure-the-perfect-language-to-expand-your-brain/</id><summary type="html">&lt;p&gt;I sometimes get asked for recommendations of what programming language to &amp;quot;learn
next&amp;quot;. It's great that folks appreciate the fact that being exposed to several
sufficiently different programming languages is an important step on the path
to programming enlightenment. But it's also true that, given limited free time,
the choice …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I sometimes get asked for recommendations of what programming language to &amp;quot;learn
next&amp;quot;. It's great that folks appreciate the fact that being exposed to several
sufficiently different programming languages is an important step on the path
to programming enlightenment. But it's also true that, given limited free time,
the choice of which languages to learn is important. As the famous quote by
&lt;a class="reference external" href="https://en.wikiquote.org/wiki/Alan_Perlis"&gt;Alan Perlis&lt;/a&gt; says:&lt;/p&gt;
&lt;blockquote&gt;
A language that doesn't affect the way you think about programming, is not
worth knowing.&lt;/blockquote&gt;
&lt;p&gt;In this post I want to explain why I think Clojure is a &lt;em&gt;terrific&lt;/em&gt; language for
this task. Whatever your background, it's &lt;a class="reference external" href="http://www.paulgraham.com/icad.html"&gt;almost guaranteed&lt;/a&gt; to affect the way you think about
programming. It's a fairly new language (from 2007) that did a good job of
collecting insights and paradigms from many existing languages and organizing
them into a coherent whole. It's chock-full of great ideas. In
other words, the &lt;em&gt;perfect language to expand your brain&lt;/em&gt;.&lt;/p&gt;
&lt;img alt="Brain with Clojure inside" class="align-center" src="https://eli.thegreenplace.net/images/2017/brainclojure.png" /&gt;
&lt;div class="section" id="it-s-a-lisp"&gt;
&lt;h2&gt;It's a Lisp!&lt;/h2&gt;
&lt;p&gt;First and foremost, Clojure belongs to the Lisp family of languages, like Common
Lisp, Scheme and Racket. Lisp is one of the oldest and still most important
families of programming languages to be familiar with. Being a Lisp in this case
means several things:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Clojure is a dynamic language. No matter where you stand on the static vs.
dynamic typing debate, knowing languages in both camps is important. Clojure
has a kind of optional typing, but in essence it's dynamic.&lt;/li&gt;
&lt;li&gt;It promotes combinations of built-in data structures (lists, maps, vectors)
over objects and has very good reasons for doing so.&lt;/li&gt;
&lt;li&gt;It promotes programming with higher-order functions. Some built-in features
like &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/reducers-transducers-and-coreasync-in-clojure/"&gt;reducers and transducers&lt;/a&gt;
rely heavily on composing higher order functions for transforming other
functions.&lt;/li&gt;
&lt;li&gt;It has uniform syntax with full Lisp-style macro support! This capability
has proved to be very elusive for non-Lisp languages, and seeing some &lt;em&gt;real&lt;/em&gt;
macros in action is enlightening. Clojure has a whole Go-like CSP equivalent
implemented using macros in &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;It encourages REPL-based development, where functionality is built and testsed
gradually from the bottom up in an interactive terminal.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Importantly, Clojure is a very &lt;em&gt;modern&lt;/em&gt; Lisp, with tons of libraries for tasks
common in our day and age. It also builds upon important recent research in data
structures, such as efficient persistent vectors, that only appeared in the
1990s or later. I've been dabbling with various Lisps for almost 15 years, and
Clojure is the first Lisp I'd consider using in production.&lt;/p&gt;
&lt;p&gt;I want the stress the importance of full Lisp-style macros once again. Lisp's
(and Clojure's) uniform syntax and macros force us to think about the
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Meta-circular_evaluator"&gt;Meta-circular abstraction&lt;/a&gt; - there's just no way
around it! We have to think of our code as data, and this has profound
implications. Back in 2005, when I was still a programming neophyte, I faced a
performance challenge for a data-decoding program I was hacking on in Perl.
Having learned some Lisp, I had the insight of &lt;a class="reference external" href="https://eli.thegreenplace.net/2005/09/04/cool-hack-creating-custom-subroutines-on-the-fly-in-perl"&gt;generating and evaluating new
Perl code on the fly&lt;/a&gt;,
which turned out to be key to the success of that program. I'm confident I could
not have come up with that solution back then without being aware of the &amp;quot;Lisp
way&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pragmatism-and-hard-won-experience"&gt;
&lt;h2&gt;Pragmatism and hard-won experience&lt;/h2&gt;
&lt;p&gt;The designers of Clojure are extremely pragmatic, building upon decades of
industry experience. I strongly recommend watching some &lt;a class="reference external" href="https://www.youtube.com/user/ClojureTV"&gt;YouTube videos of talks&lt;/a&gt; by leading Clojure developers. In
particular, watch a few of the more popular talks by Rich Hickey - Clojure's
original designer. The Alan Perlis quote mentioned above may be his most
popular, but there's another I find at least as insightful:&lt;/p&gt;
&lt;blockquote&gt;
Simplicity does not precede complexity, but follows it.&lt;/blockquote&gt;
&lt;p&gt;There's a certain quality in programmers I believe we can all recognize. It can
only come from &lt;em&gt;real&lt;/em&gt;, hard-won experience of building systems for many years
and pondering about how to build such systems more effectively next time. Rich
Hickey certainly belongs to this quality category - his talks are very
insightful, and this philosophy reigns in the design and implementation of
Clojure, as well as its (friendly and vibrant) community.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sequences-and-laziness-for-powerful-in-language-data-processing"&gt;
&lt;h2&gt;Sequences and laziness for powerful in-language data processing&lt;/h2&gt;
&lt;p&gt;Applications that process and extract useful bits of information from large
datasets all look alike in many programming languages, at least to some extent.
What we &lt;em&gt;really&lt;/em&gt; want in many cases is SQL-like primitives built into our
languages, but this is often challenging (.NET's LINQ is one example of a
successful approach).&lt;/p&gt;
&lt;p&gt;Clojure combines pervasive sequence protocols with persistent data structures
and laziness to make this kind of task natural, using only built-in tools.
Here's a realistic example of a function taken from the &lt;a class="reference external" href="https://pragprog.com/book/vmclojeco/clojure-applied"&gt;Clojure Applied&lt;/a&gt; book:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;revenue-by-department&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;carts&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="ss"&gt;:settled?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;carts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcat &lt;/span&gt;&lt;span class="ss"&gt;:line-items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;line-summary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;group-by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:dept&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reduce-kv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;dept-total&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the functions used here are built-ins, including the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&amp;gt;&lt;/span&gt;&lt;/tt&gt; macro. This
code reads like SQL and it's efficient too. In fact, it can be made somewhat
more efficient and even seamlessly parallelized using &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/reducers-transducers-and-coreasync-in-clojure/"&gt;Reducers and Transducers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://clojure.org/guides/spec"&gt;clojure.spec&lt;/a&gt; library provides a degree
of type-safety for nested data structures. If you've ever written comments like
&amp;quot;this maps strings to lists, where each list element is a map of ...&amp;quot;,
&lt;tt class="docutils literal"&gt;clojure.spec&lt;/tt&gt; makes it more formal and verifiable. This is very useful when
working with data, and is another example of where Clojure's pragmatism shines;
the language is dynamic in its core, but when you need static checking - it's
there, optionally (&lt;tt class="docutils literal"&gt;core.typed&lt;/tt&gt; is another option for a more statically typed
flavor).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-right-approach-to-object-orientation"&gt;
&lt;h2&gt;The right approach to object-orientation&lt;/h2&gt;
&lt;p&gt;Historically, Lisp programmers weren't the biggest proponents of OOP. This
doesn't mean that OOP has absolutely no value in Lisp-y languages, however.
Common Lisp has had CLOS for decades, and Clojure also comes with an array of
OO-like features.&lt;/p&gt;
&lt;p&gt;That said, Clojure's flavor of OOP is particularly powerful and tends to
discourage bad practices. Clojure uses &amp;quot;protocols&amp;quot;, which are a kind of
interfaces, and encourages thinking in terms of protocols rather than in terms
of classes with inheritance hierarchies, sort of like Go. Add to that an ability
to do true &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-4/"&gt;multiple dispatch&lt;/a&gt;
and you have a powerful modeling tool at your fingertips.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="built-in-support-for-concurrency-and-parallelism"&gt;
&lt;h2&gt;Built-in support for concurrency and parallelism&lt;/h2&gt;
&lt;p&gt;It wouldn't be a real language of the 2000s without powerful support for
concurrency and parallelism right at the core. Clojure supports this in many
ways, which are interleaved.&lt;/p&gt;
&lt;p&gt;First, it's a functional language with persistent data structures. Persistent
data structures are effectively immutable, which makes them very attractive in a
multi-threaded context. Clojure has a great implementation of persistent data
structures even for things like vectors (which are quite challenging to
implement in an efficient manner). This is a bigger deal than may originally
appear. Pure functions are often great in theory but fail in practice due to too
much copying of non-trivial data structures; Clojure's elegant usage of
persistent data structures solves this problem, making pure functions efficient
and thus much more applicable to a wide array of problems.&lt;/p&gt;
&lt;p&gt;Second, Clojure doesn't lock itself in the closet of purism and does support
lower-level primitives for concurrency and mutation, where needed. Atoms are
built-in mutable state units with atomic updates. &lt;a class="reference external" href="https://clojure.org/reference/refs"&gt;Refs and transactions&lt;/a&gt; go further, implementing STM.&lt;/p&gt;
&lt;p&gt;Third, Clojure comes with a bunch of concurrency tools built in. Promises,
futures and threads leverage the underlying JVM's threading utilities.&lt;/p&gt;
&lt;p&gt;Finally, Clojure has a pretty good implementation of Go's CSP in the
&lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; module. It provides two useful things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Channels and Go &lt;tt class="docutils literal"&gt;select&lt;/tt&gt;-like functionality (&lt;tt class="docutils literal"&gt;alts!!&lt;/tt&gt;) which makes it
easy to work with safe concurrent queues and &amp;quot;share data by communicating&amp;quot;.&lt;/li&gt;
&lt;li&gt;go-blocks with non-blocking primitives that &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/clojure-concurrency-and-blocking-with-coreasync/"&gt;make it possible&lt;/a&gt;
to write cooperative &amp;quot;green threads&amp;quot; with ease.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion-try-it"&gt;
&lt;h2&gt;Conclusion - try it&lt;/h2&gt;
&lt;p&gt;Finally, it's important to mention that Clojure is far from being an academic
exercise. It's used in production by several companies, and has strong roots in
the massive Java ecosystem. Clojure's interoperability with Java is seamless -
Java code can be called from Clojure with no special provisions, and all core
Clojure entities are Java objects deep under the hood.&lt;/p&gt;
&lt;p&gt;On the client side, Clojurescript has been gaining traction recently as another
language-compiled-to-JS option. It brings the elegance of Clojure to client-side
programming, among with some unique features like &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; for
callback-free concurrency.&lt;/p&gt;
&lt;p&gt;This doesn't mean that you should only consider Clojure as a fit for your next
project. On the contrary, I recommend learning if even if there's little chance
of using it in production any time soon. In fact, this was exactly my situation,
Clojure is a great language to expand your programming horizons; who knows,
maybe in the future you'll find it useful for some real work. If you do, great!
If you don't, learning it will positively affect how you use other programming
languages.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category><category term="Programming"></category></entry><entry><title>Clojure concurrency and blocking with core.async</title><link href="https://eli.thegreenplace.net/2017/clojure-concurrency-and-blocking-with-coreasync/" rel="alternate"></link><published>2017-06-23T06:01:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-06-23:/2017/clojure-concurrency-and-blocking-with-coreasync/</id><summary type="html">&lt;p&gt;This article is an attempt to dig into the performance problem of concurrent
applications using &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; in situations where blocking operations are
involved. &amp;quot;Blocking&amp;quot; operations happen when the running program has to wait for
something happening outside it; a canonical example is issuing an HTTP request
and waiting for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This article is an attempt to dig into the performance problem of concurrent
applications using &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; in situations where blocking operations are
involved. &amp;quot;Blocking&amp;quot; operations happen when the running program has to wait for
something happening outside it; a canonical example is issuing an HTTP request
and waiting for the remote server to respond. Such operations are also sometimes
called &amp;quot;synchronous&amp;quot;.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; library comes with many high-level features like transducers
and pipelines; in this article I want to focus on the two fundamental mechanisms
it provides for launching a new computation concurrently: threads and go-blocks.&lt;/p&gt;
&lt;p&gt;New threads can be created with &lt;tt class="docutils literal"&gt;(thread &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;. This call runs the body in a
new thread and (immediately) returns a channel to which the result of the body
will be posted. Similarly, a go-block is created with &lt;tt class="docutils literal"&gt;(go &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt; - it also
launches the computation concurrently, but instead of creating a new thread it
posts the computation onto a &lt;em&gt;thread pool&lt;/em&gt; of fixed size that the library
maintains for all its go-blocks. Most of the article is focusing on exploring
the differences between these two methods.&lt;/p&gt;
&lt;div class="section" id="the-go-block-thread-pool"&gt;
&lt;h2&gt;The go-block thread pool&lt;/h2&gt;
&lt;p&gt;In any given executing Clojure process, a single thread pool is dedicated to
running all go-blocks. A quick glance at the Clojure source code shows that the
size of this pool is 8, meaning that 8 physical threads are launched &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. This
number is hard-coded, though it can be modified by setting the
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clojure.core.async.pool-size&lt;/span&gt;&lt;/tt&gt; property for the JVM running the program. So 8
is the default number of threads &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; has at its disposal to implement
its ad-hoc cooperative multitasking.&lt;/p&gt;
&lt;p&gt;Let's start with a cute little experiment to determine the size of the thread
pool empirically; this exercise will also shed some light on the effect of
blocking calls inside go-blocks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;launch-n-go-blocks&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Thread/sleep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function launches &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; go-blocks, each sleeping for 10 milliseconds and
then pushing a number into a shared channel. Then it waits to receive all
numbers from the channel and returns; the effect is to block until all the
go-blocks are done. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;receive-in&lt;/span&gt;&lt;/tt&gt; is a simple function used throughout this
article:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Receive n items from the given channel and return them as a vector.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;inc &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;launch-n-go-blocks&lt;/span&gt;&lt;/tt&gt; several times, with an increasing &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;
and observe what happens:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Launching  1 -&amp;gt; &amp;quot;Elapsed time: 11.403985 msecs&amp;quot;
Launching  2 -&amp;gt; &amp;quot;Elapsed time: 11.050685 msecs&amp;quot;
Launching  3 -&amp;gt; &amp;quot;Elapsed time: 10.37412 msecs&amp;quot;
Launching  4 -&amp;gt; &amp;quot;Elapsed time: 10.342037 msecs&amp;quot;
Launching  5 -&amp;gt; &amp;quot;Elapsed time: 10.359517 msecs&amp;quot;
Launching  6 -&amp;gt; &amp;quot;Elapsed time: 10.409539 msecs&amp;quot;
Launching  7 -&amp;gt; &amp;quot;Elapsed time: 10.543612 msecs&amp;quot;
Launching  8 -&amp;gt; &amp;quot;Elapsed time: 10.429726 msecs&amp;quot;
Launching  9 -&amp;gt; &amp;quot;Elapsed time: 20.480441 msecs&amp;quot;
Launching 10 -&amp;gt; &amp;quot;Elapsed time: 20.442724 msecs&amp;quot;
Launching 11 -&amp;gt; &amp;quot;Elapsed time: 21.115002 msecs&amp;quot;
Launching 12 -&amp;gt; &amp;quot;Elapsed time: 21.192993 msecs&amp;quot;
Launching 13 -&amp;gt; &amp;quot;Elapsed time: 21.113135 msecs&amp;quot;
Launching 14 -&amp;gt; &amp;quot;Elapsed time: 21.376159 msecs&amp;quot;
Launching 15 -&amp;gt; &amp;quot;Elapsed time: 20.754207 msecs&amp;quot;
Launching 16 -&amp;gt; &amp;quot;Elapsed time: 20.654873 msecs&amp;quot;
Launching 17 -&amp;gt; &amp;quot;Elapsed time: 31.084513 msecs&amp;quot;
Launching 18 -&amp;gt; &amp;quot;Elapsed time: 31.152651 msecs&amp;quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ignoring the minor fluctuations in measurements, there's a very clear pattern
here; let's plot it:&lt;/p&gt;
&lt;img alt="Runtime of launching go-blocks with sleeps" class="align-center" src="https://eli.thegreenplace.net/images/2017/go-block-sleep-runtime.png" /&gt;
&lt;p&gt;The reason for this behavior is the blocking nature of &lt;tt class="docutils literal"&gt;Thread/sleep&lt;/tt&gt;. This
function blocks the &lt;em&gt;current thread&lt;/em&gt; for the specified duration (10 ms in our
case); so the go-block executing it will block the thread it's currently running
on. This thread is then effectively out of the pool until the sleep finishes.
The plot immediately suggests the pool size is 8; as long as 8 or fewer
go-blocks are launched, they all finish within ~10 ms because they all run
concurrently. As soon as we go above 8, the runtime jumps to ~20 ms because one
of the go-blocks will have to wait until there's a free thread in the pool.&lt;/p&gt;
&lt;p&gt;Let's try the same experiment using &lt;tt class="docutils literal"&gt;thread&lt;/tt&gt; instead of &lt;tt class="docutils literal"&gt;go&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;launch-n-threads&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/thread&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Thread/sleep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, each time through the loop &lt;em&gt;a new thread&lt;/em&gt; is launched, regardless of the
number of threads already executing &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. All these threads can run
concurrently, so the runtime plot is:&lt;/p&gt;
&lt;img alt="Runtime of launching threads with sleeps" class="align-center" src="https://eli.thegreenplace.net/images/2017/thread-sleep-runtime.png" /&gt;
&lt;p&gt;The Clojure documentation and talks / presentations by developers are careful to
warn against running blocking operations in go-blocks &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;; it's also not hard
to understand why this is so by thinking a bit about the fixed thread-pool based
implementation. That said, it's still useful to actually see this in action
using an easy-to-understand experiment. In the next section we'll explore the
real-life performance implications of blocking inside go-blocks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="blocking-i-o"&gt;
&lt;h2&gt;Blocking I/O&lt;/h2&gt;
&lt;p&gt;The sleeping example shown earlier is artificial, but the perils of blocking
inside go-blocks are real. Blocking happens quite often in realistic programs,
most often in the context of I/O. I/O devices tend to be significantly slower
than the CPU executing our program, especially if by &amp;quot;I/O device&amp;quot; we mean a web
server located half-way across the world to which we issue an HTTP request.&lt;/p&gt;
&lt;p&gt;So the next example is going to be a simple concurrent HTTP client; again, two
versions are studied and compared - one with go-blocks, another with threads.
For this sample, we'll be using the &lt;a class="reference external" href="https://github.com/dakrone/clj-http"&gt;clj-http&lt;/a&gt; library &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;, which provides a simple
API to issue blocking HTTP requests. The full code is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/clojure-blocking-async/src/clojure_blocking_async/http_client.clj"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;url-template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;https://github.com/eliben/pycparser/pull/%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;blocking-get-page&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clj-http.client/get&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;url-template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;go-blocking-generator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;doseq &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;blocking-get-page&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;go-blocking-generator&lt;/span&gt;&lt;/tt&gt; is called, it launches &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; go-blocks, each
requesting a different page from &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser's&lt;/a&gt; pull requests on GitHub. Fetching one
page takes between 760 and 990 ms on my machine, depending on the exact page.
When run with &lt;tt class="docutils literal"&gt;n=20&lt;/tt&gt;, this version takes about 2300 ms. Now let's do the same
with threads:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;thread-blocking-generator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;doseq &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;blocking-get-page&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;n=20&lt;/tt&gt;, this version takes only 1000 ms. As expected, all threads
manage to run at the same time, which is mostly spent waiting on the remote
server. In the go-blocks version, only 8 blocks run concurrently because of the
thread pool size; this example should really drive home the notion of just how
bad blocking I/O in go-blocks is. Most of the blocks sit there waiting for the
thread pool to have a vacant spot, when all they have to do is just issue a HTTP
request and wait anyway.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="parallelizing-cpu-bound-tasks"&gt;
&lt;h2&gt;Parallelizing CPU-bound tasks&lt;/h2&gt;
&lt;p&gt;We've seen how go-blocks interact with blocking operations; now let's examine
CPU-bound tasks, which spend their time doing actual computations on the CPU
rather than waiting for I/O. In an older post, I explored the effects of using
threads and processes &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/01/16/python-parallelizing-cpu-bound-tasks-with-multiprocessing"&gt;in Python to parallelize a simple numeric problem&lt;/a&gt;.
Here I'll be using a similar example: naïvely factorizing a large integer.&lt;/p&gt;
&lt;p&gt;Here's the function that factorizes a number into a vector of factors:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Naive factorization function; takes an integer n and returns a vector of&lt;/span&gt;
&lt;span class="s"&gt;  factors.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;mod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;quot &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factors&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It takes around 2.3 ms to factorize the number 29 * 982451653; I'll refer to it
as &lt;tt class="docutils literal"&gt;mynum&lt;/tt&gt; from now on &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;. Let's examine a few strategies of factorizing a
large set of numbers in parallel. We'll start with a simple &amp;quot;serial&amp;quot; factorizer,
which should also introduce the API:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;serial-factorizer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Simple serial factorizer.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zipmap &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each factorizer function in this sample takes a sequence of numbers and returns
a new map, which maps a number to its vector of factors. If we run
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;serial-factorizer&lt;/span&gt;&lt;/tt&gt; on a sequence of 1000 &lt;tt class="docutils literal"&gt;mynum&lt;/tt&gt;s, it takes ~2.3 seconds;
no surprises here!&lt;/p&gt;
&lt;p&gt;Now, a parallel factorizer using go-blocks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;async-go-factorizer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parallel factorizer for nums, launching n go blocks.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;;;; Push nums into an input channel; spin up n go-blocks to read from this&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;;;; channel and add numbers to an output channel.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go-loop&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n-maps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a pattern that should be familiar by now, this function creates a couple of
local channels and spins up a number of go-blocks to read and write from these
channels; the code should be self-explanatory. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;receive-n-maps&lt;/span&gt;&lt;/tt&gt; is similar to
the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;receive-n&lt;/span&gt;&lt;/tt&gt; function we've seen earlier in the article, just with maps
instead of vectors.&lt;/p&gt;
&lt;p&gt;Knowing that my machine has 8 CPU threads (4 cores, hyper-threaded), I
benchmarked &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;async-go-factorizer&lt;/span&gt;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;n=8&lt;/tt&gt;, and it took around 680 ms, a
3.4x speedup over the serial version &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's try the same with threads instead of go-blocks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;async-thread-factorizer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Same as async-go-factorizer, but with thread instead of go.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/thread&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nextnum&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n-maps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The performance is pretty much the same - 680 ms for 1000 numbers with
parallelism of &lt;tt class="docutils literal"&gt;n=8&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;This is an important point! On purely CPU-bound workloads, go-blocks are no
worse than threads because all the physical cores are kept busy doing useful
work at all time. There's no waiting involved, so there's no opportunity to
steal an idle core for a different thread. One minor gotcha is to be wary of
the go-block thread pool size; if you run your program on a dual socket machine
with dozens of cores, you may want to bump that number up and use a wider
parallelism setting.&lt;/p&gt;
&lt;p&gt;For completeness (and fun!) let's try a couple more methods of parallelizing
this computation. The pattern in these parallel factorizers is so common that
&lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; has a function for it - &lt;tt class="docutils literal"&gt;pipeline&lt;/tt&gt;; here's how we use it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;async-with-pipeline&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parallel factorizer using async/pipeline.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/pipeline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-map &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in-c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n-maps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;out-c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;async/pipeline&lt;/tt&gt; takes an input channel, output channel and a transducer, as
well as the parallelism. It takes care of spinning go-blocks and connecting all
the channels properly &lt;a class="footnote-reference" href="#footnote-7" id="footnote-reference-7"&gt;[7]&lt;/a&gt;. This takes about the same amount of time as the
other versions shown earlier, which isn't surprising.&lt;/p&gt;
&lt;p&gt;Finally, let's try something slightly different and use Clojure's parallel
&lt;tt class="docutils literal"&gt;fold&lt;/tt&gt; from the &lt;tt class="docutils literal"&gt;clojure.core.reducers&lt;/tt&gt; library (both &lt;tt class="docutils literal"&gt;fold&lt;/tt&gt; and
transducers are described in &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/reducers-transducers-and-coreasync-in-clojure/"&gt;my earlier article&lt;/a&gt;
- check it out!)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;conjmap&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;xs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;xs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;rfold&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parallel factorizer using r/fold.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;r/fold&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;conjmap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;r/map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-map &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we don't have to set the parallelism; &lt;tt class="docutils literal"&gt;r/fold&lt;/tt&gt; determines it on its own.
This approach takes 1.15 seconds on 1000 numbers, quite a bit slower than the
earlier attempts. It's entirely possible that the fork-join approach used by
&lt;tt class="docutils literal"&gt;r/fold&lt;/tt&gt; is less efficient than the manual chunking to different threads done
by the other versions.&lt;/p&gt;
&lt;p&gt;The conclusion from this section, however, should be that for purely CPU-bound
tasks it doesn't matter much whether go-blocks or explicit threads are used -
the performance should be more-or-less the same. That said, realistic programs
don't often spend time purely in CPU-bound tasks; the reality is usually
somewhere in between - some tasks do computations, other tasks wait on things.
Let's see a benchmark that combines the two.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="combining-blocking-and-cpu-bound-tasks"&gt;
&lt;h2&gt;Combining blocking and CPU-bound tasks&lt;/h2&gt;
&lt;p&gt;This section shows an artificial benchmark that explores how a combination of
blocking and CPU-bound tasks behaves when launched on go-blocs vs. threads. The
CPU bound task will be the same factorization but this time with a larger number
that was carefully tuned to take about 230 ms to factorize on my machine. The
blocking &amp;quot;task&amp;quot; will be &lt;tt class="docutils literal"&gt;(Thread/sleep 250)&lt;/tt&gt;. I deliberately choose the same
duration for the two kinds of tasks here to make comparisons easier, but the
principle applies more generally.&lt;/p&gt;
&lt;p&gt;Here is the go-block version of the benchmark:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;launch-go-blocking-and-compute&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nblock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ncompute&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nblock&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Thread/sleep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;250&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ncompute&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;mynum&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;receive-n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nblock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ncompute&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;nblock&lt;/tt&gt; is the number of blocking tasks to launch; &lt;tt class="docutils literal"&gt;ncompute&lt;/tt&gt; is the number
of CPU-bound tasks to launch. The rest of the code is straightforward. You can
guess what the threading version looks like by now - check out the &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/clojure-blocking-async/src/clojure_blocking_async/combine_cpubound_blocking.clj"&gt;full code
sample&lt;/a&gt;
if not.&lt;/p&gt;
&lt;p&gt;The parameter space here is pretty large; let's try 32 blocking and 16 compute
tasks in parallel:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nblock=32, ncompute=16

launch-go-blocking-and-compute: 1521 ms
launch-thread-blocking-and-compute: 530 ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The larger we set &lt;tt class="docutils literal"&gt;nblock&lt;/tt&gt;, the worse the situation becomes for the go-block
version:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nblock=64, ncompute=16

launch-go-blocking-and-compute: 3200 ms
launch-thread-blocking-and-compute: 530 ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Up to some limit, the threading version is only limited by &lt;tt class="docutils literal"&gt;ncompute&lt;/tt&gt;, since
these actually occupy the CPU cores; all the blocking tasks are run in the
background and can complete at the same time (after the initial 250 ms).&lt;/p&gt;
&lt;p&gt;The go-block version fares much worse, because the blocking tasks can occupy
threads while the compute tasks just wait in a queue. Depending on the exact
mixture of blocking and compute-bound tasks, this can range from more-or-less
the same to &lt;em&gt;exteremely&lt;/em&gt; bad for the go-blocks version. YMMV!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="managing-callback-hell-with-go-blocks"&gt;
&lt;h2&gt;Managing callback-hell with go-blocks&lt;/h2&gt;
&lt;p&gt;We've seen the issues that come up when mixing blocking I/o with go-blocks. The
reason for this is the cooperative concurrency approach implemented by go-blocks
on top of a fixed thread pool. For cooperative concurrency to work well with
I/O, the language should either make the scheduler aware of the I/O calls (to be
able to switch to another context while blocking) or the I/O should be
non-blocking. The former requires runtime support in the language, like Go; the
latter is what programming environments like Python (with &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt;) and
Node.js (with its fully non-blocking standard library) do. The same applies to
Clojure, where &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; is just a library without actual runtime support.&lt;/p&gt;
&lt;p&gt;The good news is that non-blocking I/O libraries are very popular these days,
and Clojure has a good number of them for all the common tasks you can think of.
Another good news is that &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;'s channels make it very easy to deal
with non-blocking I/O without sliding into &lt;a class="reference external" href="http://callbackhell.com/"&gt;callback hell&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's a code sample that uses the asynchronous mode of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clj-http&lt;/span&gt;&lt;/tt&gt; to repeat
the concurrent HTTP request benchmark:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;go-async-generator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;doseq &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clj-http.client/get&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;url-template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:async?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;response&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;response&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;;; Exception callback.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;exc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;throw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;exc&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When passed the &lt;tt class="docutils literal"&gt;{:async? true}&lt;/tt&gt; option, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clj-http.client/get&lt;/span&gt;&lt;/tt&gt; does a
non-blocking request with a callback for the response (and another callback for
an error). Our &amp;quot;response callback&amp;quot; simply spins a go-block that places the
response into a channel. Now another go-block (or thread) can wait on the
channel to perform the next step; compare that to cascading callbacks!&lt;/p&gt;
&lt;p&gt;The performance is good too - when run with multiple requests in parallel, this
version runs as fast as the thread-launching example from earlier in the article
(the full code &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/clojure-blocking-async/src/clojure_blocking_async/http_client_async.clj"&gt;is here&lt;/a&gt;).
All the &lt;tt class="docutils literal"&gt;get&lt;/tt&gt; requests are launched one after another, with no blocking. When
the results arrive, go-blocks patiently &amp;quot;park&amp;quot; while sending them into a
channel, but this is an explicit context-switch operation, so all of them
peacefully run concurrently on the underlying thread pool.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Would launching a thread inside the callback work as well in the last example?
Yes, I think it would. So why use go-blocks?&lt;/p&gt;
&lt;p&gt;The reason is scalability. Launching threads is fine as long as you don't have
too many, and as long as the latency of the launch is not too important. Threads
are OS constructs and have fairly heavy resource requirements - in terms of
memory consumption and context-switching time. go-blocks are extremely
lightweight in comparison.&lt;/p&gt;
&lt;p&gt;Therefore, if you want to serve 1000s of connections concurrently from a single
machine - go-blocks are the way to go, combined with non-blocking APIs. Note
that go-blocks use a thread pool that can use multipe cores, so this isn't just
a single-core concurrent multitasking solution (such as you may encounter in
Node.js or Python's &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;If the number of concurrent tasks is not too large or blocking I/O is involved,
I'd recommend using &lt;tt class="docutils literal"&gt;async/thread&lt;/tt&gt;. It avoids the pitfalls of blocking I/O,
and in other cases performance is the same. &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;'s wonderful tools
like channels and &lt;tt class="docutils literal"&gt;alts!!&lt;/tt&gt; are still available, making concurrent programming
much more pleasant.&lt;/p&gt;
&lt;p&gt;However, note that Clojure is a multi-environment language, and in some
environments (most notably ClojureScript), threads are simply unavailable. In
these cases using go-blocks is your only chance at any kind of reasonable
concurrency (the alternative being callbacks).&lt;/p&gt;
&lt;p&gt;Another use case for go-blocks is to implement coroutines which can be useful in
some cases - such as agents in games, as a &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines"&gt;replacement for complex state
machines&lt;/a&gt;,
etc. But here again, beware of the actual scale. If it's possible to use
threads, just use threads. go-blocks are trickier to use correctly and one has
to be always aware of what may block, lest performance is dramatically degraded.&lt;/p&gt;
&lt;p&gt;If there's something I'm missing, please let me know!&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is for the standard JVM implementation of Clojure; in ClojureScript
there would just be a single thread, since JS doesn't support in-browser
threads (yet).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The JVM also has some limit on the number of threads it runs at the same
time, but it's fairly high so we'll ignore it here.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;W.r.t. transgressions committed in the code sample show here,
&lt;tt class="docutils literal"&gt;Thread/sleep&lt;/tt&gt; is a big no-no inside go-blocks. By now I hope that it's
obvious why. &lt;tt class="docutils literal"&gt;timeout&lt;/tt&gt; is the right function for &amp;quot;waiting&amp;quot; inside
go-blocks, since it &amp;quot;parks&amp;quot; the go-block rather than blocking it. Parking
is go-block friendly since it actually frees up the thread the go-block
is running on. Similarly, &lt;tt class="docutils literal"&gt;&amp;gt;!&lt;/tt&gt; is the right channel sending function to
use inside go-blocks; &lt;tt class="docutils literal"&gt;&amp;gt;!!&lt;/tt&gt; blocks the whole thread.&lt;/p&gt;
&lt;p class="last"&gt;This is also a good place to mention that similar thread pool size
&amp;quot;artifacts&amp;quot; &lt;a class="reference external" href="https://www.future-processing.pl/blog/on-problems-with-threads-in-node-js/"&gt;can be found in Node.js&lt;/a&gt;,
which uses &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt; to handle events. &lt;tt class="docutils literal"&gt;libuv&lt;/tt&gt; uses its own thread pool
to execute blocking calls, thus giving the calling application a sense of
concurrency (up to some thread pool size).&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This sample is inspired by &lt;a class="reference external" href="http://martintrojer.github.io/clojure/2013/07/07/coreasync-and-blocking-io"&gt;Martin Trojer's blog post&lt;/a&gt;,
which is the best introduction to the issues with blocking I/O in
go-blocks I found before starting this article.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Why this particular number? The second factor is a large-ish prime, so it
will make the factorizer sweat a bit (by iterating over all the odd numbers
up to its square root); the multiplication by another (prime) factor
ensures more of the paths in the &lt;tt class="docutils literal"&gt;factorize&lt;/tt&gt; function are exercised.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Benchmarking multi-core CPU performance with modern CPUs is notoriously
tricky; CPUs regulate their frequency based on load, so it's entirely
possible that a single core runs faster than each one core in a group of
4; also, hyper-threading reuses some CPU resources within each core so
its speedup is rarely linear.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that &lt;tt class="docutils literal"&gt;pipeline&lt;/tt&gt; spins up go-blocks by default, so the cautions
explored in this article apply. There's also &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pipeline-blocking&lt;/span&gt;&lt;/tt&gt; if you
need blocking operations. Looking at the &lt;a class="reference external" href="https://github.com/clojure/core.async/blob/2afc2dc5102f60713135ffca6fab993fb35809f0/src/main/clojure/clojure/core/async.clj#L475"&gt;implementation if pipeline&lt;/a&gt;
is actually pretty illuminating, and should be easy to understand given
what we discuss here.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category><category term="Programming"></category><category term="Concurrency"></category></entry><entry><title>Reducers, transducers and core.async in Clojure</title><link href="https://eli.thegreenplace.net/2017/reducers-transducers-and-coreasync-in-clojure/" rel="alternate"></link><published>2017-06-07T05:32:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-06-07:/2017/reducers-transducers-and-coreasync-in-clojure/</id><summary type="html">&lt;p&gt;This is a whirlwind tour of some of the cool new features that appeared
in Clojure in the past few years. I find it fascinating how one good idea
(reducers) morphed into another (transducers), and ended up mating with yet
another, apparently unrelated concept (concurrent pipelines) to produce some
really …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is a whirlwind tour of some of the cool new features that appeared
in Clojure in the past few years. I find it fascinating how one good idea
(reducers) morphed into another (transducers), and ended up mating with yet
another, apparently unrelated concept (concurrent pipelines) to produce some
really powerful coding abstractions.&lt;/p&gt;
&lt;p&gt;The article is not for beginners; otherwise it'd take a small book to cover all
this material. Some experience with Clojure or a similar functional language is
required.&lt;/p&gt;
&lt;div class="section" id="sequences-iterators-and-laziness"&gt;
&lt;h2&gt;Sequences, iterators and laziness&lt;/h2&gt;
&lt;p&gt;Let's start with the basics. Suppose we want to iterate over a sequence of
items, performing some combination of transforming and filtering on the
items in it. Here's an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;simplerepl.core/s&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reduce + &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map inc &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="nv"&gt;even?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's very simple, but our imagination and experience tell us that it is
representative of many real data processing pipelines. Mapping, filtering and
reducing is the bread and butter of functional programming, after all. However,
our eternal concern with efficiency should sound the sirens here; it seems like
we take a sequence and pull it through several operations that need the whole
sequence to operate. Are there copies involved? The way the Clojure code is
written above, the answer is &lt;em&gt;no&lt;/em&gt; - because of laziness.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;range&lt;/tt&gt; returns a lazy sequence - a sequence whose members are not really
materialized until we try to use them. Further, Clojure's functional primitives
like map and filter respect laziness by not materializing more than they need
for any given step (sans a bit of chunking/buffering for efficiency).&lt;/p&gt;
&lt;p&gt;In other words, the code above does not create intermediate sequences between
steps. It creates &lt;em&gt;lazy&lt;/em&gt; sequences, which are just thunks holding a function to
materialize the next item.&lt;/p&gt;
&lt;p&gt;Python has iterators for the same purpose. When writing a function to generate a
sequence of items in modern Python, returning a list is discouraged because this
may incur unnecessary copying. Rather, such functions ought to return
&lt;em&gt;iterators&lt;/em&gt; (which is very easy using &lt;tt class="docutils literal"&gt;yield&lt;/tt&gt;). Moreover, functions consuming
sequences should be careful about not materializing the whole sequence but
rather using elementwise iteration (which is the default in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;for...in&lt;/span&gt;&lt;/tt&gt; loops).
Python 3 made this style prevalent by switching &lt;tt class="docutils literal"&gt;range&lt;/tt&gt; to return an iterable;
same for &lt;tt class="docutils literal"&gt;map&lt;/tt&gt;. In Python 2 both &lt;tt class="docutils literal"&gt;range&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; return fully
materialized lists.&lt;/p&gt;
&lt;p&gt;In an imperative programming style, we'd probably have a loop to perform the
operation shown above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's easy to reason about the efficiency of this code, but it's also structured
in a less modular way. A composition of &lt;tt class="docutils literal"&gt;map&lt;/tt&gt;s, &lt;tt class="docutils literal"&gt;filter&lt;/tt&gt;s and reductions
could be easier to reason about because it maps well to the actual business
logic of our application. The imperative implementation does not compose as
well.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reducers"&gt;
&lt;h2&gt;Reducers&lt;/h2&gt;
&lt;img alt="Pipe reducers" class="align-center" src="https://eli.thegreenplace.net/images/2017/reducers.jpg" /&gt;
&lt;p&gt;Alright, so laziness ensures that Clojure code as shown above is not as
inefficient as we may have feared. But still, is it as efficient as an
imperative implementation? It turns out the answer is no; while laziness avoids
large copying costs, it &lt;em&gt;does&lt;/em&gt; incur a constant overhead for boxing and unboxing
thunks representing the rest of the sequence; it would be nice to avoid these
costs as well. This brings us to reducers.&lt;/p&gt;
&lt;p&gt;Expressing data transformation with reducers starts with the observation that
&lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt; is a fundamental building block that can express other
transformations fairly easily. Here's how we can perform the job of a &lt;tt class="docutils literal"&gt;map&lt;/tt&gt;
with &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reduce &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;inc &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;filter&lt;/tt&gt; is only slightly trickier:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reduce &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;even?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is cool, but note something slightly disturbing. This code will work fine
only on collections for which &lt;tt class="docutils literal"&gt;conj&lt;/tt&gt; works well; it will blow up on lists.
Also, we've just spent time talking about &lt;em&gt;not&lt;/em&gt; building temporary collections
in between transformations, but this exactly what this code is doing with that
&lt;tt class="docutils literal"&gt;conj&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;clojure.core.reducers&lt;/tt&gt; library solves both these problems by conceptually
inverting the process of applying multiple transformations to a sequence
inside-out. Reducers are now integrated into Clojure core, but it's worth
spending a few minutes getting an intuitive feel for how they work by
implementing a simplistic variant. For the full scoop, read &lt;a class="reference external" href="https://clojure.org/news/2012/05/15/anatomy-of-reducer"&gt;Rich Hickey's
article&lt;/a&gt;. Here's
an abridged version.&lt;/p&gt;
&lt;p&gt;We start by defining a &amp;quot;reducing function&amp;quot;. A reducing function is what
&lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt; takes - a function accepting an accumulator and a new item, and
returning the new accumulator value. In classical reductions this function can
just be &lt;tt class="docutils literal"&gt;+&lt;/tt&gt;; in the sense of implementing-map-with-a-reduce, it can be as
shown above. In pseudo-type-notation, it's something like &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducingf :: acc -&amp;gt; item -&amp;gt; acc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, let's define the concept of &amp;quot;transforming&amp;quot; a reducing function. This is
simply a function that takes a reducing function and returns another reducing
function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;transformingf :: (acc -&amp;gt; item -&amp;gt; acc) -&amp;gt; (acc -&amp;gt; item -&amp;gt; acc)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main insight is that we can express all kinds of data transformations simply
by transforming a reducing function. In the end we'll end up with a single
reducing function that can be passed to &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Here's another take at representing &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;, this time using the
generalized approach described above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;mapping-transform&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mapf&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;reducingf&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reducingf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;mapf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It may look scary, but it's just an code embodiment of the textual description
above. A call to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt; will create a function that transforms
a reducing function into another reducing function. The actual parameter passed
to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt; is used to modify every item in the collection before
that item is passed to the original reducing function. Here's how we can use
this to compute a sum of squares for a given vector:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;reducers.core=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reduce &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;mapping-transform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mi"&gt;91&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's nothing more magical than some higher-order function munging going on
here. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(mapping-transform&lt;/span&gt; #(* % %))&lt;/tt&gt; returns a function that takes a reducing
function as argument, and returns another reducing function. Since the actual
reduction we want to perform is &lt;tt class="docutils literal"&gt;+&lt;/tt&gt;, this is what we pass in &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. The
returned reducing function is then given to &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;. Take a couple of minutes
to convince yourself how this works. It may help tracing the &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; in the REPL:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (trace-vars +)
#&amp;#39;clojure.core/+
reducers.core=&amp;gt; (reduce ((mapping-transform #(* % %)) +) 0 [1 2 3 4 5 6])
TRACE t8399: (clojure.core/+ 1 4)
TRACE t8399: =&amp;gt; 5
TRACE t8400: (clojure.core/+ 5 9)
TRACE t8400: =&amp;gt; 14
TRACE t8401: (clojure.core/+ 14 16)
TRACE t8401: =&amp;gt; 30
TRACE t8402: (clojure.core/+ 30 25)
TRACE t8402: =&amp;gt; 55
TRACE t8403: (clojure.core/+ 55 36)
TRACE t8403: =&amp;gt; 91
91
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Question: how many times do we process each item in the input vector? Note that
we do &lt;em&gt;two&lt;/em&gt; data transformation operations:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Map the square function &lt;tt class="docutils literal"&gt;#(* % %)&lt;/tt&gt; over each item.&lt;/li&gt;
&lt;li&gt;Sum all squared items together.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, this code only walks over the input sequence &lt;strong&gt;once&lt;/strong&gt;. What happens
here is that, instead of generating a new lazy thunk after each step, we combine
all steps into a single traversal. This combination is achieved via a
composition of functions orchestrated by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt;. We can take this
approach further, and define a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;filtering-transform&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;filtering-transform&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;predicate&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;reducingf&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;predicate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reducingf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's how we sum up the all the even numbers in a vector:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (reduce ((filtering-transform even?) +) 0 [1 2 3 4 5 6])
12
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now it's time to go back to the first example we started the article with. Let's
take all the even numbers in a sequence, increment them and sum them up, using
the higher-order reducing transforms. Here goes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (reduce ((filtering-transform even?)
           #_=&amp;gt;            ((mapping-transform inc) +)) 0 (range 0 10))
25
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember the mention of inverting the transformation process inside-out? The
order of transformations is inverted from the usual Clojure function application
order. We first filter the evens, then increment, then add them all up. The
&amp;quot;standard&amp;quot; Clojure code is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reduce + &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map inc &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="nv"&gt;even?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But we've flipped it with &lt;tt class="docutils literal"&gt;even?&lt;/tt&gt; on the outside and &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; on the inside
(with &lt;tt class="docutils literal"&gt;inc&lt;/tt&gt; still in-between), due to the way our &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;filtering-transform&lt;/span&gt;&lt;/tt&gt; are defined. The order doesn't really matter, and the
actual Clojure reducers library lets us write it in the more expected order, as
we will soon see &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What &lt;em&gt;really&lt;/em&gt; matters is that this approach only walks the input sequence
&lt;em&gt;once&lt;/em&gt;, without any temporary sequences or lazy thunks in the interim. It really
is similar to the imperative-style loop &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="is-it-faster-in-practice"&gt;
&lt;h2&gt;Is it faster in practice?&lt;/h2&gt;
&lt;p&gt;Let's leave this explanatory framework behind and just use
&lt;tt class="docutils literal"&gt;clojure.core.reducers&lt;/tt&gt; that exports its own versions of &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;filter&lt;/tt&gt;, which are designed to be passed to &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;. These functions do
essentially the same thing as the trick explained above, but with a bit more
sophistication so that invoking them looks exactly like invoking the built-in
&lt;tt class="docutils literal"&gt;map&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;filter&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;To use them in the REPL, we'll first &lt;tt class="docutils literal"&gt;require&lt;/tt&gt; the module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (require &amp;#39;[clojure.core.reducers :as r])
nil
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can distinguish between the built-in &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; and the transforming
&lt;tt class="docutils literal"&gt;r/map&lt;/tt&gt;. Here is a benchmark that compares this new way of transforming
collections &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (def s (range 0 9999999))
#&amp;#39;reducers.core/s
reducers.core=&amp;gt; (time (reduce + 0 (map inc (filter even? s))))
&amp;quot;Elapsed time: 599.985027 msecs&amp;quot;
25000000000000
reducers.core=&amp;gt; (time (reduce + 0 (r/map inc (r/filter even? s))))
&amp;quot;Elapsed time: 432.453733 msecs&amp;quot;
25000000000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;reducers&lt;/tt&gt; version is quite a bit faster. As an excercise, try to make the
transforming chain longer by adding several more mapping and filtering steps.
How does it affect the performance difference?&lt;/p&gt;
&lt;p&gt;Great, so we can speed up our data processing with &lt;em&gt;this one weird trick&lt;/em&gt;.
However, if you have some experience in working on compiler backends, you may be
feeling underwhelmed. Isn't this just loop fusion? Indeed, it is. Our original
code had multiple loops going over the same data; but we could just fuse all the
operations done on every element into a single loop. Indeed, this is what the
imperative code in the beginning of the article does.&lt;/p&gt;
&lt;p&gt;I suspect that Clojure is too dynamic and there are too many layers of
abstraction (such as laziness, sequences, etc) to expect a perfect automatic
loop fusion from the JVM here. This is why we resort to fusing the loops
manually; well, not really manually - we actually use some higher-order function
goodness to accomplish this for us. If you squint hard at the
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt; function above, you may notice that it fuses the mapping
function into the reducing function.&lt;/p&gt;
&lt;p&gt;All of this makes me wonder - what if we &lt;em&gt;really&lt;/em&gt; fuse the loops manually, can
we go even faster? It turns out yes, but only for some types of sequences. Let's
start by changing the &lt;tt class="docutils literal"&gt;s&lt;/tt&gt; in the benchmark to a materialized vector (&lt;tt class="docutils literal"&gt;range&lt;/tt&gt;
actually produces a lazy sequence):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (def sv (vec s))
#&amp;#39;reducers.core/sv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now let's re-run the benchmark of regular filter-map-reduce with the
reducers-infused filter-map-reduce:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (time (reduce + 0 (map inc (filter even? sv))))
&amp;quot;Elapsed time: 555.125033 msecs&amp;quot;
25000000000000
reducers.core=&amp;gt; (time (reduce + 0 (r/map inc (r/filter even? sv))))
&amp;quot;Elapsed time: 371.145887 msecs&amp;quot;
25000000000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But now let's add another contender - a manually fused reducing function that
combines the addition, filtering and increment mapping:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (time (reduce (fn [acc item] (if (even? item)
                                               (+ acc (inc item))
                                               acc))
                               0 sv))
&amp;quot;Elapsed time: 324.793784 msecs&amp;quot;
25000000000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hah, even faster! Of course, writing such pipelines manually is not always
practical, isn't composable and quickly gets unreadable, so in most cases using
reducers is preferred. But that's not all. Reducers have another trick in the
sleeve - effortless parallelism.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="folding-in-parallel"&gt;
&lt;h2&gt;Folding in parallel&lt;/h2&gt;
&lt;p&gt;Let's begin this section right with the punchline:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducers.core=&amp;gt; (time (r/fold + (r/map inc (r/filter even? sv))))
&amp;quot;Elapsed time: 145.529636 msecs&amp;quot;
25000000000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whoa, what happened? Given an appropriate collection (such as a vector) that is
&lt;em&gt;foldable&lt;/em&gt;, and an appropriate reducing function that is &lt;em&gt;associative&lt;/em&gt;, we can
actually perform a reduction in parallel on multiple cores. The trick is
breaking the input sequence into chunks, reducing each chunk and then reducing
the results of the chunks. For foldable collections and associative reducing
functions this is mathematically equivalent to the original task; and the big
win is that we can reduce separate chunk in parallel, on different CPU cores.
Which is exactly what &lt;tt class="docutils literal"&gt;r/fold&lt;/tt&gt; does for us, automatically. Even though the
operation done on each item is trivial, &lt;tt class="docutils literal"&gt;r/fold&lt;/tt&gt; generates a 2x speedup on an
8-core CPU. For longer operations, the speedup could be even better.&lt;/p&gt;
&lt;p&gt;How awesome is that? We barely changed the code and get a considerably better
performance, leveraging parallelism. All of this is possible due to the
abstraction created by the reducers library. Remember the part about decoupling
the actual collection from the operations to reduce it? This comes useful here.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="transducers"&gt;
&lt;h2&gt;Transducers&lt;/h2&gt;
&lt;p&gt;Remember our discussion of transforming reducing functions above? A transforming
function (such as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt;) has the pseudo-type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;transformingf :: (acc -&amp;gt; item -&amp;gt; acc) -&amp;gt; (acc -&amp;gt; item -&amp;gt; acc)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It takes a reducing function and returns another reducing function. We've just
seen how this concept is used in the reducers library to decouple the
transformation from the actual process of reduction.&lt;/p&gt;
&lt;p&gt;Shortly after introducing reducers, the designers of Clojure had another
insight. Such transforming functions are useful not just in the context of
reductions. The Clojure core developers were designing utility functions for
&lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; to transform channels (more on this later), and found themselves
rewriting a bunch of existing logic from existing mapping and transforming
functions. The solution? Use the concept of transforming functions to define
sequence transformations in a more abstract way, completely decoupling them from
the underlying sequences.&lt;/p&gt;
&lt;p&gt;So transforming functions got a new name - &lt;em&gt;transducers&lt;/em&gt;, and got integrated
more tightly into the language. Now many of the built-in sequence processing
like &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; have an additional arity where no sequence is actually passed in.
&lt;tt class="docutils literal"&gt;(map inc)&lt;/tt&gt;, for example, simply returns a &lt;em&gt;transducer&lt;/em&gt; - a transforming
function for other reducers. These transducers are composable, so another way
to write the non-parallel reduction we've been using in the benchmarks is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reduce &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;comp &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="nv"&gt;even?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;sv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the order here is similar to the one we had to apply with our own
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;filtering-transform&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt;, to convey that we first
filter and then map (it's also similar to the Clojure &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt;&lt;/tt&gt; macro).&lt;/p&gt;
&lt;p&gt;Aimed with the insights of this article, we can actually look under the hood
of Clojure's built-in &lt;tt class="docutils literal"&gt;map&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;map&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;rf&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rf&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;inputs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;inputs&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;;; Implementation of other, non-transducer arities.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;;; ...&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To be a true transducer, a Clojure function must have three arities. I'll skip
the no-argument and single-argument versions (please read a more comprehensive
reference on transducers for the full scoop). The 2-arity version is where the
real meat is and, oh wait, it's &lt;em&gt;exactly&lt;/em&gt; the same as our &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;mapping-transform&lt;/span&gt;&lt;/tt&gt;
from this article!&lt;/p&gt;
&lt;p&gt;So OK, now &amp;quot;functions that transform reducing functions&amp;quot; have a shorter name -
&lt;em&gt;transducers&lt;/em&gt;; but what has actually changed?&lt;/p&gt;
&lt;p&gt;What's really changed is that the &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; transducer has a wider range of
applicability than just mapping collections. Its implementation has no
collection-specific code. Let's see how it can be used to transform
communication channels.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pipelines-and-transducers"&gt;
&lt;h2&gt;Pipelines and transducers&lt;/h2&gt;
&lt;p&gt;Clojure has borrowed go-routines and channels from Go, and placed them in a
standard libray module named &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;. Unfortunately, a thorough
discussion of &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; is outside the scope of this article. I'll just say
that &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; is awesome; that it was implemented as a library without
changing the language is beyond awesome - it's a terrific example of the power
of Lisps to &lt;em&gt;grow the language&lt;/em&gt; towards the problem domain.&lt;/p&gt;
&lt;p&gt;That said, I do want to mention &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; in the context of transducers,
since the two mix in an interesting way.&lt;/p&gt;
&lt;p&gt;Let's take the simple squaring pipeline from &lt;a class="reference external" href="https://blog.golang.org/pipelines"&gt;Go concurrency patterns&lt;/a&gt; and rewrite it in Clojure. The first
version is a pretty-much verbatim transcription:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;gen-1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;doseq &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/close!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;sq-1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go-loop&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;do&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;gt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/close!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;main-1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c-gen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gen-1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sq-1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-gen&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are two pipeline stages; the first, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gen-1&lt;/span&gt;&lt;/tt&gt; generates a sequence of
numbers into a channel. The second, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;sq-1&lt;/span&gt;&lt;/tt&gt; takes a channel of inputs,
transforms them (by squaring each number) and puts the results in another
channel. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;main-1&lt;/span&gt;&lt;/tt&gt; connects the two pipeline stages together.&lt;/p&gt;
&lt;p&gt;The second version makes more use of higher-level &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; tools:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;gen-2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/to-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;sq-2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/map&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;main-2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c-gen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gen-2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sq-2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-gen&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;gen-2&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;to-chan&lt;/span&gt;&lt;/tt&gt; places its input collection into a channel, and closes
the channel; all of this in a separate go-block, of course. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;sq-2&lt;/span&gt;&lt;/tt&gt; uses the
&lt;tt class="docutils literal"&gt;map&amp;lt;&lt;/tt&gt; function to create a mapping channel which takes items from its input
channel, maps some function on them and returns a channel of results.&lt;/p&gt;
&lt;p&gt;If you read the documentation of &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt;, you'll notice that &lt;tt class="docutils literal"&gt;map&amp;lt;&lt;/tt&gt; is
now deprecated and you're advised to &amp;quot;use transducers instead&amp;quot;. Let's see how to
do that, in this third version:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;main-3&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c-sq&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we create a &lt;em&gt;single&lt;/em&gt; channel named &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;c-sq&lt;/span&gt;&lt;/tt&gt;, with a mapping transducer.
This means that every item going through the channel gets transformed with the
given mapping function before being read out of the channel. We don't need
a separate channel, and &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; doesn't need a separate mapping helper.&lt;/p&gt;
&lt;p&gt;In fact, with the introduction of transducers &lt;tt class="docutils literal"&gt;core.async&lt;/tt&gt; deprecated a whole
bunch of functions. &lt;tt class="docutils literal"&gt;map&amp;lt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;filter&amp;lt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;unique&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;partition&lt;/tt&gt; and so on.
While implementing these for channels, the Clojure core devs had the epiphany
that they're basically reimplementing all sequence processing functions in a
different context &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt;. Transducers is an elegant solution to abstract away the
concept of transformation from the underlying context (be it collections or
channels, or...)&lt;/p&gt;
&lt;p&gt;It's easy to compose transducers on channels. Here's a silly example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;square&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;xform&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;comp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="nv"&gt;even?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;square&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;xform&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/onto-chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async/&amp;lt;!!&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here the transducer is more complex, applying several filtering and mapping
steps on the items going through the channel. That said, as we've seen earlier
in the article this is actually pretty efficient, with no unnecessary copying
involved.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="closing-thoughts-on-the-generality-of-reducing-functions"&gt;
&lt;h2&gt;Closing thoughts - on the generality of reducing functions&lt;/h2&gt;
&lt;p&gt;It's interesting to ponder how reducing functions, from the humble beginning of
the workhorse of &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;, became the most important building block of the
concepts discussed in this article. Recall that a reducing function has the
type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reducingf :: acc -&amp;gt; item -&amp;gt; acc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I think the key insight is that taking and returning the new combined value
permits a reducing function to implement things like filtering, because we can
convey the concept of including or not including the current item in the
combined result. Clojure's reductions also support the &lt;tt class="docutils literal"&gt;reduced&lt;/tt&gt; call for
early termination, and keeping state between reductions can help implement more
involved processing steps. For a fairly complete example of all these tools,
take a look at the implementation of the transducer variant of &lt;tt class="docutils literal"&gt;take&lt;/tt&gt; in the
&lt;a class="reference external" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj"&gt;Clojure core library sources&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The code snippets shown throughout the article are &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2017/reducers-transducers-async"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is a Haskell-y type notation. &lt;tt class="docutils literal"&gt;x &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; y &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; z&lt;/tt&gt; means a function
taking a parameter of type &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; and a parameter of type &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; and
returning a value of type &lt;tt class="docutils literal"&gt;z&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;(x &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; y) &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; z&lt;/tt&gt; means we take one
parameter of type &amp;quot;function taking &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; and returning &lt;tt class="docutils literal"&gt;y&lt;/tt&gt;) and
return a value of type &lt;tt class="docutils literal"&gt;z&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Execrise: modify this code to produce a new vector of squares, instead
of summing them up. Your solution will still use &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The actual &lt;a class="reference external" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj"&gt;reducers library&lt;/a&gt;
cleverly uses Clojure protocols to make this process even more abstract
and let sequences decide the best way to reduce them. It's worth checking
out, though there's quite a bit of added complexity that obscures away
the main point I want to make in this article.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;We have to give up laziness though, since Clojure's &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt; is
inherently &lt;em&gt;eager&lt;/em&gt;. It implements left-folding rather than right-folding,
so it can't be run on infinite sequences.&lt;/p&gt;
&lt;p class="last"&gt;This is usually not a very big deal; while infinite sequences are a nice
abstraction in some cases, most of the real data processing tasks we have
are, luckily, finite.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Benchmarking in Clojure is tricky since the JVM needs some warmup for the
heavy-handed JIT to kick-in, so it's worth rerunning such benchmarks
several times and collecting the fastest runtime. The numbers shown here
are representative of the results obtained on my machine.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There's a small caveat here to be aware of, IMHO. Pipelines as
demonstrated in the Go article linked here aren't only useful to decouple
the different steps. They are also useful to actually &lt;em&gt;parallelize&lt;/em&gt; them.
Squaring is a toy example, but imagine this step in the pipeline was time
consuming. Then the go-routines running the generating step (or some
other pipeline step) could actually run in parallel with the squaring
step. When we use transducers as shown here, this flexibility goes away.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Programming"></category><category term="Concurrency"></category></entry><entry><title>Notes on debugging Clojure code</title><link href="https://eli.thegreenplace.net/2017/notes-on-debugging-clojure-code/" rel="alternate"></link><published>2017-05-23T20:02:00-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-05-23:/2017/notes-on-debugging-clojure-code/</id><summary type="html">&lt;p&gt;Clojure is a great programming language, but a recurring complaint one keeps
hearing from developers hacking on Clojure code is that debugging can be
unpleasant. First of all, I agree! Debugging Clojure code &lt;em&gt;can&lt;/em&gt; be more daunting
on average than, say, debugging Python code. This is mainly due to two …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Clojure is a great programming language, but a recurring complaint one keeps
hearing from developers hacking on Clojure code is that debugging can be
unpleasant. First of all, I agree! Debugging Clojure code &lt;em&gt;can&lt;/em&gt; be more daunting
on average than, say, debugging Python code. This is mainly due to two reasons:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Clojure's Java legacy. Clojure is compiled to Java bytecode, which has some
terminology and idiosyncracies Clojure programmers aren't always familiar
with. These terms tend to pop up in stack traces and cause confusion (e.g.
&lt;tt class="docutils literal"&gt;IFN&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;Clojure - being a Lisp - has a certain code structure which is different
from, say, a more common imperative coding style. Rather than being a
sequence of statements, Clojure programs tend to involve long call chains of
nested expressions. Where only part of an expression fails, it's often
non-trivial to figure out why.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this post I want to share some notes from my own experience debugging Clojure
programs.&lt;/p&gt;
&lt;div class="section" id="dealing-with-clojure-s-cryptic-exceptions"&gt;
&lt;h2&gt;Dealing with Clojure's cryptic exceptions&lt;/h2&gt;
&lt;p&gt;The first problem with Clojure's runtime exceptions is that we usually don't get
to see the full stack trace &lt;em&gt;by default&lt;/em&gt;. Let's say we have this silly,
nonsensical, function in a file called &lt;tt class="docutils literal"&gt;sample.clj&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then to try how it works, we load the file into the REPL and type the following
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (foo 24)
IllegalArgumentException Don&amp;#39;t know how to create ISeq from: java.lang.Long
  clojure.lang.RT.seqFrom (RT.java:542)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Uh oh. There are two problems here. First, what does this error message mean?
What's &lt;tt class="docutils literal"&gt;ISeq&lt;/tt&gt; and what's &lt;tt class="docutils literal"&gt;java.lang.Long&lt;/tt&gt;? Second, it's not clear where it
is actually failing (thanks for that pointer to &lt;tt class="docutils literal"&gt;RT.java&lt;/tt&gt; though, Clojure!)
Let's address the second problem first. The magic incantation to show the stack
trace of the last exception is calling the &lt;tt class="docutils literal"&gt;pst&lt;/tt&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (pst)
IllegalArgumentException Don&amp;#39;t know how to create ISeq from: java.lang.Long
  clojure.lang.RT.seqFrom (RT.java:542)
  clojure.lang.RT.seq (RT.java:523)
  clojure.lang.RT.first (RT.java:668)
  clojure.core/first--4339 (core.clj:55)
  clojure.core/first--4339 (core.clj:55)
  debugging.sample/foo (sample.clj:10)
  debugging.sample/foo (sample.clj:7)
  debugging.core/eval13715 (form-init6539101589609174055.clj:1)
  debugging.core/eval13715 (form-init6539101589609174055.clj:1)
  clojure.lang.Compiler.eval (Compiler.java:6927)
  clojure.lang.Compiler.eval (Compiler.java:6890)
  clojure.core/eval (core.clj:3105)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is much better because at least &lt;em&gt;some&lt;/em&gt; files in this trace are familiar.
&lt;tt class="docutils literal"&gt;core.clj&lt;/tt&gt; is not &lt;em&gt;our&lt;/em&gt; &lt;tt class="docutils literal"&gt;core.clj&lt;/tt&gt;, it's Clojure's core library. But
&lt;tt class="docutils literal"&gt;sample.clj&lt;/tt&gt; &lt;em&gt;is&lt;/em&gt; our file, and we can infer that on line 10 we call
&lt;tt class="docutils literal"&gt;clojure,core/first&lt;/tt&gt; and something goes wrong. Line 10 happens to be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now things become more clear. The call &lt;tt class="docutils literal"&gt;(first n)&lt;/tt&gt; must be bad, and bad in
a way that tries to coerce clojure into creating an &lt;tt class="docutils literal"&gt;ISeq&lt;/tt&gt; from a &lt;tt class="docutils literal"&gt;Long&lt;/tt&gt;.
In other words, we're passing a number into a function that expects a sequence,
and this is, indeed, bad. Learning to map from Clojure values and types to the
JVM's expectations will take time and grit - especially if you (like me) don't
have much Java experience. I suggest doing a bit of reading on Clojure/Java
interoperability, and about other Java-isms Clojure inherits; it ain't pretty,
and you may not always want to use it, but being familiar with the terms can go
a long way in deciphering cryptic stack traces.&lt;/p&gt;
&lt;p&gt;For a more detailed treatment of this debugging issue I highly recommend
&lt;a class="reference external" href="https://aphyr.com/posts/319-clojure-from-the-ground-up-debugging"&gt;Aphyr's article on debugging Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="finding-which-form-an-exception-comes-from"&gt;
&lt;h2&gt;Finding which form an exception comes from&lt;/h2&gt;
&lt;p&gt;Let's invoke the &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; function in a different way that demonstrates another
issue with debugging Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (foo nil)

NullPointerException   clojure.lang.Numbers.ops (Numbers.java:1013)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK, we know what to do next:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (pst)
NullPointerException
  clojure.lang.Numbers.ops (Numbers.java:1013)
  clojure.lang.Numbers.gt (Numbers.java:229)
  clojure.lang.Numbers.gt (Numbers.java:3864)
  debugging.sample/foo (sample.clj:9)
  debugging.sample/foo (sample.clj:7)
  debugging.core/eval14693 (form-init6539101589609174055.clj:1)
  debugging.core/eval14693 (form-init6539101589609174055.clj:1)
  clojure.lang.Compiler.eval (Compiler.java:6927)
  clojure.lang.Compiler.eval (Compiler.java:6890)
  clojure.core/eval (core.clj:3105)
  clojure.core/eval (core.clj:3101)
  clojure.main/repl/read-eval-print--7408/fn--7411 (main.clj:240)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the exception comes from line 9, which is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This exception also tells us it comes from &lt;tt class="docutils literal"&gt;clojure.lang.Numbers.gt&lt;/tt&gt; from
which we can infer it's the &lt;tt class="docutils literal"&gt;&amp;gt;&lt;/tt&gt; operator that is complaining. But imagine for
a second that we had two forms with the same operator on that line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we got a &lt;tt class="docutils literal"&gt;NullPointerException&lt;/tt&gt; about an addition, we wouldn't know which
one fails. Luckily, Clojure comes with a very useful module that helps
debugging - &lt;a class="reference external" href="https://github.com/clojure/tools.trace"&gt;tools.trace&lt;/a&gt;. In this
particular case, we'd use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt; macro  which tells us which
nested form (expression) is failing. We can modify our function to be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;trace-forms&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now when called with &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;, we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (foo nil)
NullPointerException : No message attached to throwable java.lang.NullPointerException
  Form failed: (&amp;gt; n 40)
  Form failed: (if
 (&amp;gt; n 40)
 (+ n 20)
 (clojure.core/cond (&amp;gt; n 20) (- (first n) 20) :else 0))
  Form failed: (cond (&amp;gt; n 40) (+ n 20) (&amp;gt; n 20) (- (first n) 20) :else 0)
  clojure.lang.Numbers.ops (Numbers.java:1013)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat, huh? &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt; breaks the form it traces to all the nested forms
and reports precisely which one failed - propagating this information upwards
towards the top form &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt; is &lt;em&gt;very&lt;/em&gt; useful when errors manifest
as exceptions.&lt;/p&gt;
&lt;p&gt;Unfortunately, this isn't sufficient for all cases. Our &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; wasn't designed
to handle &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;s, and the bug here is in the place where the &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; came
from. This may be quite a bit removed - and not on the same stack trace - from
where &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is invoked. We'll get an exception when &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is called, but the
&lt;em&gt;real&lt;/em&gt; challenge is to find where the &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; came from. More generally, bugs
that manifest as thrown exceptions are the easier kind of bugs. The more
insidious bugs hide in programs that run just fine end-to-end but compute
slightly incorrect results.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tracing-and-logging"&gt;
&lt;h2&gt;Tracing and logging&lt;/h2&gt;
&lt;p&gt;This gets us into the more general domain of debugging, where the tricks and
tools programmers use are as varied as the bugs hiding in our programs. When it
comes to debugging, I'm firmly in the &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; camp; I rarely prefer debuggers
over &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt;-based debugging &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;, and Clojure is no exception. In fact, due
to the way Clojure programs look (nested forms), I find that debuggers are even
less useful in Clojure than in other languages. On the other hand, Clojure's
macros make it possible to trace / print stuff in a very nice way.&lt;/p&gt;
&lt;p&gt;For example, I find that it's useful to be able to turn debugging printouts on
and off frequently. So I have this trusty code in my utilities:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="ss"&gt;:dynamic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;*verbose*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;printfv&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;fmt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;*verbose*&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;fmt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="nv"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Calls to &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt; can be freely scattered around the code; by default,
they will not print anything. When I do want to see what these &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt;s
have to say, another macro comes useful:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;with-verbose&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;binding &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;*verbose*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's how it works; Suppose we've written this factorial function, with a
debugging printout:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;printfv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;factorial: %d%n&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, if we just call it as usual from the REPL, we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (factorial 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But if we want to actually see the debugging output, we call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (with-verbose (factorial 6))
factorial: 6
factorial: 5
factorial: 4
factorial: 3
factorial: 2
factorial: 1
factorial: 0
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This optional verbosity is perfect when you're in the middle of a furious bug
hunt, adding &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt;s in many places in your code. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;with-verbose&lt;/span&gt;&lt;/tt&gt; can
turn verbose logging on selectively and control the amount of debugging spew
&lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This example brings us back to the &lt;tt class="docutils literal"&gt;tools.trace&lt;/tt&gt; library, which provides
another awesome tool that helps trace function calls (the bread and butter of
Clojure programs). Enter &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-vars&lt;/span&gt;&lt;/tt&gt;. After importing it, all we need to do
is invoke it on any functions we want traced; for example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (trace-vars factorial)
#&amp;#39;debugging.core/factorial
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now invoking our &lt;tt class="docutils literal"&gt;factorial&lt;/tt&gt; produces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (factorial 6)
TRACE t16315: (debugging.core/factorial 6)
TRACE t16316: | (debugging.core/factorial 5)
TRACE t16317: | | (debugging.core/factorial 4)
TRACE t16318: | | | (debugging.core/factorial 3)
TRACE t16319: | | | | (debugging.core/factorial 2)
TRACE t16320: | | | | | (debugging.core/factorial 1)
TRACE t16321: | | | | | | (debugging.core/factorial 0)
TRACE t16321: | | | | | | =&amp;gt; 1
TRACE t16320: | | | | | =&amp;gt; 1
TRACE t16319: | | | | =&amp;gt; 2
TRACE t16318: | | | =&amp;gt; 6
TRACE t16317: | | =&amp;gt; 24
TRACE t16316: | =&amp;gt; 120
TRACE t16315: =&amp;gt; 720
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get to see the full call tree, including values of parameters and what each
call returns. It even works for mutually-recursive functions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;iseven?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;isodd?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;isodd?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;iseven?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's try it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (trace-vars iseven? isodd?)
#&amp;#39;debugging.core/isodd?
debugging.core=&amp;gt; (iseven? 7)
TRACE t16332: (debugging.core/iseven? 7)
TRACE t16333: | (debugging.core/isodd? 6)
TRACE t16334: | | (debugging.core/iseven? 5)
TRACE t16335: | | | (debugging.core/isodd? 4)
TRACE t16336: | | | | (debugging.core/iseven? 3)
TRACE t16337: | | | | | (debugging.core/isodd? 2)
TRACE t16338: | | | | | | (debugging.core/iseven? 1)
TRACE t16339: | | | | | | | (debugging.core/isodd? 0)
TRACE t16339: | | | | | | | =&amp;gt; false
TRACE t16338: | | | | | | =&amp;gt; false
TRACE t16337: | | | | | =&amp;gt; false
TRACE t16336: | | | | =&amp;gt; false
TRACE t16335: | | | =&amp;gt; false
TRACE t16334: | | =&amp;gt; false
TRACE t16333: | =&amp;gt; false
TRACE t16332: =&amp;gt; false
false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how easy it to see what calls what. Quite often, bugs are uncovered simply
by carefully studying the chain of function calls some input tickles in our
code, and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-vars&lt;/span&gt;&lt;/tt&gt; is a very low-effort method to enable this kind of
debugging.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="deeper-tracing-inside-cond-forms"&gt;
&lt;h2&gt;Deeper tracing inside &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; forms&lt;/h2&gt;
&lt;p&gt;Tracing function calls is great, but sometimes insufficient. It's not uncommon
to have &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; forms in functions, and sometimes it's pretty hard to know
which condition was actually &amp;quot;taken&amp;quot; (this isn't always easy to infer from the
return value of the function). We've seen how to explore where exceptions come
from with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-forms&lt;/span&gt;&lt;/tt&gt;, but exceptions are just one kind of problem. The more
difficul problem arises when the code throws no exceptions but still produces a
wrong value.&lt;/p&gt;
&lt;p&gt;I've mentioned how Clojure's macro superpowers let us write very powerful
debugging tools. What follows is another example.&lt;/p&gt;
&lt;p&gt;Consider this toy code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It happens to return 10 since the second condition fires. But suppose it stands
for a much more complicated &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; where it's not obvious which condition was
taken and where the return value came from. How do we go about debugging this?&lt;/p&gt;
&lt;p&gt;Well, we can always add a &lt;tt class="docutils literal"&gt;printfv&lt;/tt&gt; into every result expression (possibly
wrapping in a &lt;tt class="docutils literal"&gt;do&lt;/tt&gt; form) and see what fires. This would work, but it's quite
tiresome, especially for large &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt;s. To do this automatically, we can
write the following macro:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;condv&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;if&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;next &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condv &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;second &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;throw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;IllegalArgumentException.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cond requires an even number of forms&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;condv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;next &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;next &lt;/span&gt;&lt;span class="nv"&gt;clauses&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It behaves just like &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt;, while also printing out the condition that fired.
If we replace the &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; in the original example with &lt;tt class="docutils literal"&gt;condv&lt;/tt&gt; and evaluate
it, we'll get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debugging.core=&amp;gt; (condv (&amp;gt; 10 20) (+ 10 20)
            #_=&amp;gt;        (&amp;gt; 20 10) (- 20 10)
            #_=&amp;gt;        :else 200)
condv (&amp;gt; 20 10)
10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the printout before the return value of 10: &lt;tt class="docutils literal"&gt;condv (&amp;gt; 20 10)&lt;/tt&gt; - it shows
us exactly which condition was taken.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;While beginning Clojure programmers may find the debugging experience
challenging, I believe that with some effort and perseverance it's possible to
get used to the unusual environment and even reach new levels of productivity
by developing a set of debugging tools and techniques.&lt;/p&gt;
&lt;p&gt;In this endeavor, Clojure's macro capabilities are an extremely powerful ally.
Coupled with a fast edit-rerun cycle in the REPL, such tools can turn Clojure
debugging into a much less painful activity.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Alternatively, we can evaluate the same expression somewhere in our
editor using a Clojure plugin (such as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;vim-fireplace&lt;/span&gt;&lt;/tt&gt; for Vim).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The astute reader will notice a slight discrepancy between our code and
the output of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;trace-form&lt;/span&gt;&lt;/tt&gt;. We don't have an &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; form, or do we?
Quiz: what does &lt;tt class="docutils literal"&gt;cond&lt;/tt&gt; expand to? Complex interactions between macros
and functions is yet another reason debugging Clojure code is sometimes
hard...&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In my professional life I spent far more time writing debuggers than
actually using them.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This method is only recommended when the debugging prinouts are destined
to be eventually eliminated from the code. For more permanent logging
with more verbosity controls, consider using a proper logging library
like &lt;a class="reference external" href="https://github.com/clojure/tools.logging"&gt;tools.logging&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category></entry><entry><title>On Recursion, Continuations and Trampolines</title><link href="https://eli.thegreenplace.net/2017/on-recursion-continuations-and-trampolines/" rel="alternate"></link><published>2017-04-11T05:50:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-04-11:/2017/on-recursion-continuations-and-trampolines/</id><summary type="html">&lt;p&gt;How is tail recursion different from regular recursion? What do continuations
have to do with this, what is CPS, and how do trampolines help? This article
provides an introduction, with code samples in Python and Clojure.&lt;/p&gt;
&lt;div class="section" id="recursion-and-tail-recursion"&gt;
&lt;h2&gt;Recursion and Tail Recursion&lt;/h2&gt;
&lt;p&gt;Here's a textbook version of a recursive factorial implementation in …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;How is tail recursion different from regular recursion? What do continuations
have to do with this, what is CPS, and how do trampolines help? This article
provides an introduction, with code samples in Python and Clojure.&lt;/p&gt;
&lt;div class="section" id="recursion-and-tail-recursion"&gt;
&lt;h2&gt;Recursion and Tail Recursion&lt;/h2&gt;
&lt;p&gt;Here's a textbook version of a recursive factorial implementation in Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fact_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Tail&lt;/em&gt; recursion is when the recursive call happens in &lt;em&gt;tail position&lt;/em&gt;, meaning
that it is the last thing the function does before returning its own result.
Here's a tail-recursive version of factorial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact_tailrec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fact_tailrec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The tail call doesn't have to be directly recursive. It can call another
function as well, implementing mutual recursion or some more complex scheme.
Here's a canonical example of mutual recursion - a silly way to tell whether a
number is odd or even:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_even&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;is_odd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_odd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;is_even&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the function calls here are in tail position.&lt;/p&gt;
&lt;p&gt;Both these examples are simple in a way, because they only contain a single
call within each function. When functions make multiple calls, things become
more challenging. Computing the Fibonacci sequence is a good example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we have two recursive calls to &lt;tt class="docutils literal"&gt;fib_rec&lt;/tt&gt; within itself. Converting this
function to a tail-call variant will be more challenging. How about this
attempt:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib_almost_tail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="n"&gt;prev2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fib_almost_tail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib_almost_tail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prev2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The last thing &lt;tt class="docutils literal"&gt;fib_almost_tail&lt;/tt&gt; does is call itself; so is this function
tail-recursive? No, because there's another call to &lt;tt class="docutils literal"&gt;fib_almost_tail&lt;/tt&gt;, and
that one is &lt;em&gt;not&lt;/em&gt; in tail position. Here's a more thorough attempt:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib_tail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accum1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accum2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;accum1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib_tail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accum1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;accum2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accum1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this conversion wasn't as simple as for the factorial; it's much less
obvious how to come up with the algorithm, and we even changed the number of
calls - there's only one recursive call here, while the original &lt;tt class="docutils literal"&gt;fib_rec&lt;/tt&gt; had
two. Obviously, it's challenging to have no calls outside a tail position in a
function that calls multiple functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="blowing-up-the-stack"&gt;
&lt;h2&gt;Blowing up the stack&lt;/h2&gt;
&lt;p&gt;Recursive solutions tend to be succinct and elegant; however, they carry a
dangerous burden - the possibility of blowing up the runtime stack. In Python
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;, the &lt;a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.getrecursionlimit"&gt;default call stack depth&lt;/a&gt; is 1000. If
we try the &lt;tt class="docutils literal"&gt;fact_rec&lt;/tt&gt; function shown above in a terminal, we'll get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; fact_rec(900)
... some uselessly huge number

&amp;gt;&amp;gt;&amp;gt; fact_rec(1000)
... spew ...
RecursionError: maximum recursion depth exceeded in comparison
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You may say - who needs to compute a factorial of 1000? And that may be true;
however, with multiple recursion the problems start much earlier. If you try to
compute the 50th Fibonacci number using &lt;tt class="docutils literal"&gt;fib_rec&lt;/tt&gt; as shown above, you'll end
up waiting for a &lt;em&gt;very&lt;/em&gt; long time, even though the request seems modest at first
glance. The reason is the &lt;a class="reference external" href="http://stackoverflow.com/questions/7547133/why-is-the-complexity-of-computing-the-fibonacci-series-2n-and-not-n2"&gt;exponential complexity of the naive implementation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that &lt;tt class="docutils literal"&gt;fib_tail&lt;/tt&gt; doesn't suffer from this problem because there's no
exponential tree of calls, but it will also happily blow the stack when run with
a sufficiently large number. The same is true for &lt;tt class="docutils literal"&gt;fact_tail&lt;/tt&gt;, by the way.
Tail recursion itself doesn't solve the stack issue; another ingredient is
required and we'll cover it shortly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="solutions-tco-or-manual-conversion-to-iteration"&gt;
&lt;h2&gt;Solutions: TCO or manual conversion to iteration&lt;/h2&gt;
&lt;p&gt;The problems described in the previous section help motivate the discussion of
tail calls. Why convert to tail calls at all? Because then, in some languages,
the compiler can automatically elide the stack buildup by converting the tail
call to a jump. This trick is called &lt;em&gt;tail-call optimization&lt;/em&gt; (TCO) &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. Scheme
has been doing it since the 1970s - indeed, since Scheme encourages programmers
to write recursive algorithms, TCO is at the core of the language. More modern
languages are catching up too - Lua supports TCO and JavaScript will too, once
ES6 becomes the de-facto universal version.&lt;/p&gt;
&lt;p&gt;Some languages do not support TCO, however. Python is one of those - Guido
explicitly states that &lt;a class="reference external" href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html"&gt;TCO is unpythonic&lt;/a&gt; and
he doesn't want it in the language. In the end of this post I'll explain why I
think it's not a big deal for Python. For other languages, it's a much bigger
problem.&lt;/p&gt;
&lt;p&gt;Take Clojure for example. Since Clojure is built on top of the JVM, it has to
use JVM semantics for calls (if it wants any speed at all). The JVM doesn't have
full support for TCO; so Clojure - a Lisp, mind you - ends up without TCO &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;
Clojure takes a pragmatic approach and faces this problem with valor - it
encourages a manual TCO conversion using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;loop...recur&lt;/span&gt;&lt;/tt&gt; pair:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;fib_iterative&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="nv"&gt;accum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="nv"&gt;accum2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nv"&gt;accum1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;accum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;accum2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;accum1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the similarity between this code and the Python &lt;tt class="docutils literal"&gt;fib_tail&lt;/tt&gt; shown
earlier. This is not a coincidence! Once the algorithm is expressed in tail
form, it's pretty easy to convert it to an iteration pattern manually; if it
wasn't easy, compilers wouldn't be able to do it automatically for the past 40
years!&lt;/p&gt;
&lt;p&gt;Just as a point of reference, here's &lt;tt class="docutils literal"&gt;fib_iterative&lt;/tt&gt; in Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib_iterative&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;accum1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accum2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;accum1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accum2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;accum1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;accum2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accum1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;accum1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only slightly more awkward than the Clojure version - but it's essentially the
same approach. Since the tail call carries the whole state around in arguments,
we just imitate this using an explicit loop and state variables.&lt;/p&gt;
&lt;p&gt;The iterative solution is what we &lt;em&gt;really&lt;/em&gt; want here - it avoids the exponential
algorithm &lt;em&gt;and&lt;/em&gt; the stack explosion. It also doesn't incur the costs of a
function call and return for every iteration. The only problem is that we have
to do this manually in languages that don't support TCO. The beauty of automatic
TCO is that you can write your algorithm recursively, and get the performance &amp;amp;
runtime characteristics of an iterative solution.&lt;/p&gt;
&lt;p&gt;At this point you may wonder how to convert indirect / mutual recursion to an
iterative pattern - for example the even / odd pair above. While this doesn't
present a problem for the compiler &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;, to do it manually is indeed more
challenging. We'll be covering this topic later in the article when we get to
trampolines.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="more-realistic-examples"&gt;
&lt;h2&gt;More realistic examples&lt;/h2&gt;
&lt;p&gt;Before we get to the more advanced topics, I'd like to present a few more
realistic functions with an elegant recursive formulation that would be
challenging to rewrite iteratively.&lt;/p&gt;
&lt;p&gt;Let's start with merge sorting. Here's a straightforward Python implementation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;merge_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;merge_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="n"&gt;merge_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;:]))&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lst2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Merges two sorted lists into a single sorted list.&lt;/span&gt;

&lt;span class="sd"&gt;    Returns new list. lst1 and lst2 are destroyed in the process.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;lst1&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;lst2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;lst1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lst2&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;lst2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lst1&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;lst1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;lst2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
            &lt;span class="c1"&gt;# Note: pop(0) may be slow -- this isn&amp;#39;t optimized code.&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a way, merge sort always reminds me of &lt;em&gt;postorder&lt;/em&gt; tree traversal - we
recurse to the left, then recurse to the right, then combine the results. Such
algorithms are fairly tricky to convert to non-recursive code. Try it! Chances
are you'll end up emulating a stack, or coming up with an &lt;a class="reference external" href="http://stackoverflow.com/questions/1557894/non-recursive-merge-sort"&gt;entirely different
algorithm&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Merge sort is an example of multiple recursion, which as we've seen even for the
simple Fibonacci, presents a challenge for TCO. Another common problem is
indirect recursion. We've seen the trivial case of even / odd. For something
more realistic consider a recursive-descent parser for this grammar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;expr&amp;gt;    : &amp;lt;term&amp;gt; + &amp;lt;expr&amp;gt;
            &amp;lt;term&amp;gt;
&amp;lt;term&amp;gt;    : &amp;lt;factor&amp;gt; * &amp;lt;factor&amp;gt;
            &amp;lt;factor&amp;gt;
&amp;lt;factor&amp;gt;  : &amp;lt;number&amp;gt;
          | &amp;#39;(&amp;#39; &amp;lt;expr&amp;gt; &amp;#39;)&amp;#39;
&amp;lt;number&amp;gt;  : \d+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The full Python code is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/rdparser.py"&gt;here&lt;/a&gt;;
&lt;tt class="docutils literal"&gt;parse_expr&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;parse_term&lt;/tt&gt;; &lt;tt class="docutils literal"&gt;parse_term&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;parse_factor&lt;/tt&gt;;
&lt;tt class="docutils literal"&gt;parse_factor&lt;/tt&gt;, in term, calls &lt;tt class="docutils literal"&gt;parse_expr&lt;/tt&gt;. For a complex expression, the
call stack will end up containing multiple instances of each function, and at
least in theory it's unbounded.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="continuations-and-cps"&gt;
&lt;h2&gt;Continuations and CPS&lt;/h2&gt;
&lt;p&gt;Continuations are a cool concept in computer science, hailing from the earliest
days of functional programming. There's tons of information online about
continuations; my modest attempt to explain them here is just the beginning! If
this looks interesting, make sure to google for more information.&lt;/p&gt;
&lt;p&gt;Consider the following expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;2 * (3 + 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One way to reason about its evaluation is:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Compute &lt;tt class="docutils literal"&gt;value = 3 + 4&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Then compute &lt;tt class="docutils literal"&gt;2 * value&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can view &lt;tt class="docutils literal"&gt;2 * value&lt;/tt&gt; to be the &lt;em&gt;continuation&lt;/em&gt; of &lt;tt class="docutils literal"&gt;value = 3 + 4&lt;/tt&gt;.
Similarly, if the expression above is part of the bigger expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;2 * (3 + 4) + 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can say that &lt;tt class="docutils literal"&gt;value + 100&lt;/tt&gt; is the continuation of &lt;tt class="docutils literal"&gt;2 * (3 + 4)&lt;/tt&gt;. This may
seem a bit abstract, so let's convert it to Lisp-y syntax &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt; to bring it back
to the domain of programming. Here is one way to compute &lt;tt class="docutils literal"&gt;2 * (3 + 4)&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can call &lt;tt class="docutils literal"&gt;(expr)&lt;/tt&gt; and get 14 back. Another way to express the same
computation is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;end-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;print &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;apply-cont&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;expr-cps&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;make-double-cont&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;saved-cont&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;saved-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expr-cps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-double-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;end-cont&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We represent continuations as functions taking a single argument &lt;tt class="docutils literal"&gt;value&lt;/tt&gt;. We
also abstract away the concept of &lt;em&gt;applying a continuation&lt;/em&gt; with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;apply-cont&lt;/span&gt;&lt;/tt&gt;.
The final continuation &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;end-cont&lt;/span&gt;&lt;/tt&gt; consumes the result of the whole computation
and prints it out. Note how continuations are composed here: we invoke
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr-cps&lt;/span&gt;&lt;/tt&gt;, which expects a continuation. We use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;make-double-cont&lt;/span&gt;&lt;/tt&gt;
constructor to create a continuation that doubles its value. Note how this
doubling continuation works: it knows what its own continuation is, and applies
it to &lt;tt class="docutils literal"&gt;(* 2 value)&lt;/tt&gt;. In fact, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;make-double-cont&lt;/span&gt;&lt;/tt&gt; is just syntactic sugar; we
could do without it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expr-cps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;end-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's see how to do this for the longer expression. We keep the utilities
defined earlier and add:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;make-plus100-cont&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;saved-cont&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;saved-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expr-cps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-double-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-plus100-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;end-cont&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happens in this last invocation?&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr-cps&lt;/span&gt;&lt;/tt&gt; gets called with some continuation. It computes &lt;tt class="docutils literal"&gt;3 + 4&lt;/tt&gt; and
passes the result into the continuation.&lt;/li&gt;
&lt;li&gt;This continuation happens to be the doubling continuation, which applies
&lt;tt class="docutils literal"&gt;2 * value&lt;/tt&gt; to its &lt;tt class="docutils literal"&gt;value&lt;/tt&gt; and passes this result to its own
continuation.&lt;/li&gt;
&lt;li&gt;That continuation, in turn, is a &amp;quot;plus 100&amp;quot; continuation: it applies &lt;tt class="docutils literal"&gt;value
+ 100&lt;/tt&gt; to its &lt;tt class="docutils literal"&gt;value&lt;/tt&gt; and passes the result to its own continuation.&lt;/li&gt;
&lt;li&gt;The last continuation in the chain happens to be &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;end-cont&lt;/span&gt;&lt;/tt&gt;, which prints
the overall result: 114&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If all of this looks like a masochistic exercise in inverting the call stack
(note how the continuations are composed - from the inside out), just a bit more
patience - it will all start making sense soon. The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-cps&lt;/span&gt;&lt;/tt&gt; suffix of
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;expr-cps&lt;/span&gt;&lt;/tt&gt; stands for Continuation Passing Style, by the way, which is the
style of programming we're seeing here; converting &amp;quot;normal&amp;quot; code into this
style is called &lt;em&gt;CPS-transform&lt;/em&gt; (or &lt;em&gt;CPS conversion&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;The lightbulb should go on when you make the following observation: all the
expressions computed in this CPS approach are in tail position. Wait, what
does it mean? The original function computing the full expression is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only tail call here is to the outermost &lt;tt class="docutils literal"&gt;+&lt;/tt&gt;. Both the &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; and the inner
&lt;tt class="docutils literal"&gt;+&lt;/tt&gt; are not in tail position. However, if you carefully examine the CPS
approach, &lt;em&gt;all&lt;/em&gt; the operator calls are in tail positions - their results are
passed directly into the relevant continuations, without any changes. For this
purpose we do not count the continuation application as a function call. We're
going to be using this wonderful feature of CPS very soon to great benefit. But
first, a brief dip into theory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="undelimited-and-delimited-continuations"&gt;
&lt;h2&gt;Undelimited and delimited continuations&lt;/h2&gt;
&lt;p&gt;The formulation of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;end-cont&lt;/span&gt;&lt;/tt&gt; I'm using in the example above may appear
peculiar. It &lt;tt class="docutils literal"&gt;print&lt;/tt&gt;s its value - but what if we want to do something else
with it? The strange &lt;tt class="docutils literal"&gt;print&lt;/tt&gt; is a trick to emulate &lt;em&gt;real&lt;/em&gt;, or &lt;em&gt;unbounded&lt;/em&gt;
continuations in a language that doesn't support them &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt;. Applying unbounded
continuations is not just calling a function - it's passing control without hope
of return. Just like coroutines, or &lt;tt class="docutils literal"&gt;longjmp&lt;/tt&gt; in C.&lt;/p&gt;
&lt;p&gt;Unbounded continuations &lt;em&gt;do not return to their caller&lt;/em&gt;. They express a flow of
computation where results flow in one direction, without ever returning.
This is getting beyond the scope of the article, but when unbounded
continuations can be treated as first-class values in a language, they become so
powerful that they can be used to implement pretty much any control-flow feature
you can imagine - exceptions, threads, coroutines and so on. This is precisely
what continuations are sometimes used for in the implementation of functional
languages, where CPS-transform is one of the compilation stages.&lt;/p&gt;
&lt;p&gt;I'd love to expound more on the topic, but I'll have to leave it to another day.
If you're interested, read some information online and play with a language
that supports real continuations - like Scheme with &lt;tt class="docutils literal"&gt;call/cc&lt;/tt&gt;. It's fun and
scary at the same time.&lt;/p&gt;
&lt;p&gt;Even though most programming languages don't support real, &lt;em&gt;unbounded&lt;/em&gt;
continuations, &lt;em&gt;bounded&lt;/em&gt; continuations is another deal. A &lt;em&gt;bounded&lt;/em&gt; continuation
is just a function that returns to its caller. We can still use CPS but just
have to be realistic about our expectations. Applying a bounded continuation
simply means calling a function - so the stack &lt;em&gt;will&lt;/em&gt; grow.&lt;/p&gt;
&lt;p&gt;If we cycle back to our expression, we can stop pretending our continuations are
anything except a simulation, and just define:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;end-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In fact, we don't even have to pretend &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(apply-cont&lt;/span&gt; cont value)&lt;/tt&gt; is any
different from simply calling &lt;tt class="docutils literal"&gt;(cont value)&lt;/tt&gt;, so now we can rewrite our
CPS expression much more succinctly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;real-end-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expr-cps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;real-end-cont&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It looks a bit weird because we could just inline the &lt;tt class="docutils literal"&gt;(* 2 value)&lt;/tt&gt; into
the internal call, but keeping them separate will help us later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="synthesizing-tail-calls-with-cps-transform"&gt;
&lt;h2&gt;Synthesizing tail calls with CPS-transform&lt;/h2&gt;
&lt;p&gt;Armed with this new tool, let's revisit some of the Python functions from the
beginning of the article. For the factorial, we used an extra parameter to get a
tail-call version; for Fibonacci we needed two; for more advanced examples (like
merge sort) it wasn't very clear how to do the conversion. CPS-transform to the
rescue!&lt;/p&gt;
&lt;p&gt;It turns out we can convert any function to use tail calls instead of recursion
(direct or indirect) by applying the following recipe:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Pass each function an extra parameter - &lt;tt class="docutils literal"&gt;cont&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Whenever the function returns an expression that doesn't contain function
calls, send that expression to the continuation &lt;tt class="docutils literal"&gt;cont&lt;/tt&gt; instead.&lt;/li&gt;
&lt;li&gt;Whenever a function call occurs in a tail position, call the function with
the same continuation - &lt;tt class="docutils literal"&gt;cont&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Whenever a function call occurs in an operand (non-tail) position, instead
perform this call in a new continuation that gives a name to the result and
continues with the expression.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This may not make much sense without examples. Let's review the recursive
factorial first:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;                       &lt;span class="c1"&gt;# (1)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fact_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;# (2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The line marked with (1) hits step 2 of the recipe; the line marked with (2)
hits step 4, since a function call (to &lt;tt class="docutils literal"&gt;fact_rec&lt;/tt&gt; itself) occurs in an operand
position. Here is how we transform this function to CPS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fact_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The application of steps 1 and 2 is straightforward. Step 4 requires a bit more
explanation. Since the call &lt;tt class="docutils literal"&gt;fact_rec(n - 1)&lt;/tt&gt; is the one occurring in operand
position, we extract it out and perform it in a new continuation. This
continuation then passes &lt;tt class="docutils literal"&gt;n * value&lt;/tt&gt; to the original continuation of
&lt;tt class="docutils literal"&gt;fact_cps&lt;/tt&gt;. Take a moment to convince yourself that this code does, in fact,
compute the factorial. We have to run it with the &amp;quot;end continuation&amp;quot; discussed
before:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; end_cont = lambda value: value
&amp;gt;&amp;gt;&amp;gt; fact_cps(6, end_cont)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's do the same thing for Fibonacci, which demonstrates a more complex
recursion pattern:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;                                 &lt;span class="c1"&gt;# (1)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib_rec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;# (2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, applying steps 1 and 2 is trivial. Step 4 will have to applied on
line marked with (2), but twice, since we have two function calls in operand
positions. Let's handle the &lt;tt class="docutils literal"&gt;fib_rec(n - 1)&lt;/tt&gt; first, similarly to what we
did for the factorial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib_cps_partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib_cps_partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib_cps_partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All calls in &lt;tt class="docutils literal"&gt;fib_cps_partial&lt;/tt&gt; are in tail position now, but there's a
problem. The continuation we crafted for the recursive call... itself has a call
not in tail position. We'll have to apply CPS-transform once again, recursively.
We'll treat the expression inside the &lt;tt class="docutils literal"&gt;lambda&lt;/tt&gt; as just another function
definition to transform. Here's the final version, which is fully transformed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                 &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fib_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                                 &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                 &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And once again, it's easy to see this version contains no calls that aren't
in tail position. As opposed to the conversions shown in the beginning of the
article, this one is much less ad-hoc and follows a clear recipe. In fact, it
can be performed automatically by a compiler or a source transformation tool!&lt;/p&gt;
&lt;p&gt;Just to show this is actually helpful in more general cases, let's tackle merge
sort again. We have the recursive implementation at the top of this post, with
the tricky part in the line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;merge_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="n"&gt;merge_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;:]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But transforming merge sort to CPS turns out not much different from
transforming Fibonacci. I won't go through the partial stage for this now, and
will just present the final answer:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;merge_sort_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;merge_sort_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;merge_sort_cps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;:],&lt;/span&gt;
                                          &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/rdparser.py"&gt;recursive-descent parser sample&lt;/a&gt;
has an example of a more complex CPS-transform applied to realistic code, if
you're interested.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="trampolines-to-avoid-stack-growth-in-tail-recursive-calls"&gt;
&lt;h2&gt;Trampolines to avoid stack growth in tail-recursive calls&lt;/h2&gt;
&lt;p&gt;Now we're ready to discuss why we want to place all calls in tail position, even
if our language doesn't support TCO. The final tool that ties things together
is &lt;em&gt;trampolines&lt;/em&gt;.&lt;/p&gt;
&lt;img alt="A blue jumpy trampoline" class="align-center" src="https://eli.thegreenplace.net/images/2017/trampolineblue.jpg" /&gt;
&lt;p&gt;... not this kind!&lt;/p&gt;
&lt;p&gt;Let's borrow a definition from Wikipedia:&lt;/p&gt;
&lt;blockquote&gt;
As used in some Lisp implementations, a trampoline is a loop that iteratively
invokes thunk-returning functions (continuation-passing style). A single
trampoline suffices to express all control transfers of a program; a program
so expressed is trampolined, or in trampolined style; converting a program to
trampolined style is trampolining. Programmers can use trampolined functions
to implement tail-recursive function calls in stack-oriented programming
languages.&lt;/blockquote&gt;
&lt;p&gt;But wait, what's a &amp;quot;thunk-returning function&amp;quot;?&lt;/p&gt;
&lt;p&gt;A thunk, in programming language jargon, is simply some expression wrapped in an
argument-less function. This wrapping &lt;em&gt;delays&lt;/em&gt; the evaluation of the expression
until the point at which the function is called:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;14&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;thunk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;thunk&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7f2c2977c510&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;thunk&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="mi"&gt;14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This example shows how we ask the interpreter to evaluate an expression. Then,
we wrap it in a thunk: in Python simply a &lt;tt class="docutils literal"&gt;lambda&lt;/tt&gt; with no arguments. The
thunk itself is just a function. But when we call the thunk, the expression is
actually evaluated. Thunks can be used to emulate &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Lazy_evaluation"&gt;Lazy Evaluation&lt;/a&gt; in languages that don't
support it by default (like Python, or Clojure). But for our uses in this post,
thunks are an essential part of the solution to the stack explosion problem.&lt;/p&gt;
&lt;p&gt;The missing part of the puzzle is this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;trampoline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;callable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;em&gt;trampoline&lt;/em&gt; is a Python function. It takes a function and a sequence of
arguments, and applies the function to the arguments. Nothing more exciting than
delayed evaluation so far. But there's more. If the function returns a callable,
the trampoline assumes it's a thunk and calls it. And so on, until the function
returns somethings that's no longer callable &lt;a class="footnote-reference" href="#footnote-7" id="footnote-reference-7"&gt;[7]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Remember how I said, when discussing unbounded continuations, that in &amp;quot;regular&amp;quot;
languages like Python we're just cheating and simulating continuations with
function calls? Trampolines is what make this viable without blowing the stack.
Let's see how. Here's our CPS version of factorial, transformed once again to
return a thunk:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact_cps_thunked&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fact_cps_thunked&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                         &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case the transformation is straightforward: we just wrap the tail calls
in an argument-less &lt;tt class="docutils literal"&gt;lambda&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-8" id="footnote-reference-8"&gt;[8]&lt;/a&gt;. To invoke this function properly, we have
to use a trampoline. So, to compute the factorial of 6, we'll do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;trampoline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fact_cps_thunked&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end_cont&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;720&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now comes the bang! If you carefully trace the execution of this trampoline,
you'll immediately note that &lt;em&gt;the stack doesn't grow&lt;/em&gt;! Instead of calling
itself, &lt;tt class="docutils literal"&gt;fact_cps_thunked&lt;/tt&gt; returns a thunk, so the call is done by the
trampoline. Indeed, if we trace the function calls for the recursive factorial
we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fact_rec(6)
  fact_rec(5)
    fact_rec(4)
      fact_rec(3)
        fact_rec(2)
          fact_rec(1)
            fact_rec(0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But if we do the same for the thunked version, we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;trampoline(&amp;lt;callable&amp;gt;, 6, &amp;lt;callable&amp;gt;)
  fact_cps_thunked(6, &amp;lt;callable&amp;gt;)
  fact_cps_thunked(5, &amp;lt;callable&amp;gt;)
  fact_cps_thunked(4, &amp;lt;callable&amp;gt;)
  fact_cps_thunked(3, &amp;lt;callable&amp;gt;)
  fact_cps_thunked(2, &amp;lt;callable&amp;gt;)
  fact_cps_thunked(1, &amp;lt;callable&amp;gt;)
  fact_cps_thunked(0, &amp;lt;callable&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember how, earlier in the post, we've discovered the maximum stack depth of
Python by invoking &lt;tt class="docutils literal"&gt;fact_rec(1000)&lt;/tt&gt; and observing it blow up? No such problem
with the thunked version:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; trampoline(fact_cps_thunked, 1000, end_cont)
... number with 2568 digits

&amp;gt;&amp;gt;&amp;gt; trampoline(fact_cps_thunked, 2000, end_cont)
... number with 5736 digits
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/fib.py"&gt;full Fibonacci sample&lt;/a&gt;
shows how to use thunks and trampolines to compute the Fibonacci sequence
without growing the stack.&lt;/p&gt;
&lt;p&gt;I hope the pieces have fallen into place by now. By using a combination of CPS
and trampolines, we've taken arbitrary recusive functions and converted them
to tail-recursive versions that consume only a bounded number of stack frames.
All of this &lt;em&gt;in a language without TCO support&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="trampolines-for-mutual-recursion"&gt;
&lt;h2&gt;Trampolines for mutual recursion&lt;/h2&gt;
&lt;p&gt;If you're left wondering how realistic this is, let's go back to the topic of
mutual recursion. As I've mentioned before, Clojure doesn't support TCO, even
though it's a Lisp. To overcome this, the recommended programming style in
Clojure is explicit &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;loop...recur&lt;/span&gt;&lt;/tt&gt; iteration, which makes tail-recursive
algorithms relatively easy (and efficient) to express. But this still leaves
Clojure with the problem of mutual or indirect recursion, where &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;loop...recur&lt;/span&gt;&lt;/tt&gt;
doesn't help.&lt;/p&gt;
&lt;p&gt;Here's that silly even/odd example again, this time in Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;declare &lt;/span&gt;&lt;span class="nv"&gt;is-even?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;is-odd?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-even?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;is-even?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-odd?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can't get rid of the tail recursion here with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;loop...recur&lt;/span&gt;&lt;/tt&gt;. But Clojure
solves the problem by offering &lt;tt class="docutils literal"&gt;trampoline&lt;/tt&gt; in the &lt;a class="reference external" href="https://clojuredocs.org/clojure.core/trampoline"&gt;language core&lt;/a&gt;! Here's a thunked version:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;declare &lt;/span&gt;&lt;span class="nv"&gt;is-even-thunked?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;is-odd-thunked?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-even-thunked?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;is-even-thunked?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-odd-thunked?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To invoke it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;=&amp;gt; (trampoline is-even-thunked? 3)
false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how small the difference from the non-thunked version is. This is due to
Clojure's awesome syntax for anonymous functions, where a thunk is simply
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;#(...)&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Clojure's own implementation of &lt;tt class="docutils literal"&gt;trampoline&lt;/tt&gt; is about what we'd expect. Here
it is, pasted in full, including its educational docstring:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;trampoline&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;trampoline can be used to convert algorithms requiring mutual&lt;/span&gt;
&lt;span class="s"&gt;  recursion without stack consumption. Calls f with supplied args, if&lt;/span&gt;
&lt;span class="s"&gt;  any. If f returns a fn, calls that fn with no arguments, and&lt;/span&gt;
&lt;span class="s"&gt;  continues to repeat, until the return value is not a fn, then&lt;/span&gt;
&lt;span class="s"&gt;  returns that non-fn value. Note that if you want to return a fn as a&lt;/span&gt;
&lt;span class="s"&gt;  final value, you must wrap it in some data structure and unpack it&lt;/span&gt;
&lt;span class="s"&gt;  after trampoline returns.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:added&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="ss"&gt;:static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;ret&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="nv"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;trampoline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;args&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="back-to-reality"&gt;
&lt;h2&gt;Back to reality&lt;/h2&gt;
&lt;p&gt;While the tools described in this post can (and do) serve as building blocks for
some compilers of functional languages, how relevant are they to day-to-day
programming in languages like Python and Clojure?&lt;/p&gt;
&lt;p&gt;The answer is, IMHO, not &lt;em&gt;very&lt;/em&gt;, but they're still worth knowing about. For
Clojure, quite obviously Rich Hickey found trampolines important enough to
include them in the language. Since Clojure is not TCO'd and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;loop...recur&lt;/span&gt;&lt;/tt&gt; is
only good for direct recursion, some solution had to be offered for
mutual/indirect recursion. But how often would you use it anyway?&lt;/p&gt;
&lt;p&gt;Algorithms like merge-sort, or any tree-like traversal, tend to be fine just
with regular recursion because the supported depth is more than sufficient.
Because of the logarithmic nature of depth vs. total problem size, you're
unlikely to recurse into merge-sort more than a few dozen times. An array
needing just 30 divisions has to contain about a billion items.&lt;/p&gt;
&lt;p&gt;The same is true for recursive-descent parsing, since realistic expressions get
only so large. However, with some algorithms like graph traversals we definitely
have to be more careful.&lt;/p&gt;
&lt;p&gt;Another important use case is state machines, which may be conveniently
expressed with indirect recursive calls for state transitions. Here's a &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/statemachine.py"&gt;code
sample&lt;/a&gt;.
Guido mentions this problem in &lt;a class="reference external" href="http://neopythonic.blogspot.com/2009/04/final-words-on-tail-calls.html"&gt;his post on TCO in Python&lt;/a&gt;, and
actually suggests trampolined tail-calls as a possible solution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-generators-and-coroutines-as-an-alternative"&gt;
&lt;h2&gt;Python generators and coroutines as an alternative&lt;/h2&gt;
&lt;p&gt;That said, I personally believe that Python offers better ways to solve these
problems. I've &lt;a class="reference external" href="https://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines"&gt;written before&lt;/a&gt;
about using coroutines for modeling state machines. Since then, Python grew more
supportive features - I've written about using &lt;tt class="docutils literal"&gt;yield from&lt;/tt&gt; to &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/08/09/using-sub-generators-for-lexical-scanning-in-python/"&gt;implement
lexical scanning&lt;/a&gt;,
for example, and similar techniques can be adapted for parsing.&lt;/p&gt;
&lt;p&gt;In Python 3.5, &lt;a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html"&gt;even more features&lt;/a&gt; were added to support
coroutines. I plan to find some time to dig in these and write more about them.&lt;/p&gt;
&lt;p&gt;All of this is to say that I wouldn't find much use for direct expression of CPS
and trampolines in Python code these days. But I may be wrong! Please feel free
to make suggestions in the comments or by email - I'll be really curious to know
about realistic use cases where these techniques could be employed in modern
Python.&lt;/p&gt;
&lt;p&gt;Regardless of their usefulness in modern Python, these topics are fascinating
and I feel they improve my understanding of how some programming languages work
under the hood.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;For this post I'm using Python 3.5 to run and test all the code, on an
Ubuntu Linux machine; for a different version of Python or environment,
the recursion limit may be different.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Alternatively you may see TRE (Tail Recursion Elimination). TCO is more
general because tail calls don't necessarily have to be directly
recursive (as the &lt;tt class="docutils literal"&gt;is_even / is_odd&lt;/tt&gt; example demonstrates).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;AFAIU, some JVM languages emulate TCO by using trampolines, but Clojure
doesn't since it prefers to be compatible with Java and retain high
performance. My information may be out of date here, so please feel free
to comment if I'm wrong.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The compiler can cheat by emitting constructs not accessible from the
source language. What happens in practice, on the lowest level of emitted
machine code, is that instead of a &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; the compiler just prepares
a stack frame for the called function and jumps to it. Since the results
of the called function will not be used in the caller (except returning
them further up the chain), the compiler doesn't have to save any caller
state.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I'm using a Lisp (Clojure) here because it unifies the syntax
of mathematical operations with function calls, which makes the
explanation less convoluted.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Clojure in this case, but Python doesn't support them either.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Astute readers will note this is problematic when our code makes heavy
use of first-class functions and we may legitimately return a function
from another function call. This is true, and in this case it should be
easy to make a thunk something more explicit than simply a &lt;tt class="docutils literal"&gt;lambda&lt;/tt&gt;.
We could, for example, encapsulate it in a type - &lt;tt class="docutils literal"&gt;Thunk&lt;/tt&gt;, that we
would check with &lt;tt class="docutils literal"&gt;isinstance&lt;/tt&gt; inside &lt;tt class="docutils literal"&gt;trampoline&lt;/tt&gt;, instead of just
&lt;tt class="docutils literal"&gt;callable&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that the new continuation constructed for the recursive call also
returns a thunk. Figuring out why this is necessary is a good exercise!&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Python"></category><category term="Clojure"></category></entry><entry><title>Common Lisp's consp and listp in Clojure</title><link href="https://eli.thegreenplace.net/2016/common-lisps-consp-and-listp-in-clojure/" rel="alternate"></link><published>2016-12-26T08:15:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-12-26:/2016/common-lisps-consp-and-listp-in-clojure/</id><summary type="html">&lt;p&gt;The list is a very central data structure in Common Lisp, especially when
looking at educational content (such as classic books). In Clojure, lists exist
and are used quite a bit, but their place is less central since their inherent
inefficiency compared to other data structures is acknowledged. This often …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The list is a very central data structure in Common Lisp, especially when
looking at educational content (such as classic books). In Clojure, lists exist
and are used quite a bit, but their place is less central since their inherent
inefficiency compared to other data structures is acknowledged. This often
leaves us with a need to translate a lot of list-oriented idioms from Common
Lisp to equivalent Clojure code.&lt;/p&gt;
&lt;p&gt;When working with lists, Common Lisp often uses the predicates &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;; it turns out that neither of these has a direct equivalent in
Clojure, and we must think carefully when translating code using &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;.&lt;/p&gt;
&lt;img alt="cons cell list" class="align-center" src="https://eli.thegreenplace.net/images/2016/cons-cell-1-2.gif" /&gt;
&lt;p&gt;Throughout this post I assume cons cells are only used to construct proper
lists, such as &lt;tt class="docutils literal"&gt;(cons 'a (cons 'b nil))&lt;/tt&gt;. Other uses of &lt;tt class="docutils literal"&gt;cons&lt;/tt&gt; in Common
Lisp are fairly rare; this fact is acknowledged by the language specification.
For example, &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; returns true on a non-list cons cell, since it's assumed
that cons cells are used mostly for lists:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[6]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[7]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;listp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; predicate simply checks if its argument is a cons cell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[8]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[9]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="c1"&gt;;; list using cons&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[10]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;                         &lt;/span&gt;&lt;span class="c1"&gt;;; nicer way make the same list&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It will reject anything that's &lt;em&gt;not&lt;/em&gt; a cons cell, most notably symbols and
numbers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[12]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[13]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; also rejects &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;; but &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; is used to mean an &amp;quot;empty list&amp;quot; in
Common Lisp (it's equivalent to &lt;tt class="docutils literal"&gt;'()&lt;/tt&gt;), so &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; is not a convenient
function to use to check whether something &amp;quot;is a list&amp;quot;. That's what &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; is
for. &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; is simply an &lt;tt class="docutils literal"&gt;or&lt;/tt&gt; between the &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;null&lt;/tt&gt;
predicates:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;[14]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[15]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;listp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[16]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;consp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;NIL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;[17]&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;listp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="no"&gt;T&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As mentioned above, &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; simplistically accepts non-list cons cells as
lists as well, but that's rarely a problem in practice.&lt;/p&gt;
&lt;p&gt;Now, if you're reading some book or article that uses Common Lisp as its
demonstration language, there's a good chance calls to &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;
are nonchalantly scattered all over the code; the difference bewteen these two,
as we've just seen, is quite subtle, and authors use one or the other based on
the nature of the problem faced. For example if you see a &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, it's most
likely there because the author wants to explicitly reject empty lists.&lt;/p&gt;
&lt;p&gt;In Clojure, our first attempt would be to use &lt;tt class="docutils literal"&gt;seq&lt;/tt&gt;. It returns a truthy value
for sequences, and can be used within conditions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (if (seq (cons 1 (cons 2 nil))) &amp;#39;yes &amp;#39;no)
yes
cl-in-clj.core=&amp;gt; (if (seq &amp;#39;(1 2)) &amp;#39;yes &amp;#39;no)
yes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This appears to be a reasonable replacement for &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, until we try it with
a symbol:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (if (seq &amp;#39;foo) &amp;#39;yes &amp;#39;no)

IllegalArgumentException Don&amp;#39;t know how to create ISeq from: [...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oops, that's not good. We need a better way to detect lists that won't blow up
on us. An alternative is &lt;tt class="docutils literal"&gt;list?&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (list? &amp;#39;(1 2))
true
cl-in-clj.core=&amp;gt; (list? &amp;#39;foo)
false
cl-in-clj.core=&amp;gt; (list? &amp;#39;())
true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But wait, this returns &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;'()&lt;/tt&gt;; so it's more like an equivalent for
&lt;tt class="docutils literal"&gt;listp&lt;/tt&gt; than for &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;. For &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, we'd need to make sure we return
&lt;tt class="docutils literal"&gt;false&lt;/tt&gt; for an empty list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (defn my-consp [obj] (and (list? obj) (not (empty? obj))))
#&amp;#39;cl-in-clj.core/my-consp
cl-in-clj.core=&amp;gt; (my-consp &amp;#39;(1 2))
true
cl-in-clj.core=&amp;gt; (my-consp &amp;#39;foo)
false
cl-in-clj.core=&amp;gt; (my-consp &amp;#39;())
false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I'm using &lt;tt class="docutils literal"&gt;(not (empty? &lt;span class="pre"&gt;...))&lt;/span&gt;&lt;/tt&gt; rather than the more idiomatic &lt;tt class="docutils literal"&gt;(seq
&lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;; this is on purpose. If the object is a sequence, &lt;tt class="docutils literal"&gt;seq&lt;/tt&gt; will return it
and that will be the value of the &lt;tt class="docutils literal"&gt;and&lt;/tt&gt;. Sometimes, I really only want a
boolean, so &lt;tt class="docutils literal"&gt;(not (empty? &lt;span class="pre"&gt;...))&lt;/span&gt;&lt;/tt&gt; is more accurate.&lt;/p&gt;
&lt;p&gt;There's another issue here, having to do with &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;. In Common Lisp, &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;
is just the empty list. In Clojure, they're different. The &lt;tt class="docutils literal"&gt;list?&lt;/tt&gt; defined
above will return &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;, unlike its Common Lisp counterpart. The
real solution to this in Clojure is to avoid using &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt; to mean the empty
list; instead just use the empty list &lt;tt class="docutils literal"&gt;'()&lt;/tt&gt;. This means we have to be careful
when calling &lt;tt class="docutils literal"&gt;first&lt;/tt&gt; on an empty list, since it returns &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;While on the topic of &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;, Common Lisp's &lt;tt class="docutils literal"&gt;null&lt;/tt&gt; is true on the empty list
while Clojure's &lt;tt class="docutils literal"&gt;(nil? &lt;span class="pre"&gt;'())&lt;/span&gt;&lt;/tt&gt; is false. To approximate the behavior of
&lt;tt class="docutils literal"&gt;null&lt;/tt&gt;, we could do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cl-in-clj.core=&amp;gt; (defn my-null [obj] (or (nil? obj) (empty? obj)))
#&amp;#39;cl-in-clj.core/my-null
cl-in-clj.core=&amp;gt; (my-null nil)
true
cl-in-clj.core=&amp;gt; (my-null &amp;#39;())
true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To conclude, if you need Common Lisp's &lt;tt class="docutils literal"&gt;listp&lt;/tt&gt;, use Clojure's &lt;tt class="docutils literal"&gt;list?&lt;/tt&gt; but be
aware of &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;s. It's best to avoid &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;s in Clojure list processing, but
this isn't always trivial since &lt;tt class="docutils literal"&gt;(first &lt;span class="pre"&gt;'())&lt;/span&gt;&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;nil&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;If you need &lt;tt class="docutils literal"&gt;consp&lt;/tt&gt;, you'll have to define something like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;my-consp&lt;/span&gt;&lt;/tt&gt;, unless
you are OK with an exception being thrown on symbols and numbers, in which case
&lt;tt class="docutils literal"&gt;seq&lt;/tt&gt; should do.&lt;/p&gt;
</content><category term="misc"></category><category term="Lisp"></category><category term="Clojure"></category></entry><entry><title>Some notes on the Y combinator</title><link href="https://eli.thegreenplace.net/2016/some-notes-on-the-y-combinator/" rel="alternate"></link><published>2016-11-28T05:25:00-08:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-11-28:/2016/some-notes-on-the-y-combinator/</id><summary type="html">&lt;p&gt;The goal of this post is to jot down a few notes about the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Fixed-point_combinator"&gt;Y combinator&lt;/a&gt;, explaining how it
works without getting too much into lambda-calculus theory. I'll be using
Clojure and Python as the demonstration languages.&lt;/p&gt;
&lt;p&gt;The idea is to build up intuition for the Y combinator from simple …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The goal of this post is to jot down a few notes about the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Fixed-point_combinator"&gt;Y combinator&lt;/a&gt;, explaining how it
works without getting too much into lambda-calculus theory. I'll be using
Clojure and Python as the demonstration languages.&lt;/p&gt;
&lt;p&gt;The idea is to build up intuition for the Y combinator from simple examples in
a way that makes understanding it a sequences of small mental leaps rather than
one large one.&lt;/p&gt;
&lt;div class="section" id="recursion-with-named-functions"&gt;
&lt;h2&gt;Recursion with named functions&lt;/h2&gt;
&lt;p&gt;It wouldn't be a proper article about recursion if it didn't start with a
factorial. Here's a fairly run-of-the-mill implementation in Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;factorial-rec&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recursion is accomplished by invoking the function, by name, within itself.
Herein begins the thought experiment that will lead us to the Y combinator.
Imagine that we're using a language where functions have no names - they're all
anonymous. We can assign anonymous functions to symbols, but those symbols
aren't visible or usable from within the function's body.&lt;/p&gt;
&lt;p&gt;As an example of what I'm talking about, here is a non-recursive implementation
of factorial in Clojure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;factorial-loop&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;answer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;answer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;answer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how this is defined: we assign an anonymous function (&lt;tt class="docutils literal"&gt;lambda&lt;/tt&gt; in
Lisp/Scheme/Python parlance, &lt;tt class="docutils literal"&gt;fn&lt;/tt&gt; in Clojure) to the symbol
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-loop&lt;/span&gt;&lt;/tt&gt;. This anonymous function computes the factorial of its
parameter, and we can call it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; (factorial-loop 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To emphasize that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-loop&lt;/span&gt;&lt;/tt&gt; is just a convenience symbol and plays no
role in the implementation, we can forego it for a slightly more convoluted
invocation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((fn [n]
              #_=&amp;gt;     (loop [i n answer 1]
              #_=&amp;gt;       (if (zero? i)
              #_=&amp;gt;         answer
              #_=&amp;gt;         (recur (- i 1) (* answer i))))) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No names in sight - we just invoke the anonymous function directly. But this
implementation of factorial isn't recursive, so we don't really &lt;em&gt;need&lt;/em&gt; to refer
to the function's name from within its body. What if we do want to use
recursion? This brings us back to the thought experiment.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="recursion-with-anonymous-functions"&gt;
&lt;h2&gt;Recursion with anonymous functions&lt;/h2&gt;
&lt;p&gt;It turns out this is absolutely possible by using some ingenuity and cranking
the abstraction level up one notch. In our original &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt;, at the
point where the function invokes itself all we need is an object that implements
factorial, right? In &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt; we're using the fact that the symbol
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt; is bound to such an object (by the nature of &lt;tt class="docutils literal"&gt;defn&lt;/tt&gt;). But
we can't rely on that in our thought experiment. How else can we get access to
such an object? Well, we can take it as a parameter... Here's how:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;factorial-maker&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can compute factorials as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((factorial-maker factorial-maker) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A few things to note:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; is not computing a factorial. It creates an (anonymous)
function that computes a factorial. It expects to be passed &lt;em&gt;itself&lt;/em&gt; as a
parameter.&lt;/li&gt;
&lt;li&gt;The expression &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-maker&lt;/span&gt; &lt;span class="pre"&gt;factorial-maker)&lt;/span&gt;&lt;/tt&gt; does precisely that. It
invokes &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; and passes it itself as a parameter. The result
of that is a function that computes a factorial, which we then apply to 6.&lt;/li&gt;
&lt;li&gt;The recursion inside the factorial is replaced by &lt;tt class="docutils literal"&gt;(self self)&lt;/tt&gt;; when the
function created by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-maker&lt;/span&gt; &lt;span class="pre"&gt;factorial-maker)&lt;/span&gt;&lt;/tt&gt; runs for the first
time, &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; is assigned to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;, so &lt;tt class="docutils literal"&gt;(self self)&lt;/tt&gt;
is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-maker&lt;/span&gt; factorial maker)&lt;/tt&gt;. This is equivalent to the first
call - recursion!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You may still feel uncomfortable about the &lt;tt class="docutils literal"&gt;def&lt;/tt&gt; and the name
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;. Aren't we just cheating? Nope, because we can do the same
expansion as we did with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-loop&lt;/span&gt;&lt;/tt&gt;; we don't need that &lt;tt class="docutils literal"&gt;def&lt;/tt&gt;. Here's
how it would look:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; (((fn [self]
              #_=&amp;gt;     (fn [n]
              #_=&amp;gt;       (if (zero? n)
              #_=&amp;gt;         1
              #_=&amp;gt;         (* n ((self self) (- n 1))))))
              #_=&amp;gt;   (fn [self]
              #_=&amp;gt;     (fn [n]
              #_=&amp;gt;       (if (zero? n)
              #_=&amp;gt;         1
              #_=&amp;gt;         (* n ((self self) (- n 1))))))) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pretty it is not... But hey, we've now implemented a recursive factorial
function, without a single name in sight. How cool is that?&lt;/p&gt;
&lt;p&gt;Understanding the example above is about 80% of the way to understanding the Y
combinator, so make sure to spend the time required to thoroughly grok how it
works. Tracing through the execution for 2-3 calls while drawing the
&amp;quot;environments&amp;quot; (call frames) in action helps a lot.&lt;/p&gt;
&lt;p&gt;To get a better feel of the direction we're taking, here's another recursive
function that's slightly more complex than the factorial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;tree-sum-rec&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil? &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;left &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-sum-rec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;tree-sum-rec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given a binary tree represented as a list-of-lists with numbers for node deta,
this function computes the sum of all the nodes in the tree. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; (def t1 &amp;#39;(1 (2) (4 (3) (7))))
#&amp;#39;ycombinator.core/t1
ycombinator.core=&amp;gt; (tree-sum-rec t1)
17
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can rewrite it without using any symbol names within the function as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;tree-sum-maker&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil? &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;left &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And invoke it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((tree-sum-maker tree-sum-maker) t1)
17
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the similarities between &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-sum-maker&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;. They
are transformed very similarly to synthesize the unnamed from the
named-recursion variant. The recipe seems to be:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Instead of a function taking a parameter, create a function factory that
accepts itself as the &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; parameter, and returns the actual computation
function.&lt;/li&gt;
&lt;li&gt;In every place where we'd previously call ourselves, call &lt;tt class="docutils literal"&gt;(self self)&lt;/tt&gt;
instead.&lt;/li&gt;
&lt;li&gt;The initial invocation of &lt;tt class="docutils literal"&gt;(foo param)&lt;/tt&gt; is replaced by
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;((foo-maker&lt;/span&gt; &lt;span class="pre"&gt;foo-maker)&lt;/span&gt; param)&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="y-combinator-a-tool-for-making-anonymous-functions-recursive"&gt;
&lt;h2&gt;Y combinator - a tool for making anonymous functions recursive&lt;/h2&gt;
&lt;p&gt;Since there is a clear pattern here, we should be able to abstract it away and
provide some method that transforms a given named-recursive function into an
unnamed variant. This is precisely what the Y combinator does, though the nature
of the problem makes it somewhat obscure at first sight:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;Ycombinator&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I'll explain how it works shortly, but first let's see how we use it. We have
to write our &lt;tt class="docutils literal"&gt;factorial&lt;/tt&gt; as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;zero? &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the superficial similarity to the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; version.
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt; also takes a function and returns the actual function
computing the factorial, though in this case I don't call the function parameter
&lt;tt class="docutils literal"&gt;self&lt;/tt&gt; (it's not &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; in the strict sense, as we'll soon see). We can
convert this function to a recursive computation of the factorial by invoking
the Y combinator on it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((Ycombinator factorial-rec*) 6)
720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's easiest to understand how &lt;tt class="docutils literal"&gt;Ycombinator&lt;/tt&gt; does its magic by unraveling this
invocation step by step. Similarly to how we did earlier, we can get rid of the
&lt;tt class="docutils literal"&gt;Ycombinator&lt;/tt&gt; name and just apply the object it's defined to be directly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;factorial-rec*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As before, this does two things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Call the Y combinator (just a scary-looking anonymous function)
on &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Call the result of (1) on 6.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you look carefully at step 1, it invokes the following anonymous function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On itself, with &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; bound to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;. So what we get is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if we actually perform the call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial-rec*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;, passing it an anonymous function as &lt;tt class="docutils literal"&gt;recurse&lt;/tt&gt;
&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt; returns a factorial-computing function. This is where
the first step ends. Invoking this factorial-computing function on 6 is the
second step.&lt;/p&gt;
&lt;p&gt;It should now be obvious what's going on. When the invocation with 6 happens and
the program gets to calling &lt;tt class="docutils literal"&gt;recurse&lt;/tt&gt;, it calls the parameter of
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt; as shown above. But we've already unwrapped this call before
- it... recurses into &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec*&lt;/span&gt;&lt;/tt&gt;, while propagating itself forward
so that the &lt;tt class="docutils literal"&gt;recurse&lt;/tt&gt; parameter is always bound properly. It's just the same
trick as was employed by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt; earlier in the post.&lt;/p&gt;
&lt;p&gt;So, the Y combinator is the magic sauce that lets us take code like
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-rec&lt;/span&gt;&lt;/tt&gt; and convert it into code like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;factorial-maker&lt;/span&gt;&lt;/tt&gt;. Here's
how we can implement an unnamed version of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tree-sum-rec&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;tree-sum-rec*&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil? &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;left &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;nodeval&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recurse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And using it with the Y combinator:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ycombinator.core=&amp;gt; ((Ycombinator tree-sum-rec*) t1)
17
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is an alternative formulation of the Y combinator that can make it a bit
easier to understand. In this version I'm using named Clojure functions for
further simplification (since many folks find the syntax of anonymous functions
applied to other anonymous functions too cryptic):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;apply-to-self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;Ycombinator-alt&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply-to-self&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-y-combinator-in-python"&gt;
&lt;h2&gt;The Y combinator in Python&lt;/h2&gt;
&lt;p&gt;Finally, just to show that the Y combinator isn't something unique to the Lisp
family of languages, here's a Python implementation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ycombinator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; \
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))(&lt;/span&gt;
                        &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; \
                   &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; \
                     &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;recurse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can invoke it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ycombinator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;720&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's no real difference between the Python and the Clojure versions. As long
as the language supports creating anonymous functions and treats them as
first-class citizens, all is good.&lt;/p&gt;
&lt;p&gt;It's even possible to create the Y combinator in C++. Static typing makes it
somewhat less elegant than in the more dynamic languages, but C++14's generic
lambdas help a lot. Take a look at &lt;a class="reference external" href="https://rosettacode.org/wiki/Y_combinator#C.2B.2B"&gt;Rosetta Code&lt;/a&gt; for an example.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;Incidentally, note that by starting with &lt;tt class="docutils literal"&gt;(Ycombinator &lt;span class="pre"&gt;factorial-rec*)&lt;/span&gt;&lt;/tt&gt;,
we now got to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(factorial-rec*&lt;/span&gt; (Ycombinator &lt;span class="pre"&gt;factorial-rec*))&lt;/span&gt;&lt;/tt&gt;. For
this reason, the Y combinator is a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Fixed-point_combinator"&gt;fixed-point combinator&lt;/a&gt;
in lambda calculus.&lt;/p&gt;
&lt;p&gt;There's another interesting thing to note here - the equivalence
mentioned above is imperfect. The call &lt;tt class="docutils literal"&gt;(Ycombinator &lt;span class="pre"&gt;factorial-rec*)&lt;/span&gt;&lt;/tt&gt;
results in a &lt;em&gt;delayed&lt;/em&gt; fixed point equivalence (the delay achieved by
means of wrapping the result in a &lt;tt class="docutils literal"&gt;fn&lt;/tt&gt;). This is because we're
using Clojure - an eagerly evaluated language. This version of the Y
combinator is called the &lt;em&gt;applicative-order&lt;/em&gt; Y combinator. Without the
delay, we'd get an infinite loop. In lazily evaluated languages, it's
possible to define the Y combinator somewhat more succinctly.&lt;/p&gt;
&lt;p class="last"&gt;All of this is very interesting, but I'm deliberately avoiding getting
too deep into lambda calculus and programming language theory in this
post; I may write more about it some time in the future.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Lisp"></category><category term="Clojure"></category><category term="Python"></category></entry><entry><title>EOPL define-datatype and cases in Clojure</title><link href="https://eli.thegreenplace.net/2016/eopl-define-datatype-and-cases-in-clojure/" rel="alternate"></link><published>2016-11-14T06:12:00-08:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-11-14:/2016/eopl-define-datatype-and-cases-in-clojure/</id><summary type="html">&lt;p&gt;I'm going through the &lt;a class="reference external" href="http://www.eopl3.com/"&gt;Essentials of Programming Languages (3rd ed.)&lt;/a&gt; book and it's been pretty good so far. In chapter 2,
the authors use a pair of macros - &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; - to make
it easy to define data-driven programs, where objects belong to types, each of
which has several &amp;quot;variants …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'm going through the &lt;a class="reference external" href="http://www.eopl3.com/"&gt;Essentials of Programming Languages (3rd ed.)&lt;/a&gt; book and it's been pretty good so far. In chapter 2,
the authors use a pair of macros - &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; - to make
it easy to define data-driven programs, where objects belong to types, each of
which has several &amp;quot;variants&amp;quot; with custom fields (this is essentially a
macro-driven implementation of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_data_type"&gt;algebraic data types&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The canonical example used chapter 2 is the &amp;quot;Lambda calculus expression&amp;quot;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(define-datatype lc-exp lc-exp?
  (var-exp
   (var symbol?))
  (lambda-exp
   (bound-var symbol?)
   (body lc-exp?))
  (app-exp
   (rator lc-exp?)
   (rand lc-exp?)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means we create a type named &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;, with three variants:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;var-exp&lt;/span&gt;&lt;/tt&gt; which has a field named &lt;tt class="docutils literal"&gt;var&lt;/tt&gt;, a symbol.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lambda-exp&lt;/span&gt;&lt;/tt&gt; which has two fields: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;bound-var&lt;/span&gt;&lt;/tt&gt; is a symbol, and &lt;tt class="docutils literal"&gt;body&lt;/tt&gt;
is a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;app-exp&lt;/span&gt;&lt;/tt&gt; which has two fields: &lt;tt class="docutils literal"&gt;rator&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;rand&lt;/tt&gt;, both a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; invocation creates multiple helper functions; for
example, the predicate &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp?&lt;/span&gt;&lt;/tt&gt; that tests whether the object it's given is a
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;. It can also optionally create accessors such as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;app-exp-&amp;gt;rand&lt;/span&gt;&lt;/tt&gt;,
that will extract a field from a given variant.&lt;/p&gt;
&lt;p&gt;The companion &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; macro lets us organize code that operates on types
created with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt; succinctly. For example, a function that checks
whether some symbol occurs as a free variable in a given &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lc-exp&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cases&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;lc-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;exp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;var-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;variable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;lambda-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bound-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;and &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bound-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;app-exp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;occurs-free?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;search-var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[Note: this is actual Clojure code from my implementation; the book uses Scheme,
so it has slightly different syntax.]&lt;/p&gt;
&lt;p&gt;Alas, while the book explains how this pair of macros works and uses them all
over the place, it provides no definition. The definitions found online are
either hard to hunt down or very verbose (which may be due to &lt;a class="reference external" href="https://eli.thegreenplace.net/2007/09/16/common-lisp-vs-scheme-macros"&gt;Scheme's use of
hygienic macros&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Therefore I rolled my own, in Clojure, and the full code is
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/define-datatype/src/define_datatype/define_datatype.clj"&gt;available here&lt;/a&gt;.
The code comes with a large number of unit tests, many of which are
taken from the exercises in chapter 2 of the book.&lt;/p&gt;
&lt;p&gt;It's been quite a while since I last did any serious Lispy macro hacking, so my
implementation is fairly cautious in its use of macros. One cool thing about
the way Clojure's (Common Lisp-like) macros work is that writing them is very
close to just manipulating lists of symbols (representing code) in regular
functions. Here's my &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;define-datatype-aux&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Creates a datatype from the specification. This is a function, so all its&lt;/span&gt;
&lt;span class="s"&gt;  arguments are symbols or quoted lists. In particular, variant-descriptors is a&lt;/span&gt;
&lt;span class="s"&gt;  quoted list of all the descriptors.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;predicate-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-descriptors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;define-datatype&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Simple macro wrapper around define-datatype-aux, so that the type name,&lt;/span&gt;
&lt;span class="s"&gt;  predicate name and variant descriptors don&amp;#39;t have to be quoted but rather can&lt;/span&gt;
&lt;span class="s"&gt;  be regular Clojure symbols.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;predicate-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-descriptors&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-datatype-aux&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;predicate-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-descriptors&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the macro does here is to do the thing only macros can do - change the
evaluation rules of expressions, by not actually evaluating the arguments passed
to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype&lt;/span&gt;&lt;/tt&gt;; rather passing them as lists of symbols (code) to a
function. The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;define-datatype-aux&lt;/span&gt;&lt;/tt&gt; function can then manipulate these lists
of symbols. The only problem with this approach is that while macros can simply
inject &lt;tt class="docutils literal"&gt;defn&lt;/tt&gt;s into the namespace, functions have to work a bit harder for
that; what I use instead is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;internfunc&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Helper for interning a function with the given name (as a string) in the&lt;/span&gt;
&lt;span class="s"&gt;  current namespace.&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;strname&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;intern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;*ns*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol &lt;/span&gt;&lt;span class="nv"&gt;strname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I'm sure the code could be made much shorter by doing more work in the macro,
but writing it this way made it possible to break the implementation into a
number of small and simple functions, each of which is easy to test and
understand without peering into the output of &lt;tt class="docutils literal"&gt;macroexpand&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;In the implementation of &lt;tt class="docutils literal"&gt;cases&lt;/tt&gt; I was a bit more brave and left more work
in the macro itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;make-cond-case&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Helper function for cases that generates a single case for the variant cond.&lt;/span&gt;

&lt;span class="s"&gt;  variant-case is one variant case as given to the cases macro.&lt;/span&gt;
&lt;span class="s"&gt;  obj-variant is the actual object variant (a symbol) as taken from the object.&lt;/span&gt;
&lt;span class="s"&gt;  obj-fields is the list of the actual object&amp;#39;s fields.&lt;/span&gt;

&lt;span class="s"&gt;  Produces the code for &amp;#39;(cond-case cond-action).&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-variant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-fields&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-variant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;second &lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;last &lt;/span&gt;&lt;span class="nv"&gt;variant-case&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-fields&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;cases&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;variant-cases&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;obj-type-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;obj-variant-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;variant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;obj-fields-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;fields&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-type-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-variant-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-fields-sym&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;assert &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;obj-type-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Unexpected type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cond&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcat &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;vc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-cond-case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;vc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-variant-sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;obj-fields-sym&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="nv"&gt;variant-cases&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="ss"&gt;:else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;assert &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Unsupported variant&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, I still deferred some of the work to a function -
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;make-cond-case&lt;/span&gt;&lt;/tt&gt; - to avoid complex nested quoting within the macro.&lt;/p&gt;
&lt;p&gt;The full code is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/define-datatype/src/define_datatype/define_datatype.clj"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
</content><category term="misc"></category><category term="Clojure"></category><category term="Lisp"></category></entry><entry><title>The Expression Problem and its solutions</title><link href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/" rel="alternate"></link><published>2016-05-12T05:44:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2016-05-12:/2016/the-expression-problem-and-its-solutions/</id><summary type="html">&lt;p&gt;The craft of programming is almost universally concerned with different types of
data and operations/algorithms that act on this data &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. Therefore, it's
hardly surprising that designing abstractions for data types and operations has
been on the mind of software engineers and programming-language designers
since... forever.&lt;/p&gt;
&lt;p&gt;Yet I've only …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The craft of programming is almost universally concerned with different types of
data and operations/algorithms that act on this data &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. Therefore, it's
hardly surprising that designing abstractions for data types and operations has
been on the mind of software engineers and programming-language designers
since... forever.&lt;/p&gt;
&lt;p&gt;Yet I've only recently encountered a name for a software design problem which I
ran into multiple times in my career. It's a problem so fundamental that I was
quite surprised that I haven't seen it named before. Here is a quick problem
statement.&lt;/p&gt;
&lt;p&gt;Imagine that we have a set of data types and a set of operations that act on
these types. Sometimes we need to add more operations and make sure they work
properly on all types; sometimes we need to add more types and make sure all
operations work properly on them. Sometimes, however, we need to add both - and
herein lies the problem. Most of the mainstream programming languages don't
provide good tools to add both new types and new operations to an existing
system without having to change existing code. This is called the &amp;quot;expression
problem&amp;quot;. Studying the problem and its possible solutions gives great insight
into the fundamental differences between object-oriented and functional
programming and well as concepts like interfaces and multiple dispatch.&lt;/p&gt;
&lt;div class="section" id="a-motivating-example"&gt;
&lt;h2&gt;A motivating example&lt;/h2&gt;
&lt;p&gt;As is my wont, my example comes from the world of compilers and interpreters.
To my defense, this is also the example used in some of the seminal historic
sources on the expression problem, as the historical perspective section below
details.&lt;/p&gt;
&lt;p&gt;Imagine we're designing a simple expression evaluator. Following the standard
&lt;a class="reference external" href="https://eli.thegreenplace.net/2016/on-the-composite-and-interpreter-design-patterns"&gt;interpreter design pattern&lt;/a&gt;, we have
a tree structure consisting of expressions, with some operations we can do on
such trees. In C++ we'd have an interface every node in the expression tree
would have to implement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Eval&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This interface shows that we currently have two operations we can do on
expression trees - evaluate them and query for their string representations.
A typical leaf node expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostringstream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Eval&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a typical composite expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;BinaryPlus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; + &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Eval&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Eval&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Eval&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Until now, it's all fairly basic stuff. How extensible is this design? Let's
see... if we want to add new expression types (&amp;quot;variable reference&amp;quot;, &amp;quot;function
call&amp;quot; etc.), that's pretty easy. We just define additional classes inheriting
from &lt;tt class="docutils literal"&gt;Expr&lt;/tt&gt; and implement the &lt;tt class="docutils literal"&gt;Expr&lt;/tt&gt; interface (&lt;tt class="docutils literal"&gt;ToString&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Eval&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;However, what happens if we want to add new &lt;em&gt;operations&lt;/em&gt; that can be applied to
expression trees? Right now we have &lt;tt class="docutils literal"&gt;Eval&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;ToString&lt;/tt&gt;, but we may want
additional operations like &amp;quot;type check&amp;quot; or &amp;quot;serialize&amp;quot; or &amp;quot;compile to
machine code&amp;quot; or whatever.&lt;/p&gt;
&lt;p&gt;It turns out that adding new operations isn't as easy as adding new types. We'd
have to change the &lt;tt class="docutils literal"&gt;Expr&lt;/tt&gt; interface, and consequently change every existing
expression type to support the new method(s). If we don't control the original
code or it's hard to change it for other reasons, we're in trouble.&lt;/p&gt;
&lt;p&gt;In other words, we'd have to violate the venerable &lt;em&gt;open-closed principle&lt;/em&gt;,
one of the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29"&gt;main principles of object-oriented design&lt;/a&gt;, defined
as:&lt;/p&gt;
&lt;blockquote&gt;
software entities (classes, modules, functions, etc.) should be open for
extension, but closed for modification&lt;/blockquote&gt;
&lt;p&gt;The problem we're hitting here is called the &lt;em&gt;expression problem&lt;/em&gt;, and the
example above shows how it applies to object-oriented programming.&lt;/p&gt;
&lt;p&gt;Interestingly, the expression problem bites functional programming languages as
well. Let's see how.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-expression-problem-in-functional-programming"&gt;
&lt;h2&gt;The expression problem in functional programming&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Update 2018-02-05:&lt;/strong&gt; &lt;a class="reference external" href="https://eli.thegreenplace.net/2018/more-thoughts-on-the-expression-problem-in-haskell/"&gt;a new post&lt;/a&gt;
discusses the problem and its solutions in Haskell in more depth.&lt;/p&gt;
&lt;p&gt;Object-oriented approaches tend to collect functionality in objects (types).
Functional languages cut the cake from a different angle, usually preferring
types as thin data containers, collecting most functionality in functions
(operations) that act upon them. Functional languages don't escape the
expression problem - it just manifests there in a different way.&lt;/p&gt;
&lt;p&gt;To demonstrate this, let's see how the expression evaluator / stringifier looks
in Haskell. Haskell is a good poster child for functional programming since its
pattern matching on types makes such code especially succinct:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;Expressions&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kr"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; + &amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's say we want to add a new operation - type checking. We simply have
to add a new function &lt;tt class="docutils literal"&gt;typecheck&lt;/tt&gt; and define how it behaves for all known
kinds of expressions. No need to modify existing code.&lt;/p&gt;
&lt;p&gt;On the other hand, if we want to add a new type (like &amp;quot;function call&amp;quot;), we get
into trouble. We now have to modify all existing functions to handle this new
type. So we hit exactly the same problem, albeit from a different angle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-expression-problem-matrix"&gt;
&lt;h2&gt;The expression problem matrix&lt;/h2&gt;
&lt;p&gt;A visual representation of the expression problem can be helpful to appreciate
how it applies to OOP and FP in different ways, and how a potential solution
would look.&lt;/p&gt;
&lt;p&gt;The following 2-D table (a &amp;quot;matrix&amp;quot;) has types in its rows and operations in its
columns. A matrix cell &lt;tt class="docutils literal"&gt;row, col&lt;/tt&gt; is checked when the operation &lt;tt class="docutils literal"&gt;col&lt;/tt&gt; is
implemented for type &lt;tt class="docutils literal"&gt;row&lt;/tt&gt;:&lt;/p&gt;
&lt;img alt="Basic expression problem matrix demonstarting the starting point" class="align-center" src="https://eli.thegreenplace.net/images/2016/expr-problem-matrix.png" /&gt;
&lt;p&gt;In object-oriented languages, it's easy to add new types but difficult to add
new operations:&lt;/p&gt;
&lt;img alt="OOP expression problem matrix" class="align-center" src="https://eli.thegreenplace.net/images/2016/expr-problem-oop.png" /&gt;
&lt;p&gt;Whereas in functional languages, it's easy to add new operations but difficult
to add new types:&lt;/p&gt;
&lt;img alt="FP expression problem matrix" class="align-center" src="https://eli.thegreenplace.net/images/2016/expr-problem-fp.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="a-historical-perspective"&gt;
&lt;h2&gt;A historical perspective&lt;/h2&gt;
&lt;p&gt;The expression problem isn't new, and has likely been with us since the early
days; it pops its head as soon as programs reach some not-too-high level of
complexity.&lt;/p&gt;
&lt;p&gt;It's fairly certain that the name &lt;em&gt;expression problem&lt;/em&gt; comes from &lt;a class="reference external" href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt"&gt;an email&lt;/a&gt; sent
by &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Philip_Wadler"&gt;Philip Wadler&lt;/a&gt; to a mailing
list deailing with adding generics to Java (this was back in the 1990s).&lt;/p&gt;
&lt;p&gt;In that email, Wadler points to the paper &lt;a class="reference external" href="https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/"&gt;&amp;quot;Synthesizing Object-Oriented and
Functional Design to Promote Re-Use&amp;quot;&lt;/a&gt; by
Krishnamurthi, Felleisen and Friedman as an earlier work describing the problem
and proposed solutions. This is a great paper and I highly recommend reading it.
Krishnamurthi et.al., in their references, point to papers from as early as 1975
describing variations of the problem in Algol.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="flipping-the-matrix-with-the-visitor-pattern"&gt;
&lt;h2&gt;Flipping the matrix with the visitor pattern&lt;/h2&gt;
&lt;p&gt;So far the article has focused on the expression &lt;em&gt;problem&lt;/em&gt;, and I hope it's
clear by now. However, the title also has the word &lt;em&gt;solution&lt;/em&gt; in it, so let's
turn to that.&lt;/p&gt;
&lt;p&gt;It's possible to kinda solve (read on to understand why I say &amp;quot;kinda&amp;quot;) the
expression problem in object-oriented languages; first, we have to look at how
we can flip the problem on its side using the visitor pattern. The visitor
pattern is very common for this kind of problems, and for a good reason. It lets
us reformulate our code in a way that makes it easier to change in some
dimensions (though harder in others).&lt;/p&gt;
&lt;p&gt;For the C++ sample shown above, rewriting it using the visitor pattern means
adding a new &amp;quot;visitor&amp;quot; interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;ExprVisitor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VisitConstant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Constant&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;VisitBinaryPlus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BinaryPlus&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And changing the &lt;tt class="docutils literal"&gt;Expr&lt;/tt&gt; interface to be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ExprVisitor&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now expression types defer the actual computation to the visitor, as
follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ExprVisitor&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;VisitConstant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// ... similarly, BinaryPlus would have&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//    void Accept(ExprVisitor* visitor) const {&lt;/span&gt;
&lt;span class="c1"&gt;//      visitor-&amp;gt;VisitBinaryPlus(*this);&lt;/span&gt;
&lt;span class="c1"&gt;//    }&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// ... etc.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A sample visitor for evaluation would be &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Evaluator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExprVisitor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GetValueForExpr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_map_&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VisitConstant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Constant&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;value_map_&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VisitBinaryPlus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BinaryPlus&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetLhs&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetRhs&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;value_map_&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_map_&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetLhs&lt;/span&gt;&lt;span class="p"&gt;())]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_map_&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetRhs&lt;/span&gt;&lt;span class="p"&gt;())];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_map_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It should be obvious that for a given set of data types, adding new visitors is
easy and doesn't require modifying any other code. On the other hand, adding new
types is problematic since it means we have to update the &lt;tt class="docutils literal"&gt;ExprVisitor&lt;/tt&gt;
interface with a new abstract method, and consequently update all the visitors
to implement it.&lt;/p&gt;
&lt;p&gt;So it seems that we've just turned the expression problem on its side: we're
using an OOP language, but now it's hard to add types and easy to add ops, just
like in the functional approach. I find it extremely interesting that we can do
this. In my eyes this highlights the power of different abstractions and
paradigms, and how they enable us to rethink a problem in a completely different
light.&lt;/p&gt;
&lt;p&gt;So we haven't solved anything yet; we've just changed the nature of the problem
we're facing. Worry not - this is just a stepping stone to an actual solution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="extending-the-visitor-pattern"&gt;
&lt;h2&gt;Extending the visitor pattern&lt;/h2&gt;
&lt;p&gt;The following is code excerpts from a C++ solution that follows the extended
visitor pattern proposed by Krishnamurthi et. al. in their paper; I strongly
suggest reading the paper (particularly section 3) if you want to understand
this code on a deep level. A complete code sample in C++ that compiles and runs
is &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/c%2B%2B/visitor-extended.cpp"&gt;available here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Adding new visitors (ops) with the visitor pattern is easy. Our challenge is to
add a new &lt;em&gt;type&lt;/em&gt; without upheaving too much existing code. Let's see how it's
done.&lt;/p&gt;
&lt;p&gt;One small design change that we should make to the original visitor pattern is
use &lt;tt class="docutils literal"&gt;virtual&lt;/tt&gt; inheritance for &lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt;, for reasons that will soon become
obvious:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Evaluator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExprVisitor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// .. the rest is the same&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we're going to add a new type - &lt;tt class="docutils literal"&gt;FunctionCall&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// This is the new (&amp;quot;extended&amp;quot;) expression we&amp;#39;re adding.&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FunctionCall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;FunctionCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argument_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ExprVisitor&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ExprVisitorWithFunctionCall&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ExprVisitorWithFunctionCall&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cerr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Fatal: visitor is not ExprVisitorWithFunctionCall&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;VisitFunctionCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argument_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since we don't want to modify the existing visitors, we create a new one,
extending &lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt; for function calls. But first, we need to extend the
&lt;tt class="docutils literal"&gt;ExprVisitor&lt;/tt&gt; interface to support the new type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;ExprVisitorWithFunctionCall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExprVisitor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VisitFunctionCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FunctionCall&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we write the new evaluator, which extends &lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt; and supports
the new type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;EvaluatorWithFunctionCall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExprVisitorWithFunctionCall&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                  &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Evaluator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VisitFunctionCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FunctionCall&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Visiting FunctionCall!!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Multiple inheritance, virtual inheritance, dynamic type checking... that's
pretty hard-core C++ we have to use here, but there's no choice. Unfortunately,
multiple inheritance is the only way C++ lets us express the idea that a class
implements some interface while at the same time deriving functionality from
another class. What we want to have here is an evaluator
(&lt;tt class="docutils literal"&gt;EvaluatorWithFunctionCall&lt;/tt&gt;) that inherits all functionality from
&lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt;, and also implements the &lt;tt class="docutils literal"&gt;ExprVisitorWithFunctionCall&lt;/tt&gt;
interface. In Java, we could say something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EvaluatorWithFunctionCall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;extends&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Evaluator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;implements&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExprVisitor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But in C++ virtual multiple inheritance is the tool we have. The virtual part of
the inheritance is essential here for the compiler to figure out that the
&lt;tt class="docutils literal"&gt;ExprVisitor&lt;/tt&gt; base underlying both &lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;ExprVisitorWithFunctionCall&lt;/tt&gt; is the same and should only appear once in
&lt;tt class="docutils literal"&gt;EvaluatorWithFunctionCall&lt;/tt&gt;. Without virtual, the compiler would complain that
&lt;tt class="docutils literal"&gt;EvaluatorWithFunctionCall&lt;/tt&gt; doesn't implement the &lt;tt class="docutils literal"&gt;ExprVisitor&lt;/tt&gt; interface.&lt;/p&gt;
&lt;p&gt;This is a solution, alright. We kinda added a new type &lt;tt class="docutils literal"&gt;FunctionCall&lt;/tt&gt; and can
now visit it without changing existing code (assuming the virtual inheritance
was built into the design from the start to anticipate this approach). Here I
am using this &amp;quot;kinda&amp;quot; word again... it's time to explain why.&lt;/p&gt;
&lt;p&gt;This approach has multiple flaws, in my opinion:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Note the &lt;tt class="docutils literal"&gt;dynamic_cast&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;FunctionCall::Accept&lt;/span&gt;&lt;/tt&gt;. It's fairly ugly that
we're forced to mix in dynamic checks into this code, which should supposedly
rely on static typing and the compiler. But it's just a sign of a larger
problem.&lt;/li&gt;
&lt;li&gt;If we have an instance of an &lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt;, it will no longer work on the
whole extended expression tree since it has no understanding of
&lt;tt class="docutils literal"&gt;FunctionCall&lt;/tt&gt;. It's easy to say that all new evaluators should rather be
&lt;tt class="docutils literal"&gt;EvaluatorWithFunctionCall&lt;/tt&gt;, but we don't always control this. What about
code that was already written? What about &lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt;s created in
third-party or library code which we have no control of?&lt;/li&gt;
&lt;li&gt;The virtual inheritance is not the only provision we have to build into the
design to support this pattern. Some visitors would need to create new,
recursive visitors to process complex expressions. But we can't anticipate
in advance which dynamic type of visitor needs to be created. Therefore,
the visitor interface should also accept a &amp;quot;visitor factory&amp;quot; which extended
visitors will supply. I know this sounds complicated, and I don't want to
spend more time on this here - but the Krishnamurthi paper addresses this
issue extensively in section 3.4&lt;/li&gt;
&lt;li&gt;Finally, the solution is unwieldy for realistic applications. Adding one
new type looks manageable; what about adding 15 new types, gradually over
time? Imagine the horrible zoo of &lt;tt class="docutils literal"&gt;ExprVisitor&lt;/tt&gt; extensions and dynamic
checks this would lead to.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Yeah, programming is hard. I could go on and on about the limitations of
classical OOP and how they surface in this example &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;. Instead, I'll just
present how the expression problem can be solved in a language that supports
multiple dispatch and separates the defintion of methods from the bodies of
types they act upon.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="solving-the-expression-problem-in-clojure"&gt;
&lt;h2&gt;Solving the expression problem in Clojure&lt;/h2&gt;
&lt;p&gt;There are a number of ways the expression problem as displayed in this article
can be solved in Clojure using the language's built-in features. Let's start
with the simplest one - multi-methods.&lt;/p&gt;
&lt;p&gt;First we'll define the types as records:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defrecord &lt;/span&gt;&lt;span class="nv"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defrecord &lt;/span&gt;&lt;span class="nv"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, we'll define &lt;tt class="docutils literal"&gt;evaluate&lt;/tt&gt; as a multimethod that dispatches upon the type
of its argument, and add method implementations for &lt;tt class="docutils literal"&gt;Constant&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;BinaryPlus&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmulti &lt;/span&gt;&lt;span class="nv"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;class&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:rhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can already evaluate expressions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;expression.multimethod&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;3.3000000000000003&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Adding a new operation is easy. Let's add &lt;tt class="docutils literal"&gt;stringify&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmulti &lt;/span&gt;&lt;span class="nv"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;class&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.string/join&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; + &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:rhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Testing it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;1.1 + 2.2&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How about adding new types? Suppose we want to add &lt;tt class="docutils literal"&gt;FunctionCall&lt;/tt&gt;. First,
we'll define the new type. For simplicity, the &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; field of
&lt;tt class="docutils literal"&gt;FunctionCall&lt;/tt&gt; is just a Clojure function. In real code it could be some sort
of function object in the language we're interpreting:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defrecord &lt;/span&gt;&lt;span class="nv"&gt;FunctionCall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And define how &lt;tt class="docutils literal"&gt;evaluate&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;stringify&lt;/tt&gt; work for &lt;tt class="docutils literal"&gt;FunctionCall&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;FunctionCall&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="ss"&gt;:func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:argument&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmethod &lt;/span&gt;&lt;span class="nv"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;FunctionCall&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.repl/demunge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;(&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:argument&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's take it for a spin (the full code &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/clojure/expression/src/expression/multimethod.clj"&gt;is here&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;callexpr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;FunctionCall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;twice&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                                         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;user/callexpr&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;callexpr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;6.6000000000000005&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;callexpr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;expression.multimethod/twice@52e29c38(1.1 + 2.2)&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It should be evident that the expression problem matrix for Clojure is:&lt;/p&gt;
&lt;img alt="Expression problem matrix in Clojure" class="align-center" src="https://eli.thegreenplace.net/images/2016/expr-problem-clojure.png" /&gt;
&lt;p&gt;We can add new ops without touching any existing code. We can also add new types
without touching any existing code. The code we're adding is &lt;em&gt;only&lt;/em&gt; the new code
to handle the ops/types in question. The existing ops and types could come from
a third-party library to which we don't have source access. We could still
extend them for our new ops and types, without ever having to touch (or even
see) the original source code &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="is-multiple-dispatch-necessary-to-cleanly-solve-the-expression-problem"&gt;
&lt;h2&gt;Is multiple dispatch necessary to cleanly solve the expression problem?&lt;/h2&gt;
&lt;p&gt;I've written about &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-4"&gt;multiple dispatch in Clojure&lt;/a&gt;
before, and in the previous section we see another example of how to use the
language's &lt;tt class="docutils literal"&gt;defmulti&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;defmethod&lt;/tt&gt; constructs. But is it multiple dispatch at
all? No! It's just &lt;em&gt;single&lt;/em&gt; dispatch, really. Our ops (&lt;tt class="docutils literal"&gt;evaluate&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;stringify&lt;/tt&gt;) dispatch on a &lt;em&gt;single&lt;/em&gt; argument - the expression type) &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If we're not really using multiple dispatch, what &lt;em&gt;is&lt;/em&gt; the secret sauce that
lets us solve the expression problem so elegantly in Clojure? The answer is -
open methods. Note a crucial difference between how methods are defined in
C++/Java and in Clojure. In C++/Java, methods have to be part of a class and
defined (or at least declared) in its body. You cannot add a method to a class
without changing the class's source code.&lt;/p&gt;
&lt;p&gt;In Clojure, you can. In fact, since data types and multimethods are orthogonal
entities, this is by design. Methods simply live outside types - they are first
class citizens, rather than properties of types. We don't add methods &lt;em&gt;to a
type&lt;/em&gt;, we add new methods that &lt;em&gt;act upon the type&lt;/em&gt;. This doesn't require
modifying the type's code in any way (or even having access to its code).&lt;/p&gt;
&lt;p&gt;Some of the other popular programming languages take a middle way. In languages
like Python, Ruby and JavaScript methods belong to types, but we can dynamically
add, remove and replace methods in a class even after it was created. This
technique is lovingly called &lt;em&gt;monkey patching&lt;/em&gt;. While initially enticing, it
can lead to big maintainability headaches in code unless we're very careful.
Therefore, if I had to face the expression problem in Python I'd prefer to roll
out some sort of &lt;a class="reference external" href="https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-2"&gt;multiple dispatch mechanism&lt;/a&gt;
for my program rather than rely on monkey patching.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="another-clojure-solution-using-protocols"&gt;
&lt;h2&gt;Another Clojure solution - using protocols&lt;/h2&gt;
&lt;p&gt;Clojure's multimethods are very general and powerful. So general, in fact, that
their performance may not be optimal for the most common case - which is single
dispatch based on the type of the sole method argument; note that this is
exactly the kind of dispatch I'm using in this article. Therefore, starting with
Clojure 1.2, user code gained the ability to define and use &lt;em&gt;protocols&lt;/em&gt; - a
language feature that was previously restricted only to built-in types.&lt;/p&gt;
&lt;p&gt;Protocols leverage the host platform's (which in Clojure's case is mostly Java)
ability to provide quick virtual dispatch, so using them is a very efficient way
to implement runtime polymorphism. In addition, protocols retain enough of
the flexibility of multimethods to elegantly solve the expression problem.
Curiously, this was on the mind of Clojure's designers right from the start. The
Clojure &lt;a class="reference external" href="http://clojure.org/reference/protocols"&gt;documentation page about protocols&lt;/a&gt; lists this as one of their
capabilities:&lt;/p&gt;
&lt;blockquote&gt;
[...] Avoid the 'expression problem' by allowing independent extension of the
set of types, protocols, and implementations of protocols on types, by
different parties. [...] do so without wrappers/adapters&lt;/blockquote&gt;
&lt;p&gt;Clojure protocols are an interesting topic, and while I'd like to spend some
more time on them, this article is becoming too long as it is. So I'll leave
a more thorough treatment for some later time and for now will just show how
protocols can also be used to solve the expression problem we're discussing.&lt;/p&gt;
&lt;p&gt;The type definitions remain the same:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defrecord &lt;/span&gt;&lt;span class="nv"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defrecord &lt;/span&gt;&lt;span class="nv"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, instead of defining a multimethod for each operation, we now define
a &lt;em&gt;protocol&lt;/em&gt;. A protocol can be thought of as an interface in a language like
Java, C++ or Go - a type implements an interface when it defines the set of
methods declared by the interface. In this respect, Clojure's protocols are more
like Go's interfaces than Java's, as we don't have to say a-priori which
interfaces a type implements when we define it.&lt;/p&gt;
&lt;p&gt;Let's start with the &lt;tt class="docutils literal"&gt;Evaluatable&lt;/tt&gt; protocol, that consists of a single method
- &lt;tt class="docutils literal"&gt;evaluate&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defprotocol &lt;/span&gt;&lt;span class="nv"&gt;Evaluatable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another protocol we'll define is &lt;tt class="docutils literal"&gt;Stringable&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defprotocol &lt;/span&gt;&lt;span class="nv"&gt;Stringable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can make sure our types implement these protocols:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;extend-type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;Evaluatable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;Stringable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;extend-type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;Evaluatable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:rhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;Stringable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.string/join&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; + &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stringify&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:rhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))])))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;extend-type&lt;/span&gt;&lt;/tt&gt; macro is a convenience wrapper around the more general
&lt;tt class="docutils literal"&gt;extend&lt;/tt&gt; - it lets us implement multiple protocols for a given type.
A sibling macro named &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;extend-protocol&lt;/span&gt;&lt;/tt&gt; lets us implement the same protocol
for multiple types in the same invocation &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It's fairly obvious that adding new data types is easy - just as we did above,
we simply use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;extend-type&lt;/span&gt;&lt;/tt&gt; for each new data type to implement our current
protocols. But how do we add a new protocol and make sure all existing data
types implement it? Once again, it's easy because we don't have to modify any
existing code. Here's a new protocol:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defprotocol &lt;/span&gt;&lt;span class="nv"&gt;Serializable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;serialize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this is its implementation for the currently supported data types:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;extend-protocol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Serializable&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;Constant&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;serialize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;BinaryPlus&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;serialize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;serialize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;serialize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:rhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This time, extending a single protocol for multiple data types -
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;extend-protocol&lt;/span&gt;&lt;/tt&gt; is the more convenient macro to use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="small-interfaces-are-extensibility-friendly"&gt;
&lt;h2&gt;Small interfaces are extensibility-friendly&lt;/h2&gt;
&lt;p&gt;You may have noted that the protocols (interfaces) defined in the Clojure
solution are very small - consisting of a single method. Since adding methods to
an existing protocol is much more problematic (I'm not aware of a way to do this
in Clojure), keeping protocols small is a good idea. This guideline comes up in
other contexts as well; for example, it's good practice to keep interfaces in Go
very minimal.&lt;/p&gt;
&lt;p&gt;In our C++ solution, splitting the &lt;tt class="docutils literal"&gt;Expr&lt;/tt&gt; interface could also be a good idea,
but it wouldn't help us with the expression problem, since we can't modify which
interfaces a class implements after we've defined it; in Clojure we can.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&amp;quot;Types of data&amp;quot; and &amp;quot;operations&amp;quot; are two terms that should be fairly
obvious to modern-day programmers. Philip Wadler, in his discussion of
the expression problem (see the &amp;quot;historical perspective&amp;quot; section of the
article) calls them &amp;quot;datatypes&amp;quot; and &amp;quot;functions&amp;quot;. A famous quote from Fred
Brooks's &lt;em&gt;The Mythical Man Month&lt;/em&gt; (1975) is &amp;quot;Show me your flowcharts and
conceal your tables, and I shall continue to be mystified. Show me your
tables, and I won’t usually need your flowcharts; they’ll be obvious.&amp;quot;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;Note the peculiar way in which data is passed between &lt;tt class="docutils literal"&gt;Visit*&lt;/tt&gt; methods
in a &lt;tt class="docutils literal"&gt;Expr* &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; Value&lt;/tt&gt; map kept in the visitor. This is due to our
inability to make &lt;tt class="docutils literal"&gt;Visit*&lt;/tt&gt; methods return different types in different
visitors. For example, in &lt;tt class="docutils literal"&gt;Evaluator&lt;/tt&gt; we'd want them to return
&lt;tt class="docutils literal"&gt;double&lt;/tt&gt;, but in &lt;tt class="docutils literal"&gt;Stringifier&lt;/tt&gt; they'd probably return
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::string&lt;/span&gt;&lt;/tt&gt;. Unfortunately C++ won't let us easily mix templates and
virtual functions, so we have to resort to either returning &lt;tt class="docutils literal"&gt;void*&lt;/tt&gt; the
C way or the method I'm using here.&lt;/p&gt;
&lt;p class="last"&gt;Curiously, in their paper Krishnamurthi et.al. run into the same issue in
the dialect of Java they're using, and propose some language extensions
to solve it. Philip Wadler uses proposed Java generics in &lt;em&gt;his&lt;/em&gt; approach.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I can't resist, so just in brief: IMHO inheritance is only good for a
very narrow spectrum of uses, but languages like C++ hail it as the main
extension mechanism of types. But inheritance is deeply
flawed for many other use cases, such as implementations of
interfaces. Java is a bit better in this regard, but in the end the
primacy of classes and their &amp;quot;closed-ness&amp;quot; make a lot of tasks - like the
expression problem - very difficult to express in a clean way.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In fact, there are plenty of examples in which the Clojure implementation
and the standard library provide protocols that can be extended by the
user for user-defined types. Extending user-written protocols and
multimethods for built-in types is trivial. As an exercise, add an
&lt;tt class="docutils literal"&gt;evaluate&lt;/tt&gt; implementation for &lt;tt class="docutils literal"&gt;java.lang.Long&lt;/tt&gt;, so that built-in
integers could participate in our expression trees without requiring
wrapping in a &lt;tt class="docutils literal"&gt;Constant&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;FWIW, we &lt;em&gt;can&lt;/em&gt; formulate a multiple dispatch solution to the expression
problem in Clojure. The key idea is to dispatch on two things: type and
operation. Just for fun, I coded a prototype that does this which you can
see &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/clojure/expression/src/expression/multidispatch.clj"&gt;here&lt;/a&gt;.
I think the approach presented in the article - each operation being its
own multimethod - is preferable, though.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The sharp-eyed reader will notice a cool connection to the expression
problem matrix. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;extend-type&lt;/span&gt;&lt;/tt&gt; can add a whole new row to the matrix,
while &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;extend-protocol&lt;/span&gt;&lt;/tt&gt; adds a column. &lt;tt class="docutils literal"&gt;extend&lt;/tt&gt; adds just a single
cell.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="C &amp; C++"></category><category term="Clojure"></category><category term="Multiple dispatch"></category><category term="Haskell"></category></entry></feed>