<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website - LLVM &amp; Clang</title><link href="https://eli.thegreenplace.net/" rel="alternate"></link><link href="https://eli.thegreenplace.net/feeds/llvm-clang.atom.xml" rel="self"></link><id>https://eli.thegreenplace.net/</id><updated>2025-01-25T13:56:56-08:00</updated><entry><title>Adventures in JIT compilation: Part 3 - LLVM</title><link href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-3-llvm/" rel="alternate"></link><published>2017-05-01T05:51:00-07:00</published><updated>2024-05-04T19:46:23-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2017-05-01:/2017/adventures-in-jit-compilation-part-3-llvm/</id><summary type="html">&lt;p&gt;This is part 3 of my &amp;quot;Adventures in JIT compilation&amp;quot; series.
&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/"&gt;Part 1&lt;/a&gt;
introduced the BF input language and presented a few interpreters in increasing
degree of optimization. In &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/"&gt;part 2&lt;/a&gt;
we've seen how to roll a JIT compiler for BF from scratch, by emitting x64
machine code into executable â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is part 3 of my &amp;quot;Adventures in JIT compilation&amp;quot; series.
&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/"&gt;Part 1&lt;/a&gt;
introduced the BF input language and presented a few interpreters in increasing
degree of optimization. In &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/"&gt;part 2&lt;/a&gt;
we've seen how to roll a JIT compiler for BF from scratch, by emitting x64
machine code into executable memory and jumping to it for execution.&lt;/p&gt;
&lt;p&gt;In this part, I'm going to present another JIT compiler for BF. This time,
however, rather than rolling everything from scratch, I'll be using the &lt;a class="reference external" href="http://llvm.org/"&gt;LLVM&lt;/a&gt; framework.&lt;/p&gt;
&lt;div class="section" id="llvm-as-a-programming-language-backend"&gt;
&lt;h2&gt;LLVM as a programming language backend&lt;/h2&gt;
&lt;p&gt;I'll start by saying this post is not meant to be a full tutorial for LLVM. LLVM
has &lt;a class="reference external" href="http://llvm.org/docs/tutorial/"&gt;a pretty good tutorial&lt;/a&gt; already (see also
&lt;a class="reference external" href="https://eli.thegreenplace.net/2015/python-version-of-the-llvm-tutorial/"&gt;my Python port of it&lt;/a&gt;).
I've also written &lt;a class="reference external" href="https://eli.thegreenplace.net/tag/llvm-clang"&gt;more in-depth pieces about LLVM&lt;/a&gt; in the past; see for example
&lt;a class="reference external" href="https://eli.thegreenplace.net/2012/11/24/life-of-an-instruction-in-llvm"&gt;Life of an instruction in LLVM&lt;/a&gt;. That
said, I do hope that seeing how to apply LLVM to develop a complete JIT compiler
for BF can be useful, and the &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/llvmjit.cpp"&gt;complete code sample&lt;/a&gt;
can serve as a starting point for programming language enthusiasts to develop
their own backends with a fairly modern version of LLVM. If you have a bit more
time, look for exercise and experiment suggestions in the footnotes.&lt;/p&gt;
&lt;p&gt;Speaking of LLVM versions... LLVM's C++ API is notoriously volatile, and code
working today has little chance of working in just a few months without any
changes. However, LLVM &lt;em&gt;does&lt;/em&gt; have &lt;a class="reference external" href="http://releases.llvm.org/"&gt;numbered releases&lt;/a&gt; that can be used to maintain some sort of sanity
since they are extensively tested. The code for this post was developed with the
LLVM 4.0 release. Even if you're reading this in the year 2022, hopefully you
should be able to download LLVM 4.0 and compile &amp;amp; link the sample code.&lt;/p&gt;
&lt;p&gt;As opposed to the use of asmjit in &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/"&gt;part 2&lt;/a&gt;,
LLVM offers several distinct advantages:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Since LLVM comes with many state-of-the-art optimizations on the IR level, we
can generate fairly straightforward LLVM IR from our source language, without
worrying too much about its efficiency. I'll demonstrate this shortly.&lt;/li&gt;
&lt;li&gt;LLVM is multi-target. In this post I'm showing a JIT compiler that emits
code for the machine it runs on (x64 in my case), but one can easily reuse
the same code to compile BF to ARM, PowerPC, MIPS or a bunch of other
backends supported by LLVM.&lt;/li&gt;
&lt;li&gt;LLVM comes with a large set of tools useful to visualize and manipulate IR
and other stages of compilation. I mention a couple uses of the &lt;tt class="docutils literal"&gt;opt&lt;/tt&gt; tool
throughout the post, and &lt;a class="reference external" href="http://llvm.org/docs/CommandGuide/"&gt;there are others&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="generating-llvm-ir-from-bf"&gt;
&lt;h2&gt;Generating LLVM IR from BF&lt;/h2&gt;
&lt;p&gt;The core of the code generation code in this sample is fairly short - only ~130
lines of C++ in &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/llvmjit.cpp"&gt;emit_jit_function&lt;/a&gt;.
I'll walk through it, leaving some details out. Feel free to check the LLVM
documentation or API headers for more information, if needed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_func_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Function&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Function&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;jit_func_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Function&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ExternalLinkage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JIT_FUNC_NAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BasicBlock&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;entry_bb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BasicBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;entry&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_func&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IRBuilder&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;entry_bb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We begin by creating a LLVM function to hold the emitted code. The function is
named &lt;tt class="docutils literal"&gt;__llvmjit&lt;/tt&gt; (which is what the constant &lt;tt class="docutils literal"&gt;JIT_FUNC_NAME&lt;/tt&gt; contains) and
its linkage is external so that we could call it from outside the LLVM module
where it resides. We also create the entry basic block in the function where the
initial code will go, as well as an &lt;em&gt;IR builder&lt;/em&gt; that makes the job of emitting
LLVM IR a bit easier than using raw APIs.&lt;/p&gt;
&lt;p&gt;More setup follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AllocaInst&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateAlloca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int8_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MEMORY_SIZE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;memory&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateMemSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MEMORY_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AllocaInst&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateAlloca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int32_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr_addr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this version of the BF JIT, I decided to keep the data memory on the stack of
the JITed function. This makes it easier for LLVM to optimize accesses to the
memory (as we'll see), because the memory is private - it can't be aliased from
outside the function and can't have side effects, which frees the optimizer to
be more aggressive &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;. The data pointer itself is kept on the stack too
(created with an &lt;tt class="docutils literal"&gt;alloca&lt;/tt&gt; instruction) - more on this very shortly. The
data pointer is initialized to 0, per BF semantics &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, as usual for one-pass code emission from BF, we have to keep a stack of
open brackets (in the &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; version the type was called &lt;tt class="docutils literal"&gt;BracketLabels&lt;/tt&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;BracketBlocks&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we're ready for the compilation loop that takes the next BF instruction and
emits the LLVM IR for it. First, pointer movement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instructions&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instructions&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inc_dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateAdd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;inc_dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inc_dataptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dec_dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateSub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dec_dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_dataptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To move the data pointer, we load its value from its storage on the stack,
update it (by either incrementing or decrementing) and store it back. If this
seems inefficient, read on! Later on, the post describes why this style of LLVM
IR emission is not only acceptable, but desirable.&lt;/p&gt;
&lt;p&gt;For data memory updates, the code is not much more complicated:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateInBoundsGEP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element_addr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inc_element&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateAdd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;inc_element&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inc_element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateInBoundsGEP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element_addr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dec_element&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateSub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sub_element&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We similarly load the data pointer, this time using it to compute an offset into
the memory (using LLVM's &lt;tt class="docutils literal"&gt;getelementptr&lt;/tt&gt; instruction). We then load the
element from memory, update it and store it back. Note how we use the
&lt;tt class="docutils literal"&gt;inbounds&lt;/tt&gt; variant of &lt;tt class="docutils literal"&gt;getelementptr&lt;/tt&gt;; BF doesn't define the behavior of
stepping outside the bounds of memory - we leverage this fact to let LLVM
produce more optimized code.&lt;/p&gt;
&lt;p&gt;For I/O, we use a technique similar to the one employed with &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt; in part
2: call the &lt;tt class="docutils literal"&gt;getchar/putchar&lt;/tt&gt; functions from the host. If you look at the
signature of &lt;tt class="docutils literal"&gt;emit_jit_function&lt;/tt&gt;, it takes a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;llvm::Function*&lt;/span&gt;&lt;/tt&gt; for each of
&lt;tt class="docutils literal"&gt;getchar&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;putchar&lt;/tt&gt;; these are declared in the caller by adding their
declaration to the module. Later, in the section dealing with the JIT we'll see
how these get resolved at run-time.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateInBoundsGEP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element_addr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_i32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateIntCast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int32_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element_i32_&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;putchar_func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_i32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getchar_func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;user_input&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user_input_i8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateIntCast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int8_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;user_input_i8_&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateInBoundsGEP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element_addr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_input_i8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As usual, the trickiest part of generating code for BF is handling the loops,
which could be nested. LLVM makes this fairly easy by having &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Basic_block"&gt;basic blocks&lt;/a&gt; as first-class citizens. Every
loop body gets its basic block, and the original block gets split to two - the
first part jumping into the loop, the last part happening after the loop (since
we can skip directly to it). Here's how the control-flow graph within a function
with just a single loop looks &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;:&lt;/p&gt;
&lt;img alt="CFG for function with one loop" class="align-center" src="https://eli.thegreenplace.net/images/2017/llvmjit-oneloop-cfg.png" /&gt;
&lt;p&gt;Note how the jumps between basic blocks happen on a condition and have &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;
(true) or &lt;tt class="docutils literal"&gt;F&lt;/tt&gt; (false) clauses. These just encode the usual BF semantics:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;For a &lt;tt class="docutils literal"&gt;[&lt;/tt&gt;, we compare the current memory cell with 0; if it's 0, we skip the
loop (the &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; clause); if it's not 0, we enter the loop (the &lt;tt class="docutils literal"&gt;F&lt;/tt&gt; clause).&lt;/li&gt;
&lt;li&gt;For a &lt;tt class="docutils literal"&gt;]&lt;/tt&gt;, we compare the current memory cell with 0; if it's 0, we jump
back to the loop start; otherwise we end the loop.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here's the code generating LLVM IR from &lt;tt class="docutils literal"&gt;[&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateInBoundsGEP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element_addr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateICmpEQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;compare_zero&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BasicBlock&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loop_body_block&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BasicBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;loop_body&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_func&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BasicBlock&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;post_loop_block&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BasicBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;post_loop&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_func&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateCondBr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;post_loop_block&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loop_body_block&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BracketBlocks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop_body_block&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;post_loop_block&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetInsertPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop_body_block&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the overview and control-flow graph above, I hope it's clear. The most
interesting part is using the basic blocks to represent parts of the loop. When
&lt;tt class="docutils literal"&gt;[&lt;/tt&gt; is encountered, we create both the loop and &amp;quot;post loop&amp;quot; blocks, since the
branch instruction has to refer to them. We also save these blocks on the open
bracket stack to refer to them when the matching &lt;tt class="docutils literal"&gt;]&lt;/tt&gt; is encountered. Finally,
we set our IR builder to insert all subsequent instructions into the loop block.&lt;/p&gt;
&lt;p&gt;This is how &lt;tt class="docutils literal"&gt;]&lt;/tt&gt; is handled:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;DIE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unmatched closing &amp;#39;]&amp;#39; at pc=&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;BracketBlocks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;blocks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;open_bracket_stack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataptr_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dataptr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateInBoundsGEP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;dataptr&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element_addr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;element&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateICmpNE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInt8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;compare_zero&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateCondBr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;blocks&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loop_body_block&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;blocks&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;post_loop_block&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetInsertPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;blocks&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;post_loop_block&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pretty much as we'd expect: the relevant blocks are popped from the stack and
used as targets for another conditional branch &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ir-sample-for-a-simple-bf-program"&gt;
&lt;h2&gt;IR sample for a simple BF program&lt;/h2&gt;
&lt;p&gt;Let's see what LLVM IR our code emits for the simple &lt;tt class="docutils literal"&gt;count1to5.bf&lt;/tt&gt; program:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++

&amp;gt;+++++
[&amp;lt;+.&amp;gt;-]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The full LLVM-based JIT is available in &lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/llvmjit.cpp"&gt;llvmjit.cpp&lt;/a&gt;.
When invoked in verbose mode, it will dump LLVM IR for the translated program
before and after LLVM optimization. Let's start by looking at the
pre-optimization IR. I've added comments on lines starting with &lt;tt class="docutils literal"&gt;###&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define void @__llvmjit() {
entry:

  ### The entry BB starts by declaring the memory and data pointer, and
  ### initializing the data pointer to 0.

  %memory = alloca i8, i32 30000
  call void @llvm.memset.p0i8.i64(i8* %memory, i8 0, i64 30000, i32 1, i1 false)
  %dataptr_addr = alloca i32
  store i32 0, i32* %dataptr_addr

  ### The following 5 instructions increment memory[dataptr] (with dataptr
  ### remaining at 0, as initialized), and they are repeated 48 times...

  %dataptr = load i32, i32* %dataptr_addr
  %element_addr = getelementptr inbounds i8, i8* %memory, i32 %dataptr
  %element = load i8, i8* %element_addr
  %inc_element = add i8 %element, 1
  store i8 %inc_element, i8* %element_addr

  ### ... 47 more times skipped ...

  store i8 %inc_element184, i8* %element_addr182
  %dataptr185 = load i32, i32* %dataptr_addr
  %element_addr186 = getelementptr inbounds i8, i8* %memory, i32 %dataptr185
  %element187 = load i8, i8* %element_addr186
  %inc_element188 = add i8 %element187, 1
  store i8 %inc_element188, i8* %element_addr186

  ### Now incrementing dataptr and 5 more data increments.

  %dataptr189 = load i32, i32* %dataptr_addr
  %inc_dataptr = add i32 %dataptr189, 1
  store i32 %inc_dataptr, i32* %dataptr_addr

  %dataptr190 = load i32, i32* %dataptr_addr
  %element_addr191 = getelementptr inbounds i8, i8* %memory, i32 %dataptr190
  %element192 = load i8, i8* %element_addr191
  %inc_element193 = add i8 %element192, 1
  store i8 %inc_element193, i8* %element_addr191

  ### ... 4 more increments skipped

  ### Load memory[dataptr] and compare it to 0; on true, jump to %post_loop;
  ### on false jump to %loop_body.

  %dataptr210 = load i32, i32* %dataptr_addr
  %element_addr211 = getelementptr inbounds i8, i8* %memory, i32 %dataptr210
  %element212 = load i8, i8* %element_addr211
  %compare_zero = icmp eq i8 %element212, 0
  br i1 %compare_zero, label %post_loop, label %loop_body

loop_body:

  ### Decrement dataptr

  %dataptr213 = load i32, i32* %dataptr_addr
  %dec_dataptr = sub i32 %dataptr213, 1
  store i32 %dec_dataptr, i32* %dataptr_addr

  ### Increment memory[dataptr]

  %dataptr214 = load i32, i32* %dataptr_addr
  %element_addr215 = getelementptr inbounds i8, i8* %memory, i32 %dataptr214
  %element216 = load i8, i8* %element_addr215
  %inc_element217 = add i8 %element216, 1
  store i8 %inc_element217, i8* %element_addr215

  ### Invoke putchar on memory[dataptr]

  %dataptr218 = load i32, i32* %dataptr_addr
  %element_addr219 = getelementptr inbounds i8, i8* %memory, i32 %dataptr218
  %element220 = load i8, i8* %element_addr219
  %element_i32_ = zext i8 %element220 to i32
  %0 = call i32 @putchar(i32 %element_i32_)

  ### Increment dataptr

  %dataptr221 = load i32, i32* %dataptr_addr
  %inc_dataptr222 = add i32 %dataptr221, 1
  store i32 %inc_dataptr222, i32* %dataptr_addr

  ### Decrement memory[dataptr]

  %dataptr223 = load i32, i32* %dataptr_addr
  %element_addr224 = getelementptr inbounds i8, i8* %memory, i32 %dataptr223
  %element225 = load i8, i8* %element_addr224
  %sub_element = sub i8 %element225, 1
  store i8 %sub_element, i8* %element_addr224

  ### Load memory[dataptr] and compare it to 0; on true, jump back to
  ### %loop_body; on false jump to %post_loop.

  %dataptr226 = load i32, i32* %dataptr_addr
  %element_addr227 = getelementptr inbounds i8, i8* %memory, i32 %dataptr226
  %element228 = load i8, i8* %element_addr227
  %compare_zero229 = icmp ne i8 %element228, 0
  br i1 %compare_zero229, label %loop_body, label %post_loop

post_loop
  call void @dump_memory(i8* %memory)
  ret void
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As discussed before, this code is doing a huge amount of repetetive and mostly
unnecessary work. It keeps storing and reloading values it should already have.
But this is precisely what the LLVM optimizer is designed to fix. Let's see the
post-optimization code LLVM produces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define void @__llvmjit() local_unnamed_addr {
loop_body.preheader:
  %memory290 = alloca [30000 x i8], align 1
  %memory290.sub = getelementptr inbounds [30000 x i8], [30000 x i8]* %memory290, i64 0, i64 0
  %0 = getelementptr inbounds [30000 x i8], [30000 x i8]* %memory290, i64 0, i64 2
  call void @llvm.memset.p0i8.i64(i8* nonnull %0, i8 0, i64 29998, i32 1, i1 false)
  store i8 48, i8* %memory290.sub, align 1
  %element_addr191 = getelementptr inbounds [30000 x i8], [30000 x i8]* %memory290, i64 0, i64 1
  store i8 5, i8* %element_addr191, align 1
  br label %loop_body

loop_body:
  %1 = tail call i32 @putchar(i32 49)
  %2 = tail call i32 @putchar(i32 50)
  %3 = tail call i32 @putchar(i32 51)
  %4 = tail call i32 @putchar(i32 52)
  %5 = tail call i32 @putchar(i32 53)
  store i8 53, i8* %memory290.sub, align 1
  store i8 0, i8* %element_addr191, align 1
  call void @dump_memory(i8* nonnull %memory290.sub)
  ret void
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The LLVM optimizer is extremely aggressive! Not only all the repetition is gone,
but there isn't even a loop any more because LLVM statically computed it will
just run 5 times and unrolled it completely. &lt;tt class="docutils literal"&gt;putchar&lt;/tt&gt; is invoked 5 times
with the values the loop would have produced, and that's all. The reason LLVM
kept &lt;tt class="docutils literal"&gt;memory&lt;/tt&gt; around was only so the call to &lt;tt class="docutils literal"&gt;dump_memory&lt;/tt&gt; would have data.
If we remove this debugging call, the function turns into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define void @__llvmjit() local_unnamed_addr #0 {
entry:
  %0 = tail call i32 @putchar(i32 49)
  %1 = tail call i32 @putchar(i32 50)
  %2 = tail call i32 @putchar(i32 51)
  %3 = tail call i32 @putchar(i32 52)
  %4 = tail call i32 @putchar(i32 53)
  ret void
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="observing-how-llvm-handles-our-loops"&gt;
&lt;h2&gt;Observing how LLVM handles our loops&lt;/h2&gt;
&lt;p&gt;So the &lt;tt class="docutils literal"&gt;count1to5&lt;/tt&gt; sample was a bit too simple for the LLVM optimizer. To see
our loops actually being emitted, we'll have to resort to more tricks - by
placing &amp;quot;input&amp;quot; instructions (&lt;tt class="docutils literal"&gt;,&lt;/tt&gt; in BF) in stratetic locations so that LLVM
can't just infer their value statically. Take for example the
(slightly-nonsensical) BF program:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;,

[&amp;lt;+.&amp;gt;,]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It places user input into cell 1, and then repeatedly:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Increments cell 0, printing its value out&lt;/li&gt;
&lt;li&gt;Places new user input in cell 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It will terminate when the user input is 0. Not very useful, but it does the
job. Here's the &lt;em&gt;optimized&lt;/em&gt; IR LLVM emits for it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define void @__llvmjit() local_unnamed_addr {
entry:
  %memory29 = alloca [30000 x i8], align 1
  %memory29.sub = getelementptr inbounds [30000 x i8], [30000 x i8]* %memory29, i64 0, i64 0
  call void @llvm.memset.p0i8.i64(i8* nonnull %memory29.sub, i8 0, i64 30000, i32 1, i1 false)
  %user_input = tail call i32 @getchar()
  %user_input_i8_ = trunc i32 %user_input to i8
  %element_addr = getelementptr inbounds [30000 x i8], [30000 x i8]* %memory29, i64 0, i64 1
  store i8 %user_input_i8_, i8* %element_addr, align 1
  %compare_zero = icmp eq i8 %user_input_i8_, 0
  br i1 %compare_zero, label %post_loop, label %loop_body.preheader

loop_body.preheader:
  br label %loop_body

loop_body:
  %element730 = phi i8 [ %inc_element, %loop_body ], [ 0, %loop_body.preheader ]
  %inc_element = add i8 %element730, 1
  %element_i32_ = zext i8 %inc_element to i32
  %0 = tail call i32 @putchar(i32 %element_i32_)
  %user_input13 = tail call i32 @getchar()
  %user_input_i8_14 = trunc i32 %user_input13 to i8
  %compare_zero20 = icmp eq i8 %user_input_i8_14, 0
  br i1 %compare_zero20, label %post_loop.loopexit, label %loop_body

post_loop.loopexit:
  store i8 %inc_element, i8* %memory29.sub, align 1
  store i8 0, i8* %element_addr, align 1
  br label %post_loop

post_loop:
  call void @dump_memory(i8* nonnull %memory29.sub)
  ret void
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The two most important points to note are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;There's no extra stack movement; like, &lt;em&gt;at all&lt;/em&gt;. LLVM statically computed what
happens at address 0 and address 1 and just juggles virtual registers with
these values, &lt;em&gt;actually storing to memory only outside the loop&lt;/em&gt;!&lt;/li&gt;
&lt;li&gt;To be able to do that, it generated a &lt;tt class="docutils literal"&gt;phi&lt;/tt&gt; instruction at the loop body
start.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The latter is especially important: this is LLVM converting the IR to &lt;em&gt;SSA
form&lt;/em&gt;, where every value is assigned only once and special &lt;tt class="docutils literal"&gt;phi&lt;/tt&gt; nodes are
required to merge multiple possible values. SSA is well outside the scope of
this humble post, but I suggest reading about it. LLVM's &lt;tt class="docutils literal"&gt;mem2reg&lt;/tt&gt; pass
converts our naive stack-using code to SSA with virtual registers, and SSA form
makes it much easier for the compiler to analyze the IR and optimize it
aggressively.&lt;/p&gt;
&lt;p&gt;On the other hand, &lt;em&gt;emitters&lt;/em&gt; of LLVM IR don't have to worry about efficient
usage of virtual registers and can just assign stack slots for all &amp;quot;variables&amp;quot;,
leaving the optimization to LLVM. For our simple use case of BF this may not
matter too much, but think about a classical programming language where a
function may have dozens of variables to track &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="jiting-llvm-ir-to-executable-machine-code"&gt;
&lt;h2&gt;JITing LLVM IR to executable machine code&lt;/h2&gt;
&lt;p&gt;Being able to optimize LLVM IR is just one of the strengths of LLVM &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt;
is using. The other is the ability to efficiently execute this IR at run-time
by JITing it into an excutable in-memory chunk of machine code.&lt;/p&gt;
&lt;p&gt;In &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt;, the part doing this is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SimpleOrcJIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;jit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="cm"&gt;/*verbose=*/&lt;/span&gt;&lt;span class="n"&gt;verbose&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setDataLayout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_target_machine&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;createDataLayout&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;jit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_module&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;JITSymbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_func_sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JIT_FUNC_NAME&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;jit_func_sym&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;DIE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Unable to find symbol &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JIT_FUNC_NAME&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; in module&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JitFuncType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;JitFuncType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jit_func_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;JitFuncType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jit_func_sym&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAddress&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;jit_func_ptr&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which, of course, leaves the question - what is &lt;tt class="docutils literal"&gt;SimpleOrcJit&lt;/tt&gt;? It's a
simplified instantiation of LLVM's &lt;a class="reference external" href="http://llvm.org/docs/tutorial/BuildingAJIT2.html"&gt;newest JIT engine - ORC&lt;/a&gt;. For the full code see
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2017/bfjit/llvm_jit_utils.h"&gt;this header&lt;/a&gt;
and its accompanying source file. My implementation of the JIT is very similar
to the one in the LLVM tutorial, with the addition of dumping the JITed machine
code to a binary file prior to returning an executable pointer to it.&lt;/p&gt;
&lt;p&gt;LLVM's ORC JIT looks formidable, but there's no magic to it. In its essence,
it's just doing the thing &lt;a class="reference external" href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction"&gt;my introduction to JITing&lt;/a&gt;
describes, with with many (many!) more layers on top. One interesting thing I
&lt;em&gt;would&lt;/em&gt; like to mention, though, is how the JIT finds host functions to call,
since it's designed differently from the previous JITs I showed.&lt;/p&gt;
&lt;p&gt;For &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt;, all we do is &lt;em&gt;declare&lt;/em&gt; (without defining) the host functions in
the module, so that we can insert a &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; instruction to these functions. For
example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;declare i32 @putchar(i32) local_unnamed_addr #0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike the approach with &lt;tt class="docutils literal"&gt;asmjit&lt;/tt&gt;-based JITs, we don't encode the address of
the host function in the JITed code. Rather we let the JIT resolve it
automatically. This is done by adding the following &lt;em&gt;resolver&lt;/em&gt; to the JIT:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resolver&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;orc&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;createLambdaResolver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sym&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;find_mangled_symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sym&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JITSymbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sym_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;RTDyldMemoryManager&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getSymbolAddressInProcess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JITSymbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sym_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JITSymbolFlags&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Exported&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JITSymbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second lambda function passed to the resolver is invoked when the LLVM IR
being compiled contains a &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; to a symbol that wasn't defined in the
module. In this case, what we do amounts to a call to &lt;tt class="docutils literal"&gt;dlsym&lt;/tt&gt; with the symbol
name. The constructor of &lt;tt class="docutils literal"&gt;SimpleOrcJIT&lt;/tt&gt; calls
&lt;tt class="docutils literal"&gt;LoadLibraryPermanently(nullptr)&lt;/tt&gt; which translates to &lt;tt class="docutils literal"&gt;dlopen(nullptr,
&lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;, meaning that all symbols contained in the host executable are
visible to the JIT. To accomplish this, &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt; is compiled with the
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-rdynamic&lt;/span&gt;&lt;/tt&gt; linker flag. This way the JITed code can call any function found
in the host code, including standard C library functions like &lt;tt class="docutils literal"&gt;putchar&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-fast-does-it-run"&gt;
&lt;h2&gt;How fast does it run?&lt;/h2&gt;
&lt;p&gt;Let's see how &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt; compares to the JITs developed in &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/"&gt;part 2&lt;/a&gt;.
To make this measurement fair, I'm instrumenting the program to report &lt;em&gt;execution&lt;/em&gt;
time separately from &lt;em&gt;compilation&lt;/em&gt; time, since LLVM may take a while optimizing
a large IR program.&lt;/p&gt;
&lt;p&gt;With this instrumentation, &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt; takes 0.92 seconds to run &lt;tt class="docutils literal"&gt;mandelbrot&lt;/tt&gt;,
which is virtually the same time &lt;tt class="docutils literal"&gt;optasmjit&lt;/tt&gt; took; it takes 0.14 seconds to
run &lt;tt class="docutils literal"&gt;factor&lt;/tt&gt;, half of the time of &lt;tt class="docutils literal"&gt;optasmjit&lt;/tt&gt;. That said, for these programs
LLVM optimizations took roughly the same amount of time as execution, so if you
include everything in - &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt; is equal on &lt;tt class="docutils literal"&gt;factor&lt;/tt&gt; and loses by ~2x on
&lt;tt class="docutils literal"&gt;mandelbrot&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt;. So, as often is the case with JITs, it all depends on the
use case - if we care about run-time of long programs, it makes sense to spend
more time optimizing; it we mostly care about short programs, it doesn't. This
is why many modern JITs (think JavaScript) are multi-stage - starting with a
fast interpreter or &lt;em&gt;baseline&lt;/em&gt; (very light on optimization) JIT, and switching
to a more optimizing JIT if the program turns out to be longer-running than
initially expected.&lt;/p&gt;
&lt;img alt="BF opt3 vs. part 2 jits vs. llvmjit" class="align-center" src="https://eli.thegreenplace.net/images/2017/bf-runtime-vs-llvmjit.png" /&gt;
&lt;p&gt;Optimization-time aside, it's quite amazing that LLVM is managing to reach the
speed of &lt;tt class="docutils literal"&gt;optasmjit&lt;/tt&gt;, which emits tight machine code and uses domain-specific
optimizations to convert whole loops from the BF code to simple O(1) sequences.
This is due to the power of LLVM's optimizer; it is able, on its own, to infer
that some of these loops are really accomplishing trivial computations. I
suggest taking this as an exercise: write simple BF programs and run them
through &lt;tt class="docutils literal"&gt;llvmjit &lt;span class="pre"&gt;--verbose&lt;/span&gt;&lt;/tt&gt; to observe the post-optimization IR. You'll see
that LLVM is able to remove loops like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;[-]&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;[&amp;lt;-&amp;gt;+]&lt;/span&gt;&lt;/tt&gt;, replacing them by
simple data initialization &amp;amp; movement. Bonus points for uncovering other
optimizations that LLVM did but our &lt;tt class="docutils literal"&gt;optasmjit&lt;/tt&gt; didn't - after all, LLVM does
run the &lt;tt class="docutils literal"&gt;factor&lt;/tt&gt; benchmark much faster, so there must be something interesting
there.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;After playing with manual code-generation in part 2, this post demonstrates
using an industrial-strength compiler backend to create a JIT for BF. LLVM is a
large and complex library with a steep learning curve, but once you're past
the initial ramp-up stage it's an extremely powerful tool. LLVM lets you emit
very straightforward code without worrying about things like registers and
recomputing the same values over and over again. Its state-of-the art optimizer
removes all these inefficiencies, producing extremely tight IR. Moreover, LLVM
lets us target multiple architectures very easily from the same code - just
choose which targets you want when configuring &amp;amp; compiling LLVM itself, and you
have a multi-target compiler.&lt;/p&gt;
&lt;p&gt;However, LLVM has downsides as well - it's large, and its compile time is
considerable. This sometimes makes it less desirable in situations where a small
footprint and fast compilation are required. For an interesting account of how
the WebKit developers replaced LLVM with a custom backend for their &amp;quot;last-tier&amp;quot;
optimized JIT, read &lt;a class="reference external" href="https://webkit.org/blog/5852/introducing-the-b3-jit-compiler/"&gt;Introducing the B3 JIT compiler&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;Links to all posts in this series:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/"&gt;Part 1 - an interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/"&gt;Part 2 - an x64 JIT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-3-llvm/"&gt;Part 3 - LLVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-4-in-python/"&gt;Part 4 - Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;As an exercise, move this memory outside the function - by allocating it
on the host and passing a pointer to the JITed code, similarly to how it
was done in &lt;a class="reference external" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/"&gt;part 2&lt;/a&gt;.
Observe how this affects LLVM's optimization, if at all. Read on LLVM's
concepts of &lt;em&gt;volatile&lt;/em&gt; and &lt;em&gt;aliasing&lt;/em&gt; and think about how they may affect
optimizations.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A fun experiment is to remove this initialization and observe what LLVM
does with the code. I had this bug initially, and it's a brilliant
demonstration of LLVM's capability of optimizing code that has undefined
behavior (in this case using uninitialized values).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This CFG is produced automatically by LLVM and is a good example of the
tools provided by default with this framework. To generate it, I took
the LLVM IR file dumped by &lt;tt class="docutils literal"&gt;llvmjit&lt;/tt&gt; in verbose mode, and ran LLVM's
&lt;tt class="docutils literal"&gt;opt&lt;/tt&gt; tool on it with the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-view-cfg-only&lt;/span&gt;&lt;/tt&gt; flag. This makes &lt;tt class="docutils literal"&gt;opt&lt;/tt&gt;
dump a Graphviz &lt;tt class="docutils literal"&gt;.dot&lt;/tt&gt; file which can then be converted to an image.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Exercise: why do we need to save &lt;tt class="docutils literal"&gt;loop_body_block&lt;/tt&gt; at all? When a &lt;tt class="docutils literal"&gt;]&lt;/tt&gt;
is encountered, shouldn't the matching &lt;tt class="docutils literal"&gt;loop_body_block&lt;/tt&gt; be the same
one as the currently populated block?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A cool experiment to try is compile some C function to LLVM IR with
the Clang front-end and observe stack usage in unoptimized code, followed
by running &lt;tt class="docutils literal"&gt;opt &lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt; to see what the optimizer turned it into.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;For &lt;tt class="docutils literal"&gt;mandelbrot&lt;/tt&gt;, the textual representation of LLVM IR generated for
the BF program runs to ~42,000 lines, which takes LLVM 0.8 seconds to
fully optimize.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="LLVM &amp; Clang"></category><category term="Compilation"></category><category term="Code generation"></category></entry><entry><title>Updates for building my LLVM &amp; Clang samples for release 3.7</title><link href="https://eli.thegreenplace.net/2015/updates-for-building-my-llvm-clang-samples-for-release-37/" rel="alternate"></link><published>2015-09-06T06:22:00-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2015-09-06:/2015/updates-for-building-my-llvm-clang-samples-for-release-37/</id><summary type="html">&lt;p&gt;The &lt;tt class="docutils literal"&gt;Makefile&lt;/tt&gt; in my &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;LLVM &amp;amp; Clang samples project&lt;/a&gt; is using &lt;tt class="docutils literal"&gt;g++&lt;/tt&gt; by default as
the C++ compiler. Even though the officially recommended compiler to build Clang
and LLVM is Clang, &lt;tt class="docutils literal"&gt;g++&lt;/tt&gt; has worked well because not everyone has Clang
installed on their system.&lt;/p&gt;
&lt;p&gt;This is going to change very soon â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;The &lt;tt class="docutils literal"&gt;Makefile&lt;/tt&gt; in my &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;LLVM &amp;amp; Clang samples project&lt;/a&gt; is using &lt;tt class="docutils literal"&gt;g++&lt;/tt&gt; by default as
the C++ compiler. Even though the officially recommended compiler to build Clang
and LLVM is Clang, &lt;tt class="docutils literal"&gt;g++&lt;/tt&gt; has worked well because not everyone has Clang
installed on their system.&lt;/p&gt;
&lt;p&gt;This is going to change very soon, when LLVM and Clang 3.7 are released (any day
now, as the release is in RC2 stage). When you build the samples vs. the
binary of release 3.7, you'll likely run into compile errors about
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-Wcovered-switch-default&lt;/span&gt;&lt;/tt&gt;, and maybe other problems. The reason for this has
to do with the following:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;When LLVM &amp;amp; Clang binary releases are created, they are built with Clang.&lt;/li&gt;
&lt;li&gt;Starting with 3.7, LLVM &amp;amp; Clang are built with the
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-Wcovered-switch-default&lt;/span&gt;&lt;/tt&gt; flag by default.&lt;/li&gt;
&lt;li&gt;This also means that the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;llvm-config&lt;/span&gt;&lt;/tt&gt; utility will emit this flag when
queried for compile flags. And my samples' &lt;tt class="docutils literal"&gt;Makefile&lt;/tt&gt; uses &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;llvm-config&lt;/span&gt;&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;GCC &lt;a class="reference external" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61864"&gt;doesn't yet support -Wcovered-switch-default&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are two possible solutions for this issue. The best one is to just use
Clang to build these samples (and any other code linking with LLVM or Clang
themselves). You don't even have to have Clang installed for this; simply
download &lt;a class="reference external" href="http://llvm.org/releases/"&gt;the latest binary release&lt;/a&gt;, and point
&lt;tt class="docutils literal"&gt;CXX&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;bin/clang++&lt;/tt&gt; in the untarred directory. Everything should work,
since Clang will find GCC's include paths, libstd++ and everything else.&lt;/p&gt;
&lt;p&gt;An alternative approach, if you just &lt;em&gt;must&lt;/em&gt; stick to GCC for some reason, is to
sanitize the flags emitted by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;llvm-config&lt;/span&gt;&lt;/tt&gt;, removing those that aren't
supported before passing them to the compiler. This means you won't be able to
use my &lt;tt class="docutils literal"&gt;Makefile&lt;/tt&gt; as is, though.&lt;/p&gt;
&lt;p&gt;In the long run, I suggest to just use Clang to build LLVM &amp;amp; Clang. This is what
the LLVM core developers do to test things and build releases, so this is the
way least susceptible to unexpected problems.&lt;/p&gt;
</content><category term="misc"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Calling back into Python from llvmlite-JITed code</title><link href="https://eli.thegreenplace.net/2015/calling-back-into-python-from-llvmlite-jited-code/" rel="alternate"></link><published>2015-04-18T05:50:00-07:00</published><updated>2025-01-25T13:56:56-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2015-04-18:/2015/calling-back-into-python-from-llvmlite-jited-code/</id><summary type="html">&lt;p&gt;&lt;strong&gt;Update (2025-01-25):&lt;/strong&gt; these days &lt;tt class="docutils literal"&gt;llvmlite&lt;/tt&gt; has binary wheels on PyPI.
For self-contained examples (including this post's), check out
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2015/llvmlite-samples"&gt;this GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;This post is about a somewhat more interesting and complex use of llvmlite than
the basic example presented in &lt;a class="reference external" href="https://eli.thegreenplace.net/2015/building-and-using-llvmlite-a-basic-example/"&gt;my previous article on the subject&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I see compilation as â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Update (2025-01-25):&lt;/strong&gt; these days &lt;tt class="docutils literal"&gt;llvmlite&lt;/tt&gt; has binary wheels on PyPI.
For self-contained examples (including this post's), check out
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2015/llvmlite-samples"&gt;this GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;This post is about a somewhat more interesting and complex use of llvmlite than
the basic example presented in &lt;a class="reference external" href="https://eli.thegreenplace.net/2015/building-and-using-llvmlite-a-basic-example/"&gt;my previous article on the subject&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I see compilation as a meta-tool. It lets us build new levels of
abstraction and expressiveness within our code. We can use it to build
additional languages on top of our host language (common for C, C++ and
Java-based systems, less common for Python), to accelerate some parts of our
host language (more common in Python), or anything in between.&lt;/p&gt;
&lt;p&gt;To fully harness the power of runtime compilation (JITing), however, it's very
useful to know how to bridge the gap between the host language and the JITed
language; preferably in both directions. As the &lt;a class="reference external" href="https://eli.thegreenplace.net/2015/building-and-using-llvmlite-a-basic-example/"&gt;previous article&lt;/a&gt;
shows, calling from the host into the JITed language is trivial. In fact, this
is what JITing is mostly about. But what about the other direction? This is
somewhat more challenging, but leads to interesting uses and additional
capabilities.&lt;/p&gt;
&lt;p&gt;While the post uses llvmlite for the JITing, I believe it presents general
concepts that are relevant for any programming environment.&lt;/p&gt;
&lt;div class="section" id="callback-from-jited-code-to-python"&gt;
&lt;h2&gt;Callback from JITed code to Python&lt;/h2&gt;
&lt;p&gt;Let's start with a simple example: we want to be able to invoke some Python
function from within JITed code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;ctypes&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_void_p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CFUNCTYPE&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;llvmlite.ir&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ir&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;llvmlite.binding&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;llvm&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create_caller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# define i64 @caller(i64 (i64, i64)* nocapture %f, i64 %i) #0 {&lt;/span&gt;
    &lt;span class="c1"&gt;# entry:&lt;/span&gt;
    &lt;span class="c1"&gt;#   %mul = shl nsw i64 %i, 1&lt;/span&gt;
    &lt;span class="c1"&gt;#   %call = tail call i64 %f(i64 %i, i64 %mul) #1&lt;/span&gt;
    &lt;span class="c1"&gt;#   ret i64 %call&lt;/span&gt;
    &lt;span class="c1"&gt;# }&lt;/span&gt;
    &lt;span class="n"&gt;i64_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# The callback function &amp;#39;caller&amp;#39; accepts is a pointer to FunctionType with&lt;/span&gt;
    &lt;span class="c1"&gt;# the appropriate signature.&lt;/span&gt;
    &lt;span class="n"&gt;cb_func_ptr_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_pointer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;caller_func_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cb_func_ptr_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

    &lt;span class="n"&gt;caller_func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;caller_func_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;caller&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;caller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;caller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;irbuilder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IRBuilder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;caller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append_basic_block&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;entry&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;caller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                        &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                        &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mul&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;caller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;caller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;create_caller&lt;/tt&gt; creates a new LLVM IR function called &lt;tt class="docutils literal"&gt;caller&lt;/tt&gt; and injects
it into the given module &lt;tt class="docutils literal"&gt;m&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;If you're not an expert at reading LLVM IR, &lt;tt class="docutils literal"&gt;caller&lt;/tt&gt; is equivalent to this C
function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It takes &lt;tt class="docutils literal"&gt;f&lt;/tt&gt; - a pointer to a function accepting two integers and returning an
integer (all integers in this post are 64-bit), and &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; - an integer. It calls
&lt;tt class="docutils literal"&gt;f&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;i*2&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; as the arguments. That's it - pretty simple, but
sufficient for our demonstration's purposes.&lt;/p&gt;
&lt;p&gt;Now let's define a Python function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;I was called with &lt;/span&gt;&lt;span class="si"&gt;{0}&lt;/span&gt;&lt;span class="s1"&gt; and &lt;/span&gt;&lt;span class="si"&gt;{1}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, let's see how we can pass &lt;tt class="docutils literal"&gt;myfunc&lt;/tt&gt; as the callback &lt;tt class="docutils literal"&gt;caller&lt;/tt&gt; will
invoke. This is fairly straightforward, thanks to the support for callback
functions in &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt;. In fact, it's exactly similar to the way you'd pass
Python callbacks to C code via &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt; without any JITing involved:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Module&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;create_caller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize_native_target&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize_native_asmprinter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;llvm_module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_assembly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;tm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_default_triple&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_target_machine&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# Compile the module to machine code using MCJIT.&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_mcjit_compiler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;llvm_module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;finalize_object&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="c1"&gt;# Obtain a pointer to the compiled &amp;#39;caller&amp;#39; - it&amp;#39;s the address of its&lt;/span&gt;
        &lt;span class="c1"&gt;# JITed code in memory.&lt;/span&gt;
        &lt;span class="n"&gt;CBFUNCTY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CFUNCTYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cfptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_pointer_to_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;llvm_module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;caller&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;callerfunc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CFUNCTYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CBFUNCTY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;cfptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Wrap myfunc in CBFUNCTY and pass it as a callback to caller.&lt;/span&gt;
        &lt;span class="n"&gt;cb_myfunc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CBFUNCTY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Calling &amp;quot;caller&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;callerfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cb_myfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;  The result is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we run this code, we get the expected result:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Calling &amp;quot;caller&amp;quot;
I was called with 42 and 84
  The result is 126
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="registering-host-functions-in-jited-code"&gt;
&lt;h2&gt;Registering host functions in JITed code&lt;/h2&gt;
&lt;p&gt;When developing a JIT, one need that comes up very often is to delegate some of
the functionality in the JITed code to the host language. For example, if you're
developing a JIT to implement a fast DSL, you may not want to reimplement a
whole I/O stack in your language. So you'd prefer to delegate all I/O to the
host language. Taking C as a sample host language, you just want to call
&lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; from your DSL and somehow have it routed to the host call.&lt;/p&gt;
&lt;p&gt;How do we accomplish this feat?  The solution here, naturally, depends on both
the host language and the DSL you're JITing. Let's take the LLVM tutorial as an
example. The Kaleidoscope language does computations on floating point numbers,
but it has no I/O facilities of its own. Therefore, the Kaleidoscope compiler
exposes a &lt;tt class="docutils literal"&gt;putchard&lt;/tt&gt; function from the host (C++) to be callable in
Kaleidoscope. For &lt;a class="reference external" href="http://llvm.org/docs/tutorial/LangImpl04.html"&gt;Kaleidoscope this is fairly simple&lt;/a&gt;, because the host is C++ and is
compiled into machine code in the same process with the JITed code. All the
JITed code needs to know is the symbol name of the host function to call and the
call can happen (as long as the calling conventions match, of course).&lt;/p&gt;
&lt;p&gt;Alas, for Python as a host language, things are not so straightforward. This is
why, in my &lt;a class="reference external" href="https://github.com/eliben/pykaleidoscope/blob/master/chapter5.py"&gt;reimplementation of Kaleidoscope with llvmlite&lt;/a&gt;, I resorted
to implementing the builtins in LLVM IR, emitting them into the module
along with compiled Kaleidoscope code. These builtins just call the underlying C
functions (which still reside in the same process, since Python itself is
written in C) and don't call into Python.&lt;/p&gt;
&lt;p&gt;But say we wanted to actually call Python. How would we go about that?&lt;/p&gt;
&lt;p&gt;Well, we've seen a way to call Python from JITed code in this post. Can this
approach be used? Yes, though it's quite cumbersome. The problem is that the
only place where we have an actual interface between Python and the JITed code
is when we invoke a JITed function. Somehow we should use this interface to
convey to the JIT side what Python functions are available to it and how to call
them. Essentially, we'll have to implement something akin to the following
schematic symbol table interface in the JITed code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;CallbackType&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unordered_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CallbackType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symtab&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;register_callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CallbackType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;symtab&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;CallbackType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;get_callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symtab&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symtab&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To register Python callbacks with the JIT, we'll call &lt;tt class="docutils literal"&gt;register_callback&lt;/tt&gt; from
Python, passing it a name and the callback (&lt;tt class="docutils literal"&gt;CFUNCTYPE&lt;/tt&gt; as shown in the code
sample at the top). The JIT side will remember this mapping in a symbol table.
When it needs to invoke a Python function it will use &lt;tt class="docutils literal"&gt;get_callback&lt;/tt&gt; to
get the pointer by name.&lt;/p&gt;
&lt;p&gt;In addition to being cumbersome to implement &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;, this is also inefficient. It
seems wasteful to go through a symbol table lookup for every call to a Python
builtin. It's not like these mappings ever change in a typical use case! We are
emitting code at runtime here and have so much flexibility at our command - so
this lookup feels like a crutch.&lt;/p&gt;
&lt;p&gt;Moreover, this is a simplified example - every callback takes two integer
arguments. In real scenarios, the signatures of callback functions can be
arbitrary, so we'd have to implement a full blown FFI-dispatching on the calls.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="breaching-the-compile-run-time-barrier"&gt;
&lt;h2&gt;Breaching the compile/run-time barrier&lt;/h2&gt;
&lt;p&gt;We can do better. For every Python function we intend to call from the JITed
code, we can emit a JITed wrapper. This wrapper will hard-code a call to the
Python function, thus removing this dispatching (the symbol table shown above)
from run-time; this totally makes sense because we know at compile time which
Python functions are needed and where to find them.&lt;/p&gt;
&lt;p&gt;Let's write the code to do this with llvmlite:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;ctypes&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;ctypes&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_void_p&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;llvmlite.ir&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ir&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;llvmlite.binding&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;llvm&lt;/span&gt;

&lt;span class="n"&gt;cb_func_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="n"&gt;cb_func_ptr_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cb_func_ty&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_pointer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;i64_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create_addrcaller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# define i64 @addrcaller(i64 %a, i64 %b) #0 {&lt;/span&gt;
    &lt;span class="c1"&gt;# entry:&lt;/span&gt;
    &lt;span class="c1"&gt;#   %f = inttoptr i64% ADDR to i64 (i64, i64)*&lt;/span&gt;
    &lt;span class="c1"&gt;#   %call = tail call i64 %f(i64 %a, i64 %b)&lt;/span&gt;
    &lt;span class="c1"&gt;#   ret i64 %call&lt;/span&gt;
    &lt;span class="c1"&gt;# }&lt;/span&gt;
    &lt;span class="n"&gt;addrcaller_func_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;addrcaller_func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addrcaller_func_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;addrcaller&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;addrcaller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;addrcaller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;irbuilder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IRBuilder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addrcaller_func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append_basic_block&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;entry&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inttoptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i64_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                           &lt;span class="n"&gt;cb_func_ptr_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The IR function created by &lt;tt class="docutils literal"&gt;create_addrcaller&lt;/tt&gt; is somewhat similar to the one
we've seen above with &lt;tt class="docutils literal"&gt;create_caller&lt;/tt&gt;, but there's a subtle difference.
&lt;tt class="docutils literal"&gt;addcaller&lt;/tt&gt; does not take a function pointer at runtime. It has knowledge of
this function pointer encoded into it when it's generated. The &lt;tt class="docutils literal"&gt;addr&lt;/tt&gt; argument
passed into &lt;tt class="docutils literal"&gt;create_addrcaller&lt;/tt&gt; is the runtime address of the function to
call. &lt;tt class="docutils literal"&gt;addrcaller&lt;/tt&gt; converts it to a function pointer (using the &lt;tt class="docutils literal"&gt;inttoptr&lt;/tt&gt;
instruction, which is somewhat similar to a &lt;tt class="docutils literal"&gt;reinterpret_cast&lt;/tt&gt; in C++) and
calls it &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's how to use it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;CBFUNCTY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctypes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CFUNCTYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;I was called with &lt;/span&gt;&lt;span class="si"&gt;{0}&lt;/span&gt;&lt;span class="s1"&gt; and &lt;/span&gt;&lt;span class="si"&gt;{1}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="n"&gt;cb_myfunc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CBFUNCTY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;cb_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctypes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cb_myfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_void_p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Callback address is 0x&lt;/span&gt;&lt;span class="si"&gt;{0:x}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cb_addr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ir&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Module&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;create_addrcaller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cb_addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize_native_target&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize_native_asmprinter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;llvm_module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_assembly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;tm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_default_triple&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_target_machine&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# Compile the module to machine code using MCJIT&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_mcjit_compiler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;llvm_module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;finalize_object&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="c1"&gt;# Now call addrcaller&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Calling &amp;quot;addrcaller&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;addrcaller&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctypes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CFUNCTYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int64&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;
            &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_pointer_to_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;llvm_module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;addrcaller&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;addrcaller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;105&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;  The result is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key trick here is the call to &lt;tt class="docutils literal"&gt;ctypes.cast&lt;/tt&gt;. It takes a Python function
wrapped in a &lt;tt class="docutils literal"&gt;ctypes.CFUNCTYPE&lt;/tt&gt; and casts it to a &lt;tt class="docutils literal"&gt;void*&lt;/tt&gt;; in other words,
it obtains its address &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;. This is the address we pass into
&lt;tt class="docutils literal"&gt;create_addrcaller&lt;/tt&gt;. The code ends up having exactly the same effect as the
previous sample, but with an important difference: whereas previously the
dispatch to &lt;tt class="docutils literal"&gt;myfunc&lt;/tt&gt; happened at run-time, here it happens at compile-time.&lt;/p&gt;
&lt;p&gt;This is a synthetic example, but it should be clear how to extend it to the
full thing mentioned earlier: for each built-in needed by the JITed code from
the host code, we emit a JITed wrapper to call it. No symbol table dispatching
at runtime. Even better, since these builtins can have arbitrary signatures,
the JITed wrapper can handle all of that efficiently. PyPy uses this technique
to make calls into C (via the &lt;tt class="docutils literal"&gt;cffi&lt;/tt&gt; library) much more efficient than they
are with &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt; uses libffi, which has to pack all the arguments
to a function at runtime, according to a type signature it was provided.
However, since this type signature almost never changes during the runtime of
one program, this packing can be done much more efficiently with JITing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Hopefully it's clear that while this article focuses on a very specific
technology (using llvmlite to JIT native code from Python), its principles are
universal. The overarching idea here is that the difference between what happens
when the program is compiled and what happens when it runs is artificial. We can
breach and overlay it in many ways, and use it to build increasingly complex
abstractions. Some languages, like the Lisp family, list this mixture of
compile-time and run-time as one of their unique strengths, and have been
preaching it for decades. I fondly recall my own first real-world use of this
technique &lt;a class="reference external" href="https://eli.thegreenplace.net/2005/09/04/cool-hack-creating-custom-subroutines-on-the-fly-in-perl"&gt;many years ago&lt;/a&gt;
- reading a configuration file and generating code at runtime that unpacks data
based on that configuration. That task, emitting Perl code from Perl according
to a XML config may appear worlds away from the topic of this post - emitting
LLVM IR from Python according to a function signature, but if you really think
about it, it's exactly the same thing.&lt;/p&gt;
&lt;p&gt;I suspect this is one of the most obtuse articles I've written lately; if you
read this far, I sure hope you found it interesting and helpful. Let me know in
the comments if anything isn't clear or if you have relevant ideas - I love
discussing this topic!&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;We'll have to compile the equivalent of a hash table implementation into
our JITed code. While not impossible, this may be an overkill if you
really just want a quick-and-simple DSL.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This delightful mixture of compile-time and run-time is by far the most
important part of this article; if you remember just one thing from here,
this should be it. Let me know in the comments if it's not clear.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The concept of &amp;quot;address&amp;quot; for a Python function may raise an eyebrow. Keep
in mind that this isn't a pure Python function we're talking about here.
It's wrapped in a &lt;tt class="docutils literal"&gt;ctypes.CFUNCTYPE&lt;/tt&gt;, which is a dispatcher created by
&lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt; (&amp;quot;thunk&amp;quot; in the nomenclature of libffi, the underlying
mechanism behind &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt;) to perform argument conversion and make the
actual call.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="LLVM &amp; Clang"></category><category term="Python"></category><category term="Compilation"></category></entry><entry><title>Python version of the LLVM tutorial</title><link href="https://eli.thegreenplace.net/2015/python-version-of-the-llvm-tutorial/" rel="alternate"></link><published>2015-02-08T15:28:00-08:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2015-02-08:/2015/python-version-of-the-llvm-tutorial/</id><summary type="html">&lt;p&gt;The &lt;a class="reference external" href="http://llvm.org/docs/tutorial/"&gt;LLVM tutorial&lt;/a&gt; is a venerable and
important part of the project's documentation. It's been there for as long as
I've been using LLVM (and according to the logs, a few years before that),
almost always the first resource newcomers to the project are pointed to. It
strikes just the â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;The &lt;a class="reference external" href="http://llvm.org/docs/tutorial/"&gt;LLVM tutorial&lt;/a&gt; is a venerable and
important part of the project's documentation. It's been there for as long as
I've been using LLVM (and according to the logs, a few years before that),
almost always the first resource newcomers to the project are pointed to. It
strikes just the right balance between simplicity and interesting content to
provide an enticing introduction to LLVM. For a motivated reader, it shouldn't
take more than a work day or two to go through it from start to finish, building
a full compiler for a simple but &amp;quot;real&amp;quot; programming language in the process; how
cool is that?&lt;/p&gt;
&lt;p&gt;Anyway, it occurred to me that since the &amp;quot;official&amp;quot; version of the tutorial is
in C++ and the only alternative checked into the tree is in OCaml, it may be
interesting to re-implement the tutorial in Python. While I wouldn't write an
industrial strength compiler in Python, it's a great prototyping platform, and
when thinking about compilers and languages in general, prototyping is very
imporatnt. You want to try all kinds of possibilities and combinations of
features quickly, to get a feel for writing code in the language before it's
fully done - and Python (with LLVM) is great for that.&lt;/p&gt;
&lt;p&gt;Enter &lt;a class="reference external" href="https://github.com/eliben/pykaleidoscope/"&gt;Pykaleidoscope&lt;/a&gt;, a project I
put on GitHub that follows the steps of the official LLVM tutorial, but
implementing the Kaleidoscope compiler in Python, using &lt;a class="reference external" href="https://github.com/numba/llvmlite"&gt;llvmlite&lt;/a&gt; as the binding to LLVM.&lt;/p&gt;
&lt;p&gt;Installing llvmlite is fairly easy - see &lt;a class="reference external" href="https://eli.thegreenplace.net/2015/building-and-using-llvmlite-a-basic-example/"&gt;this post&lt;/a&gt;
if you have any issues.&lt;/p&gt;
&lt;p&gt;While working on Pykaleidoscope, I was impressed with llvmlite's maturity and
compatibility with the C++ LLVM IR APIs. I didn't run into any significant
problems, except maybe lack of documentation. But documentation isn't a strong
side of LLVM either, which is one of the problems the tutorial helps with. So I
hope this Python version will help folks understand how to use llvmlite to build
non-trivial LLVM IR in Python.&lt;/p&gt;
</content><category term="misc"></category><category term="LLVM &amp; Clang"></category><category term="Python"></category><category term="Compilation"></category></entry><entry><title>Building and using llvmlite - a basic example</title><link href="https://eli.thegreenplace.net/2015/building-and-using-llvmlite-a-basic-example/" rel="alternate"></link><published>2015-01-26T05:03:00-08:00</published><updated>2025-01-25T13:56:56-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2015-01-26:/2015/building-and-using-llvmlite-a-basic-example/</id><summary type="html">&lt;p&gt;&lt;strong&gt;Update (2025-01-25):&lt;/strong&gt; these days &lt;tt class="docutils literal"&gt;llvmlite&lt;/tt&gt; has binary wheels on PyPI.
For self-contained examples (including this post's), check out
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2015/llvmlite-samples"&gt;this GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;A while ago I wrote a &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/08/10/building-and-using-llvmpy-a-basic-example"&gt;short post about employing llvmpy&lt;/a&gt;
to invoke LLVM from within Python. Today I want to demonstrate an alternative
technique, using a new library â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Update (2025-01-25):&lt;/strong&gt; these days &lt;tt class="docutils literal"&gt;llvmlite&lt;/tt&gt; has binary wheels on PyPI.
For self-contained examples (including this post's), check out
&lt;a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2015/llvmlite-samples"&gt;this GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;A while ago I wrote a &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/08/10/building-and-using-llvmpy-a-basic-example"&gt;short post about employing llvmpy&lt;/a&gt;
to invoke LLVM from within Python. Today I want to demonstrate an alternative
technique, using a new library called &lt;a class="reference external" href="https://github.com/numba/llvmlite"&gt;llvmlite&lt;/a&gt;. llvmlite was created last year by the
developers of Numba (a JIT compiler for scientific Python), and just recently
replaced llvmpy as their bridge to LLVM. Since the Numba devs were also the most
active maintainers of llvmpy in the past couple of years, I think llvmlite is
definitily worth paying attention to.&lt;/p&gt;
&lt;p&gt;One of the reasons the Numba devs decided to ditch llvmpy in favor of a new
approach is the biggest issue heavy users of LLVM as a library have - its
incredible rate of API-breaking change. The LLVM C++ API is notoriously unstable
and will remain this way for the foreseeable future. This leaves library users
and all kinds of language bindings (like llvmpy) in a constant chase after the
latest LLVM release, if they want to benefit from improved optimizations, new
targets and so on. The Numba developers felt this while maintaining llvmpy and
decided on an alternative approach that will be easier to keep stable going
forward. In addition, llvmpy's architecture made it slow for Numba's users -
llvmlite fixes this as well.&lt;/p&gt;
&lt;p&gt;The main idea is - use the LLVM C API as much as possible. Unlike the core C++
API, the C API is meant for facing external users, and is kept relatively
stable. This is what llvmlite does, but with one twist. Since building the IR
using repeated FFI calls to LLVM proved to be slow and error-prone in llvmpy,
llvmlite re-implemented the IR builder in pure Python. Once the IR is built, its
textual representation is passed into the LLVM IR parser. This also reduces the
&amp;quot;API surface&amp;quot; llvmlite uses, since the textual representation of LLVM IR is one
of the more stable things in LLVM.&lt;/p&gt;
&lt;p&gt;I found llvmlite pretty easy to build and use on Linux (though it's portable to
OS X and Windows as well). Since there's not much documentation yet, I thought
this post may be useful for others who wish to get started.&lt;/p&gt;
&lt;p&gt;After cloning the &lt;a class="reference external" href="https://github.com/numba/llvmlite"&gt;llvmlite repo&lt;/a&gt;, I
downloaded the &lt;a class="reference external" href="http://llvm.org/releases/"&gt;binary release of LLVM 3.5&lt;/a&gt; -
pre-built binaries for Ubuntu 14.04 mean there's no need to compile LLVM
itself. Note that I didn't &lt;em&gt;install&lt;/em&gt; LLVM, just downloaded and untarred it.&lt;/p&gt;
&lt;p&gt;Next, I had to install the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;libedit-dev&lt;/span&gt;&lt;/tt&gt; package with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;apt-get&lt;/span&gt;&lt;/tt&gt;, since it's
required while building llvmlite. Depending on what you have lying around on
your machine, you may need to install some additional &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-dev&lt;/span&gt;&lt;/tt&gt; packages.&lt;/p&gt;
&lt;p&gt;Now, time to build llvmlite. I chose to use Python 3.4, but any modern version
should work (for versions below 3.4 llvmlite currently requires the &lt;tt class="docutils literal"&gt;enum34&lt;/tt&gt;
package). LLVM has a great tool named &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;llvm-config&lt;/span&gt;&lt;/tt&gt; in its binary image, and
the &lt;tt class="docutils literal"&gt;Makefile&lt;/tt&gt; in llvmlite uses it, which means building llvmlite with any
version of LLVM I want is just a simple matter of running:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ LLVM_CONFIG=&amp;lt;path/to/llvm-config&amp;gt; python3.4 setup.py build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This compiles the C/C++ parts of llvmlite and links them statically to LLVM.
Now, you're ready to use &lt;tt class="docutils literal"&gt;llvmlite&lt;/tt&gt;. Again, I prefer not to install things
unless I really have to, so the following script can be run with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ PYTHONPATH=$PYTHONPATH:&amp;lt;path/to/llvmlite&amp;gt; python3.4 basic_sum.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Replace the path with your own, or just install llvmlite into some
&lt;tt class="docutils literal"&gt;virtualenv&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;And the sample code does the same as the &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/08/10/building-and-using-llvmpy-a-basic-example"&gt;previous post&lt;/a&gt; -
creates a function that adds two numbers, and JITs it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;ctypes&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CFUNCTYPE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;llvmlite.ir&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ll&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;llvmlite.binding&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;llvm&lt;/span&gt;

&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize_native_target&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initialize_native_asmprinter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Create a new module with a function implementing this:&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# int sum(int a, int b) {&lt;/span&gt;
&lt;span class="c1"&gt;#   return a + b;&lt;/span&gt;
&lt;span class="c1"&gt;# }&lt;/span&gt;
&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Module&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;func_ty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;func_ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;bb_entry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append_basic_block&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;entry&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;irbuilder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IRBuilder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bb_entry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irbuilder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;=== LLVM IR&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Convert textual LLVM IR into in-memory representation.&lt;/span&gt;
&lt;span class="n"&gt;llvm_module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_assembly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;tm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_default_triple&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_target_machine&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Compile the module to machine code using MCJIT&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;llvm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_mcjit_compiler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;llvm_module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;finalize_object&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;=== Assembly&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emit_assembly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;llvm_module&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;# Obtain a pointer to the compiled &amp;#39;sum&amp;#39; - it&amp;#39;s the address of its JITed&lt;/span&gt;
    &lt;span class="c1"&gt;# code in memory.&lt;/span&gt;
    &lt;span class="n"&gt;cfptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ee&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_pointer_to_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;llvm_module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;# To convert an address to an actual callable thing we have to use&lt;/span&gt;
    &lt;span class="c1"&gt;# CFUNCTYPE, and specify the arguments &amp;amp; return type.&lt;/span&gt;
    &lt;span class="n"&gt;cfunc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CFUNCTYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c_int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c_int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;cfptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Now &amp;#39;cfunc&amp;#39; is an actual callable we can invoke&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;The result is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This should print the LLVM IR for the function we built, its assembly as
produced by LLVM's JIT compiler, and the result 59.&lt;/p&gt;
&lt;p&gt;Compared to llvmpy, llvmlite now seems like the future, mostly due to the
maintenance situation. llvmpy is only known to work with LLVM up to 3.3, which
is already a year and half old by now. Having just been kicked out of Numba,
there's a good chance it will fall further behind. llvmlite, on the other hand,
is very actively developed and keeps track with the latest stable LLVM release.
Also, it's architectured in a way that should make it significantly easier to
keep up with LLVM in the future. Unfortunately, as far as uses outside of Numba
go, llvmlite is still rough around the edges, especially w.r.t. documentation
and examples. But the llvmlite developers appear keen on making it useful in a
more general setting and not just for Numba, so that's a good sign.&lt;/p&gt;
</content><category term="misc"></category><category term="LLVM &amp; Clang"></category><category term="Python"></category><category term="Compilation"></category></entry><entry><title>Samples for using LLVM and Clang as a library</title><link href="https://eli.thegreenplace.net/2014/samples-for-using-llvm-and-clang-as-a-library/" rel="alternate"></link><published>2014-11-11T07:10:00-08:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-11-11:/2014/samples-for-using-llvm-and-clang-as-a-library/</id><summary type="html">&lt;p&gt;My &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;llvm-clang-samples&lt;/a&gt;
repository has been public for over a year, and has become quite popular
recently. I figured it's about time I write a quick blog post explaining how it
came to be and what the principles behind it are.&lt;/p&gt;
&lt;p&gt;One on the biggest selling points of LLVM and Clang â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;My &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;llvm-clang-samples&lt;/a&gt;
repository has been public for over a year, and has become quite popular
recently. I figured it's about time I write a quick blog post explaining how it
came to be and what the principles behind it are.&lt;/p&gt;
&lt;p&gt;One on the biggest selling points of LLVM and Clang is that they're packaged as
libraries with a rich C++ API (and also C APIs), and thus can be easily embedded
in larger applications. However, if you look online for samples of making this
embedding happen, you'll start noticing two fairly big problems with most of the
code you find:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;All official LLVM tutorials (and many of the samples online) talk about
building your project &lt;em&gt;inside&lt;/em&gt; the LLVM tree, using LLVM's own build system.
Actually, LLVM has two official build systems (one based on autotools and
another on CMake), so the samples will be further fragmented between these.
While building within the LLVM tree if fine for experimenting, it won't work
if you want to integrate LLVM as a library into a parent project.&lt;/li&gt;
&lt;li&gt;LLVM's and Clang's C++ API is changing constantly; C++ API stability is not a
design goal of the LLVM community (one could argue that &lt;em&gt;instability&lt;/em&gt; is a
design goal). Therefore, if you find some code a few months after it was
posted online, there's a very good chance that it won't compile or run. Code
from a couple of years ago? Forget about it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A few years ago, when I was getting started with LLVM, I was also frustrated by
these problems. So I rolled my sleeves and banged out a simple Makefile that
made it possible to build a few samples out of the LLVM tree, and then
industriously kept it up to date with LLVM and Clang changes. I had it in my
private code coffers for a while, but last year figured it could be useful to
others, so I published it in a &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;public GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The idea of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;llvm-clang-samples&lt;/span&gt;&lt;/tt&gt; is very simple - it's just a bunch of
self-contained programs using LLVM or Clang as libraries, centered around the
&lt;tt class="docutils literal"&gt;Makefile&lt;/tt&gt;, which dictates how to build these programs vs. a built version of
LLVM &amp;amp; Clang itself. I chose a Makefile since it's the lowest common denominator
of build systems - my Makefile is purposefully very simple and linear - think of
it as a shell script with some automatic dependency management thrown in.&lt;/p&gt;
&lt;p&gt;With simple configuration, this Makefile can build programs vs. either a built
source checkout of LLVM, or released binaries (so compiling LLVM itself is not
really required). There's also a suite of tests I run to make sure that the
samples are not only built correctly, but also run correctly and keep producing
expected results.&lt;/p&gt;
&lt;p&gt;The samples themselves cover a wide range of LLVM &amp;amp; Clang uses. There are
standalone programs using LLVM as a library to process LLVM IR. There's a sample
of building a dynamically-linked pass that can be loaded as a plugin with
&lt;tt class="docutils literal"&gt;opt&lt;/tt&gt;. There are samples of &lt;a class="reference external" href="https://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling/"&gt;Clang tooling&lt;/a&gt;,
a Clang plugin, and so on.&lt;/p&gt;
&lt;p&gt;How do I keep the repository up-to-date, though? There are two paths. First,
every time there is a new official LLVM release (this happens about twice a
year), I make sure the samples build and work fine with it, and create a new
branch. Forever after, checking this branch out will give you the repository in
a state that works with the relevant released version. This is very useful
because for most users, the bleeding edge is not required and they can do just
fine with the latest released version. Moreover, if there's a need to work with
an even older release, the repository already has &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/branches"&gt;some history&lt;/a&gt;, going back to LLVM
3.3 (released in June 2013).&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;master&lt;/tt&gt; branch of the repository is kept in sync with LLVM by me
manually, and the &amp;quot;last known good LLVM revision&amp;quot; it works against appears on
the main README file. I usually try to refresh it every week or two. It's very
rare for it to fall more than a few weeks behind. And of course, if you find it
&lt;em&gt;did&lt;/em&gt; fall behind, don't hesitate to open an issue (or better yet, create a pull
request) - I usually get to these fairly quickly.&lt;/p&gt;
</content><category term="misc"></category><category term="Compilation"></category><category term="LLVM &amp; Clang"></category><category term="C &amp; C++"></category></entry><entry><title>AST matchers and Clang refactoring tools</title><link href="https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools" rel="alternate"></link><published>2014-07-29T20:22:19-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-07-29:/2014/07/29/ast-matchers-and-clang-refactoring-tools</id><summary type="html">
        &lt;p&gt;Clang tooling sees lots of interest and development focus in the past few years. At last, we have a convenient, accurate, open-source and well supported framework for programmatically analyzing and refactoring C++ code; I find this very exciting.&lt;/p&gt;
&lt;p&gt;A great outcome of this rapid pace of development is that new â€¦&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;Clang tooling sees lots of interest and development focus in the past few years. At last, we have a convenient, accurate, open-source and well supported framework for programmatically analyzing and refactoring C++ code; I find this very exciting.&lt;/p&gt;
&lt;p&gt;A great outcome of this rapid pace of development is that new APIs and tools spring up all the time. For example, some time ago the Clang tooling developers figured out folks doing AST traversals have to write a lot of repetitive code to find interesting AST nodes, so they came up with a great new API called &lt;a class="reference external" href="http://clang.llvm.org/docs/LibASTMatchers.html"&gt;AST matchers&lt;/a&gt;, which I want to discuss here.&lt;/p&gt;
&lt;div class="section" id="visitors-vs-matchers"&gt;
&lt;h3&gt;Visitors vs. matchers&lt;/h3&gt;
&lt;p&gt;Here's a motivating example. Suppose we're looking for pointer-typed variables being used in &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; comparisons. To make this more specific, let's say we're looking for cases where the pointer-typed variable is on the left-hand-side of an equality comparison (&lt;tt class="docutils literal"&gt;==&lt;/tt&gt;). To find such nodes in a recursive visitor, we'd have to write something like this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;bool&lt;/span&gt; VisitIfStmt(IfStmt *s) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BinaryOperator *BinOP =
          llvm::dyn_cast&amp;lt;BinaryOperator&amp;gt;(s-&amp;gt;getCond())) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (BinOP-&amp;gt;getOpcode() == BO_EQ) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Expr *LHS = BinOP-&amp;gt;getLHS();
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; ImplicitCastExpr *Cast =
              llvm::dyn_cast&amp;lt;ImplicitCastExpr&amp;gt;(LHS)) {
        LHS = Cast-&amp;gt;getSubExpr();
      }

      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; DeclRefExpr *DeclRef = llvm::dyn_cast&amp;lt;DeclRefExpr&amp;gt;(LHS)) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; VarDecl *Var =
                llvm::dyn_cast&amp;lt;VarDecl&amp;gt;(DeclRef-&amp;gt;getDecl())) {
          &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (Var-&amp;gt;getType()-&amp;gt;isPointerType()) {
            Var-&amp;gt;dump();  &lt;span style="color: #007f00"&gt;// YAY found it!!&lt;/span&gt;
          }
        }
      }
    }
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is quite a bit of code, but nothing out of the ordinary if you've been working with Clang ASTs for a while. Perhaps it can be golfed down into a somewhat shorter form, but the main problem is that to write this one has to go through quite a bit of documentation and header files to figure out which methods to call and what kinds of objects they return.&lt;/p&gt;
&lt;p&gt;Here's the equivalent AST matcher:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Finder.addMatcher(
    ifStmt(hasCondition(binaryOperator(
        hasOperatorName(&lt;span style="color: #7f007f"&gt;&amp;quot;==&amp;quot;&lt;/span&gt;),
        hasLHS(ignoringParenImpCasts(declRefExpr(
            to(varDecl(hasType(pointsTo(AnyType))).bind(&lt;span style="color: #7f007f"&gt;&amp;quot;lhs&amp;quot;&lt;/span&gt;)))))))),
    &amp;amp;HandlerForIf);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some difference, right? The declarative nature of matcher definitions makes this very natural to read and to map to the actual problem. &lt;tt class="docutils literal"&gt;HandlerForIf&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;MatchCallback&lt;/tt&gt; object that has direct access to the bound nodes of the matcher:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;struct&lt;/span&gt; IfStmtHandler : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; MatchFinder::MatchCallback {
  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; MatchFinder::MatchResult &amp;amp;Result) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; VarDecl *lhs = Result.Nodes.getNodeAs&amp;lt;VarDecl&amp;gt;(&lt;span style="color: #7f007f"&gt;&amp;quot;lhs&amp;quot;&lt;/span&gt;);
    lhs-&amp;gt;dump();   &lt;span style="color: #007f00"&gt;// YAY found it!!&lt;/span&gt;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's actually quite a bit of documentation available about AST matchers on the official Clang website. For a complete example that can be built outside of the LLVM tree, I redid the &lt;a class="reference external" href="https://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling/"&gt;tooling sample from the previous article&lt;/a&gt;, now &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src_clang/matchers_rewriter.cpp"&gt;with AST matchers&lt;/a&gt; (all available in the &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/"&gt;llvm-clang-samples repository&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-clang-query-to-test-matchers-and-explore-the-ast"&gt;
&lt;h3&gt;Using clang-query to test matchers and explore the AST&lt;/h3&gt;
&lt;p&gt;An interesting new tool in Clang-land is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-query&lt;/span&gt;&lt;/tt&gt;. It's an interactive evaluator for AST matchers that can be used both to test your matchers and do some programmatic exploration of the AST. Let's say we want to develop an AST matcher for pointer comparisons, similar to the one shown above. Here's a sample input file we're going to work on:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* p, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; v) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (p == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; v + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; v - &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's fire up &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-query&lt;/span&gt;&lt;/tt&gt; and see what it can do:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang-query /tmp/iflhsptr.c --
clang-query&amp;gt; set output diag
clang-query&amp;gt; match functionDecl()

Match #1:

/tmp/iflhsptr.c:1:1: note: &amp;quot;root&amp;quot; binds here
int foo(int* p, int v) {
^~~~~~~~~~~~~~~~~~~~~~~~
1 match.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a basic smoke test to see how it matches the function declaration. The output mode set in the first command could also ask the tool to dump or print the AST, but for our purpose the diagnostic output is convenient.&lt;/p&gt;
&lt;p&gt;Here's how we can match deeper nodes and bind them:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;clang-query&amp;gt; match ifStmt(hasCondition(binaryOperator(hasOperatorName(&amp;quot;==&amp;quot;)).bind(&amp;quot;op&amp;quot;)))

Match #1:

/tmp/iflhsptr.c:2:7: note: &amp;quot;op&amp;quot; binds here
  if (p == 0) {
      ^~~~~~
/tmp/iflhsptr.c:2:3: note: &amp;quot;root&amp;quot; binds here
  if (p == 0) {
  ^~~~~~~~~~~~~
1 match.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we intend to provide our own bindings, the root binding can be turned off:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;clang-query&amp;gt; set bind-root false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's see multiple matches:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;clang-query&amp;gt; match varDecl().bind(&amp;quot;var&amp;quot;)

Match #1:

/tmp/iflhsptr.c:1:9: note: &amp;quot;var&amp;quot; binds here
int foo(int* p, int v) {
        ^~~~~~

Match #2:

/tmp/iflhsptr.c:1:17: note: &amp;quot;var&amp;quot; binds here
int foo(int* p, int v) {
                ^~~~~
2 matches.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point I'll stop because long matchers don't format conveniently in a blog post, but I'm sure you got the idea. It's very obvious how helpful this tool can be with developing matchers. It's still new and has some rough edges, but is already quite useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="refactoring-tools-and-replacements"&gt;
&lt;h3&gt;Refactoring tools and replacements&lt;/h3&gt;
&lt;p&gt;With the growing usage of libTooling, it's hardly surprising that its developers keep coming up with higher levels of abstraction that help writing new tools with less and less effort. The AST matchers framework presented above is one example. Another is &lt;tt class="docutils literal"&gt;RefactoringTool&lt;/tt&gt;, a subclass of &lt;tt class="docutils literal"&gt;ClangTool&lt;/tt&gt; that makes it possible to craft new tools with very little code. I'll show an example soon, but first a word about replacements.&lt;/p&gt;
&lt;p&gt;The tools I was demonstrating so far used a &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; to change the underlying source code in response to finding interesting things in the AST. This is a good approach, but it has a problem scaling for large projects. Imagine running a tool over a large project with many source files and many header files. Some of rewritings may need to happen in the header files, but how to manage that, given that the same headers get included into multiple translation units? Some edits may end up being duplicated or even conflicting, and that's a problem.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Replacement&lt;/tt&gt;s are the solution. The source transformation task is divided into two distinct steps:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Custom tools go through the source base, finding the refactoring patterns to apply, and generating serialized replacements into files. Think of replacements as something like patch files (precise directions of how to modify a source file), but in a somewhat friendlier format.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-apply-replacements&lt;/span&gt;&lt;/tt&gt; can then run with access to all replacements, perform the required de-duplication and conflict resolution and actually apply the changes to the source.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This approach also allows nice parallelization of the refactoring over huge code-bases, though there aren't many projects and companies in the world with source code large enough to make this a real problem.&lt;/p&gt;
&lt;p&gt;Back to an example then. I took the simple sample tool from the previous article (just finding interesting &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; nodes and adding some comments into them) and rewrote it once again, using &lt;tt class="docutils literal"&gt;RefactoringTool&lt;/tt&gt; and replacements. &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src_clang/matchers_replacements.cpp"&gt;The full code is available in the samples project&lt;/a&gt;, but it's so short that I can show most of it here.&lt;/p&gt;
&lt;p&gt;Here's the complete &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; function. For ease of hacking it just dumps the replacements to stdout instead of serializing or applying them:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; main(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; argc, &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt; **argv) {
  CommonOptionsParser op(argc, argv, ToolingSampleCategory);
  RefactoringTool Tool(op.getCompilations(), op.getSourcePathList());

  &lt;span style="color: #007f00"&gt;// Set up AST matcher callbacks.&lt;/span&gt;
  IfStmtHandler HandlerForIf(&amp;amp;Tool.getReplacements());

  MatchFinder Finder;
  Finder.addMatcher(ifStmt().bind(&lt;span style="color: #7f007f"&gt;&amp;quot;ifStmt&amp;quot;&lt;/span&gt;), &amp;amp;HandlerForIf);

  &lt;span style="color: #007f00"&gt;// Run the tool and collect a list of replacements. We could call&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// runAndSave, which would destructively overwrite the files with&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// their new contents. However, for demonstration purposes it&amp;#39;s&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// interesting to show the replacements.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; Result = Tool.run(newFrontendActionFactory(&amp;amp;Finder).get())) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; Result;
  }

  llvm::outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;Replacements collected by the tool:\n&amp;quot;&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;auto&lt;/span&gt; &amp;amp;r : Tool.getReplacements()) {
    llvm::outs() &amp;lt;&amp;lt; r.toString() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IfStmtHandler&lt;/tt&gt; is just a &lt;tt class="docutils literal"&gt;MatchCallback&lt;/tt&gt; that is triggered on &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; statements:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;IfStmtHandler&lt;/span&gt; : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; MatchFinder::MatchCallback {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  IfStmtHandler(Replacements *Replace) : Replace(Replace) {}

  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; MatchFinder::MatchResult &amp;amp;Result) {
    &lt;span style="color: #007f00"&gt;// The matched &amp;#39;if&amp;#39; statement was bound to &amp;#39;ifStmt&amp;#39;.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; IfStmt *IfS =
          Result.Nodes.getNodeAs&amp;lt;clang::IfStmt&amp;gt;(&lt;span style="color: #7f007f"&gt;&amp;quot;ifStmt&amp;quot;&lt;/span&gt;)) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Stmt *Then = IfS-&amp;gt;getThen();
      Replacement Rep(*(Result.SourceManager), Then-&amp;gt;getLocStart(), &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;,
                      &lt;span style="color: #7f007f"&gt;&amp;quot;// the &amp;#39;if&amp;#39; part\n&amp;quot;&lt;/span&gt;);
      Replace-&amp;gt;insert(Rep);

      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Stmt *Else = IfS-&amp;gt;getElse()) {
        Replacement Rep(*(Result.SourceManager), Else-&amp;gt;getLocStart(), &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;,
                        &lt;span style="color: #7f007f"&gt;&amp;quot;// the &amp;#39;else&amp;#39; part\n&amp;quot;&lt;/span&gt;);
        Replace-&amp;gt;insert(Rep);
      }
    }
  }

&lt;span style="color: #00007f; font-weight: bold"&gt;private&lt;/span&gt;:
  Replacements *Replace;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how little boilerplate this code contains. The tool is set up in just a handful of lines of code, and most of my code deals with the actual refactoring at hand. This definitely makes writing tools quicker and easier than ever before.&lt;/p&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Compilation databases for Clang-based tools</title><link href="https://eli.thegreenplace.net/2014/05/21/compilation-databases-for-clang-based-tools" rel="alternate"></link><published>2014-05-21T22:09:14-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-05-21:/2014/05/21/compilation-databases-for-clang-based-tools</id><summary type="html">
        &lt;p&gt;If you're interested in writing analysis and source-rewriting tools with Clang's libTooling, you may have run into the following ominous error while trying to invoke a tool on some code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang-check -analyze div0.c
LLVM ERROR: Could not auto-detect compilation database for file &amp;quot;div0.c&amp;quot;
No compilation database found in â€¦&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
        &lt;p&gt;If you're interested in writing analysis and source-rewriting tools with Clang's libTooling, you may have run into the following ominous error while trying to invoke a tool on some code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang-check -analyze div0.c
LLVM ERROR: Could not auto-detect compilation database for file &amp;quot;div0.c&amp;quot;
No compilation database found in /tmp or any parent directory
json-compilation-database: Error while opening JSON database:
     No such file or directory
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what's a &lt;em&gt;compilation database&lt;/em&gt;, why do Clang tools need it, and how do you go about creating one?&lt;/p&gt;
&lt;div class="section" id="motivation-faithfully-reproducing-a-compilation"&gt;
&lt;h3&gt;Motivation - faithfully reproducing a compilation&lt;/h3&gt;
&lt;p&gt;Unlike many other source analysis tools (for example - syntax coloring in editors) which only provide approximate parsing of C++ source, Clang tools are the real thing. The same compiler frontend that's used to actually parse and compile source is used to build the AST for analysis. This is great because it means you never get false positives; but it also means the analysis tools need the complete information available to the compiler when looking at source files.&lt;/p&gt;
&lt;p&gt;When we compile code we pass all kinds of flags to the compiler. Warning flags, language-version flags, etc. But most importantly - macro definitions (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-D&lt;/span&gt;&lt;/tt&gt;)) and include directories (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-I&lt;/span&gt;&lt;/tt&gt;). Without the latter, &lt;a class="reference external" href="https://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;it's not even possible to parse the source code properly&lt;/a&gt;. Historically, a &amp;quot;classical&amp;quot; C compiler pipeline used to run the preprocessor (&lt;tt class="docutils literal"&gt;cpp&lt;/tt&gt;) to take care of these before the compiler would even see the file. These days modern compilers like Clang combine preprocessing with parsing, but the fundamentals remain in place.&lt;/p&gt;
&lt;p&gt;OK then, we need to know which flags the code was compiled with. How do we pass this information to tools?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fixed-compilation-database"&gt;
&lt;h3&gt;Fixed compilation database&lt;/h3&gt;
&lt;p&gt;This is where the concept of &amp;quot;compilation database&amp;quot; comes in. In simple terms, it's a collection of exact compilation commands for a set of files. I'll discuss it in more detail shortly, but first a brief detour into specifying the commands in a simple way that doesn't require a special file.&lt;/p&gt;
&lt;p&gt;A &amp;quot;fixed&amp;quot; compilation database allows us to pass the compilation flags to a tool on the command-line, following a special token &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt;. Here's a complete example that will demonstrate what I mean. Consider this code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;#define DODIV(a, b) ((a) / (b))&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;test&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; z) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (z == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
&lt;span style="color: #007f00"&gt;#ifdef FOO&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; DODIV(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, z);
&lt;span style="color: #007f00"&gt;#else&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; - z;
&lt;span style="color: #007f00"&gt;#endif&lt;/span&gt;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; + z;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-check&lt;/span&gt;&lt;/tt&gt; simply as shown in the beginning of the post results in an error message. If we tack a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; to the end of the command-line, however, it works:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang-check -analyze div0.c --
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By &amp;quot;works&amp;quot; here I mean &amp;quot;does not die with an error&amp;quot;. But it doesn't report anything either, while I'd expect it to detect a division by zero in the &lt;tt class="docutils literal"&gt;if (z == 0)&lt;/tt&gt; case &lt;a class="footnote-reference" href="#id6" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is because we didn't provide any compiler flags. So the analysis assumed the file is compiled like so:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang -c div0.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Indeed, note that the &amp;quot;divide by 0&amp;quot; error happens only if the &lt;tt class="docutils literal"&gt;FOO&lt;/tt&gt; macro is defined. It's not defined here, so the analyzer is quiet &lt;a class="footnote-reference" href="#id7" id="id2"&gt;[2]&lt;/a&gt;. Let's define it then:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ $clang-check -analyze div0.c -- -DFOO
/tmp/div0.c:6:12: warning: Division by zero
    return DODIV(1, z);
           ^~~~~~~~~~~
/tmp/div0.c:1:26: note: expanded from macro &amp;#39;DODIV&amp;#39;
#define DODIV(a, b) ((a) / (b))
                     ~~~~^~~~~
1 warning generated.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So providing compilation commands to tools on the command-line is easy. However, if you want to run analyses/transformations over larger projects for which some sort of build system already exists, you'll probably find a real compilation database more useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="json-compilation-database"&gt;
&lt;h3&gt;JSON compilation database&lt;/h3&gt;
&lt;p&gt;When Clang tools complain they can't find a compilation database, what they actually mean is a specially named JSON file in either the same directory as the file being processed or in one of its parent directories. The &lt;a class="reference external" href="http://clang.llvm.org/docs/JSONCompilationDatabase.html"&gt;JSON compilation database&lt;/a&gt; is very simple. Here's an example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;[
{
  &lt;span style="color: #7f007f"&gt;&amp;quot;directory&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;command&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;gcc div0.c&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;file&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp/div0.c&amp;quot;&lt;/span&gt;
},
{
  &lt;span style="color: #7f007f"&gt;&amp;quot;directory&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;command&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;gcc -DFOO div0.c&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;file&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp/div0.c&amp;quot;&lt;/span&gt;
}
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's just a list of entries, each of which consists of these fields:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;File: the file to which the compilation applies&lt;/li&gt;
&lt;li&gt;Command: the exact compilation command used&lt;/li&gt;
&lt;li&gt;Directory: the directory from which the compilation is executed &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see above, there may be multiple entries for the same file. This is not a mistake - it's entirely plausible that the same file gets compiled multiple times inside a project, each time with different options.&lt;/p&gt;
&lt;p&gt;If you paste this into a file name &lt;tt class="docutils literal"&gt;compile_commands.json&lt;/tt&gt; and place it in the same directory (or any of its parents) with the file you want to run the analysis on, the tool will work without requiring the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; part, because it can find the file in the compilation database and infer the compilation command on its own. If the tool finds more than one entry for a file, it just runs multiple times, once per entry. As far as the tool is concerned, two compilations of the same file can be entirely different due to differences in flags.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="compilation-database-for-transformation-tools"&gt;
&lt;h3&gt;Compilation database for transformation tools&lt;/h3&gt;
&lt;p&gt;Source transformation tools use a compilation database similarly to analysis tools. Consider this contrived example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* foo() {
&lt;span style="color: #007f00"&gt;#ifdef FOO&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
&lt;span style="color: #007f00"&gt;#else&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
&lt;span style="color: #007f00"&gt;#endif&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's save this file as &lt;tt class="docutils literal"&gt;nullptr.cpp&lt;/tt&gt; and run &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-modernize&lt;/span&gt; &lt;span class="pre"&gt;-use-nullptr&lt;/span&gt;&lt;/tt&gt; on it to transform all &amp;quot;NULL-pointer like&amp;quot; constants to an actual &lt;tt class="docutils literal"&gt;nullptr&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ $LLVMGH/clang-modernize -use-nullptr -summary nullptr.cpp --
Transform: UseNullptr - Accepted: 1
$ cat nullptr.cpp
#include &amp;lt;stdlib.h&amp;gt;

int* foo() {
#ifdef FOO
  return 0;
#else
  return nullptr;
#endif
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As expected, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-modernize&lt;/span&gt;&lt;/tt&gt; only replaced within the &lt;tt class="docutils literal"&gt;#else&lt;/tt&gt; clause because &lt;tt class="docutils literal"&gt;FOO&lt;/tt&gt; is not defined. We already know how to define it on the command line. We also know that a hypothetical compilation database could provide two entries for &lt;tt class="docutils literal"&gt;nullptr.cpp&lt;/tt&gt; - one with and one without &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-DFOO&lt;/span&gt;&lt;/tt&gt;. In this case, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-modernize&lt;/span&gt;&lt;/tt&gt; would actually run twice over the same file and replace both the &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; and the &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-a-compilation-database-for-your-project"&gt;
&lt;h3&gt;Creating a compilation database for your project&lt;/h3&gt;
&lt;p&gt;By now we have a good understanding of how to provide Clang tools with  compilation flags for simple files. What about whole projects, however? Assume you have a large existing project and you want to run tools on its source code. You already have a build system of some sort that compiles all the files. How do you tell Clang tools which flags are suitable for any file in the project?&lt;/p&gt;
&lt;p&gt;There are a few good options. A reasonably recent version of the CMake build tool supports emitting compilation databases &lt;a class="footnote-reference" href="#id9" id="id5"&gt;[4]&lt;/a&gt;. All you need is to run the &lt;tt class="docutils literal"&gt;cmake&lt;/tt&gt; step with the  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-DCMAKE_EXPORT_COMPILE_COMMANDS&lt;/span&gt;&lt;/tt&gt; flag, and CMake will take it from there, emitting a &lt;tt class="docutils literal"&gt;compile_commands.json&lt;/tt&gt; file into your build directory.&lt;/p&gt;
&lt;p&gt;If you're not using CMake, there are other options. The Ninja build tool can also emit a compilation database since version 1.2, so a Gyp/Ninja combination should be good too.&lt;/p&gt;
&lt;p&gt;If your project doesn't use either, you should be able to roll your own without too much difficulty. Tools like &lt;a class="reference external" href="https://github.com/rizsotto/Bear"&gt;Build EAR&lt;/a&gt; may be helpful here.&lt;/p&gt;
&lt;p&gt;By the way, it should be clear that large projects is precisely the raison d'Ãªtre of compilation databases. A single &amp;quot;database&amp;quot; file contains complete information about all the source files in the project, providing Clang tools with the compilation commands required to do their tasks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-custom-compilation-database"&gt;
&lt;h3&gt;A custom compilation database&lt;/h3&gt;
&lt;p&gt;It may be the case that you have a very specialized build system that already keeps some sort of record of the flags used to build each file. This is sometimes the case in large companies with monolithic code bases. For such scenarios, you'll be happy to find out that this aspect of Clang tools is fully customizable, because compilation database readers are based on a plugin system. The &lt;tt class="docutils literal"&gt;CompilationDatabase&lt;/tt&gt; interface (&lt;tt class="docutils literal"&gt;clang/include/clang/Tooling/CompilationDatabase.h&lt;/tt&gt;) is something you can implement on your own. The same header file that defines the interface also defines &lt;tt class="docutils literal"&gt;CompilationDatabasePlugin&lt;/tt&gt;, which can be used to link your own compilation database readers to Clang tools.&lt;/p&gt;
&lt;p&gt;The existing JSON compilation database implementation (&lt;tt class="docutils literal"&gt;clang/lib/Tooling/JSONCompilationDatabase.cpp&lt;/tt&gt;) is implemented as such a plugin, so there's a handy in-tree example for rolling your own.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="final-words"&gt;
&lt;h3&gt;Final words&lt;/h3&gt;
&lt;p&gt;For most users of Clang tools and people interested in writing custom tools, this post contains way too much information. Most chances are you won't need all of this. But I felt it's important, for the sake of completeness, to describe in full detail what compilation databases are, and how they tie into the large picture.&lt;/p&gt;
&lt;p&gt;This will help me focus on more internals and examples of Clang tooling in future posts without worrying about compilation databases again.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-check&lt;/span&gt;&lt;/tt&gt; is the Clang static analysis tool; it performs control-flow based analysis that can detect cases like this.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;To motivate this - you wouldn't want the analyzer to bug you about &amp;quot;errors&amp;quot; in code that's &lt;tt class="docutils literal"&gt;#if 0&lt;/tt&gt;-ed out, or hidden behind an &lt;tt class="docutils literal"&gt;#ifdef&lt;/tt&gt; for a different compiler/platform, would you?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that this is critical for things like relative paths to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-I&lt;/span&gt;&lt;/tt&gt; - the tool needs to know where the compiler was actually invoked from to find the directories.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is what the upstream LLVM project uses for its own needs.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Modern source-to-source transformation with Clang and libTooling</title><link href="https://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling" rel="alternate"></link><published>2014-05-01T19:08:14-07:00</published><updated>2023-02-04T13:41:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-05-01:/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling</id><summary type="html">
        &lt;p&gt;I couple of years ago I published a blog post named &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/06/08/basic-source-to-source-transformation-with-clang/"&gt;Basic source-to-source transformation with Clang&lt;/a&gt;, in which I presented a small but complete sample of a tool that performs C++ source-to-source rewriting using Clang. That post was (and still is) quite popular, but also severely out of date;  it's â€¦&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;I couple of years ago I published a blog post named &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/06/08/basic-source-to-source-transformation-with-clang/"&gt;Basic source-to-source transformation with Clang&lt;/a&gt;, in which I presented a small but complete sample of a tool that performs C++ source-to-source rewriting using Clang. That post was (and still is) quite popular, but also severely out of date;  it's time to fix that.&lt;/p&gt;
&lt;p&gt;Clang is moving forward very fast. Today, to develop tools similar to the one presented in that post one should use the &amp;quot;tooling&amp;quot; library (libTooling). I hinted at its existence even in that post, but it was still at its infancy then. Now libTooling is a fairly mature layer through which it's possible to interact with Clang. Moreover, there are reasons to be optimistic about its stability, since tools using it pop up all the time, both in and outside the LLVM/Clang source tree &lt;a class="footnote-reference" href="#id4" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So I rewrote the tool presented in the &lt;a class="reference external" href="https://eli.thegreenplace.net/2012/06/08/basic-source-to-source-transformation-with-clang/"&gt;previous post&lt;/a&gt; using libTooling. The tool is very basic, but it demonstrates a lot of the machinery. It takes C++ code like:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* a, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; *b) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (a[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] &amp;gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) {
    b[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] = &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And adds some descriptive comments:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Begin function foo returning void&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* a, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; *b) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (a[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] &amp;gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) &lt;span style="color: #007f00"&gt;// the &amp;#39;if&amp;#39; part&lt;/span&gt;
  {
    b[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] = &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;
  }
}
&lt;span style="color: #007f00"&gt;// End function foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Non-trivial code samples pasted into blog posts tend to go stale, so this time I'll just directly link to my &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;Github repository for LLVM and Clang samples&lt;/a&gt;, which I'm keeping functional fairly close to the LLVM trunk (as well as with released versions of LLVM, in branches). The direct path to the sample described here is &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src_clang/tooling_sample.cpp"&gt;src_clang/tooling_sample.cpp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The good thing about this repository is that it comes complete with a makefile which builds the tools &amp;amp; samples &lt;em&gt;out of tree&lt;/em&gt;, meaning that they can reside anywhere as long as the paths to LLVM &amp;amp; Clang headers and libraries are set up correctly. If you've ever tried to build an out-of-tree tool using LLVM or Clang as a library, you will not underestimate the utility of having this makefile available and continuously updated ;-)&lt;/p&gt;
&lt;p&gt;Anyway, it's time to explain the code.&lt;/p&gt;
&lt;div class="section" id="implementing-the-transformation-itself"&gt;
&lt;h3&gt;Implementing the transformation itself&lt;/h3&gt;
&lt;p&gt;The low-level details of the sample haven't changed much. An implementation of the &lt;tt class="docutils literal"&gt;ASTConsumer&lt;/tt&gt; interface chooses which AST parsing events to handle. &lt;tt class="docutils literal"&gt;MyASTConsumer&lt;/tt&gt; implements &lt;tt class="docutils literal"&gt;HandleTopLevelDecl&lt;/tt&gt;, so it will be invoked on each top-level declaration in the AST. It uses an implementation of &lt;tt class="docutils literal"&gt;RecursiveASTVisitor&lt;/tt&gt; to do the actual traversal over declaration AST nodes. &lt;tt class="docutils literal"&gt;MyASTVisitor&lt;/tt&gt; implements &lt;tt class="docutils literal"&gt;VisitFunctionDecl&lt;/tt&gt; to be able to emit comments before and after function definitions, and &lt;tt class="docutils literal"&gt;VisitStmt&lt;/tt&gt; to detect &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; statements and analyze them.&lt;/p&gt;
&lt;p&gt;Finally, a &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; is used to manage the textual changes to the source code. This is how Clang-based source to source transformations work - analysis of the AST lets us find out where to apply changes, and a &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; is used to actually apply those changes &lt;a class="footnote-reference" href="#id5" id="id2"&gt;[2]&lt;/a&gt;. The link between the two is the very accurate source location information managed by the AST for each node.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="becoming-a-tool-via-libtooling"&gt;
&lt;h3&gt;Becoming a tool via libTooling&lt;/h3&gt;
&lt;p&gt;What's really new about this sample is how it turns this low-level transformation logic into an actual tool. With libTooling, we no longer need to laboriously set up an instance of the compiler front-end manually. The &lt;tt class="docutils literal"&gt;ClangTool&lt;/tt&gt; class does it all for us, while &lt;tt class="docutils literal"&gt;CommonOptionsParser&lt;/tt&gt; simplifies the command-line interface of the tool. All we need is to implement a &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; - a very central abstraction within Clang for entities that produce stuff from the parsed AST &lt;a class="footnote-reference" href="#id6" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;MyFrontendAction&lt;/tt&gt; is very simple. All it does is provide our custom AST consumer in &lt;tt class="docutils literal"&gt;CreateASTConsumer&lt;/tt&gt; and sets up the &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt;. Note that &lt;tt class="docutils literal"&gt;ClangTool&lt;/tt&gt; will create a new &lt;tt class="docutils literal"&gt;MyFrontendAction&lt;/tt&gt; instance per file, so it's correct to have a new &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; in each instance. This is enabled by adding another layer of abstraction - the &lt;tt class="docutils literal"&gt;FrontendActionFactory&lt;/tt&gt;. The factory pattern here is used to decouple the process of creating objects implementing &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; from the concrete &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; subclasses used by our tool. It also lets us customize the creation process to a greater extent - for example passing additional information into each &lt;tt class="docutils literal"&gt;MyFrontendAction&lt;/tt&gt; object. In our sample, advanced features aren't really needed so we use the convenience &lt;tt class="docutils literal"&gt;newFrontendActionFactory&lt;/tt&gt; template which creates a basic factory behind the scenes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="invoking-the-tool"&gt;
&lt;h3&gt;Invoking the tool&lt;/h3&gt;
&lt;p&gt;It's important to spend a few minutes to discuss how to invoke the tool. libTooling has the concept of a &lt;em&gt;compilation database&lt;/em&gt;, which tells tools about the compiler options used to build the sources under consideration. Describing compilation databases in detail is out of scope here, and I may devote a separate post to it in the future, but in the meantime it helps knowing that a compilation database isn't strictly required to run tools.&lt;/p&gt;
&lt;p&gt;The libTooling command-line parser (&lt;tt class="docutils literal"&gt;CommonOptionsParser&lt;/tt&gt;) supports providing compiler flags on the command line, following the special flag &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt;. Think of it as a simplified, ad-hoc version of a compilation database.&lt;/p&gt;
&lt;p&gt;If you clone and build the &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;llvm-clang-samples&lt;/a&gt; repository, you can invoke the sample discussed here as follows:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ build/tooling_sample inputs/cfunc_with_if.c --
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; at the end: this invocation means there are no special flags the tool needs to know about while analyzing the file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-next"&gt;
&lt;h3&gt;What next&lt;/h3&gt;
&lt;p&gt;This post provides an introduction into building a source-to-source transformation tool based on Clang's libTooling. It should provide a foundation for building custom tools, and nicely complements the existing Clang libTooling documentation and examples. Check them out, by the way. Clang actually has &lt;a class="reference external" href="http://clang.llvm.org/docs/index.html"&gt;decent documentation&lt;/a&gt; on using libTooling these days.&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The &lt;a class="reference external" href="http://llvm.org/devmtg/2014-04/"&gt;Euro LLVM 2014 conference&lt;/a&gt;, held just a couple of weeks ago, has a talk and a tutorial about writing Clang tools based on libTooling.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that the code presented here uses low-level APIs. libTooling has some more convenient higher-level APIs which I hope to talk about in future posts.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; is used throughout the main Clang compiler as well. For example, the Clang code generator - the component responsible for emitting LLVM IR from the AST - defines a subclass named &lt;tt class="docutils literal"&gt;CodeGenAction&lt;/tt&gt; which is its main entry point.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Analyzing function CFGs with LLVM</title><link href="https://eli.thegreenplace.net/2013/09/16/analyzing-function-cfgs-with-llvm" rel="alternate"></link><published>2013-09-16T07:16:53-07:00</published><updated>2022-10-04T14:08:24-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-09-16:/2013/09/16/analyzing-function-cfgs-with-llvm</id><summary type="html">
        &lt;p&gt;A common question about LLVM that comes up on Stack Overflow is how to build the  control-flow graph (CFG) of a function and then topologically sort it, or some variation of this. To save myself answering time in the future, I figured I'll just throw a quick post together that â€¦&lt;/p&gt;</summary><content type="html">
        &lt;p&gt;A common question about LLVM that comes up on Stack Overflow is how to build the  control-flow graph (CFG) of a function and then topologically sort it, or some variation of this. To save myself answering time in the future, I figured I'll just throw a quick post together that shows off a number of capabilities LLVM provides in this domain.&lt;/p&gt;
&lt;p&gt;First of all, people asking this question often miss the fact that basic blocks (BBs) are already organized in a CFG, and there's no need to build a new graph in order to run interesting analyses.&lt;/p&gt;
&lt;p&gt;Each BB has a list of &lt;em&gt;successors&lt;/em&gt; - BBs to which control-flow may transfer from this BB. It can be easily obtained by looking at the terminator instruction of the BB (by definition, a BB has a single terminator):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// BB is a BasicBlock*&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// ...&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; TerminatorInst *TInst = BB-&amp;gt;getTerminator();
&lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; I = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, NSucc = TInst-&amp;gt;getNumSuccessors(); I &amp;lt; NSucc; ++I) {
  BasicBlock *Succ = TInst-&amp;gt;getSuccessor(I);
  &lt;span style="color: #007f00"&gt;// Do stuff with Succ&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This interlinking of BBs constitutes a graph we can traverse in any way we see fit. For example, here is an implementation of topological sorting:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;TopoSorter&lt;/span&gt; {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; runToposort(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Function &amp;amp;F) {
    outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;Topological sort of &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;:\n&amp;quot;&lt;/span&gt;;
    &lt;span style="color: #007f00"&gt;// Initialize the color map by marking all the vertices white.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (Function::const_iterator I = F.begin(), IE = F.end(); I != IE; ++I) {
      ColorMap[I] = TopoSorter::WHITE;
    }

    &lt;span style="color: #007f00"&gt;// The BB graph has a single entry vertex from which the other BBs should&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;// be discoverable - the function entry block.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;bool&lt;/span&gt; success = recursiveDFSToposort(&amp;amp;F.getEntryBlock());
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (success) {
      &lt;span style="color: #007f00"&gt;// Now we have all the BBs inside SortedBBs in reverse topological order.&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (BBVector::const_reverse_iterator RI = SortedBBs.rbegin(),
                                            RE = SortedBBs.rend();
                                            RI != RE; ++RI) {
        outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; (*RI)-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
      }
    } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
      outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; Sorting failed\n&amp;quot;&lt;/span&gt;;
    }
  }
&lt;span style="color: #00007f; font-weight: bold"&gt;private&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;enum&lt;/span&gt; Color {WHITE, GREY, BLACK};
  &lt;span style="color: #007f00"&gt;// Color marks per vertex (BB).&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; DenseMap&amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BasicBlock *, Color&amp;gt; BBColorMap;
  &lt;span style="color: #007f00"&gt;// Collects vertices (BBs) in &amp;quot;finish&amp;quot; order. The first finished vertex is&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// first, and so on.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; SmallVector&amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BasicBlock *, &lt;span style="color: #007f7f"&gt;32&lt;/span&gt;&amp;gt; BBVector;
  BBColorMap ColorMap;
  BBVector SortedBBs;

  &lt;span style="color: #007f00"&gt;// Helper function to recursively run topological sort from a given BB.&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// Returns true if the sort succeeded and false otherwise; topological sort&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// may fail if, for example, the graph is not a DAG (detected a cycle).&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;bool&lt;/span&gt; recursiveDFSToposort(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BasicBlock *BB) {
    ColorMap[BB] = TopoSorter::GREY;
    &lt;span style="color: #007f00"&gt;// For demonstration, using the lowest-level APIs here. A BB&amp;#39;s successors&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;// are determined by looking at its terminator instruction.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; TerminatorInst *TInst = BB-&amp;gt;getTerminator();
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; I = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, NSucc = TInst-&amp;gt;getNumSuccessors(); I &amp;lt; NSucc; ++I) {
      BasicBlock *Succ = TInst-&amp;gt;getSuccessor(I);
      Color SuccColor = ColorMap[Succ];
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (SuccColor == TopoSorter::WHITE) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (!recursiveDFSToposort(Succ))
          &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;false&lt;/span&gt;;
      } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (SuccColor == TopoSorter::GREY) {
        &lt;span style="color: #007f00"&gt;// This detects a cycle because grey vertices are all ancestors of the&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;// currently explored vertex (in other words, they&amp;#39;re &amp;quot;on the stack&amp;quot;).&lt;/span&gt;
        outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; Detected cycle: edge from &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; BB-&amp;gt;getName() &amp;lt;&amp;lt;
                  &lt;span style="color: #7f007f"&gt;&amp;quot; to &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; Succ-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;false&lt;/span&gt;;
      }
    }
    &lt;span style="color: #007f00"&gt;// This BB is finished (fully explored), so we can add it to the vector.&lt;/span&gt;
    ColorMap[BB] = TopoSorter::BLACK;
    SortedBBs.push_back(BB);
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[The full code that also contains the other snippets in this post is &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src_llvm/bb_toposort_sccs.cpp"&gt;available here&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;It uses the simple recursive &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Depth-first_search"&gt;DFS&lt;/a&gt; algorithm outlined in &amp;quot;Introduction to Algorithms&amp;quot; by Cormen et al. During the recursive search, vertices are marked &amp;quot;grey&amp;quot; when first encountered and &amp;quot;black&amp;quot; when they're &lt;em&gt;finished&lt;/em&gt;. A finished vertex is one whose outgoing edges have all been explored. Topological sorting is the list of all vertices sorted by finish time, from last to first (this is also called &amp;quot;reverse post-order&amp;quot;). In our specific case, a BB is a vertex and links to its successors are edges.&lt;/p&gt;
&lt;p&gt;For this CFG:&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/2013/09/diamond-cfg.png" /&gt;
&lt;p&gt;We'll get:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Topological sort of func:
  AA
  BB
  CC
  DD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's an important caveat, however. Topological order is only defined for directed graphs without cycles (DAGs). While the basic block graph is directed, it's not necessarily cycle-free. In fact, any loop in the code translates to a cycle in the BB graph. The code above detects this and reports an error, refusing to provide a sort when a cycle is found.&lt;/p&gt;
&lt;p&gt;For example, consider this CFG with some loops in it:&lt;/p&gt;
&lt;img class="align-center" src="https://eli.thegreenplace.net/images/2013/09/loopy-cfg.png" /&gt;
&lt;p&gt;The code will now complain:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Topological sort of func:
  Detected cycle: edge from BB4 to BB3
  Sorting failed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that we know how to do it the hard way, let's see some of the useful tools LLVM has in its coffers. The header &lt;tt class="docutils literal"&gt;llvm/ADT/PostOrderIterator.h&lt;/tt&gt; offers iterators for going over BBs inside a function in post-order traversal. Here's the complete usage snippet:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;Basic blocks of &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; in post-order:\n&amp;quot;&lt;/span&gt;;
&lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (po_iterator&amp;lt;BasicBlock *&amp;gt; I = po_begin(&amp;amp;F.getEntryBlock()),
                               IE = po_end(&amp;amp;F.getEntryBlock());
                               I != IE; ++I) {
  outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;  &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; (*I)-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall that topological sort is reverse post-order, though. So if it's really that order you need, consider the &lt;tt class="docutils literal"&gt;ReversePostOrderTraversal&lt;/tt&gt; class from the same header. Note that neither detects cycles, however. In the presence of cycles these iterators will produce some traversal, but it won't be the topological order because it's simply undefined in such cases. If you want a tool to detect cycles, there's &lt;tt class="docutils literal"&gt;FindFunctionBackedges&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;llvm/Analysis/CFG.h&lt;/tt&gt;. It essentially runs the same DFS as I showed above, though using an iterative algorithm with an explicit stack instead of the recursion.&lt;/p&gt;
&lt;p&gt;One interesting thing to note about &lt;tt class="docutils literal"&gt;po_iterator&lt;/tt&gt; and its kin is that they can be used for &lt;em&gt;any&lt;/em&gt; kind of graph, not just the graph of basic blocks. They can be used for graphs of functions in inter-procedural analysis, for nodes in an expression graph, and so on. This magic is achieved by means of the &lt;tt class="docutils literal"&gt;GraphTraits&lt;/tt&gt; mechanism (&lt;tt class="docutils literal"&gt;llvm/ADT/GraphTraits.h&lt;/tt&gt;), which lets us decouple graph representations from the actual algorithms that work on all kinds of graphs. The template specialization that makes this work for basic blocks can be found in &lt;tt class="docutils literal"&gt;llvm/Support/CFG.h&lt;/tt&gt; - in this header you can also find iterators for going over the successors (and predecessors) of BBs without manually querying the terminator instruction.&lt;/p&gt;
&lt;p&gt;Back to topological sort though. Since many interesting functions will have loops and thus cycles, what do we do about them? The answer is &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Strongly_connected_components"&gt;strongly-connected components&lt;/a&gt; (SCCs). If we identify the SCCs of the BB graph, we can topologically sort these SCCs and still do interesting analyses. A loop would usually collapse into a single SCC, for example. So how do we go about implementing this?&lt;/p&gt;
&lt;p&gt;Luckily, LLVM already has a tool to help us. The header &lt;tt class="docutils literal"&gt;llvm/ADT/SCCIterator.h&lt;/tt&gt; defines &lt;tt class="docutils literal"&gt;scc_iterator&lt;/tt&gt; which iterates over the SCCs in a graph in post-order. This lets us topologically sort the SCCs similarly to the way we'd sort BBs in a cycle-less graph. In fact, in a cycle-less graph each BB is a SCC on its own, so the SCC approach is a generalization. Using &lt;tt class="docutils literal"&gt;scc_iterator&lt;/tt&gt; is easy:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Use LLVM&amp;#39;s Strongly Connected Components (SCCs) iterator to produce&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// a reverse topological sort of SCCs.&lt;/span&gt;
outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;SCCs for &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; in post-order:\n&amp;quot;&lt;/span&gt;;
&lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (scc_iterator&amp;lt;Function *&amp;gt; I = scc_begin(&amp;amp;F),
                              IE = scc_end(&amp;amp;F);
                              I != IE; ++I) {
  &lt;span style="color: #007f00"&gt;// Obtain the vector of BBs in this SCC and print it out.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; std::vector&amp;lt;BasicBlock *&amp;gt; &amp;amp;SCCBBs = *I;
  outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;  SCC: &amp;quot;&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (std::vector&amp;lt;BasicBlock *&amp;gt;::const_iterator BBI = SCCBBs.begin(),
                                                 BBIE = SCCBBs.end();
                                                 BBI != BBIE; ++BBI) {
    outs() &amp;lt;&amp;lt; (*BBI)-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;  &amp;quot;&lt;/span&gt;;
  }
  outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the loopy CFG shown above, this code will print:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;SCCs for func in post-order:
  SCC: DD
  SCC: CC2  CC1  CC
  SCC: BB4  BB3
  SCC: BB2  BB1  BB
  SCC: AA
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[Note that this is post-order, not reverse post-order; hence the topological sort is showing in the list from the bottom up.]&lt;/p&gt;
&lt;p&gt;I hope this was a useful peek into the CFG analysis capabilities of LLVM. I've given a lot of pointers into the code and these can serve as starting points for some serious code-reading. It's pretty cool to see how many different tools LLVM has for this purpose, and especially nice to see that most of them apply to any kind of graph, thanks to the &lt;tt class="docutils literal"&gt;GraphTraits&lt;/tt&gt; mechanism.&lt;/p&gt;

    </content><category term="misc"></category><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry></feed>