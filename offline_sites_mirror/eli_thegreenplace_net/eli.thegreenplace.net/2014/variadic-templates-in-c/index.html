<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2014/variadic-templates-in-c/ by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:00:45 GMT -->
<head>
    <title>Variadic templates in C++ - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Variadic templates in C++">
                        Variadic templates in C++
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> October 24, 2014 at 06:11</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/c-c.html">C & C++</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Prior to C++11, the only way to write functions that take an arbitrary number of
arguments was to use variadic functions like <tt class="docutils literal">printf</tt>, with the ellipsis
syntax (<tt class="docutils literal">...</tt>) and the accompanying <tt class="docutils literal">va_</tt> family of macros. If you've ever
written code using this approach you know how cumbersome it is. In addition to
being type unsafe (all type resolution has to be done explicitly with casts in
<tt class="docutils literal">va_arg</tt>, at runtime), it's also tricky to get right. The <tt class="docutils literal">va_</tt> macros
perform low-level memory manipulation, and I've seen a lot of code that
segfaults because it isn't using them carefully enough.</p>
<p>But what always bothered me most with this approach is leaving something that
is clearly known at compile-time, to run-time. Yes, when we write a variadic
function we don't know all the ways it's going to be used. But when the compiler
puts the whole program together, <em>it does know</em>. It sees perfectly well all the
invocations of the function throughout the program, and all the possible
argument types it gets passed (types are, after all, resolved at compile-time in
C++).</p>
<div class="section" id="variadic-templates">
<h2>Variadic templates</h2>
<p>One of the new features of C++11 is <em>variadic templates</em>. Finally, there's a way
to write functions that take an arbitrary number of arguments in a type-safe way
and have all the argument handling logic resolved at compile-time, rather than
run-time. Variadic templates can be used for much more than just functions that
take an arbitrary number of arguments; in this article I want to demonstrate
some of these capabilities.</p>
</div>
<div class="section" id="basic-example">
<h2>Basic example</h2>
<p>Let's dive in, by implementing a function that adds all of its arguments
together:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">adder</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">adder</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">adder</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And here are a couple of ways we could call it:</p>
<div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adder</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;aa&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;bb&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;yy&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ssum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adder</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">adder</tt> will accept any number of arguments, and will compile properly as long
as it can apply the <tt class="docutils literal">+</tt> operator to them. This checking is done by the
compiler, at compile time. There's nothing magical about it - it follows C++'s
usual template and overload resolution rules.</p>
<p><tt class="docutils literal"><span class="pre">typename...</span> Args</tt> is called a <em>template parameter pack</em>, and <tt class="docutils literal"><span class="pre">Args...</span> args</tt>
is called a <em>function parameter pack</em> (<tt class="docutils literal">Args</tt> is, of course, a completely
arbitrary name and could be anything else). Variadic templates are written just
the way you'd write recursive code - you need a base case (the <tt class="docutils literal">adder(T v)</tt>
declaration above) and a general case which &quot;recurses&quot; <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>. The recursion
itself happens in the call <tt class="docutils literal"><span class="pre">adder(args...)</span></tt>. Note how the general <tt class="docutils literal">adder</tt> is
defined - the first argument is peeled off the template parameter pack into type
<tt class="docutils literal">T</tt> (and accordingly, argument <tt class="docutils literal">first</tt>). So with each call, the parameter
pack gets shorter by one parameter. Eventually, the base case is encountered.</p>
<p>To get a better feel for the process, one can use the <tt class="docutils literal">__PRETTY_FUNCTION__</tt>
macro <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>. If we insert the following as the first line in both versions
of <tt class="docutils literal">adder</tt> above:</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__PRETTY_FUNCTION__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>And then execute <tt class="docutils literal">adder(1, 2, 3, 8, 7)</tt>, we'll see:</p>
<div class="highlight"><pre><span></span>T adder(T, Args...) [T = int, Args = &lt;int, int, int, int&gt;]
T adder(T, Args...) [T = int, Args = &lt;int, int, int&gt;]
T adder(T, Args...) [T = int, Args = &lt;int, int&gt;]
T adder(T, Args...) [T = int, Args = &lt;int&gt;]
T adder(T) [T = int]
</pre></div>
</div>
<div class="section" id="some-simple-variations">
<h2>Some simple variations</h2>
<p>When reading about C++ template meta-programming, one often hears about &quot;pattern
matching&quot; and how this part of the language constitutes a fairly complete
compile-time functional language.</p>
<p>The example shown above is very basic - template arguments are peeled off one
by one until the base case is hit. Here's a somewhat more interesting display
of pattern matching:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">pair_comparer</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// In real-world code, we wouldn&#39;t compare floating point values like</span>
<span class="w">  </span><span class="c1">// this. It would make sense to specialize this function for floating</span>
<span class="w">  </span><span class="c1">// point types to use approximate comparison.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">pair_comparer</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pair_comparer</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">pair_comparer</tt> accepts any number of arguments and returns <tt class="docutils literal">true</tt> if and
only if they are pair-wise equal. The types are not enforced - everything that
can be compared goes. For example:</p>
<div class="highlight"><pre><span></span><span class="n">pair_comparer</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Returns <tt class="docutils literal">true</tt>. But if we change the second argument to just <tt class="docutils literal">1</tt>, this won't
compile since a <tt class="docutils literal">double</tt> and <tt class="docutils literal">int</tt> are not the same type.</p>
<p>More interestingly, <tt class="docutils literal">pair_comparer</tt> will only work for an even number of
arguments because they are peeled off in pairs and the base case compares two.
The following:</p>
<div class="highlight"><pre><span></span><span class="n">pair_comparer</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Does not compile; the compiler complains that the base case expects 2 arguments
but only 1 is provided. To fix this, we can add another variation of the
function template:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">pair_comparer</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Here, we force all odd-numbered sequences of arguments to return <tt class="docutils literal">false</tt>,
because when only a single argument is left this version is matched.</p>
<p>Note that <tt class="docutils literal">pair_comparer</tt> forces both members of the compared pair to be of
the exact same type. A simple variation would be to allow different types,
as long as they can be compared. I'll leave this an an exercise to the
interested reader.</p>
</div>
<div class="section" id="performance">
<h2>Performance</h2>
<p>If you're concerned with the performance of code that relies on variadic
templates, worry not. As there's no actual recursion involved, all we have is
a sequence of function calls pre-generated at compile-time. This sequence is, in
practice, fairly short (variadic calls with more than 5-6 arguments are rare).
Since modern compilers are aggressively inlining code, it's likely to end up
being compiled to machine code that has absolutely no function calls. What you
end up with, actually, is not unlike loop unrolling.</p>
<p>Compared to the C-style variadic functions, this is a marked win, because
C-style variadic arguments have to be resolved at runtime. The <tt class="docutils literal">va_</tt> macros
are literally manipulating the runtime stack. Therefore, variadic templates are
often a performance optimization for variadic functions.</p>
</div>
<div class="section" id="type-safe-variadic-functions">
<h2>Type-safe variadic functions</h2>
<p>I have mentioned <tt class="docutils literal">printf</tt> in the beginning of the article, as an example of a
variadic function that doesn't use templates. However, as we all know,
<tt class="docutils literal">printf</tt> and its kin are not <em>type safe</em>. If you pass a number into a <tt class="docutils literal">%s</tt>
format, bad things may happen and the compiler won't warn you about it <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>.</p>
<p>It's pretty obvious how variadic templates enable us to write type safe
functions. In the case of <tt class="docutils literal">printf</tt>, when the implementation reaches a new
formatting directive it can actually assert the type of the argument passed.
This assertion won't fire at compile-time, but it <em>will</em> fire - and a nice error
message can be generated instead of undefined behavior.</p>
<p>I will not discuss the implementation of a type-safe <tt class="docutils literal">printf</tt> further - it has
been rehashed many times already. For some good examples see Stroustrup's new
edition of &quot;The C++ Programming Language&quot;, or Alexandrescu's &quot;Variadic templates
are funadic&quot; talk.</p>
</div>
<div class="section" id="variadic-data-structures">
<h2>Variadic data structures</h2>
<p>This use-case is much more interesting, IMHO, because it was something that just
wasn't possible prior to introduction of C++11, at least without considerable
hackery.</p>
<p>Custom data structures (<tt class="docutils literal">struct</tt>s since the times of C and <tt class="docutils literal">class</tt>es in
C++) have compile-time defined fields. They can represent types that grow at
runtime (<tt class="docutils literal"><span class="pre">std::vector</span></tt>, for example) but if you want to add new fields, this
is something the compiler has to see. Variadic templates make it possible to
define data structures that could have an arbitrary number of fields, and have
this number configured per use. The prime example of this is a <tt class="docutils literal">tuple</tt> class,
and here I want to show how to construct one <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>.</p>
<p>For the full code that you can play with and compile on your own:
<a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2014/variadic-tuple.cpp">variadic-tuple.cpp</a>.</p>
<p>Let's start with the type definition:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">tuple</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tuple</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">tuple</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">...),</span><span class="w"> </span><span class="n">tail</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>We start with the base case - the definition of a class template named
<tt class="docutils literal">tuple</tt>, which is empty. The specialization that follows peels off the first
type from the parameter pack, and defines a member of that type named <tt class="docutils literal">tail</tt>.
It also derives from the tuple instantiated with the rest of the pack. This is a
recursive definition that stops when there are no more types to peel off, and
the base of the hierarchy is an empty <tt class="docutils literal">tuple</tt>. To get a better feel for the
resulting data structure, let's use a concrete example:</p>
<div class="highlight"><pre><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="mf">12.2</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;big&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Ignoring the constructor, here's a pseudo-trace of the <tt class="docutils literal">tuple</tt> structs
created:</p>
<div class="highlight"><pre><span></span>struct tuple&lt;double, uint64_t, const char*&gt; : tuple&lt;uint64_t, const char*&gt; {
  double tail;
}

struct tuple&lt;uint64_t, const char*&gt; : tuple&lt;const char*&gt; {
  uint64_t tail;
}

struct tuple&lt;const char*&gt; : tuple {
  const char* tail;
}

struct tuple {
}
</pre></div>
<p>The layout of data members in the original 3-element <tt class="docutils literal">tuple</tt> will be:</p>
<div class="highlight"><pre><span></span>[const char* tail, uint64_t tail, double tail]
</pre></div>
<p>Note that the empty base consumes no space, due to
<a class="reference external" href="http://en.cppreference.com/w/cpp/language/ebo">empty base optimization</a>.
Using Clang's <a class="reference external" href="../../2012/12/17/dumping-a-c-objects-memory-layout-with-clang/index.html">layout dump feature</a>,
we can verify this:</p>
<div class="highlight"><pre><span></span>*** Dumping AST Record Layout
   0 | struct tuple&lt;double, unsigned long, const char *&gt;
   0 |   struct tuple&lt;unsigned long, const char *&gt; (base)
   0 |     struct tuple&lt;const char *&gt; (base)
   0 |       struct tuple&lt;&gt; (base) (empty)
   0 |       const char * tail
   8 |     unsigned long tail
  16 |   double tail
     | [sizeof=24, dsize=24, align=8
     |  nvsize=24, nvalign=8]
</pre></div>
<p>Indeed, the size of the data structure and the internal layout of members is as
expected.</p>
<p>So, the <tt class="docutils literal">struct</tt> definition above lets us create tuples, but there's not much
else we can do with them yet. The way to access tuples is with the <tt class="docutils literal">get</tt>
function template <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>, so let's see how it works. First, we'll have to define
a helper type that lets us access the type of the k-th element in a tuple:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elem_type_holder</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">elem_type_holder</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">elem_type_holder</span><span class="o">&lt;</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">elem_type_holder</span><span class="o">&lt;</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">elem_type_holder</tt> is yet another variadic class template. It takes a number
<tt class="docutils literal">k</tt> and the <tt class="docutils literal">tuple</tt> type we're interested in as template parameters. Note
that this is a compile-time template metaprogramming construct - it acts on
constants and types, not on runtime objects. For example, given
<tt class="docutils literal">elem_type_holder&lt;2, some_tuple_type&gt;</tt>, we'll get the following pseudo
expansion:</p>
<div class="highlight"><pre><span></span>struct elem_type_holder&lt;2, tuple&lt;T, Ts...&gt;&gt; {
  typedef typename elem_type_holder&lt;1, tuple&lt;Ts...&gt;&gt;::type type;
}

struct elem_type_holder&lt;1, tuple&lt;T, Ts...&gt;&gt; {
  typedef typename elem_type_holder&lt;0, tuple&lt;Ts...&gt;&gt;::type type;
}

struct elem_type_holder&lt;0, tuple&lt;T, Ts...&gt;&gt; {
  typedef T type;
}
</pre></div>
<p>So the <tt class="docutils literal">elem_type_holder&lt;2, some_tuple_type&gt;</tt> peels off two types from the
beginning of the tuple, and sets its <tt class="docutils literal">type</tt> to the type of the third one,
which is what we need. Armed with this, we can implement <tt class="docutils literal">get</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">elem_type_holder</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="o">&amp;&gt;::</span><span class="n">type</span><span class="w"></span>
<span class="n">get</span><span class="p">(</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">elem_type_holder</span><span class="o">&lt;</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="o">&amp;&gt;::</span><span class="n">type</span><span class="w"></span>
<span class="n">get</span><span class="p">(</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Here, <a class="reference external" href="../sfinae-and-enable_if/index.html">enable_if</a> is
used to select between two template overloads of <tt class="docutils literal">get</tt> - one for when <tt class="docutils literal">k</tt> is
zero, and one for the general case which peels off the first type and recurses,
as usual with variadic function templates.</p>
<p>Since it returns a reference, we can use <tt class="docutils literal">get</tt> to both read tuple elements and
write to them:</p>
<div class="highlight"><pre><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="mf">12.2</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;big&quot;</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;0th elem is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;1th elem is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;2th elem is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">103</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;1th elem is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="variadic-templates-for-catch-all-functions">
<h2>Variadic templates for catch-all functions</h2>
<p>Here is another example I find interesting. It's different from the ones already
shown in the article, because it doesn't really use the traditional recursive
approach of implementing variadic templates. Rather, it uses them to express the
&quot;any template parameters can go here&quot; concept.</p>
<p>Say we want to write a function that can print out standard library
containers. We want it to work for any container, and we also want the user to
type as little as possible, so we don't want to act on iterators. We just want
<tt class="docutils literal">print_container(c)</tt> to work for any container <tt class="docutils literal">c</tt>. Here's a first approach:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ContainerType</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueType</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">AllocType</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">print_container</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ContainerType</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="p">,</span><span class="w"> </span><span class="n">AllocType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Many of the STL containers are templates that can be parameterized by the value
type and an allocator type; for example <tt class="docutils literal">vector</tt>, <tt class="docutils literal">list</tt>, <tt class="docutils literal">deque</tt>, and so
on. So we can write:</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vd</span><span class="p">{</span><span class="mf">3.14</span><span class="p">,</span><span class="w"> </span><span class="mf">8.1</span><span class="p">,</span><span class="w"> </span><span class="mf">3.2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">};</span><span class="w"></span>
<span class="n">print_container</span><span class="p">(</span><span class="n">vd</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">li</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span><span class="w"></span>
<span class="n">print_container</span><span class="p">(</span><span class="n">li</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>And this works as expected. However, if we try to use it for <tt class="docutils literal">map</tt>, we get a
compile error:</p>
<div class="highlight"><pre><span></span>std::map&lt;std::string, int&gt; msi{{&quot;foo&quot;, 42}, {&quot;bar&quot;, 81}, {&quot;bazzo&quot;, 4}};
print_container(msi);
^~~~~~~~~~~~~~~
error: no matching function for call to &#39;print_container&#39;
note: candidate template ignored: substitution failure :
      template template argument has different template
      parameters than its corresponding template template parameter
</pre></div>
<p>This is because <tt class="docutils literal">map</tt> is a template parameterized by 4 template arguments, not
2. The same problem would occur for a <tt class="docutils literal">set</tt>, which has 3 template arguments.
This is annoying - while the contents of the <tt class="docutils literal">print_container</tt> function would
be the same for all these containers, the signature has to be different. What
can we do without duplicating code? Variadic templates for the rescue:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ContainerType</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueType</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">print_container</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ContainerType</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>What this says is - <tt class="docutils literal">ContainerType</tt> is a template template parameter with any
amount of template parameters itself. We don't care really, as long as the
compiler can type-deduce them at the call. This version of the function will
work for <tt class="docutils literal">map</tt>, <tt class="docutils literal">set</tt>, <tt class="docutils literal">unordered_map</tt> and other containers <a class="footnote-reference" href="#footnote-6" id="footnote-reference-6">[6]</a>. One
small addition we have to make to support mappings is:</p>
<div class="highlight"><pre><span></span><span class="c1">// Implement &lt;&lt; for pairs: this is needed to print out mappings where range</span>
<span class="c1">// iteration goes over (key, value) pairs.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="variadic-templates-for-forwarding">
<h2>Variadic templates for forwarding</h2>
<p>A somewhat related example is templates that don't do much on their own, but
have to forward all their arguments to some other template or function. This
turns out to be very useful because C++ has a commonly used construct that
is inherently &quot;variadic&quot; when viewed from a template parameter point of view -
the constructor. Given a generic type <tt class="docutils literal">T</tt>, to invoke the constructor of <tt class="docutils literal">T</tt>,
we may need to pass in an arbitrary number of arguments. Unlike function types
that specify their arguments at compile time, given just a generic type <tt class="docutils literal">T</tt>
we don't know which constructor(s) it has and how many arguments the constructor
accepts.</p>
<p>A very important example of this is the <tt class="docutils literal"><span class="pre">std::make_unique</span></tt> function, available
in the standard library since C++14. We want to be able to use it as follows:</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FooType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">FooType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;str&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">2.13</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">FooType</tt> is an arbitrary type and can be constructed in arbitrary ways. How
does <tt class="docutils literal">make_unique</tt> know the signature of its constructor? With variadic
templates, it doesn't have to know! Here's how <tt class="docutils literal">make_unique</tt> is typically
implemented:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Ignore the <tt class="docutils literal">&amp;&amp;</tt> syntax and <tt class="docutils literal"><span class="pre">std::forward</span></tt> for now; I will cover them in a
future article. What's important for the sake of our current discussion is the
use of a variadic template to convey &quot;any amount of arguments can go here&quot; and
passing them through to the constructor of <tt class="docutils literal">c</tt> in the <tt class="docutils literal">new</tt> expression.</p>
</div>
<div class="section" id="links-to-resources">
<h2>Links to resources</h2>
<p>I found a number of resources useful while preparing this article:</p>
<ol class="arabic simple">
<li>The 4th edition of &quot;The C++ Programming Language&quot; (by Bjarne Stroustrup) has
a good discussion of variadic templates in chapter 28.</li>
<li><a class="reference external" href="http://stackoverflow.com/a/14311714/8206">This StackOverflow thread</a> for
the <tt class="docutils literal">print_container</tt> example and also for mentioning
<tt class="docutils literal">__PRETTY_FUNCTION__</tt> in the context of variadic templates.</li>
<li><a class="reference external" href="http://lbrandy.com/blog/2013/03/variadic_templates/">C++ variadic templates, for the doubters</a> by Louis Brandy.</li>
<li>Andrei Alexandrescu's &quot;Variadic templates are funadic&quot; talk from Going Native
2012 was very useful - it's also the basis for my <tt class="docutils literal">tuple</tt> example
implementation.</li>
<li>Finally, if recursive use of variadic templates reminds you of pattern
matching in functional languages, you're right! <a class="reference external" href="http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/">Bartosz Milewski's article</a>
dives into more details about this.</li>
</ol>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Technically, this is not recursion, because a different function is
called. The compiler ends up generating a different function for every
used length of the parameter pack. It's useful to reason about it
recursively, though.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>It's a gcc extension, supported by Clang as well.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>To be fair, modern compilers <em>may</em> warn you about it (Clang almost
certainly will); but this is just special-casing the <tt class="docutils literal">printf</tt> family
of functions. In other variadic code, you're on your own.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td><tt class="docutils literal"><span class="pre">std::tuple</span></tt> is part of the standard library in C++11, and it's a more
sophisticated version of what I'm showing here.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td><tt class="docutils literal">get</tt> is a standalone function rather than a member, because it would
be awkward to use as a member. Since it requires explicit template
parameter specification and can't use deduction, we'd have to write
something like <tt class="docutils literal">tup.template <span class="pre">get&lt;2&gt;()</span></tt> to use it, which is ugly and
too verbose.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-6">[6]</a></td><td>Exercise for the reader: there is a C++11 container this still won't
work for. Which one?</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2014/variadic-templates-in-c/ by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:00:45 GMT -->
</html>