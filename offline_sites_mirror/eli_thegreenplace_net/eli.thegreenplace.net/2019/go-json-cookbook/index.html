<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2019/go-json-cookbook/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:07 GMT -->
<head>
    <title>Go JSON Cookbook - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Go JSON Cookbook">
                        Go JSON Cookbook
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> February 04, 2019 at 06:21</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/go.html">Go</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Recently I've gotten into answering Go questions on StackOverflow, and one of
the patterns I noticed are many repetitive questions about JSON processing. The
goal of this post is to collect a &quot;cookbook&quot; of JSON processing code and
examples; think of it as a vastly expanded version of the <a class="reference external" href="https://gobyexample.com/json">JSON gobyexample page</a>. It's a living document - I will update it once
in a while when I find new patterns/problems people ask about.</p>
<p>The code samples here should be reasonably self-contained; if you want actual
code, full <tt class="docutils literal">go run</tt>-able files are <a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2019/gojsoncookbook">available here</a>.</p>
<div class="section" id="some-background-on-json">
<h2>Some background on JSON</h2>
<p>The acronym JSON stands for JavaScript Object Notation. It originally came into
existence as a serialization format for JS, and can actually be considered a
subset of JS. That said, it's no longer considered good style to pass JSON to
JS's <tt class="docutils literal">eval()</tt>; in fact, some valid JSON is not valid JS. Newer editions of the
ECMAScript standard provide <tt class="docutils literal">JSON.stringify</tt> and <tt class="docutils literal">JSON.parse</tt> for
serialization and deserialization, respectively.</p>
<p>These days JSON is a very popular language-independent serialization format,
with simple syntax that's <a class="reference external" href="http://json.org/">described here</a>. In brief, JSON
has values that can be either strings, numbers, null, true/false boolean
constants, arrays or objects. Arrays are linear, ordered collections of values;
in Go they are mapped to slices. Objects are unordered sets of key/value pairs;
in Go they mapped to maps. JSON object keys are strings, and values are
arbitrary JSON values. Note that this is a recursive definition - objects can
hold other objects, or lists, which themselves can hold other objects, etc. This
should be very familiar to programmers coming from dynamic languages like
Python, Perl or JavaScript, or from the Lisp family where such nested data
structures are common and idiomatic.</p>
</div>
<div class="section" id="marshaling-of-basic-go-data-types">
<h2>Marshaling of basic Go data types</h2>
<p>Go uses the term <a class="reference external" href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">marshaling</a> to refer to
the kind of serialization done by converting Go data structures to JSON <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>.
Therefore, the <tt class="docutils literal">json</tt> package's main convenience functions are called
<tt class="docutils literal">json.Marshal</tt> and <tt class="docutils literal">json.Unmarshal</tt>. These functions are <em>generic</em>, in the
sense that they work with <tt class="docutils literal">interface{}</tt> values, and they have the proper
runtime logic to figure out which <em>actual</em> type is being (un)marshaled. Here
is an example that uses the basic types:</p>
<div class="highlight"><pre><span></span><span class="nx">boolS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">boolS</span><span class="p">))</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">boolS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">b</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled bool:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"></span>

<span class="nx">intS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">intS</span><span class="p">))</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">intS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">i</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled int:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>

<span class="nx">floatS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">floatS</span><span class="p">))</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">f</span><span class="w"> </span><span class="kt">float64</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">floatS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">f</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled float64:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="p">)</span><span class="w"></span>

<span class="nx">stringS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="s">&quot;golang&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">stringS</span><span class="p">))</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="kt">string</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">stringS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">s</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled string:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>This will print:</p>
<div class="highlight"><pre><span></span>true
unmarshaled bool: true
42
unmarshaled int: 42
3.14159
unmarshaled float64: 3.14159
&quot;golang&quot;
unmarshaled string: golang
</pre></div>
<p>Note that while JSON doesn't distinguish between integers and floating-point
numbers, Go lets us do this by having the static type information on the objects
passed into <tt class="docutils literal">json.Marshal</tt> or <tt class="docutils literal">json.Unmarshal</tt>. For more details on numbers
see the &quot;JSON numbers - ints or floats?&quot; section.</p>
</div>
<div class="section" id="null-and-nil">
<h2>Null and nil</h2>
<p>Another basic type supported by JSON is null, which is just a way of saying
&quot;nothing to see here&quot;. In Go, <tt class="docutils literal">nil</tt> pointers are marshaled to null:</p>
<div class="highlight"><pre><span></span><span class="nx">nilS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">nilS</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Prints <tt class="docutils literal">null</tt>. Demonstrating unmarshaling of <tt class="docutils literal">null</tt> is a little bit
trickier, because it's not clear what to pass to <tt class="docutils literal">json.Unmarshal</tt>. Passing it
any uninitialized pointer (<tt class="docutils literal">nil</tt>) results in an error. A trick that works is:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">nilS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">p</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled null:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Prints:</p>
<div class="highlight"><pre><span></span>unmarshaled null: &lt;nil&gt;
</pre></div>
</div>
<div class="section" id="un-marshaling-with-generic-interface-values">
<h2>(Un)marshaling with generic interface{} values</h2>
<p>As was briefly mentioned above, the definitions of <tt class="docutils literal">json.Marshal</tt> and
<tt class="docutils literal">json.Unmarshal</tt> are generic, in the sense that they use an <tt class="docutils literal">interface{}</tt>
for the Go object which is to be encoded or decoded into:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="kt">error</span><span class="w"></span>
</pre></div>
<p>The samples above showcased how special logic inside these functions handles
basic types that are known at compile time. We can do similar things using
<tt class="docutils literal">interface{}</tt> directly. While not overly useful for these basic types, this
knowledge will come handy when we're discussing collection types (JSON
representations of slices and maps) later on.</p>
<p>We saw earlier that to encode a boolean into JSON we can do:</p>
<div class="highlight"><pre><span></span><span class="nx">boolS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Alternatively, we can do:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">ii</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="nx">ii</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="nx">boolS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">ii</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">boolS</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>As far as <tt class="docutils literal">json.Marshal</tt> is concerned, these two code samples are equivalent
because the function really accepts a <tt class="docutils literal">interface{}</tt>. It becomes a bit more
interesting when unmarshaling. Where we previously did:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">boolS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">b</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled bool:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>We can also do:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">ib</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">boolS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">ib</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>But now what do we do with <tt class="docutils literal">ib</tt>? It's not a <tt class="docutils literal">bool</tt>, so we can't treat it
as such. Since we already know it <em>should</em> contain an <tt class="docutils literal">bool</tt>, we can do a type
assertion:</p>
<div class="highlight"><pre><span></span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ib</span><span class="p">.(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled bool:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>If we don't know what type to expect here exactly, we'll likely need a type
switch:</p>
<div class="highlight"><pre><span></span><span class="k">switch</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ib</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="kt">bool</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s a bool:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="kt">float64</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s a float:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="c1">// other possible types enumerated...</span><span class="w"></span>
<span class="k">default</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;can&#39;t figure out the type&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="json-numbers-ints-or-floats">
<h2>JSON numbers - ints or floats?</h2>
<p>One common issue with decoding JSON is distinguishing between different numeric
types. Unlike Go, which has separate types for integers and floats, JavaScript
only has floats; this fact is reflected in JSON. The JSON standard doesn't
acknowledge the distinction between the two, and treats both as &quot;numbers&quot;,
though it's clear from the specification that the more general type (floating
point) is inferred.</p>
<p>As long as we know the type of field to decode statically, everything will work
fine. As the very first example in this post demonstrates, when we pass a
pointer to <tt class="docutils literal">int</tt> to <tt class="docutils literal">Unmarshal</tt>, it will know to parse properly into an
integer. But what happens when we don't know the type at compile time?</p>
<p>When using generic <tt class="docutils literal">interface{}</tt> decoding, floating point is always chosen.
Consider this:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;1234&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">inum</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">inum</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">inum</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="kt">int</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s an int:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="kt">float64</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s a float:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="c1">// other possible types enumerated...</span><span class="w"></span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;can&#39;t figure out the type&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It will print:</p>
<div class="highlight"><pre><span></span>it&#39;s a float: 1234
</pre></div>
<p>This is not a bug; it's the logical thing for <tt class="docutils literal">Unmarshal</tt> to do, given that
it doesn't know what type to expect. <tt class="docutils literal">1234</tt> looks like an integer, but it
might as well be a float with the decimal point omitted. <tt class="docutils literal">Unmarshal</tt> has
to decode the most general type based on the JSON specification.</p>
<p>If this is a real issue, one way to work around it is to use the alternative
<tt class="docutils literal">json.Decoder</tt> API for unmarshaling. This API is slightly different from
<tt class="docutils literal">json.Unmarhsal</tt>; it's designed to parse JSON <em>streams</em>, which could result
from reading over HTTP, for example. Here's the same code using <tt class="docutils literal">Decoder</tt>:</p>
<div class="highlight"><pre><span></span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">ii</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">d</span><span class="p">.</span><span class="nx">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ii</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">switch</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ii</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="kt">int</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s an int:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="kt">float64</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s a float:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="c1">// other possible types enumerated...</span><span class="w"></span>
<span class="k">default</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;can&#39;t figure out the type&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It gives a similar result to using <tt class="docutils literal">Unmarshal</tt>. However, here's the twist.
<tt class="docutils literal">Decoder</tt> has an option to not parse numbers into concrete types. Instead,
a number be left unparsed as a <tt class="docutils literal">json.Number</tt>, which is a just a string used to
represent number literals. This is accomplished by calling
<tt class="docutils literal">Decoder.UseNumber()</tt>, as follows:</p>
<div class="highlight"><pre><span></span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">ii</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="nx">d</span><span class="p">.</span><span class="nx">UseNumber</span><span class="p">()</span><span class="w">                              </span><span class="c1">// &lt;-- UseNumber</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">d</span><span class="p">.</span><span class="nx">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ii</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">switch</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ii</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="kt">int</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s an int:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="kt">float64</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s a float:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Number</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;it&#39;s a string:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="c1">// other possible types enumerated...</span><span class="w"></span>
<span class="k">default</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;can&#39;t figure out the type&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now this will print:</p>
<div class="highlight"><pre><span></span>it&#39;s a string: 1234
</pre></div>
<p>And we're free to parse the string as we wish, for example with
<tt class="docutils literal">strconv.Atoi</tt>.</p>
<p>You may think this is unnecessary - can't we just convert the <tt class="docutils literal">float64</tt> read
by <tt class="docutils literal">Unmarshal</tt> into an <tt class="docutils literal">int</tt>? Things are not so simple, however. Floating
point numbers have limited representation accuracy, and for big integers we may
get wrong results. We might even want to marshal arbitrary precision integers
(<tt class="docutils literal">big.Int</tt>), and these also have to be properly parsed to not lose precision.</p>
</div>
<div class="section" id="json-arrays-and-go-slices">
<h2>JSON arrays and Go slices</h2>
<p>Go slices are encoded to JSON arrays, and vice-versa:</p>
<div class="highlight"><pre><span></span><span class="nx">sS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;broccoli&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;almonds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;banana&quot;</span><span class="p">})</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">sS</span><span class="p">))</span><span class="w"></span>

<span class="kd">var</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">sS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">s</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled []string:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Prints:</p>
<div class="highlight"><pre><span></span>[&quot;broccoli&quot;,&quot;almonds&quot;,&quot;banana&quot;]
unmarshaled []string: [broccoli almonds banana]
</pre></div>
<p>When we unmarshal the JSON bytes above, we used a <tt class="docutils literal">[]string</tt> since we knew
all the elements of the JSON array are strings. But what happens when JSON array
elements have different types? While in Go the types of all slice elements has
to be the uniform, the same is not true in JSON (due to its JavaScript roots).
Let's try this:</p>
<div class="highlight"><pre><span></span><span class="nx">variedEncodedSlice</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`[&quot;broccoli&quot;, true]`</span><span class="p">)</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">s2</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">variedEncodedSlice</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">s2</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled []string:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">s2</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>This code panics:</p>
<div class="highlight"><pre><span></span>panic: json: cannot unmarshal bool into Go value of type string
</pre></div>
<p>The error message makes sense: we gave <tt class="docutils literal">json.Unmarshal</tt> a <tt class="docutils literal">[]string</tt> to
unmarshal into, but the JSON bytes contain a bool. We can't unmarshal into
an <tt class="docutils literal">[]bool</tt>, for a similar reason. So what is there to do?</p>
<p>This is where generic JSON comes in again. If we don't know - ahead of time -
the types of elements contained in a JSON array we're unmarshaling, we have to
fall back to generic <tt class="docutils literal">interface{}</tt>s and type switches:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">iis</span><span class="w"> </span><span class="p">[]</span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">variedEncodedSlice</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">iis</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshalled slice of length:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">iis</span><span class="p">))</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">iis</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;decoding element %d\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">e</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="kt">bool</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;  it&#39;s a bool:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="kt">string</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;  it&#39;s a string:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="c1">// other possible types enumerated...</span><span class="w"></span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;can&#39;t figure out the type&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This outputs:</p>
<div class="highlight"><pre><span></span>unmarshalled slice of length: 2
decoding element 0
  it&#39;s a string: broccoli
decoding element 1
  it&#39;s a bool: true
</pre></div>
</div>
<div class="section" id="json-objects-and-go-maps">
<h2>JSON objects and Go maps</h2>
<p>Go maps are encoded to JSON objects, and vice-versa:</p>
<div class="highlight"><pre><span></span><span class="nx">mS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">{</span><span class="s">&quot;almonds&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cashews&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">})</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">mS</span><span class="p">))</span><span class="w"></span>

<span class="kd">var</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">mS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">m</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled map[string]bool:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Prints:</p>
<div class="highlight"><pre><span></span>{&quot;almonds&quot;:false,&quot;cashews&quot;:true}
unmarshaled map[string]bool: map[almonds:false cashews:true]
</pre></div>
<p>Similarly to the case of slices, this works well as long as the types of JSON
elements are known ahead of time. If these types are not known, or values can
have one of several types, we'll need to use generic capabilities, by
unmarshaling into an <tt class="docutils literal">interface{}</tt> and following up with type assertions or
switches.</p>
<p>We've seen how to do these in the slice example, so let's play with something
slightly different now. JSON objects are sometimes nested, and we don't even
know at compile-time what their level of nesting is. Consider this sample JSON:</p>
<div class="highlight"><pre><span></span>{
  &quot;foo&quot;: true,
  &quot;bar&quot;: false,
  &quot;baz&quot;: {
    &quot;next&quot;: true,
    &quot;prev&quot;: {
      &quot;fizz&quot;: true,
      &quot;buzz&quot;: false
    },
    &quot;top&quot;: false
  }
}
</pre></div>
<p>Say we want to find the key &quot;fizz&quot; in it, and to see what it maps to. How
can we do that?</p>
<p>Let's think this through. First, it's obvious that we'll have to use
<tt class="docutils literal">interface{}</tt> unmarshaling, because the values of keys in each object can have
different types (some are booleans, some are nested objects). Second, since JSON
is a tree structure, a recursive approach is natural. Here's a function that
will do that:</p>
<div class="highlight"><pre><span></span><span class="c1">// findNested looks for a key named s in map m. If values in m map to other</span><span class="w"></span>
<span class="c1">// maps, findNested looks into them recursively. Returns true if found, and</span><span class="w"></span>
<span class="c1">// the value found.</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="nx">findNested</span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{},</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Try to find key s at this level</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Not found on this level, so try to find it nested</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">nm</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">v</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">found</span><span class="p">,</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">findNested</span><span class="p">(</span><span class="nx">nm</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="nx">found</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">found</span><span class="p">,</span><span class="w"> </span><span class="nx">val</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Not found recursively</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And here's how we can use it:</p>
<div class="highlight"><pre><span></span><span class="nx">bb</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`</span>
<span class="s">{</span>
<span class="s">  &quot;foo&quot;: true,</span>
<span class="s">  &quot;bar&quot;: false,</span>
<span class="s">  &quot;baz&quot;: {</span>
<span class="s">    &quot;next&quot;: true,</span>
<span class="s">    &quot;prev&quot;: {</span>
<span class="s">      &quot;fizz&quot;: true,</span>
<span class="s">      &quot;buzz&quot;: false</span>
<span class="s">    },</span>
<span class="s">    &quot;top&quot;: false</span>
<span class="s">  }</span>
<span class="s">}`</span><span class="p">)</span><span class="w"></span>

<span class="kd">var</span><span class="w"> </span><span class="nx">ii</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">bb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">ii</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">mi</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ii</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span><span class="w"></span>
<span class="nx">ok</span><span class="p">,</span><span class="w"> </span><span class="nx">fizzVal</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">findNested</span><span class="p">(</span><span class="nx">mi</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fizz&quot;</span><span class="p">)</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;found fizz! value is&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fizzVal</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="golang-structs-as-json-objects">
<h2>Golang structs as JSON objects</h2>
<p>Nested slices and maps are great, but in Go it's idiomatic to assign more
semantics to structured data with <tt class="docutils literal">struct</tt>s. Go's <tt class="docutils literal">json</tt> package supports
marshaling structs into JSON objects and vice versa. Here's a simple example:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Food</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Id</span><span class="w">             </span><span class="kt">int</span><span class="w"></span>
<span class="w">  </span><span class="nx">Name</span><span class="w">           </span><span class="kt">string</span><span class="w"></span>
<span class="w">  </span><span class="nx">FatPerServ</span><span class="w">     </span><span class="kt">float64</span><span class="w"></span>
<span class="w">  </span><span class="nx">ProteinPerServ</span><span class="w"> </span><span class="kt">float64</span><span class="w"></span>
<span class="w">  </span><span class="nx">CarbPerServ</span><span class="w">    </span><span class="kt">float64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Food</span><span class="p">{</span><span class="mi">200403</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Broccoli&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span><span class="w"> </span><span class="mf">3.5</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">MarshalIndent</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">fS</span><span class="p">))</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">fD</span><span class="w"> </span><span class="nx">Food</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">fS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">fD</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled Food:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fD</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It will print:</p>
<div class="highlight"><pre><span></span>{
  &quot;Id&quot;: 200403,
  &quot;Name&quot;: &quot;Broccoli&quot;,
  &quot;FatPerServ&quot;: 0.3,
  &quot;ProteinPerServ&quot;: 2.5,
  &quot;CarbPerServ&quot;: 3.5
}
unmarshaled Food: {200403 Broccoli 0.3 2.5 3.5}
</pre></div>
<p>Here we're using the <tt class="docutils literal">MarshalIndent</tt> method that indents JSON output for
easier visual scanning.</p>
<p>You'll notice that the JSON objects have their key names set from the struct
field names automatically. This is nice for low-effort dumping, but isn't always
satisfactory in real applications. We often don't control the format of the JSON
data we're consuming, so we may get something like:</p>
<div class="highlight"><pre><span></span>{
  &quot;id&quot;: 200403,
  &quot;name&quot;: &quot;Broccoli&quot;,
  &quot;fat_per_serv&quot;: 0.3,
  &quot;protein_per_serv&quot;: 2.5,
  &quot;carb_per_serv&quot;: 3.5
}
</pre></div>
<p>If we call <tt class="docutils literal">json.Unmarshal</tt> for data like this, it will expect a struct with
similarly named fields; but these names aren't idiomatic in Go, and moreover
they start with lowercase so they won't even be visible outside the struct's
own methods. We have a problem - we either sacrifice the style of our Go code,
or have to enforce schemas on JSON we don't necessarily control.</p>
<p>The solution is to use custom field tags, which is an esoteric feature of Go
that was designed specifically for such use cases. Here's a complete example:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Food</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Id</span><span class="w">             </span><span class="kt">int</span><span class="w">     </span><span class="s">`json:&quot;id&quot;`</span><span class="w">                </span><span class="c1">// &lt;--- Field tags</span><span class="w"></span>
<span class="w">  </span><span class="nx">Name</span><span class="w">           </span><span class="kt">string</span><span class="w">  </span><span class="s">`json:&quot;name&quot;`</span><span class="w"></span>
<span class="w">  </span><span class="nx">FatPerServ</span><span class="w">     </span><span class="kt">float64</span><span class="w"> </span><span class="s">`json:&quot;fat_per_serv&quot;`</span><span class="w"></span>
<span class="w">  </span><span class="nx">ProteinPerServ</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="s">`json:&quot;protein_per_serv&quot;`</span><span class="w"></span>
<span class="w">  </span><span class="nx">CarbPerServ</span><span class="w">    </span><span class="kt">float64</span><span class="w"> </span><span class="s">`json:&quot;carb_per_serv&quot;`</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Food</span><span class="p">{</span><span class="mi">200403</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Broccoli&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span><span class="w"> </span><span class="mf">3.5</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">MarshalIndent</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">fS</span><span class="p">))</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">fD</span><span class="w"> </span><span class="nx">Food</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">fS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">fD</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled Food:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fD</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It prints:</p>
<div class="highlight"><pre><span></span>{
  &quot;id&quot;: 200403,
  &quot;name&quot;: &quot;Broccoli&quot;,
  &quot;fat_per_serv&quot;: 0.3,
  &quot;protein_per_serv&quot;: 2.5,
  &quot;carb_per_serv&quot;: 3.5
}
unmarshaled Food: {200403 Broccoli 0.3 2.5 3.5}
</pre></div>
<p>Field tags let us map between the Go internal view of the struct's fields and
its external materialization as a JSON object.</p>
<p>These techniques work just as well with nested structs. Check out these code
samples: <a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2019/gojsoncookbook/structs.go">sample 1</a>,
<a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2019/gojsoncookbook/structs-fieldtags.go">sample 2</a>.</p>
</div>
<div class="section" id="partial-encoding-and-decoding-of-structs">
<h2>Partial encoding and decoding of structs</h2>
<p>It's common for JSON data to omit some fields that are then assumed to not exist
or take on their default values. Think about passing many options, where the
full list of options is so large that a lot of time and bandwidth would be
wasted to transfer them all fully; usually we only want to modify a small number
of options for every given call.</p>
<p>The <tt class="docutils literal">json</tt> package supports this with partial unmarshaling. Here's an
example using the <tt class="docutils literal">Food</tt> struct shown above:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">bb</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`</span>
<span class="s">  {</span>
<span class="s">    &quot;Name&quot;: &quot;Broccoli&quot;,</span>
<span class="s">    &quot;FatPerServ&quot;: 0.3,</span>
<span class="s">    &quot;ProteinPerServ&quot;: 2.5,</span>
<span class="s">    &quot;CarbPerServ&quot;: 3.5</span>
<span class="s">  }`</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">fD</span><span class="w"> </span><span class="nx">Food</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">bb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">fD</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unmarshaled Food:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fD</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note that the JSON string doesn't have the <tt class="docutils literal">Id</tt> field populated. The result
will be:</p>
<div class="highlight"><pre><span></span>unmarshaled Food: {0 Broccoli 0.3 2.5 3.5}
</pre></div>
<p>The unmarshaling is successful, and <tt class="docutils literal">fD.Id</tt> is left at the default value for
its type (0 for numbers, empty string for strings, etc). This behavior can be
controlled via the <tt class="docutils literal">Decoder.DisallowUnknownFields</tt> method when using the
<tt class="docutils literal">json.Decoder</tt> API.</p>
<p>For a similar effect during marshaling, we can use the special <tt class="docutils literal">&quot;omitempty&quot;</tt>
field tag; it tells the <tt class="docutils literal">json</tt> package to not emit a struct field if it has
the default value for its type. Here's an example:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Food</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Id</span><span class="w">             </span><span class="kt">int</span><span class="w">     </span><span class="s">`json:&quot;id,omitempty&quot;`</span><span class="w"></span>
<span class="w">  </span><span class="nx">Name</span><span class="w">           </span><span class="kt">string</span><span class="w">  </span><span class="s">`json:&quot;name&quot;`</span><span class="w"></span>
<span class="w">  </span><span class="nx">FatPerServ</span><span class="w">     </span><span class="kt">float64</span><span class="w"> </span><span class="s">`json:&quot;fat_per_serv&quot;`</span><span class="w"></span>
<span class="w">  </span><span class="nx">ProteinPerServ</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="s">`json:&quot;protein_per_serv&quot;`</span><span class="w"></span>
<span class="w">  </span><span class="nx">CarbPerServ</span><span class="w">    </span><span class="kt">float64</span><span class="w"> </span><span class="s">`json:&quot;carb_per_serv&quot;`</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Food</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Broccoli&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span><span class="w"> </span><span class="mf">3.5</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">MarshalIndent</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">fS</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span>{
  &quot;name&quot;: &quot;Broccoli&quot;,
  &quot;fat_per_serv&quot;: 0.3,
  &quot;protein_per_serv&quot;: 2.5,
  &quot;carb_per_serv&quot;: 3.5
}
</pre></div>
<p>Note how the <tt class="docutils literal">id</tt> field is left out of the JSON, because it was given the
empty value 0.</p>
<p>We can also tell the encoder to omit certain fields. For example, we may have
a struct with a field that should be kept private to the application and not
sent over the wire. Even when the field has a non-empty value, we want it out
of the serialized JSON string. We can do this with the <tt class="docutils literal"><span class="pre">json:&quot;-&quot;</span></tt> field
tag:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Account</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">Name</span><span class="w">     </span><span class="kt">string</span><span class="w"></span>
<span class="w">    </span><span class="nx">Password</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="s">`json:&quot;-&quot;`</span><span class="w"></span>
<span class="w">    </span><span class="nx">Balance</span><span class="w">  </span><span class="kt">float64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">joe</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Account</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Joe&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">Password</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;123456&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">Balance</span><span class="p">:</span><span class="w"> </span><span class="mf">102.4</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">joe</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="delayed-parsing-with-json-rawmessage">
<h2>Delayed parsing with json.RawMessage</h2>
<p>Sometimes the data you need to parse is not on the top level of the JSON string,
and/or you'd like to ignore a lot of the JSON contents, focusing just on the
piece you need to parse. Consider this JSON string:</p>
<div class="highlight"><pre><span></span>{
        &quot;event&quot;: {&quot;name&quot;: &quot;joe&quot;, &quot;url&quot;: &quot;event://101&quot;},
        &quot;otherstuff&quot;: 15.2,
        &quot;anotherstuff&quot;: 100
}
</pre></div>
<p>And suppose we're interested only in the <tt class="docutils literal">event</tt> key, as we already have
a structure to parse it into:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Event</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="s">`json:&quot;name&quot;`</span><span class="w"></span>
<span class="w">    </span><span class="nx">Url</span><span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="s">`json:&quot;url&quot;`</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>How do we do that? The <tt class="docutils literal">json</tt> module relies on static typing quite a bit,
unless we go full generic with <tt class="docutils literal">interface{}</tt>. But in that case, we may need to
convert large maps into large structs manually, which is undesirable.</p>
<p>The solution is <tt class="docutils literal">json.RawMessage</tt>, which exists for this purpose. It tells
the <tt class="docutils literal">json</tt> module to not parse some parts of the string and leave them as
<tt class="docutils literal">string</tt>s, which we can then parse again later. Here's a complete solution
to the issue discussed above:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Event</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="s">`json:&quot;name&quot;`</span><span class="w"></span>
<span class="w">    </span><span class="nx">Url</span><span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="s">`json:&quot;url&quot;`</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">bb</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`</span>
<span class="s">    {</span>
<span class="s">        &quot;event&quot;: {&quot;name&quot;: &quot;joe&quot;, &quot;url&quot;: &quot;event://101&quot;},</span>
<span class="s">        &quot;otherstuff&quot;: 15.2,</span>
<span class="s">        &quot;anotherstuff&quot;: 100</span>
<span class="s">    }`</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">json</span><span class="p">.</span><span class="nx">RawMessage</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">bb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">m</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">eventRaw</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;event&quot;</span><span class="p">];</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">event</span><span class="w"> </span><span class="nx">Event</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">eventRaw</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">event</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Parsed Event:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">event</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Can&#39;t find &#39;event&#39; key in JSON&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="json-and-pointer-reference-types">
<h2>JSON and pointer/reference types</h2>
<p>The <tt class="docutils literal">json</tt> package has special handling for pointer and reference types.
Consider this sample structure:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">NamePtr</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Id</span><span class="w">   </span><span class="kt">int</span><span class="w"></span>
<span class="w">  </span><span class="nx">Name</span><span class="w"> </span><span class="o">*</span><span class="kt">string</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>We can marshal it as follows:</p>
<div class="highlight"><pre><span></span><span class="nx">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;Sam&quot;</span><span class="w"></span>
<span class="nx">np</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">NamePtr</span><span class="p">{</span><span class="mi">101</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">name</span><span class="p">}</span><span class="w"></span>

<span class="nx">npS</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">np</span><span class="p">)</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">npS</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>This will print:</p>
<div class="highlight"><pre><span></span>{&quot;Id&quot;:101,&quot;Name&quot;:&quot;Sam&quot;}
</pre></div>
<p>This works because <tt class="docutils literal">json.Marshal</tt> does the right thing here - it &quot;sees
through&quot; the pointer to string and emits the string itself as the <tt class="docutils literal">&quot;Name&quot;</tt>
field. It works in reverse as well:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">npD</span><span class="w"> </span><span class="nx">NamePtr</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">npS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">npD</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">npD</span><span class="p">.</span><span class="nx">Id</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">npD</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Note that when we create <tt class="docutils literal">npD</tt>, its <tt class="docutils literal">Name</tt> field is initialized with the
default value - a <tt class="docutils literal">nil</tt> for pointers. <tt class="docutils literal">json.Unmarshal</tt> allocates an actual
value and sets the pointer to its address when unmarshaling. If <tt class="docutils literal">Name</tt> is not
present in the JSON string being decoded, the pointer will be left as <tt class="docutils literal">nil</tt>.</p>
<p>The same applies to other reference types, like slices:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">BoolAndVals</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Fresh</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="w">  </span><span class="nx">Vals</span><span class="w">  </span><span class="p">[]</span><span class="kt">float64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">bb</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`</span>
<span class="s">  {</span>
<span class="s">    &quot;Fresh&quot;: true,</span>
<span class="s">    &quot;Vals&quot;: [1.2, 3.24, 18.99]</span>
<span class="s">  }`</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">bvD</span><span class="w"> </span><span class="nx">BoolAndVals</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">bb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">bvD</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">bvD</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This will print:</p>
<div class="highlight"><pre><span></span>{true [1.2 3.24 18.99]}
</pre></div>
<p>When we declare the variable <tt class="docutils literal">bvD</tt>, its <tt class="docutils literal">Vals</tt> field is an unallocated
slice, but <tt class="docutils literal">json.Unmarshal</tt> will allocate it for us if the <tt class="docutils literal">Vals</tt> field is
present in the decoded JSON object.</p>
<p>This behavior is very useful for being able to <em>multiplex</em> several
struct types in a single container, implementing a <a class="reference external" href="https://en.wikipedia.org/wiki/Tagged_union">sum type</a>. Here's a complete example:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">RequestBodyFoo</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Name</span><span class="w">    </span><span class="kt">string</span><span class="w"></span>
<span class="w">  </span><span class="nx">Balance</span><span class="w"> </span><span class="kt">float64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">type</span><span class="w"> </span><span class="nx">RequestBodyBar</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Id</span><span class="w">  </span><span class="kt">int</span><span class="w"></span>
<span class="w">  </span><span class="nx">Ref</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Request</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Foo</span><span class="w"> </span><span class="o">*</span><span class="nx">RequestBodyFoo</span><span class="w"></span>
<span class="w">  </span><span class="nx">Bar</span><span class="w"> </span><span class="o">*</span><span class="nx">RequestBodyBar</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span><span class="w"> </span><span class="nx">Show</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">Foo</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Request has Foo:&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">r</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">Bar</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Request has Bar:&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">r</span><span class="p">.</span><span class="nx">Bar</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">bb</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`</span>
<span class="s">  {</span>
<span class="s">    &quot;Foo&quot;: {&quot;Name&quot;: &quot;joe&quot;, &quot;balance&quot;: 4591.25}</span>
<span class="s">  }</span>
<span class="s">  `</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">req1</span><span class="w"> </span><span class="nx">Request</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">bb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">req1</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">req1</span><span class="p">.</span><span class="nx">Show</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="nx">bb</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`</span>
<span class="s">  {</span>
<span class="s">    &quot;Bar&quot;: {&quot;Id&quot;: 128992, &quot;Ref&quot;: 801472}</span>
<span class="s">  }</span>
<span class="s">  `</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">req2</span><span class="w"> </span><span class="nx">Request</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">bb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">req2</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">req2</span><span class="p">.</span><span class="nx">Show</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This prints:</p>
<div class="highlight"><pre><span></span>Request has Foo: {joe 4591.25}
Request has Bar: {128992 801472}
</pre></div>
</div>
<div class="section" id="parsing-json-streams-with-decoder">
<h2>Parsing JSON streams with Decoder</h2>
<p>We've briefly seen <tt class="docutils literal">json.Decoder</tt> before because it has some extended
functionality that <tt class="docutils literal">json.Marshal</tt> lacks. Now let's see how to use it more
idiomatically, for parsing JSON streams.</p>
<p><tt class="docutils literal">json.Marshal</tt> is a convenience function. It takes a full <tt class="docutils literal">byte</tt> slice and
parses its contents. But JSON data often arrives from some streaming medium like
a socket, and it's occasionally useful to parse it in a more fine-grained
manner. For example, the stream may contain a sequence of <tt class="docutils literal">JSON</tt> values and we
want to parse each value as  soon as it arrives - <tt class="docutils literal">json.Marshal</tt> would require
us to consume the whole stream before parsing it.</p>
<p>Here's an example that accomplishes this. It showcases using the <tt class="docutils literal">More</tt> and
<tt class="docutils literal">Token</tt> methods for fine-grained parsing of a stream:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">`</span>
<span class="s">  [</span>
<span class="s">    {&quot;almonds&quot;: false},</span>
<span class="s">    {&quot;cashews&quot;: true},</span>
<span class="s">    {&quot;walnuts&quot;: false}</span>
<span class="s">  ]`</span><span class="w"></span>
<span class="w">  </span><span class="nx">dec</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span><span class="w"></span>

<span class="w">  </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">dec</span><span class="p">.</span><span class="nx">Token</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Delim</span><span class="p">(</span><span class="sc">&#39;[&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;Expected &#39;[&#39; delimiter&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">dec</span><span class="p">.</span><span class="nx">More</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="w"></span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">dec</span><span class="p">.</span><span class="nx">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;decoded&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">dec</span><span class="p">.</span><span class="nx">Token</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Delim</span><span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;Expected &#39;]&#39; delimiter&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Since <tt class="docutils literal">json.NewDecoder</tt> accepts any <tt class="docutils literal">io.Reader</tt>, it's very versatile. Many
Go types implement the <tt class="docutils literal">io.Reader</tt> interface, so decoders can be hooked up to
sockets, files or even something like a decompressed reading using the <tt class="docutils literal">zip</tt>
package.</p>
</div>
<div class="section" id="encoding-json-streams-with-encoder">
<h2>Encoding JSON streams with Encoder</h2>
<p>So far we've done marshaling with the <tt class="docutils literal">json.Marshal</tt> function, which takes
an object and produces a slice of bytes. The <tt class="docutils literal">json</tt> package also offers a
lower-level, more flexible API called <tt class="docutils literal">Encoder</tt>, which can encode objects into
a <em>stream</em>, without having to materialize a temporary <tt class="docutils literal">[]byte</tt> buffer. In Go,
streams can be conveniently hooked together using interfaces provided by the
<tt class="docutils literal">io</tt> package, such as <tt class="docutils literal">io.Writer</tt>. Here's a complete example that emits
objects in JSON while also encoding them with <tt class="docutils literal">base64</tt>. Follow the comments in
the code:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;encoding/base64&quot;</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;encoding/json&quot;</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;os&quot;</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Create an io.Writer that encodes bytes written into it as base64 and emits</span><span class="w"></span>
<span class="w">  </span><span class="c1">// them to stdout.</span><span class="w"></span>
<span class="w">  </span><span class="nx">base64writer</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">base64</span><span class="p">.</span><span class="nx">NewEncoder</span><span class="p">(</span><span class="nx">base64</span><span class="p">.</span><span class="nx">StdEncoding</span><span class="p">,</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Create a new JSON encoder, hooking up its output to base64writer.</span><span class="w"></span>
<span class="w">  </span><span class="nx">je</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">NewEncoder</span><span class="p">(</span><span class="nx">base64writer</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">je</span><span class="p">.</span><span class="nx">Encode</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">4.12</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pi&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">3.14159</span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Flush any partially encoded blocks left in the base64 encoder.</span><span class="w"></span>
<span class="w">  </span><span class="nx">base64writer</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="custom-json-encoding-with-the-marshaler-interface">
<h2>Custom JSON encoding with the Marshaler interface</h2>
<p>Suppose you have a type which you want to encode in some special way, and the
supported field tags are insufficient to customize it the way you need. For
example, you may want your numbers to be encoded as hexadecimal (maybe because
of some limitations of the API on the other end).</p>
<p>For full customization, your type can implement the <tt class="docutils literal">json.Marshaler</tt>
interface:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Marshaler</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">MarshalJSON</span><span class="p">()</span><span class="w"> </span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Here's an example:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Account</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">Id</span><span class="w">   </span><span class="kt">int32</span><span class="w"></span>
<span class="w">    </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="nx">Account</span><span class="p">)</span><span class="w"> </span><span class="nx">MarshalJSON</span><span class="p">()</span><span class="w"> </span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;id&quot;</span><span class="p">:</span><span class="w">   </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;0x%08x&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">.</span><span class="nx">Id</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="nx">a</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">joe</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Account</span><span class="p">{</span><span class="nx">Id</span><span class="p">:</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="nx">Name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Joe&quot;</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">joe</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">joe</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This prints:</p>
<div class="highlight"><pre><span></span>{&quot;id&quot;:&quot;0x0000007b&quot;,&quot;name&quot;:&quot;Joe&quot;}
</pre></div>
<p>Similarly, we could customize decoding by implementing the <tt class="docutils literal">json.Unmarshaler</tt>
interface.</p>
</div>
<div class="section" id="unmarshaling-time-values">
<h2>Unmarshaling Time values</h2>
<p>See my separate blog post on this topic:
<a class="reference external" href="../../2020/unmarshaling-time-values-from-json/index.html">https://eli.thegreenplace.net/2020/unmarshaling-time-values-from-json/</a></p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Though Go is not overly consistent in this terminology, and
encoding/decoding is also used for the same purpose. This post will also
alternate between marshaling/encoding.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2019/go-json-cookbook/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:07 GMT -->
</html>