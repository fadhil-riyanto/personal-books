<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2019/rsa-theory-and-implementation/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:57:44 GMT -->
<head>
    <title>RSA - theory and implementation - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to RSA - theory and implementation">
                        RSA - theory and implementation
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> September 03, 2019 at 05:24</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/math.html">Math</a>
        ,
    <a href="../../tag/programming.html">Programming</a>
        ,
    <a href="../../tag/go.html">Go</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>RSA has been a staple of public key cryptography for over 40 years, and is
still being used today for some tasks in the newest TLS 1.3 standard. This
post describes the theory behind RSA - the math that makes it work, as well as
some practical considerations; it also presents a complete implementation of RSA
key generation, encryption and decryption in Go.</p>
<div class="section" id="the-rsa-algorithm">
<h2>The RSA algorithm</h2>
<p>The beauty of the RSA algorithm is its simplicity. You don't need much more
than some familiarity with elementary number theory to understand it, and the
prerequisites can be grokked in a few hours.</p>
<p>In this presentation <em>M</em> is the message we want to encrypt, resulting in the
ciphertext <em>C</em>. Both <em>M</em> and <em>C</em> are large integers. Refer to the Practical
Considerations section for representing arbitrary data with such integers.</p>
<p>The RSA algorithm consists of three main phases: key generation, encryption and
decryption.</p>
<div class="section" id="key-generation">
<h3>Key generation</h3>
<p>The first phase in using RSA is generating the public/private keys. This is
accomplished in several steps.</p>
<p><strong>Step 1</strong>: find two random, very large prime numbers <em>p</em> and <em>q</em> and calculate
<object class="valign-m4" data="../../images/math/2df650fff78b85cfb0330f2a2e65e4ac0e1e1ca1.svg" style="height: 12px;" type="image/svg+xml">n=pq</object>. How large should these primes be? The current recommendation is
for <em>n</em> to be at least 2048 bits, or over 600 decimal digits. We'll assume that
the message <em>M</em> - represented as a number - is smaller than <em>n</em> (see Practical
Considerations for details on what to do if it's not).</p>
<p><strong>Step 2</strong>: select a small odd integer <em>e</em> that is relatively prime to
<object class="valign-m4" data="../../images/math/1c7f9bc7f04407dd7fee51ec2ec4df99f20355ee.svg" style="height: 18px;" type="image/svg+xml">\phi(n)</object>, which is <a class="reference external" href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler's totient function</a>. <object class="valign-m4" data="../../images/math/1c7f9bc7f04407dd7fee51ec2ec4df99f20355ee.svg" style="height: 18px;" type="image/svg+xml">\phi(n)</object> is
calculated directly from Euler's formula (its proof is on Wikipedia):</p>
<object class="align-center" data="../../images/math/660f0ef1ba862cad10df79d9274e30ed265331c0.svg" style="height: 51px;" type="image/svg+xml">\[\phi(n) =n \prod_{p\mid n} \left(1-\frac{1}{p}\right)\]</object>
<p>For <object class="valign-m4" data="../../images/math/2df650fff78b85cfb0330f2a2e65e4ac0e1e1ca1.svg" style="height: 12px;" type="image/svg+xml">n=pq</object> where <em>p</em> and <em>q</em> are primes, we get</p>
<object class="align-center" data="../../images/math/c4e921f87628b962ed3f77e50dfd51d92a924041.svg" style="height: 40px;" type="image/svg+xml">\[\phi(n)=n\frac{p-1}{p}\frac{q-1}{q}=(p-1)(q-1)\]</object>
<p>In practice, it's recommended to pick <em>e</em> as one of a set of known prime values,
most notably <a class="reference external" href="https://tools.ietf.org/html/rfc2313">65537</a>. Picking this known
number does not diminish the security of RSA, and has some advantages such as
efficiency <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>.</p>
<p><strong>Step 3</strong>: compute <em>d</em> as the multiplicative inverse of <em>e</em> modulo
<object class="valign-m4" data="../../images/math/1c7f9bc7f04407dd7fee51ec2ec4df99f20355ee.svg" style="height: 18px;" type="image/svg+xml">\phi(n)</object>. Lemma 3 in <a class="reference external" href="../the-chinese-remainder-theorem/index.html">this post</a> guarantees
that <em>d</em> exists and is unique (and also explains what a modular multiplicative
inverse is).</p>
<p>At this point we have all we need for the public/private keys. The public key is
the pair <object class="valign-m5" data="../../images/math/e97a2ea99cfffbb197c3a2ea0c0e8d6962422e84.svg" style="height: 18px;" type="image/svg+xml">[e,n]</object> and the private key is the pair <object class="valign-m5" data="../../images/math/30c8e363b6a1070055dd59a89f457dd42dbad6a5.svg" style="height: 18px;" type="image/svg+xml">[d,n]</object>. In
practice, when doing decryption we have access to <em>n</em> already (from the public
key), so <em>d</em> is really the only unknown.</p>
</div>
<div class="section" id="encryption-and-decryption">
<h3>Encryption and decryption</h3>
<p>Encryption and decryption are both accomplished with the same <a class="reference external" href="../../2009/03/28/efficient-modular-exponentiation-algorithms.html">modular
exponentiation</a>
formula, substituting different values for <em>x</em> and <em>y</em>:</p>
<object class="align-center" data="../../images/math/7ba9e4575b2f901ac6ab1301c9260a0ebb8c4ddb.svg" style="height: 18px;" type="image/svg+xml">\[f(x)=x^y\pmod{n}\]</object>
<p>For encryption, the input is <em>M</em> and the exponent is <em>e</em>:</p>
<object class="align-center" data="../../images/math/16100b92251780f65ec193d9e8f0fd7b3df7f55e.svg" style="height: 18px;" type="image/svg+xml">\[Enc(M)=M^e\pmod{n}\]</object>
<p>For decryption, the input is the ciphertext <em>C</em> and the exponent is <em>d</em>:</p>
<object class="align-center" data="../../images/math/e501f753509274a8d9c1792563b70c7afb04b7cb.svg" style="height: 21px;" type="image/svg+xml">\[Dec(C)=C^d\pmod{n}\]</object>
</div>
</div>
<div class="section" id="why-does-it-work">
<h2>Why does it work?</h2>
<p>Given <em>M</em>, we encrypt it by raising to the power of <em>e</em> modulo <em>n</em>. Apparently,
this process is reversible by raising the result to the power of <em>d</em> modulo
<em>n</em>, getting <em>M</em> back. Why does this work?</p>
<p><strong>Proof</strong>:</p>
<object class="align-center" data="../../images/math/b1865666d04fc18858aee6e6bb0e79b861822cc8.svg" style="height: 21px;" type="image/svg+xml">\[Dec(Enc(M))=M^{ed}\pmod{n}\]</object>
<p>Recall that <em>e</em> and <em>d</em> are multiplicative inverses modulo <object class="valign-m4" data="../../images/math/1c7f9bc7f04407dd7fee51ec2ec4df99f20355ee.svg" style="height: 18px;" type="image/svg+xml">\phi(n)</object>. That
is, <object class="valign-m4" data="../../images/math/ff52bee7e9ab7e6ba6c4eaec88d621a058253f8b.svg" style="height: 18px;" type="image/svg+xml">ed\equiv 1\pmod{\phi(n)}</object>. This means that for some integer <em>k</em> we have
<object class="valign-m4" data="../../images/math/d9312685b11b6605d92b1cb3f528e78bfdae9ce0.svg" style="height: 18px;" type="image/svg+xml">ed=1+k\phi(n)</object> or <object class="valign-m4" data="../../images/math/068d54df52635d19705da7af64959f05f5415dc0.svg" style="height: 18px;" type="image/svg+xml">ed=1+k(p-1)(q-1)</object>.</p>
<p>Let's see what <object class="valign-0" data="../../images/math/0851d104a1204f3680dc479111e1c56b15d50924.svg" style="height: 15px;" type="image/svg+xml">M^{ed}</object> is modulo <em>p</em>. Substituting in the formula for
<em>ed</em> we get:</p>
<object class="align-center" data="../../images/math/2a143c253f8d87a633a3d784919995f4849e2820.svg" style="height: 23px;" type="image/svg+xml">\[M^{ed}\equiv M(M^{p-1})^{k(q-1)}\pmod{p}\]</object>
<p>Now we can use <a class="reference external" href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">Fermat's little theorem</a>, which states that
if <em>M</em> is not divisible by <em>p</em>, we have <object class="valign-m4" data="../../images/math/e59079c61e78d1fa10e39d2394416b925e961e50.svg" style="height: 19px;" type="image/svg+xml">M^{p-1}\equiv 1\pmod{p}</object>. This
theorem is a special case of Euler's theorem, the proof of which <a class="reference external" href="../../2009/08/01/a-group-theoretic-proof-of-eulers-theorem.html">I wrote about
here</a>.</p>
<p>So we can substitute 1 for <object class="valign-0" data="../../images/math/ce56881e232caecbb33c9e0c42f73da4568bc43e.svg" style="height: 15px;" type="image/svg+xml">M^{p-1}</object> in the latest equation, and raising 1
to any power is still 1:</p>
<object class="align-center" data="../../images/math/992600d7cffd6118684c9fb7bd2884eddbd28c1b.svg" style="height: 21px;" type="image/svg+xml">\[M^{ed}\equiv M\pmod{p}\]</object>
<p>Note that Fermat's little theorem requires that <em>M</em> is not divisible by <em>p</em>. We
can safely assume that, because if <object class="valign-m4" data="../../images/math/edc02af17cdf5fefdcee2d00c213bfc9deed163b.svg" style="height: 18px;" type="image/svg+xml">M\equiv 0\pmod{p}</object>, then trivially
<object class="valign-m4" data="../../images/math/e3faa78a6c339536793bb1521021b33a8d0e7a01.svg" style="height: 19px;" type="image/svg+xml">M^{ed}\equiv 0\pmod{p}</object> and again <object class="valign-m4" data="../../images/math/4bdc1b0fbf669d81ffa7e4f726380a7090fda112.svg" style="height: 19px;" type="image/svg+xml">M^{ed}\equiv M\pmod{p}</object>.</p>
<p>We can similarly show that:</p>
<object class="align-center" data="../../images/math/c924efc575ead500eb25859e78fcd2aa4b166166.svg" style="height: 21px;" type="image/svg+xml">\[M^{ed}\equiv M\pmod{q}\]</object>
<p>So we have <object class="valign-0" data="../../images/math/01e9660f252f2e39af7563cd3464c24f770bc7db.svg" style="height: 15px;" type="image/svg+xml">M^{ed}\equiv M</object> for the prime factors of <em>n</em>. Using
a <a class="reference external" href="../the-chinese-remainder-theorem/index.html">corollary to the Chinese Remainder Theorem</a>, they are
then equivalent modulo <em>n</em> itself:</p>
<object class="align-center" data="../../images/math/59989cc9b589764c6339babf180807ad78c02721.svg" style="height: 21px;" type="image/svg+xml">\[M^{ed}\equiv M\pmod{n}\]</object>
<p>Since we've defined <em>M</em> to be smaller than <em>n</em>, we've shown that
<object class="valign-m4" data="../../images/math/933aa016970d0adaae6a5832eafe9f4f73750317.svg" style="height: 18px;" type="image/svg+xml">Dec(Enc(M))=M</object> ∎</p>
</div>
<div class="section" id="why-is-it-secure">
<h2>Why is it secure?</h2>
<p>Without the private key in hand, attackers only have the result of
<object class="valign-m4" data="../../images/math/00149eb8468e1ff6a5afe1ac4edc10a3426e6a18.svg" style="height: 18px;" type="image/svg+xml">M^e\pmod {n}</object>, as well as <em>n</em> and <em>e</em> (as they're part of the public
key). Could they infer <em>M</em> from these numbers?</p>
<p>There is no <em>known</em> general way of doing this without factoring
<em>n</em> (see the <a class="reference external" href="http://people.csail.mit.edu/rivest/Rsapaper.pdf">original RSA paper</a>,
section IX), and factoring is known to be a difficult problem. Specifically,
here we assume that <em>M</em> and <em>e</em> are sufficiently large that <object class="valign-0" data="../../images/math/08c3c067bdffe6aa41c60dada94a96fa79a030b9.svg" style="height: 12px;" type="image/svg+xml">M^e&gt;n</object>
(otherwise decrypting would be trivial).</p>
<p>If factoring was easy, we could factor <em>n</em> into <em>p</em> and <em>q</em>, then compute
<object class="valign-m4" data="../../images/math/1c7f9bc7f04407dd7fee51ec2ec4df99f20355ee.svg" style="height: 18px;" type="image/svg+xml">\phi(n)</object> and then finally find <em>d</em> from
<object class="valign-m4" data="../../images/math/ff52bee7e9ab7e6ba6c4eaec88d621a058253f8b.svg" style="height: 18px;" type="image/svg+xml">ed\equiv 1\pmod{\phi(n)}</object> using the extended Euclidean algorithm.</p>
</div>
<div class="section" id="practical-considerations">
<h2>Practical considerations</h2>
<p>The algorithm described so far is sometimes called <em>textbook RSA</em> (or
<em>schoolbook RSA</em>). That's because it deals entirely in numbers, ignoring all
kinds of practical matters. In fact, textbook RSA is susceptible to <a class="reference external" href="https://crypto.stackexchange.com/questions/20085/which-attacks-are-possible-against-raw-textbook-rsa">several clever
attacks</a>
and has to be enhanced with random padding schemes for practical use.</p>
<p>A simple padding scheme called PKCS #1 v1.5 has been used for many years and is
defined in <a class="reference external" href="https://tools.ietf.org/html/rfc2313">RFC 2313</a>. These days more
advanced schemes like <a class="reference external" href="https://tools.ietf.org/html/rfc2437">OAEP</a> are
recommended instead, but PKCS #1 v1.5 is very easy to explain and therefore I'll
use it for didactic purposes.</p>
<p>Suppose we have some binary data <em>D</em> to encrypt. The approach works for data of
any size, but we will focus on just encrypting small pieces of data. In
practice this is sufficient because RSA is commonly used to only encrypt a
symmetric encryption key, which is much smaller than the RSA key size <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>. The
scheme can work well enough for arbitrary sized messages though - we'll just
split it to multiple blocks with some pre-determined block size.</p>
<p>From <em>D</em> we create a block for encryption - the block has the same length as our
RSA key:</p>
<img alt="PKCS #1 v1.5 encryption padding scheme" class="align-center" src="../../images/2019/pkcs-15-rsa.png" />
<p>Here <em>PS</em> is the padding, which should occupy all the bytes not taken by the
header and <em>D</em> in the block, and should be at least 8 bytes long (if it's
shorter, the data may be broken into two separate blocks). It's a sequence
of random non-zero bytes generated separately for each encryption. Once we
have this full block of data, we convert it to a number treating the bytes
as a big-endian encoding <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>. We end up with a large number <em>x</em>, which we then
perform the RSA encryption step on with <object class="valign-m4" data="../../images/math/76a0d009913eb990fab8299e3574b743b0bed303.svg" style="height: 18px;" type="image/svg+xml">Enc(x)=x^e\pmod{n}</object>. The result
is then encoded in binary and sent over the wire.</p>
<p>Decryption is done in reverse. We turn the received byte stream into a number,
perform <object class="valign-m4" data="../../images/math/67a657cde6a7d17787a986e10bf64e55a83c65ae.svg" style="height: 19px;" type="image/svg+xml">Dec(C)=C^d\pmod{n}</object>, then strip off the padding (note that the
padding has no 0 bytes and is terminated with a 0, so this is easy) and get our
original message back.</p>
<p>The random padding here makes attacks on textbook RSA impractical, but the
scheme as a whole may still be vulnerable to
<a class="reference external" href="https://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5">more sophisticated attacks</a>
in some cases. Therefore, more modern schemes like OAEP should be used in
practice.</p>
</div>
<div class="section" id="implementing-rsa-in-go">
<h2>Implementing RSA in Go</h2>
<p>I've implemented a simple variant of RSA encryption and
decryption as described in this post, in Go. Go makes it particularly easy to
implement cryptographic algorithms because of its great support for
arbitrary-precision integers with the stdlib <tt class="docutils literal">big</tt> package. Not only does
this package support basics of manipulating numbers, it also supports several
primitives specifically for cryptography - for example the <tt class="docutils literal">Exp</tt> method
supports efficient modular exponentiation, and the <tt class="docutils literal">ModInverse</tt> method
supports finding modular multiplicative modular inverses. In addition, the
<tt class="docutils literal">crypto/rand</tt> contains randomness primitives specifically designed for
cryptographic uses.</p>
<p>Go has a production-grade crypto implementation in the standard library. RSA is
in <tt class="docutils literal">crypto/rsa</tt>, so for anything real <em>please</em> use that <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>. The code shown
and linked here is just for educational purposes.</p>
<p>The full code, with some tests, is <a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2019/rsa">available on GitHub</a>. We'll start by
defining the types to hold public and private keys:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">PublicKey</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">N</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w"></span>
<span class="w">  </span><span class="nx">E</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">type</span><span class="w"> </span><span class="nx">PrivateKey</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">N</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w"></span>
<span class="w">  </span><span class="nx">D</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The code also contains a <tt class="docutils literal">GenerateKeys</tt> function that will randomly generate
these keys with an appropriate bit length. Given a public key, textbook
encryption is simply:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">encrypt</span><span class="p">(</span><span class="nx">pub</span><span class="w"> </span><span class="o">*</span><span class="nx">PublicKey</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">c</span><span class="p">.</span><span class="nx">Exp</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="w"> </span><span class="nx">pub</span><span class="p">.</span><span class="nx">E</span><span class="p">,</span><span class="w"> </span><span class="nx">pub</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And decryption is:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">decrypt</span><span class="p">(</span><span class="nx">priv</span><span class="w"> </span><span class="o">*</span><span class="nx">PrivateKey</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">m</span><span class="p">.</span><span class="nx">Exp</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">priv</span><span class="p">.</span><span class="nx">D</span><span class="p">,</span><span class="w"> </span><span class="nx">priv</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">m</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>You'll notice that the bodies of these two functions are pretty much the same,
except for which exponent they use. Indeed, they are just typed wrappers around
the <tt class="docutils literal">Exp</tt> method.</p>
<p>Finally, here's the full PKCS #1 v1.5 encryption procedure, as described above:</p>
<div class="highlight"><pre><span></span><span class="c1">// EncryptRSA encrypts the message m using public key pub and returns the</span><span class="w"></span>
<span class="c1">// encrypted bytes. The length of m must be &lt;= size_in_bytes(pub.N) - 11,</span><span class="w"></span>
<span class="c1">// otherwise an error is returned. The encryption block format is based on</span><span class="w"></span>
<span class="c1">// PKCS #1 v1.5 (RFC 2313).</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="nx">EncryptRSA</span><span class="p">(</span><span class="nx">pub</span><span class="w"> </span><span class="o">*</span><span class="nx">PublicKey</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Compute length of key in bytes, rounding up.</span><span class="w"></span>
<span class="w">  </span><span class="nx">keyLen</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="nx">pub</span><span class="p">.</span><span class="nx">N</span><span class="p">.</span><span class="nx">BitLen</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">keyLen</span><span class="o">-</span><span class="mi">11</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;len(m)=%v, too long&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Following RFC 2313, using block type 02 as recommended for encryption:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// EB = 00 || 02 || PS || 00 || D</span><span class="w"></span>
<span class="w">  </span><span class="nx">psLen</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">keyLen</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">  </span><span class="nx">eb</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">keyLen</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">eb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x00</span><span class="w"></span>
<span class="w">  </span><span class="nx">eb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x02</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Fill PS with random non-zero bytes.</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="nx">psLen</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">rand</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">eb</span><span class="p">[</span><span class="nx">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">eb</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0x00</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">i</span><span class="o">++</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">eb</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="nx">psLen</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x00</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Copy the message m into the rest of the encryption block.</span><span class="w"></span>
<span class="w">  </span><span class="nb">copy</span><span class="p">(</span><span class="nx">eb</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="nx">psLen</span><span class="p">:],</span><span class="w"> </span><span class="nx">m</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Now the encryption block is complete; we take it as a m-byte big.Int and</span><span class="w"></span>
<span class="w">  </span><span class="c1">// RSA-encrypt it with the public key.</span><span class="w"></span>
<span class="w">  </span><span class="nx">mnum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">SetBytes</span><span class="p">(</span><span class="nx">eb</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">encrypt</span><span class="p">(</span><span class="nx">pub</span><span class="p">,</span><span class="w"> </span><span class="nx">mnum</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// The result is a big.Int, which we want to convert to a byte slice of</span><span class="w"></span>
<span class="w">  </span><span class="c1">// length keyLen. It&#39;s highly likely that the size of c in bytes is keyLen,</span><span class="w"></span>
<span class="w">  </span><span class="c1">// but in rare cases we may need to pad it on the left with zeros (this only</span><span class="w"></span>
<span class="w">  </span><span class="c1">// happens if the whole MSB of c is zeros, meaning that it&#39;s more than 256</span><span class="w"></span>
<span class="w">  </span><span class="c1">// times smaller than the modulus).</span><span class="w"></span>
<span class="w">  </span><span class="nx">padLen</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">keyLen</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">padLen</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">eb</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x00</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nb">copy</span><span class="p">(</span><span class="nx">eb</span><span class="p">[</span><span class="nx">padLen</span><span class="p">:],</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">eb</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>There's also <tt class="docutils literal">DecryptRSA</tt>, which unwraps this:</p>
<div class="highlight"><pre><span></span><span class="c1">// DecryptRSA decrypts the message c using private key priv and returns the</span><span class="w"></span>
<span class="c1">// decrypted bytes, based on block 02 from PKCS #1 v1.5 (RCS 2313).</span><span class="w"></span>
<span class="c1">// It expects the length in bytes of the private key modulo to be len(eb).</span><span class="w"></span>
<span class="c1">// Important: this is a simple implementation not designed to be resilient to</span><span class="w"></span>
<span class="c1">// timing attacks.</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="nx">DecryptRSA</span><span class="p">(</span><span class="nx">priv</span><span class="w"> </span><span class="o">*</span><span class="nx">PrivateKey</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">keyLen</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="nx">priv</span><span class="p">.</span><span class="nx">N</span><span class="p">.</span><span class="nx">BitLen</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">keyLen</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;len(c)=%v, want keyLen=%v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span><span class="w"> </span><span class="nx">keyLen</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Convert c into a bit.Int and decrypt it using the private key.</span><span class="w"></span>
<span class="w">  </span><span class="nx">cnum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">SetBytes</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">mnum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">decrypt</span><span class="p">(</span><span class="nx">priv</span><span class="p">,</span><span class="w"> </span><span class="nx">cnum</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Write the bytes of mnum into m, left-padding if needed.</span><span class="w"></span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">keyLen</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nb">copy</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">keyLen</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nx">mnum</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">()):],</span><span class="w"> </span><span class="nx">mnum</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">())</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Expect proper block 02 beginning.</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0x00</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;m[0]=%v, want 0x00&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0x02</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;m[1]=%v, want 0x02&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Skip over random padding until a 0x00 byte is reached. +2 adjusts the index</span><span class="w"></span>
<span class="w">  </span><span class="c1">// back to the full slice.</span><span class="w"></span>
<span class="w">  </span><span class="nx">endPad</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bytes</span><span class="p">.</span><span class="nx">IndexByte</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span><span class="w"> </span><span class="mh">0x00</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">endPad</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;end of padding not found&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="nx">endPad</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="w"> </span><span class="kc">nil</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="digital-signatures-with-rsa">
<h2>Digital signatures with RSA</h2>
<p>RSA can be also used to perform <em>digital signatures</em>. Here's how it works:</p>
<ol class="arabic simple">
<li>Key generation and distribution remains the same. Alice has a public key and
a private key. She publishes her public key online.</li>
<li>When Alice wants to send Bob a message and have Bob be sure that only she
could have sent it, she will <em>encrypt</em> the message with her <em>private</em> key,
that is <object class="valign-m4" data="../../images/math/ad1c0c30bf900657c2a36a6361873f2e8801873f.svg" style="height: 19px;" type="image/svg+xml">S=Sign(M)=M^d\pmod{n}</object>. The signature is attached to the
message.</li>
<li>When Bob receives a message, he can <em>decrypt</em> the signature with Alice's
public key: <object class="valign-m4" data="../../images/math/15a4fcf51b7c6984cc437be976d1e1d52e5f749c.svg" style="height: 18px;" type="image/svg+xml">Check(S)=S^e\pmod{n}</object> and if he gets the original message
back, the signature was correct.</li>
</ol>
<p>The correctness proof would be exactly the same as for encryption. No one else
could have signed the message, because proper signing would require having the
private key of Alice, which only she possesses.</p>
<p>This is the textbook signature algorithm. One difference between the practical
implementation of signing and encryption is in the padding protocol used. While
OAEP is recommended for encryption, <a class="reference external" href="https://en.wikipedia.org/wiki/Probabilistic_signature_scheme">PSS</a> is recommended
for signing <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>. I'm not going to implement signing for this post, but the
Go standard library has great code for this - for example <tt class="docutils literal">rsa.SignPKCS1v15</tt>
and <tt class="docutils literal">rsa.SignPSS</tt>.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>For two reasons: one is that we don't have to randomly find another large
number - this operation takes time; another is that 65537 has only two
bits &quot;on&quot; in its binary representation, which makes <a class="reference external" href="../../2009/03/28/efficient-modular-exponentiation-algorithms.html">modular
exponentiation algorithms faster</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>A strong AES key is 256 bits, while RSA is commonly 2048 or more. The
reason RSA encrypts a symmetric key is efficiency - RSA encryption is
much slower than block ciphers, to the extent that it's often impractical
to encrypt large streams of data with it. A hybrid scheme - wherein a
strong AES key is first encrypted with RSA, and then AES is used to
encrypt large data - is very common. This is the general idea behind what
TLS and similar secure protocols use.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>Note that the first 8 bits of the data block are 0, which makes it easy
to ensure that the number we encrypt is smaller than <em>n</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>The stdlib implementation is resilient to common kinds of side-channel
attacks, such as using algorithms whose run time is independent of
certain characteristics of the input, which makes timing attacks less
feasible.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>The reason for a different protocol is that the attacks on
encrypted messages and on signatures tend to be different. For example,
while for encrypted messages it's unthinkable to let attackers know any
characteristics of the original message (the <em>base</em> in the
exponentiation), in signing it's usually plainly available.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2019/rsa-theory-and-implementation/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:57:44 GMT -->
</html>