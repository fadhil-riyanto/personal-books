<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2005/06/12/lessons-from-paip by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:20:41 GMT -->
<head>
    <title>lessons from PAIP - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../theme/css/style.css" type="text/css"/>

        <link href="../../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../../index.html" class="navbar-brand">
                <img src="../../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="lessons-from-paip.html"
                       rel="bookmark"
                       title="Permalink to lessons from PAIP">
                        lessons from PAIP
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> June 12, 2005 at 13:11</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../../tag/lisp.html">Lisp</a>
        ,
    <a href="../../../tag/perl.html">Perl</a>
        ,
    <a href="../../../tag/programming.html">Programming</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                
        <p>PAIP (Paradigms of AI Programming) is one of the best programming books in existence, IMHO. In an article named <a href="http://www.norvig.com/Lisp-retro.html" rel="nofollow">A Retrospective on PAIP</a>, Peter Norvig lists the most important lessons to be learned from his book (with references to the book's relevant pages):
<ol>
<li>
Use anonymous functions. [p. 20]</li>
<li>
Create new functions (closures) at run time. [p. 22]</li>
<li>
Use the most natural notation available to solve a problem. [p. 42]</li>
<li>
Use the same data for several programs. [p. 43]</li>
<li>
Be specific. Use abstractions. Be concise. Use the provided tools. Don't<br />
be obscure. Be consistent. [p. 49]</li>
<li>
Use macros (if really necessary). [p. 66]</li>
<li>
There are 20 or 30 major data types; familiarize yourself with them. [p.<br />
81]</li>
<li>
Whenever you develop a complex data structure, develop a corresponding<br />
consistency checker. [p. 90]</li>
<li>
To solve a problem, describe it, specify it in algorithmic terms, implement<br />
it, test it, debug and analyze it. Expect this to be an iterative process.<br />
[p. 110]</li>
<li>
<p>AI programming is largely exploratory programming; the aim is often to<br />
discover more about the problem area. [p. 119]</li>
<li>
A general problem solver should be able to solve different problems. [p.<br />
132]</li>
<li>
We must resist the temptation to belive that all thinking follows the computational<br />
model. [p. 147]</li>
<li>
The main object of this book is to cause the reader to say to him or herself<br />
"I could have written that". [p. 152]</li>
<li>
If we left out the prompt, we could write a complete Lisp interpreter using<br />
just four symbols. Consider what we would have to do to write a Lisp (or<br />
Pascal, or Java) interpreter in Pascal (or Java). [p. 176]</li>
<li>
Design patterns can be used informally, or can be abstracted into a formal<br />
function, macro, or data type (often involving higher-order functions).<br />
[p. 177]</li>
<li>
Use data-driven programming, where pattern/action pairs are stored in a<br />
table. [p. 182]</li>
<li>
Sometimes "more is less": its easier to produce more output than just the<br />
right output. [p. 231]</li>
<li>
Lisp is not inherently less efficient than other high-level languages -<br />
<i>Richard Fateman</i>. [p. 265]</li>
<li>
First develop a working program. Second, instrument it. Third, replace<br />
the slow parts. [p. 265]</li>
<li>
The expert Lisp programmer eventually develops a<br />
good "efficiency model". [p. 268]</li>
<li>
There are four general techniques for speeding up<br />
an algorithm: caching, compiling, delaying computation, and indexing. [p.<br />
269]</li>
<li>
We can write a compiler as a set of macros. [p. 277]</li>
<li>
Compilation and memoization can yield 100-fold speed-ups.<br />
[p. 307]</li>
<li>
Low-level efficiency concerns can yield 40-fold speed-ups.<br />
[p. 315]</li>
<li>
For efficiency, use declarations, avoid generic functions,<br />
avoid complex argument lists, avoid unnecessary consing, use the right<br />
data structure. [p. 316]</li>
<li>
A language that doesn't affect the way you think<br />
about programming is not worth knowing - <i>Alan Perlis</i>. [p. 348]</li>
<li>
Prolog relies on three important ideas: a uniform<br />
data base, logic variables, and automatic backtracking. [p. 349]</li>
<li>
Prolog is similar to Lisp on the main points. [p.<br />
381]</li>
<li>
Object orientation = Objects + Classes + Inheritance<br />
- <i>Peter Wegner</i> [p. 435]</li>
<li>
<p>Instead of prohibiting global state (as functional<br />
programming does), object-oriented programming breaks up the unruly mass<br />
of global state and encapsulates it into small, manageable pieces, or objects.<br />
[p. 435]</li>
<li>
Depending on your definition, CLOS is or is not object-oriented.<br />
It doesn't support encapsulation. [p. 454]</li>
<li>
Prolog may not provide exactly the logic you want<br />
[p. 465], nor the efficiency you want [p. 472]. Other representation schemes<br />
are possible.</li>
<li>
Rule-based translation is a powerful idea, however<br />
sometimes you need more efficiency, and need to give up the simplicity<br />
of a rule-based system [p. 509].</li>
<li>
Translating inputs to a canonical form is often a<br />
good strategy [p. 510].</li>
<li>
An "Expert System" goes beyond a simple logic programming<br />
system: it provides reasoning with uncertainty, explanations, and flexible<br />
flow of control [p. 531].</li>
<li>
Certainty factors provide a simple way of dealing<br />
with uncertainty, but there is general agreement that probabilities provide<br />
a more solid foundation [p. 534].</li>
<li>
The strategy you use to search for a sequence of<br />
good moves can be important [p. 615].</li>
<li>
You can compare two different strategies for a task<br />
by running repeated trials of the two [p. 626].</li>
<li>
It pays to precycle [p. 633].</li>
<li>
Memoization can turn an inefficient program into<br />
an efficient one [p. 662].</li>
<li>
It is often easier to deal with preferences among<br />
competing interpretations of inputs, rather than trying to strictly rule<br />
one interpretation in or out [p 670].</li>
<li>
Logic programs have a simple way to express grammars<br />
[p. 685].</li>
<li>
<p>Handling quantifiers in natural languiage can be<br />
tricky [p. 696].</li>
<li>
Handling long-distance dependencies in natural language<br />
can be tricky [p. 702].</li>
<li>
Understanding how a Scheme interpreter works can<br />
give you a better appreciation of how Lisp works, and thus make you a better<br />
programmer [p. 753].</li>
<li>
The truly amazing, wonderful thing about <tt>call/cc</tt><br />
is the ability to return to a continuation point more than once. [p. 771].</li>
<li>
The first Lisp interpreter was a result of a programmer<br />
ignoring his boss's advice. [p. 777].</li>
<li>
Abelson and Sussman (1985) is probably the best introduction<br />
to computer science ever written [p. 777].</li>
<li>
The simplest compiler need not be much more complex<br />
than an interpreter [p. 784].</li>
<li>
An extraordinary feature of ANSI Common Lisp is the<br />
facility for handling errors [p. 837].</li>
<li>
If you can understand how to write and when to use<br />
<tt>once-only, </tt>then you truly understand macros [p. 853].</li>
<li>
A word to the wise: don't get carried away with macros [p. 855].</li>
</ol>

    
            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2005/06/12/lessons-from-paip by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:20:41 GMT -->
</html>