<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints/ by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:08:12 GMT -->
<head>
    <title>How debuggers work: Part 2 - Breakpoints - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../theme/css/style.css" type="text/css"/>

        <link href="../../../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../../../index.html" class="navbar-brand">
                <img src="../../../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="../how-debuggers-work-part-2-breakpoints.html"
                       rel="bookmark"
                       title="Permalink to How debuggers work: Part 2 - Breakpoints">
                        How debuggers work: Part 2 - Breakpoints
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> January 27, 2011 at 06:43</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../../../tag/debuggers.html">Debuggers</a>
        ,
    <a href="../../../../tag/programming.html">Programming</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                
        <p>This is the second part in a series of articles on how debuggers work. Make sure you read <a class="reference external" href="../../23/how-debuggers-work-part-1/index.html">the first part</a> before this one.</p>
<div class="section" id="in-this-part">
<h3>In this part</h3>
<p>I'm going to demonstrate how breakpoints are implemented in a debugger. Breakpoints are one of the two main pillars of debugging - the other being able to inspect values in the debugged process's memory. We've already seen a preview of the other pillar in part 1 of the series, but breakpoints still remain mysterious. By the end of this article, they won't be.</p>
</div>
<div class="section" id="software-interrupts">
<h3>Software interrupts</h3>
<p>To implement breakpoints on the x86 architecture, software interrupts (also known as &quot;traps&quot;) are used. Before we get deep into the details, I want to explain the concept of interrupts and traps in general.</p>
<p>A CPU has a single stream of execution, working through instructions one by one <a class="footnote-reference" href="#id7" id="id1">[1]</a>. To handle asynchronous events like IO and hardware timers, CPUs use interrupts. A hardware interrupt is usually a dedicated electrical signal to which a special &quot;response circuitry&quot; is attached. This circuitry notices an activation of the interrupt and makes the CPU stop its current execution, save its state, and jump to a predefined  address where a handler routine for the interrupt is located. When the handler finishes its work, the CPU resumes execution from where it stopped.</p>
<p>Software interrupts are similar in principle but a bit different in practice. CPUs support special instructions that allow the software to simulate an interrupt. When such an instruction is executed, the CPU treats it like an interrupt - stops its normal flow of execution, saves its state and jumps to a handler routine. Such &quot;traps&quot; allow many of the wonders of modern OSes (task scheduling, virtual memory, memory protection, debugging) to be implemented efficiently.</p>
<p>Some programming errors (such as division by 0) are also treated by the CPU as traps, and are frequently referred to as &quot;exceptions&quot;. Here the line between hardware and software blurs, since it's hard to say whether such exceptions are really hardware interrupts or software interrupts. But I've digressed too far away from the main topic, so it's time to get back to breakpoints.</p>
</div>
<div class="section" id="int-3-in-theory">
<h3>int 3 in theory</h3>
<p>Having written the previous section, I can now simply say that breakpoints are implemented on the CPU by a special trap called <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt>. <tt class="docutils literal"><span class="pre">int</span></tt> is x86 jargon for &quot;trap instruction&quot; - a call to a predefined interrupt handler. x86 supports the <tt class="docutils literal"><span class="pre">int</span></tt> instruction with a 8-bit operand specifying the number of the interrupt that occurred, so in theory 256 traps are supported. The first 32 are reserved by the CPU for itself, and number 3 is the one we're interested in here - it's called &quot;trap to debugger&quot;.</p>
<p>Without further ado, I'll quote from the bible itself <a class="footnote-reference" href="#id8" id="id2">[2]</a>:</p>
<blockquote>
The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a breakpoint, including other one byte instructions, without over-writing other code).</blockquote>
<p>The part in parens is important, but it's still too early to explain it. We'll come back to it later in this article.</p>
</div>
<div class="section" id="int-3-in-practice">
<h3>int 3 in practice</h3>
<p>Yes, knowing the theory behind things is great, OK, but what does this really mean? How do we use <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> to implement breakpoints? Or to paraphrase common programming Q&amp;A jargon - <em>Plz show me the codes!</em></p>
<p>In practice, this is really very simple. Once your process executes the <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> instruction, the OS stops it <a class="footnote-reference" href="#id9" id="id3">[3]</a>. On Linux (which is what we're concerned with in this article) it then sends the process a signal - <tt class="docutils literal"><span class="pre">SIGTRAP</span></tt>.</p>
<p>That's all there is to it - honest! Now recall from the first part of the series that a tracing (debugger) process gets notified of all the signals its child (or the process it attaches to for debugging) gets, and you can start getting a feel of where we're going.</p>
<p>That's it, no more computer architecture 101 jabber. It's time for examples and code.</p>
</div>
<div class="section" id="setting-breakpoints-manually">
<h3>Setting breakpoints manually</h3>
<p>I'm now going to show code that sets a breakpoint in a program. The target program I'm going to use for this demonstration is the following:</p>
<div class="highlight"><pre>section    .text
    ; The _start symbol must be declared for the linker (ld)
    global _start

_start:

    ; Prepare arguments for the sys_write system call:
    ;   - eax: system call number (sys_write)
    ;   - ebx: file descriptor (stdout)
    ;   - ecx: pointer to string
    ;   - edx: string length
    mov     edx, len1
    mov     ecx, msg1
    mov     ebx, 1
    mov     eax, 4

    ; Execute the sys_write system call
    int     0x80

    ; Now print the other message
    mov     edx, len2
    mov     ecx, msg2
    mov     ebx, 1
    mov     eax, 4
    int     0x80

    ; Execute sys_exit
    mov     eax, 1
    int     0x80

section    .data

msg1    db      &#39;Hello,&#39;, 0xa
len1    equ     $ - msg1
msg2    db      &#39;world!&#39;, 0xa
len2    equ     $ - msg2
</pre></div>
<p>I'm using assembly language for now, in order to keep us clear of compilation issues and symbols that come up when we get into C code. What the program listed above does is simply print &quot;Hello,&quot; on one line and then &quot;world!&quot; on the next line. It's very similar to the program demonstrated in the previous article.</p>
<p>I want to set a breakpoint after the first printout, but before the second one. Let's say right after the first <tt class="docutils literal"><span class="pre">int</span> <span class="pre">0x80</span></tt> <a class="footnote-reference" href="#id10" id="id4">[4]</a>, on the <tt class="docutils literal"><span class="pre">mov</span> <span class="pre">edx,</span> <span class="pre">len2</span></tt> instruction. First, we need to know what address this instruction maps to. Running <tt class="docutils literal"><span class="pre">objdump</span> <span class="pre">-d</span></tt>:</p>
<div class="highlight"><pre>traced_printer2:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000033  08048080  08048080  00000080  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  080490b4  080490b4  000000b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .text:

08048080 &lt;.text&gt;:
 8048080:     ba 07 00 00 00          mov    $0x7,%edx
 8048085:     b9 b4 90 04 08          mov    $0x80490b4,%ecx
 804808a:     bb 01 00 00 00          mov    $0x1,%ebx
 804808f:     b8 04 00 00 00          mov    $0x4,%eax
 8048094:     cd 80                   int    $0x80
 8048096:     ba 07 00 00 00          mov    $0x7,%edx
 804809b:     b9 bb 90 04 08          mov    $0x80490bb,%ecx
 80480a0:     bb 01 00 00 00          mov    $0x1,%ebx
 80480a5:     b8 04 00 00 00          mov    $0x4,%eax
 80480aa:     cd 80                   int    $0x80
 80480ac:     b8 01 00 00 00          mov    $0x1,%eax
 80480b1:     cd 80                   int    $0x80
</pre></div>
<p>So, the address we're going to set the breakpoint on is 0x8048096. Wait, this is not how real debuggers work, right? Real debuggers set breakpoints on lines of code and on functions, not on some bare memory addresses? Exactly right. But we're still far from there - to set breakpoints like <em>real</em> debuggers we still have to cover symbols and debugging information first, and it will take another part or two in the series to reach these topics. For now, we'll have to do with bare memory addresses.</p>
<p>At this point I really want to digress again, so you have two choices. If it's really interesting for you to know <em>why</em> the address is 0x8048096 and what does it mean, read the next section. If not, and you just want to get on with the breakpoints, you can safely skip it.</p>
</div>
<div class="section" id="digression-process-addresses-and-entry-point">
<h3>Digression - process addresses and entry point</h3>
<p>Frankly, 0x8048096 itself doesn't mean much, it's just a few bytes away from the beginning of the text section of the executable. If you look carefully at the dump listing above, you'll see that the text section starts at 0x08048080. This tells the OS to map the text section starting at this address in the virtual address space given to the process. On Linux these addresses can be absolute (i.e. the executable isn't being relocated when it's loaded into memory), because with the virtual memory system each process gets its own chunk of memory and sees the whole 32-bit address space as its own (called &quot;linear&quot; address).</p>
<p>If we examine the ELF <a class="footnote-reference" href="#id11" id="id5">[5]</a> header with <tt class="docutils literal"><span class="pre">readelf</span></tt>, we get:</p>
<div class="highlight"><pre>$ readelf -h traced_printer2
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048080
  Start of program headers:          52 (bytes into file)
  Start of section headers:          220 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         4
  Section header string table index: 3
</pre></div>
<p>Note the &quot;entry point address&quot; section of the header, which also points to 0x8048080. So if we interpret the directions encoded in the ELF file for the OS, it says:</p>
<ol class="arabic simple">
<li>Map the text section (with given contents) to address 0x8048080</li>
<li>Start executing at the entry point - address 0x8048080</li>
</ol>
<p>But still, why 0x8048080? For historic reasons, it turns out. Some googling led me to a few sources that claim that the first 128MB of each process's address space were reserved for the stack. 128MB happens to be 0x8000000, which is where other sections of the executable may start. 0x8048080, in particular, is the default entry point used by the Linux <tt class="docutils literal"><span class="pre">ld</span></tt> linker. This entry point can be modified by passing the <tt class="docutils literal"><span class="pre">-Ttext</span></tt> argument to <tt class="docutils literal"><span class="pre">ld</span></tt>.</p>
<p>To conclude, there's nothing really special in this address and we can freely change it. As long as the ELF executable is properly structured and the entry point address in the header matches the real beginning of the program's code (text section), we're OK.</p>
</div>
<div class="section" id="setting-breakpoints-in-the-debugger-with-int-3">
<h3>Setting breakpoints in the debugger with int 3</h3>
<p>To set a breakpoint at some target address in the traced process, the debugger does the following:</p>
<ol class="arabic simple">
<li>Remember the data stored at the target address</li>
<li>Replace the first byte at the target address with the int 3 instruction</li>
</ol>
<p>Then, when the debugger asks the OS to run the process (with <tt class="docutils literal"><span class="pre">PTRACE_CONT</span></tt> as we saw in the previous article), the process will run and eventually hit upon the <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt>, where it will stop and the OS will send it a signal. This is where the debugger comes in again, receiving a signal that its child (or traced process) was stopped. It can then:</p>
<ol class="arabic simple">
<li>Replace the int 3 instruction at the target address with the original instruction</li>
<li>Roll the instruction pointer of the traced process back by one. This is needed because the instruction pointer now points <em>after</em> the <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt>, having already executed it.</li>
<li>Allow the user to interact with the process in some way, since the process is still halted at the desired target address. This is the part where your debugger lets you peek at variable values, the call stack and so on.</li>
<li>When the user wants to keep running, the debugger will take care of placing the breakpoint back (since it was removed in step 1) at the target address, unless the user asked to cancel the breakpoint.</li>
</ol>
<p>Let's see how some of these steps are translated into real code. We'll use the debugger &quot;template&quot; presented in part 1 (forking a child process and tracing it). In any case, there's a link to  the full source code of this example at the end of the article.</p>
<div class="highlight"><pre><span style="color: #007f00">/* Obtain and show child&#39;s instruction pointer */</span>
ptrace(PTRACE_GETREGS, child_pid, <span style="color: #007f7f">0</span>, &amp;regs);
procmsg(<span style="color: #7f007f">&quot;Child started. EIP = 0x%08x\n&quot;</span>, regs.eip);

<span style="color: #007f00">/* Look at the word at the address we&#39;re interested in */</span>
<span style="color: #00007f; font-weight: bold">unsigned</span> addr = <span style="color: #007f7f">0x8048096</span>;
<span style="color: #00007f; font-weight: bold">unsigned</span> data = ptrace(PTRACE_PEEKTEXT, child_pid, (<span style="color: #00007f; font-weight: bold">void</span>*)addr, <span style="color: #007f7f">0</span>);
procmsg(<span style="color: #7f007f">&quot;Original data at 0x%08x: 0x%08x\n&quot;</span>, addr, data);
</pre></div>
<p>Here the debugger fetches the instruction pointer from the traced process, as well as examines the word currently present at 0x8048096. When run tracing  the assembly program listed in the beginning of the article, this prints:</p>
<div class="highlight"><pre>[13028] Child started. EIP = 0x08048080
[13028] Original data at 0x08048096: 0x000007ba
</pre></div>
<p>So far, so good. Next:</p>
<div class="highlight"><pre><span style="color: #007f00">/* Write the trap instruction &#39;int 3&#39; into the address */</span>
<span style="color: #00007f; font-weight: bold">unsigned</span> data_with_trap = (data &amp; <span style="color: #007f7f">0xFFFFFF00</span>) | <span style="color: #007f7f">0xCC</span>;
ptrace(PTRACE_POKETEXT, child_pid, (<span style="color: #00007f; font-weight: bold">void</span>*)addr, (<span style="color: #00007f; font-weight: bold">void</span>*)data_with_trap);

<span style="color: #007f00">/* See what&#39;s there again... */</span>
<span style="color: #00007f; font-weight: bold">unsigned</span> readback_data = ptrace(PTRACE_PEEKTEXT, child_pid, (<span style="color: #00007f; font-weight: bold">void</span>*)addr, <span style="color: #007f7f">0</span>);
procmsg(<span style="color: #7f007f">&quot;After trap, data at 0x%08x: 0x%08x\n&quot;</span>, addr, readback_data);
</pre></div>
<p>Note how <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> is inserted at the target address. This prints:</p>
<div class="highlight"><pre>[13028] After trap, data at 0x08048096: 0x000007cc
</pre></div>
<p>Again, as expected - <tt class="docutils literal"><span class="pre">0xba</span></tt> was replaced with <tt class="docutils literal"><span class="pre">0xcc</span></tt>. The debugger now runs the child and waits for it to halt on the breakpoint:</p>
<div class="highlight"><pre><span style="color: #007f00">/* Let the child run to the breakpoint and wait for it to</span>
<span style="color: #007f00">** reach it</span>
<span style="color: #007f00">*/</span>
ptrace(PTRACE_CONT, child_pid, <span style="color: #007f7f">0</span>, <span style="color: #007f7f">0</span>);

wait(&amp;wait_status);
<span style="color: #00007f; font-weight: bold">if</span> (WIFSTOPPED(wait_status)) {
    procmsg(<span style="color: #7f007f">&quot;Child got a signal: %s\n&quot;</span>, strsignal(WSTOPSIG(wait_status)));
}
<span style="color: #00007f; font-weight: bold">else</span> {
    perror(<span style="color: #7f007f">&quot;wait&quot;</span>);
    <span style="color: #00007f; font-weight: bold">return</span>;
}

<span style="color: #007f00">/* See where the child is now */</span>
ptrace(PTRACE_GETREGS, child_pid, <span style="color: #007f7f">0</span>, &amp;regs);
procmsg(<span style="color: #7f007f">&quot;Child stopped at EIP = 0x%08x\n&quot;</span>, regs.eip);
</pre></div>
<p>This prints:</p>
<div class="highlight"><pre>Hello,
[13028] Child got a signal: Trace/breakpoint trap
[13028] Child stopped at EIP = 0x08048097
</pre></div>
<p>Note the &quot;Hello,&quot; that was printed before the breakpoint - exactly as we planned. Also note where the child stopped - just after the single-byte trap instruction.</p>
<p>Finally, as was explained earlier, to keep the child running we must do some work. We replace the trap with the original instruction and let the process continue running from it.</p>
<div class="highlight"><pre><span style="color: #007f00">/* Remove the breakpoint by restoring the previous data</span>
<span style="color: #007f00">** at the target address, and unwind the EIP back by 1 to</span>
<span style="color: #007f00">** let the CPU execute the original instruction that was</span>
<span style="color: #007f00">** there.</span>
<span style="color: #007f00">*/</span>
ptrace(PTRACE_POKETEXT, child_pid, (<span style="color: #00007f; font-weight: bold">void</span>*)addr, (<span style="color: #00007f; font-weight: bold">void</span>*)data);
regs.eip -= <span style="color: #007f7f">1</span>;
ptrace(PTRACE_SETREGS, child_pid, <span style="color: #007f7f">0</span>, &amp;regs);

<span style="color: #007f00">/* The child can continue running now */</span>
ptrace(PTRACE_CONT, child_pid, <span style="color: #007f7f">0</span>, <span style="color: #007f7f">0</span>);
</pre></div>
<p>This makes the child print &quot;world!&quot; and exit, just as planned.</p>
<p>Note that we don't restore the breakpoint here. That can be done by executing the original instruction in single-step mode, then placing the trap back and only then do <tt class="docutils literal"><span class="pre">PTRACE_CONT</span></tt>. The debug library demonstrated later in the article implements this.</p>
</div>
<div class="section" id="more-on-int-3">
<h3>More on int 3</h3>
<p>Now is a good time to come back and examine <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> and that curious note from Intel's manual. Here it is again:</p>
<blockquote>
This one byte form is valuable because it can be used to replace the first byte of any instruction with a breakpoint, including other one byte instructions, without over-writing other code</blockquote>
<p><tt class="docutils literal"><span class="pre">int</span></tt> instructions on x86 occupy two bytes - <tt class="docutils literal"><span class="pre">0xcd</span></tt> followed by the interrupt number <a class="footnote-reference" href="#id12" id="id6">[6]</a>. <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> could've been encoded as <tt class="docutils literal"><span class="pre">cd</span> <span class="pre">03</span></tt>, but there's a special single-byte instruction reserved for it - 0xcc.</p>
<p>Why so? Because this allows us to insert a breakpoint without ever overwriting more than one instruction. And this is important. Consider this sample code:</p>
<div class="highlight"><pre>    .. some code ..
    jz    foo
    dec   eax
foo:
    call  bar
    .. some code ..
</pre></div>
<p>Suppose we want to place a breakpoint on <tt class="docutils literal"><span class="pre">dec</span> <span class="pre">eax</span></tt>. This happens to be a single-byte instruction (with the opcode <tt class="docutils literal"><span class="pre">0x48</span></tt>). Had the replacement breakpoint instruction been longer than 1 byte, we'd be forced to overwrite part of the next instruction (<tt class="docutils literal"><span class="pre">call</span></tt>), which would garble it and probably produce something completely invalid. But what is the branch <tt class="docutils literal"><span class="pre">jz</span> <span class="pre">foo</span></tt> was taken? Then, without stopping on <tt class="docutils literal"><span class="pre">dec</span> <span class="pre">eax</span></tt>, the CPU would go straight to execute the invalid instruction after it.</p>
<p>Having a special 1-byte encoding for <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> solves this problem. Since 1 byte is the shortest an instruction can get on x86, we guarantee than only the instruction we want to break on gets changed.</p>
</div>
<div class="section" id="encapsulating-some-gory-details">
<h3>Encapsulating some gory details</h3>
<p>Many of the low-level details shown in code samples of the previous section can be easily encapsulated behind a convenient API. I've done some encapsulation into a small utility library called <tt class="docutils literal"><span class="pre">debuglib</span></tt> - its code is available for download at the end of the article. Here I just want to demonstrate an example of its usage, but with a twist. We're going to trace a program written in C.</p>
</div>
<div class="section" id="tracing-a-c-program">
<h3>Tracing a C program</h3>
<p>So far, for the sake of simplicity, I focused on assembly language targets. It's time to go one level up and see how we can trace a program written in C.</p>
<p>It turns out things aren't very different - it's just a bit harder to find where to place the breakpoints. Consider this simple program:</p>
<div class="highlight"><pre><span style="color: #007f00">#include &lt;stdio.h&gt;</span>


<span style="color: #00007f; font-weight: bold">void</span> <span style="color: #00007f">do_stuff</span>()
{
    printf(<span style="color: #7f007f">&quot;Hello, &quot;</span>);
}


<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">main</span>()
{
    <span style="color: #00007f; font-weight: bold">for</span> (<span style="color: #00007f; font-weight: bold">int</span> i = <span style="color: #007f7f">0</span>; i &lt; <span style="color: #007f7f">4</span>; ++i)
        do_stuff();
    printf(<span style="color: #7f007f">&quot;world!\n&quot;</span>);
    <span style="color: #00007f; font-weight: bold">return</span> <span style="color: #007f7f">0</span>;
}
</pre></div>
<p>Suppose I want to place a breakpoint at the entrance to <tt class="docutils literal"><span class="pre">do_stuff</span></tt>. I'll use the old friend <tt class="docutils literal"><span class="pre">objdump</span></tt> to disassemble the executable, but there's a lot in it. In particular, looking at the <tt class="docutils literal"><span class="pre">text</span></tt> section is a bit useless since it contains a lot of C runtime initialization code I'm currently not interested in. So let's just look for <tt class="docutils literal"><span class="pre">do_stuff</span></tt> in the dump:</p>
<div class="highlight"><pre>080483e4 &lt;do_stuff&gt;:
 80483e4:     55                      push   %ebp
 80483e5:     89 e5                   mov    %esp,%ebp
 80483e7:     83 ec 18                sub    $0x18,%esp
 80483ea:     c7 04 24 f0 84 04 08    movl   $0x80484f0,(%esp)
 80483f1:     e8 22 ff ff ff          call   8048318 &lt;puts@plt&gt;
 80483f6:     c9                      leave
 80483f7:     c3                      ret
</pre></div>
<p>Alright, so we'll place the breakpoint at 0x080483e4, which is the first instruction of <tt class="docutils literal"><span class="pre">do_stuff</span></tt>. Moreover, since this function is called in a loop, we want to keep stopping at the breakpoint until the loop ends. We're going to use the <tt class="docutils literal"><span class="pre">debuglib</span></tt> library to make this simple. Here's the complete debugger function:</p>
<div class="highlight"><pre><span style="color: #00007f; font-weight: bold">void</span> <span style="color: #00007f">run_debugger</span>(pid_t child_pid)
{
    procmsg(<span style="color: #7f007f">&quot;debugger started\n&quot;</span>);

    <span style="color: #007f00">/* Wait for child to stop on its first instruction */</span>
    wait(<span style="color: #007f7f">0</span>);
    procmsg(<span style="color: #7f007f">&quot;child now at EIP = 0x%08x\n&quot;</span>, get_child_eip(child_pid));

    <span style="color: #007f00">/* Create breakpoint and run to it*/</span>
    debug_breakpoint* bp = create_breakpoint(child_pid, (<span style="color: #00007f; font-weight: bold">void</span>*)<span style="color: #007f7f">0x080483e4</span>);
    procmsg(<span style="color: #7f007f">&quot;breakpoint created\n&quot;</span>);
    ptrace(PTRACE_CONT, child_pid, <span style="color: #007f7f">0</span>, <span style="color: #007f7f">0</span>);
    wait(<span style="color: #007f7f">0</span>);

    <span style="color: #007f00">/* Loop as long as the child didn&#39;t exit */</span>
    <span style="color: #00007f; font-weight: bold">while</span> (<span style="color: #007f7f">1</span>) {
        <span style="color: #007f00">/* The child is stopped at a breakpoint here. Resume its</span>
<span style="color: #007f00">        ** execution until it either exits or hits the</span>
<span style="color: #007f00">        ** breakpoint again.</span>
<span style="color: #007f00">        */</span>
        procmsg(<span style="color: #7f007f">&quot;child stopped at breakpoint. EIP = 0x%08X\n&quot;</span>, get_child_eip(child_pid));
        procmsg(<span style="color: #7f007f">&quot;resuming\n&quot;</span>);
        <span style="color: #00007f; font-weight: bold">int</span> rc = resume_from_breakpoint(child_pid, bp);

        <span style="color: #00007f; font-weight: bold">if</span> (rc == <span style="color: #007f7f">0</span>) {
            procmsg(<span style="color: #7f007f">&quot;child exited\n&quot;</span>);
            <span style="color: #00007f; font-weight: bold">break</span>;
        }
        <span style="color: #00007f; font-weight: bold">else</span> <span style="color: #00007f; font-weight: bold">if</span> (rc == <span style="color: #007f7f">1</span>) {
            <span style="color: #00007f; font-weight: bold">continue</span>;
        }
        <span style="color: #00007f; font-weight: bold">else</span> {
            procmsg(<span style="color: #7f007f">&quot;unexpected: %d\n&quot;</span>, rc);
            <span style="color: #00007f; font-weight: bold">break</span>;
        }
    }


    cleanup_breakpoint(bp);
}
</pre></div>
<p>Instead of getting our hands dirty modifying EIP and the target process's memory space, we just use <tt class="docutils literal"><span class="pre">create_breakpoint</span></tt>, <tt class="docutils literal"><span class="pre">resume_from_breakpoint</span></tt> and <tt class="docutils literal"><span class="pre">cleanup_breakpoint</span></tt>. Let's see what this prints when tracing the simple C code displayed above:</p>
<div class="highlight"><pre>$ bp_use_lib traced_c_loop
[13363] debugger started
[13364] target started. will run &#39;traced_c_loop&#39;
[13363] child now at EIP = 0x00a37850
[13363] breakpoint created
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,
world!
[13363] child exited
</pre></div>
<p>Just as expected!</p>
</div>
<div class="section" id="the-code">
<h3>The code</h3>
<p><a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2011/debuggers_part2_code">Here are</a> the complete source code files for this part. In the archive you'll find:</p>
<ul class="simple">
<li>debuglib.h and debuglib.c - the simple library for encapsulating some of the inner workings of a debugger</li>
<li>bp_manual.c - the &quot;manual&quot; way of setting breakpoints presented first in this article. Uses the <tt class="docutils literal"><span class="pre">debuglib</span></tt> library for some boilerplate code.</li>
<li>bp_use_lib.c - uses <tt class="docutils literal"><span class="pre">debuglib</span></tt> for most of its code, as demonstrated in the second code sample for tracing the loop in a C program.</li>
</ul>
</div>
<div class="section" id="conclusion-and-next-steps">
<h3>Conclusion and next steps</h3>
<p>We've covered how breakpoints are implemented in debuggers. While implementation details vary between OSes, when you're on x86 it's all basically variations on the same theme - substituting <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> for the instruction where we want the process to stop.</p>
<p>That said, I'm sure some readers, just like me, will be less than excited about specifying raw memory addresses to break on. We'd like to say &quot;break on <tt class="docutils literal"><span class="pre">do_stuff</span></tt>&quot;, or even &quot;break on <em>this</em> line in <tt class="docutils literal"><span class="pre">do_stuff</span></tt>&quot; and have the debugger do it. In the next article I'm going to show how it's done.</p>
</div>
<div class="section" id="references">
<h3>References</h3>
<p>I've found the following resources and articles useful in the preparation of this article:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.alexonlinux.com/how-debugger-works">How debugger works</a></li>
<li><a class="reference external" href="http://www.linuxforums.org/articles/understanding-elf-using-readelf-and-objdump_125.html">Understanding ELF using readelf and objdump</a></li>
<li><a class="reference external" href="http://mainisusuallyafunction.blogspot.com/2011/01/implementing-breakpoints-on-x86-linux.html">Implementing breakpoints on x86 Linux</a></li>
<li><a class="reference external" href="http://www.nasm.us/xdoc/2.09.04/html/nasmdoc0.html">NASM manual</a></li>
<li><a class="reference external" href="http://stackoverflow.com/questions/2187484/elf-binary-entry-point">SO discussion of the ELF entry point</a></li>
<li><a class="reference external" href="https://news.ycombinator.net/item?id=2131894">This Hacker News discussion</a> of the first part of the series</li>
<li><a class="reference external" href="http://www.deansys.com/doc/gdbInternals/gdbint_toc.html">GDB Internals</a></li>
</ul>
<div align="center" class="align-center"><img class="align-center" src="../../../../images/hline.jpg" style="width: 320px; height: 5px;" /></div>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>On a high-level view this is true. Down in the gory details, many CPUs today execute multiple instructions in parallel, some of them <a class="reference external" href="http://en.wikipedia.org/wiki/Out-of-order_execution">not in their original order</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The bible in this case being, of course, Intel's Architecture software developer's manual, volume 2A.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>How can the OS stop a process just like that? The OS registered its own handler for <tt class="docutils literal"><span class="pre">int</span> <span class="pre">3</span></tt> with the CPU, that's how!</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Wait, <tt class="docutils literal"><span class="pre">int</span></tt> again? Yes! Linux uses <tt class="docutils literal"><span class="pre">int</span> <span class="pre">0x80</span></tt> to implement system calls from user processes into the OS kernel. The user places the number of the system call and its arguments into registers and executes <tt class="docutils literal"><span class="pre">int</span> <span class="pre">0x80</span></tt>. The CPU then jumps to the appropriate interrupt handler, where the OS registered a procedure that looks at the registers and decides which system call to execute.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> (Executable and Linkable Format) is the file format used by Linux for object files, shared libraries and executables.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>An observant reader can spot the translation of <tt class="docutils literal"><span class="pre">int</span> <span class="pre">0x80</span></tt> into <tt class="docutils literal"><span class="pre">cd</span> <span class="pre">80</span></tt> in the dumps listed above.</td></tr>
</tbody>
</table>
</div>

    
            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints/ by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:08:12 GMT -->
</html>