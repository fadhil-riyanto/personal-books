<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:04:11 GMT -->
<head>
    <title>Python metaclasses by example - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../theme/css/style.css" type="text/css"/>

        <link href="../../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../../index.html" class="navbar-brand">
                <img src="../../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="python-metaclasses-by-example.html"
                       rel="bookmark"
                       title="Permalink to Python metaclasses by example">
                        Python metaclasses by example
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> August 14, 2011 at 06:05</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../../tag/python.html">Python</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                
        <p>Python rightfully prides itself as a relatively straightforward language without a lot of &quot;magic&quot; hiding in its workings and features. Sometimes, however, to make interesting abstractions possible, one can dig deep in Python's more dusty and obscure corners to find language constructs that are a bit more magical than usual. <em>Metaclasses</em> are one such feature.</p>
<p>Unfortunately, metaclasses have a reputation for &quot;a solution seeking a problem&quot;. The aim of this article is to demonstrate a few actual uses of metaclasses in widely used Python code.</p>
<p>There is a lot of material on Python metaclasses online, so this isn't just another tutorial (look in the <em>References</em> section below for some links I found useful). I will spend some time explaining what metaclasses are, but my main aim is the examples. That said, this article still aspires to be self-contained - you can start reading it even if you don't know what metaclasses are.</p>
<p>Another quick note before we begin - this article focuses on Python 2.6 &amp; 2.7, because most of the code you find online is still for these versions <a class="footnote-reference" href="#id10" id="id1">[1]</a>. In Python 3.x metaclasses work similarly, although the syntax of specifying them is a bit different. So the vast majority of this article applies to 3.x as well.</p>
<div class="section" id="classes-are-objects-too">
<h3>Classes are objects too</h3>
<p>To understand <em>metaclasses</em>, first we should make some things clear about <em>classes</em>. In Python, <em>everything is an object</em>. And that includes classes. In fact, classes in Python are <a class="reference external" href="http://en.wikipedia.org/wiki/First-class_object">first-class objects</a> <a class="footnote-reference" href="#id11" id="id2">[2]</a> - they can be created at runtime, passed as parameters and returned from functions, and assigned to variables. Here's a short interactive session that demonstrates these qualities of classes:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">make_myklass</span>(**kwattrs):
...   <span style="color: #00007f; font-weight: bold">return</span> <span style="color: #00007f">type</span>(<span style="color: #7f007f">&#39;MyKlass&#39;</span>, (<span style="color: #00007f">object</span>,), <span style="color: #00007f">dict</span>(**kwattrs))
...
&gt;&gt;&gt; myklass_foo_bar = make_myklass(foo=<span style="color: #007f7f">2</span>, bar=<span style="color: #007f7f">4</span>)
&gt;&gt;&gt; myklass_foo_bar
&lt;<span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">__main__</span>.MyKlass&gt;
&gt;&gt;&gt; x = myklass_foo_bar()
&gt;&gt;&gt; x
&lt;__main__.MyKlass <span style="color: #00007f">object</span> at <span style="color: #007f7f">0x01F6B050</span>&gt;
&gt;&gt;&gt; x.foo, x.bar
(<span style="color: #007f7f">2</span>, <span style="color: #007f7f">4</span>)
</pre></div>
<p>Here we use the 3-argument form of the <tt class="docutils literal">type</tt> built-in function to dynamically create a class named <tt class="docutils literal">MyKlass</tt>, inheriting from <tt class="docutils literal">object</tt> with some attributes provided as arguments. Then we create one such class. As you can see, <tt class="docutils literal">myklass_foo_bar</tt> is equivalent to:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">MyKlass</span>(<span style="color: #00007f">object</span>):
  foo = <span style="color: #007f7f">2</span>
  bar = <span style="color: #007f7f">4</span>
</pre></div>
<p>But it was created at runtime, returned from a function and assigned to a variable.</p>
</div>
<div class="section" id="the-class-of-a-class">
<h3>The class of a class</h3>
<p>Every object (including built-ins) in Python has a class. We've just seen that classes are objects too, so classes must also have a class, right? Exactly. Python lets us examine the class of an object with the <tt class="docutils literal">__class__</tt> attribute. Let's see this in action:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">SomeKlass</span>(<span style="color: #00007f">object</span>): <span style="color: #00007f; font-weight: bold">pass</span>
...
&gt;&gt;&gt; someobject = SomeKlass()
&gt;&gt;&gt; someobject.__class__
&lt;<span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">__main__</span>.SomeKlass&gt;
&gt;&gt;&gt; SomeKlass.__class__
&lt;<span style="color: #00007f">type</span> <span style="color: #7f007f">&#39;type&#39;</span>&gt;
</pre></div>
<p>We've created a class and an object of that class. Examining the <tt class="docutils literal">__class__</tt> of <tt class="docutils literal">someobject</tt> we saw that it's <tt class="docutils literal">SomeKlass</tt>. Next comes the interesting part. What is the class of <tt class="docutils literal">SomeKlass</tt>? We can again examine it with <tt class="docutils literal">__class__</tt> and we see it's <tt class="docutils literal">type</tt>.</p>
<p>So <tt class="docutils literal">type</tt> is the class of Python classes <a class="footnote-reference" href="#id12" id="id3">[3]</a>. In other words, while in the example above <tt class="docutils literal">someobject</tt> is <em>a SomeKlass</em> object, <tt class="docutils literal">SomeKlass</tt> itself is <em>a type object</em>.</p>
<p>I don't know about you, but I find this reassuring. Since we learned that classes are objects in Python, it makes sense that they also have a class, and it's nice to know there's a built-in class (<tt class="docutils literal">type</tt>) serving the role of being the class of classes.</p>
</div>
<div class="section" id="metaclass">
<h3>Metaclass</h3>
<p>A metaclass is defined as &quot;the class of a class&quot;. Any class whose instances are themselves classes, is a metaclass. So, according to what we've seen above, this makes <tt class="docutils literal">type</tt> a metaclass - in fact, the most commonly used metaclass in Python, since it's the default metaclass of all classes.</p>
<p>Since a metaclass is the class of a class, it is used to construct classes (just as a class is used to construct objects). But wait a second, don't we create classes with a standard <tt class="docutils literal">class</tt> definition? Definitely, but what Python does under the hood is the following:</p>
<ul class="simple">
<li>When it sees a <tt class="docutils literal">class</tt> definition, Python executes it to collect the attributes (including methods) into a dictionary.</li>
<li>When the <tt class="docutils literal">class</tt> definition is over, Python determines the metaclass of the class. Let's call it <tt class="docutils literal">Meta</tt></li>
<li>Eventually, Python executes <tt class="docutils literal">Meta(name, bases, dct)</tt>, where:<ul>
<li><tt class="docutils literal">Meta</tt> is the metaclass, so this invocation is instantiating it.</li>
<li><tt class="docutils literal">name</tt> is the name of the newly created class</li>
<li><tt class="docutils literal">bases</tt> is a tuple of the class's base classes</li>
<li><tt class="docutils literal">dct</tt> maps attribute names to objects, listing all of the class's attributes</li>
</ul>
</li>
</ul>
<p>How do we determine the metaclass of a class? Simply stated <a class="footnote-reference" href="#id13" id="id4">[4]</a>, if either a class or one of its bases has a <tt class="docutils literal">__metaclass__</tt> attribute <a class="footnote-reference" href="#id14" id="id5">[5]</a>, it's taken as the metaclass. Otherwise, <tt class="docutils literal">type</tt> is the metaclass.</p>
<p>So what happens when we define:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">MyKlass</span>(<span style="color: #00007f">object</span>):
  foo = <span style="color: #007f7f">2</span>
</pre></div>
<p>Is this: <tt class="docutils literal">MyKlass</tt> has no <tt class="docutils literal">__metaclass__</tt> attribute, so <tt class="docutils literal">type</tt> is used instead, and the class creation is done as:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">MyKlass = <span style="color: #00007f">type</span>(name, bases, dct)
</pre></div>
<p>Which is consistent to what we've seen in the beginning of the article. If, on the other hand, <tt class="docutils literal">MyKlass</tt> <em>does</em> have a metaclass defined:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">MyKlass</span>(<span style="color: #00007f">object</span>):
  __metaclass__ = MyMeta
  foo = <span style="color: #007f7f">2</span>
</pre></div>
<p>Then the class creation is done as:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">MyKlass = MyMeta(name, bases, dct)
</pre></div>
<p>So <tt class="docutils literal">MyMeta</tt> should be implemented appropriately to support such calling form and return the new class. It's actually similar to writing a normal class with a pre-defined constructor signature.</p>
</div>
<div class="section" id="metaclass-s-new-and-init">
<h3>Metaclass's <tt class="docutils literal">__new__</tt> and <tt class="docutils literal">__init__</tt></h3>
<p>To control the creation and initialization of the class in the metaclass, you can implement the metaclass's <tt class="docutils literal">__new__</tt> method and/or <tt class="docutils literal">__init__</tt> constructor <a class="footnote-reference" href="#id15" id="id6">[6]</a>. Most real-life metaclasses will probably override just one of them.  <tt class="docutils literal">__new__</tt> should be implemented when you want to control the creation of a new object (class in our case), and <tt class="docutils literal">__init__</tt> should be implemented when you want to control the initialization of the new object after it has been created.</p>
<p>So when the call to <tt class="docutils literal">MyMeta</tt> is done above, what happens under the hood is this:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">MyKlass = MyMeta.__new__(MyMeta, name, bases, dct)
MyMeta.__init__(MyKlass, name, bases, dct)
</pre></div>
<p>Here's a more concrete example that should demonstrate what's going on. Let's write down this definition for a metaclass:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">MyMeta</span>(<span style="color: #00007f">type</span>):
    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__new__</span>(meta, name, bases, dct):
        <span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&#39;-----------------------------------&#39;</span>
        <span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&quot;Allocating memory for class&quot;</span>, name
        <span style="color: #00007f; font-weight: bold">print</span> meta
        <span style="color: #00007f; font-weight: bold">print</span> bases
        <span style="color: #00007f; font-weight: bold">print</span> dct
        <span style="color: #00007f; font-weight: bold">return</span> <span style="color: #00007f">super</span>(MyMeta, meta).__new__(meta, name, bases, dct)
    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__init__</span>(cls, name, bases, dct):
        <span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&#39;-----------------------------------&#39;</span>
        <span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&quot;Initializing class&quot;</span>, name
        <span style="color: #00007f; font-weight: bold">print</span> cls
        <span style="color: #00007f; font-weight: bold">print</span> bases
        <span style="color: #00007f; font-weight: bold">print</span> dct
        <span style="color: #00007f">super</span>(MyMeta, cls).__init__(name, bases, dct)
</pre></div>
<p>When Python executes the following class definition:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">MyKlass</span>(<span style="color: #00007f">object</span>):
    __metaclass__ = MyMeta

    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">foo</span>(<span style="color: #00007f">self</span>, param):
        <span style="color: #00007f; font-weight: bold">pass</span>

    barattr = <span style="color: #007f7f">2</span>
</pre></div>
<p>What gets printed is this (reformatted for clarity):</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">-----------------------------------
Allocating memory for class MyKlass
&lt;class &#39;__main__.MyMeta&#39;&gt;
(&lt;type &#39;object&#39;&gt;,)
{&#39;barattr&#39;: 2, &#39;__module__&#39;: &#39;__main__&#39;,
 &#39;foo&#39;: &lt;function foo at 0x00B502F0&gt;,
 &#39;__metaclass__&#39;: &lt;class &#39;__main__.MyMeta&#39;&gt;}
-----------------------------------
Initializing class MyKlass
&lt;class &#39;__main__.MyKlass&#39;&gt;
(&lt;type &#39;object&#39;&gt;,)
{&#39;barattr&#39;: 2, &#39;__module__&#39;: &#39;__main__&#39;,
 &#39;foo&#39;: &lt;function foo at 0x00B502F0&gt;,
 &#39;__metaclass__&#39;: &lt;class &#39;__main__.MyMeta&#39;&gt;}
</pre></div>
<p>Study and understand this example and you'll grasp most of what one needs to know about writing metaclasses.</p>
<p>It's important to note here that these print-outs are actually done at <em>class creation time</em>, i.e. when the module containing the class is being imported for the first time. Keep this detail in mind for later.</p>
</div>
<div class="section" id="metaclass-s-call">
<h3>Metaclass's <tt class="docutils literal">__call__</tt></h3>
<p>Another metaclass method that's occasionally useful to override is <tt class="docutils literal">__call__</tt>. The reason I'm discussing it separately from <tt class="docutils literal">__new__</tt> and <tt class="docutils literal">__init__</tt> is that unlike those two that get called at class creation time, <tt class="docutils literal">__call__</tt> is called when the already-created class is &quot;called&quot; to instantiate a new object. Here's some code to clarify this:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">MyMeta</span>(<span style="color: #00007f">type</span>):
    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__call__</span>(cls, *args, **kwds):
        <span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&#39;__call__ of &#39;</span>, <span style="color: #00007f">str</span>(cls)
        <span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&#39;__call__ *args=&#39;</span>, <span style="color: #00007f">str</span>(args)
        <span style="color: #00007f; font-weight: bold">return</span> <span style="color: #00007f">type</span>.__call__(cls, *args, **kwds)

<span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">MyKlass</span>(<span style="color: #00007f">object</span>):
    __metaclass__ = MyMeta

    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__init__</span>(<span style="color: #00007f">self</span>, a, b):
        <span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&#39;MyKlass object with a=%s, b=%s&#39;</span> % (a, b)

<span style="color: #00007f; font-weight: bold">print</span> <span style="color: #7f007f">&#39;gonna create foo now...&#39;</span>
foo = MyKlass(<span style="color: #007f7f">1</span>, <span style="color: #007f7f">2</span>)
</pre></div>
<p>This prints:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">gonna create foo now...
__call__ of  &lt;class &#39;__main__.MyKlass&#39;&gt;
__call__ *args= (1, 2)
MyKlass object with a=1, b=2
</pre></div>
<p>Here <tt class="docutils literal">MyMeta.__call__</tt> just notifies us of the arguments and delegates to <tt class="docutils literal">type.__call__</tt>. But it can also interfere in the process, affecting the way objects of the class are created. In a way, this is not unlike overriding the <tt class="docutils literal">__new__</tt> method of the class itself, although there are some differences <a class="footnote-reference" href="#id16" id="id7">[7]</a>.</p>
</div>
<div class="section" id="examples">
<h3>Examples</h3>
<p>We've now covered enough theory to understand what metaclasses are and how to write them. At this point, it's time for the examples that should make things clearer. As I mentioned above, instead of writing synthetic examples I prefer to examine the usage of metaclasses in <em>real</em> Python code.</p>
</div>
<div class="section" id="string-template">
<h3>string.Template</h3>
<p>The first example of a metaclass is taken from the Python standard library. It is one of the very few examples of metaclasses that ships with Python itself.</p>
<p><tt class="docutils literal">string.Template</tt> provides convenient, named string substitutions, and can serve as a very simple templating system. If you're not familiar with this class, this would be a good time to read the docs. I will just explain how it uses metaclasses.</p>
<p>Here are the first few lines from <tt class="docutils literal">class Template</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">Template</span>:
    <span style="color: #7f007f">&quot;&quot;&quot;A string class for supporting $-substitutions.&quot;&quot;&quot;</span>
    __metaclass__ = _TemplateMetaclass

    delimiter = <span style="color: #7f007f">&#39;$&#39;</span>
    idpattern = <span style="color: #7f007f">r&#39;[_a-z][_a-z0-9]*&#39;</span>

    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__init__</span>(<span style="color: #00007f">self</span>, template):
        <span style="color: #00007f">self</span>.template = template
</pre></div>
<p>And this is <tt class="docutils literal">_TemplateMetaclass</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">_TemplateMetaclass</span>(<span style="color: #00007f">type</span>):
    pattern = <span style="color: #7f007f">r&quot;&quot;&quot;</span>
<span style="color: #7f007f">    %(delim)s(?:</span>
<span style="color: #7f007f">      (?P&lt;escaped&gt;%(delim)s) |   # Escape sequence of two delimiters</span>
<span style="color: #7f007f">      (?P&lt;named&gt;%(id)s)      |   # delimiter and a Python identifier</span>
<span style="color: #7f007f">      {(?P&lt;braced&gt;%(id)s)}   |   # delimiter and a braced identifier</span>
<span style="color: #7f007f">      (?P&lt;invalid&gt;)              # Other ill-formed delimiter exprs</span>
<span style="color: #7f007f">    )</span>
<span style="color: #7f007f">    &quot;&quot;&quot;</span>

    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__init__</span>(cls, name, bases, dct):
        <span style="color: #00007f">super</span>(_TemplateMetaclass, cls).__init__(name, bases, dct)
        <span style="color: #00007f; font-weight: bold">if</span> <span style="color: #7f007f">&#39;pattern&#39;</span> <span style="color: #0000aa">in</span> dct:
            pattern = cls.pattern
        <span style="color: #00007f; font-weight: bold">else</span>:
            pattern = _TemplateMetaclass.pattern % {
                <span style="color: #7f007f">&#39;delim&#39;</span> : _re.escape(cls.delimiter),
                <span style="color: #7f007f">&#39;id&#39;</span>    : cls.idpattern,
                }
        cls.pattern = _re.compile(pattern, _re.IGNORECASE | _re.VERBOSE)
</pre></div>
<p>The explanation provided in the first part of this article should be sufficient for understanding how <tt class="docutils literal">_TemplateMetaclass</tt> works. Its <tt class="docutils literal">__init__</tt> method looks at some class attributes (specifically, <tt class="docutils literal">pattern</tt>, <tt class="docutils literal">delimiter</tt> and <tt class="docutils literal">idpattern</tt>) and uses them (or its own-supplied defaults) to build a compiled regex, which is then stored back into the class's <tt class="docutils literal">pattern</tt> attribute.</p>
<p>According to its documentation, <tt class="docutils literal">Template</tt> can be inherited to provide a custom delimiter and ID pattern, or the whole regex. The metaclass makes sure that these get converted into a compiled regex pattern at <em>class creation time</em>, so this is an optimization of a sort.</p>
<p>What I mean is that the same customization could be achieved without using a metaclass, by simply building the compiled regex in the constructor. However, this means that the compilation step is done each time a <tt class="docutils literal">Template</tt> object is instantiated.</p>
<p>Consider the following usage, which IMHO is common with <tt class="docutils literal">string.Template</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #00007f; font-weight: bold">from</span> <span style="color: #00007f">string</span> <span style="color: #00007f; font-weight: bold">import</span> Template
&gt;&gt;&gt; Template(<span style="color: #7f007f">&quot;$name is $value&quot;</span>).substitute(name=<span style="color: #7f007f">&#39;me&#39;</span>, value=<span style="color: #7f007f">&#39;2&#39;</span>)
<span style="color: #7f007f">&#39;me is 2&#39;</span>
</pre></div>
<p>Leaving regex compilation to <tt class="docutils literal">Template</tt> instantiation time means it is being created and compiled each time such piece of code runs. And this is a shame - because the regex really isn't dependent on the template string, but only on the <em>properties of the class</em>.</p>
<p>With a metaclass, the <tt class="docutils literal">pattern</tt> class attribute is getting created just once when the module is being loaded and the <tt class="docutils literal">class Template</tt> (or its subclass) definition is being executed. This saves time when <tt class="docutils literal">Template</tt> objects are created, and makes sense because at class creation time we have all the information we need to compile the regex - so why delay this operation?</p>
<p>One may claim that this is a premature optimization, and this could be true. I don't plan to defend this (or any) usage of a metaclass. My intention here is simply to demonstrate how metaclasses are being used in real code for various tasks. So, for this educational purpose it's a good example, since it shows an interesting use case. Whether premature optimization or not, the metaclass <em>does</em> make code more efficient by moving a computation one step earlier in the process of code execution.</p>
</div>
<div class="section" id="twisted-python-reflect-accessortype">
<h3>twisted.python.reflect.AccessorType</h3>
<p>The following example is a frequently-used demonstration of metaclasses. An excerpt from its documentation:</p>
<blockquote>
Metaclass that generates properties automatically. Using this metaclass for your class will give you explicit accessor methods; a method called set_foo, will automatically create a property 'foo' that uses set_foo as a setter method. Same for get_foo and del_foo.</blockquote>
<p>Here's the metaclass, shortened a bit to emphasize the important parts:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">AccessorType</span>(<span style="color: #00007f">type</span>):
    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__init__</span>(<span style="color: #00007f">self</span>, name, bases, d):
        <span style="color: #00007f">type</span>.__init__(<span style="color: #00007f">self</span>, name, bases, d)
        accessors = {}
        prefixs = [<span style="color: #7f007f">&quot;get_&quot;</span>, <span style="color: #7f007f">&quot;set_&quot;</span>, <span style="color: #7f007f">&quot;del_&quot;</span>]
        <span style="color: #00007f; font-weight: bold">for</span> k <span style="color: #0000aa">in</span> d.keys():
            v = <span style="color: #00007f">getattr</span>(<span style="color: #00007f">self</span>, k)
            <span style="color: #00007f; font-weight: bold">for</span> i <span style="color: #0000aa">in</span> <span style="color: #00007f">range</span>(<span style="color: #007f7f">3</span>):
                <span style="color: #00007f; font-weight: bold">if</span> k.startswith(prefixs[i]):
                    accessors.setdefault(k[<span style="color: #007f7f">4</span>:], [<span style="color: #00007f">None</span>, <span style="color: #00007f">None</span>, <span style="color: #00007f">None</span>])[i] = v
        <span style="color: #00007f; font-weight: bold">for</span> name, (getter, setter, deler) <span style="color: #0000aa">in</span> accessors.items():
            <span style="color: #007f00"># create default behaviours for the property - if we leave</span>
            <span style="color: #007f00"># the getter as None we won&#39;t be able to getattr, etc..</span>

            <span style="color: #007f00"># [...] some code that implements the above comment</span>

            <span style="color: #00007f">setattr</span>(<span style="color: #00007f">self</span>, name, <span style="color: #00007f">property</span>(getter, setter, deler, <span style="color: #7f007f">&quot;&quot;</span>))
</pre></div>
<p>What this does is straightforward:</p>
<ol class="arabic simple">
<li>Find all attributes of the class that start with <tt class="docutils literal">get_</tt>, <tt class="docutils literal">set_</tt> or <tt class="docutils literal">del_</tt></li>
<li>Organize them by the property they aim to control (the part of their name that comes after the underscore)</li>
<li>For each getter, setter, deleter triple thus found:</li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Make sure all three exist, or create suitable defaults</li>
<li>Set them as a <tt class="docutils literal">property</tt> on the class</li>
</ol>
</blockquote>
<p>How useful is such a metaclass? It's hard to say, really. Twisted itself doesn't use it, but does provide it as a public API. If you have several classes to write with a lot of properties, this metaclass may save quite a bit of coding.</p>
</div>
<div class="section" id="pygments-lexer-and-regexlexer">
<h3>pygments Lexer and RegexLexer</h3>
<p>The <a class="reference external" href="http://pygments.org/">pygments</a> library presents an interesting idiom of metaclass usage. A base class is created with a custom metaclass. User classes can then inherit from this base class, and get the metaclass as a bonus <a class="footnote-reference" href="#id17" id="id8">[8]</a>. First, let's look at the <tt class="docutils literal">LexerMeta</tt> metaclass, which is used as the metaclass for <tt class="docutils literal">Lexer</tt> - the base class of lexers in pygments:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">LexerMeta</span>(<span style="color: #00007f">type</span>):
    <span style="color: #7f007f">&quot;&quot;&quot;</span>
<span style="color: #7f007f">    This metaclass automagically converts ``<code>analyse_text</code>`` methods into</span>
<span style="color: #7f007f">    static methods which always return float values.</span>
<span style="color: #7f007f">    &quot;&quot;&quot;</span>

    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__new__</span>(cls, name, bases, d):
        <span style="color: #00007f; font-weight: bold">if</span> <span style="color: #7f007f">&#39;analyse_text&#39;</span> <span style="color: #0000aa">in</span> d:
            d[<span style="color: #7f007f">&#39;analyse_text&#39;</span>] = make_analysator(d[<span style="color: #7f007f">&#39;analyse_text&#39;</span>])
        <span style="color: #00007f; font-weight: bold">return</span> <span style="color: #00007f">type</span>.__new__(cls, name, bases, d)
</pre></div>
<p>This metaclass overrides the <tt class="docutils literal">__new__</tt> method to intercept the definition of the <tt class="docutils literal">analyse_text</tt> message and turn it into a static method that always returns a floating point value (this is what the <tt class="docutils literal">make_analysator</tt> function does).</p>
<p>Note the usage of <tt class="docutils literal">__new__</tt> instead of <tt class="docutils literal">__init__</tt> here. Why isn't <tt class="docutils literal">__init__</tt> used? In my opinion, this is simply a matter of preference - the same effect could also be achieved with overriding <tt class="docutils literal">__init__</tt>.</p>
<p>The second example from pygments is more complicated, but worth the effort to explain since it contains a couple of features we haven't seen in previous examples. The code for <tt class="docutils literal">RegexLexerMeta</tt> is quite long, so I will snip it to leave the relevant part:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">class</span> <span style="color: #00007f">RegexLexerMeta</span>(LexerMeta):
    <span style="color: #7f007f">&quot;&quot;&quot;</span>
<span style="color: #7f007f">    Metaclass for RegexLexer, creates the self._tokens attribute from</span>
<span style="color: #7f007f">    self.tokens on the first instantiation.</span>
<span style="color: #7f007f">    &quot;&quot;&quot;</span>

    <span style="color: #007f00"># [...] snip</span>

    <span style="color: #00007f; font-weight: bold">def</span> <span style="color: #00007f">__call__</span>(cls, *args, **kwds):
        <span style="color: #7f007f">&quot;&quot;&quot;Instantiate cls after preprocessing its token definitions.&quot;&quot;&quot;</span>
        <span style="color: #00007f; font-weight: bold">if</span> <span style="color: #0000aa">not</span> <span style="color: #00007f">hasattr</span>(cls, <span style="color: #7f007f">&#39;_tokens&#39;</span>):
            cls._all_tokens = {}
            cls._tmpname = <span style="color: #007f7f">0</span>
            <span style="color: #00007f; font-weight: bold">if</span> <span style="color: #00007f">hasattr</span>(cls, <span style="color: #7f007f">&#39;token_variants&#39;</span>) <span style="color: #0000aa">and</span> cls.token_variants:
                <span style="color: #007f00"># don&#39;t process yet</span>
                <span style="color: #00007f; font-weight: bold">pass</span>
            <span style="color: #00007f; font-weight: bold">else</span>:
                cls._tokens = cls.process_tokendef(<span style="color: #7f007f">&#39;&#39;</span>, cls.tokens)

        <span style="color: #00007f; font-weight: bold">return</span> <span style="color: #00007f">type</span>.__call__(cls, *args, **kwds)
</pre></div>
<p>Generally, the code is quite clear - the metaclass examines the <tt class="docutils literal">tokens</tt> class attribute, and creates <tt class="docutils literal">_tokens</tt> from it. This is only done on the first instantiation of the class. There are two things of special interest here:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">RegexLexerMeta</tt> inherits from <tt class="docutils literal">LexerMeta</tt>, so its users also get the service <tt class="docutils literal">LexerMeta</tt> provides. Inheritance of metaclasses is one of the reasons they are one of the most powerful language constructs in Python. Contrast this to class decorators, for example. For some simple tasks, class decorators could replace metaclasses, but the ability of metaclasses to form inheritance relationships is something that decorators can't do.</li>
<li>The <tt class="docutils literal">process_tokendef</tt> computation is performed in <tt class="docutils literal">__call__</tt> - and a special check makes sure it actually runs only in the first instantiation of the class (although <tt class="docutils literal">__call__</tt> itself is called for all instantiations). Why do it like this, instead of at class creation time (say in the metaclass's <tt class="docutils literal">__init__</tt>)? It appears to me this could be an optimization of a sort. pygments comes with many lexers <a class="footnote-reference" href="#id18" id="id9">[9]</a>, but you may want to use just one or two in any given code. Why spend the loading time on lexers you don't need, as opposed to just the lexers you use? Whether this is the real reason or not, I think it's still an interesting aspect of metaclasses to ponder - the great flexibility they provide you to choose where and how to perform their meta-work.</li>
</ol>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>My intention in this article was to explain how metaclasses in Python work and provide a few concrete examples of metaclass usage in real Python code. I know that metaclasses have some notoriety, as many people consider them more magic than usually necessary. My opinion on the subject is that, like other language constructs, metaclasses are <em>a tool</em>, and the programmer is eventually responsible for using it correctly. Always write the simplest code that does the job, but if you feel that a metaclass is what you need, you're free to use a metaclass.</p>
<p>I hope this article demonstrated the great flexibility metaclasses provide for customizing the way classes are created and used. The examples presented several aspects of metaclass implementation and usage - overriding <tt class="docutils literal">__init__</tt>, <tt class="docutils literal">__new__</tt> and <tt class="docutils literal">__call__</tt> methods, using metaclass inheritance, adding properties to classes, converting object methods to static methods and performing optimizations at either class definition or instantiation time.</p>
<p>The most notable example of metaclasses in Python is probably their usage in ORM (Object Relational Mapping) frameworks, such as Django's models. Indeed, these are forceful demonstrations of what metaclasses are capable of, but I decided not to present them here because their code is complex and the many domain-specific details would obscure the main goal of presenting metaclasses. Having read this article, however, you have everything necessary to understand the more complex examples.</p>
<p>P.S. If you find other interesting examples of metaclasses, please let me know. I'm very interested in seeing additional real-life uses.</p>
</div>
<div class="section" id="references">
<h3>References</h3>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/reference/datamodel.html">Data model page</a> in the official docs.</li>
<li><a class="reference external" href="http://www.ibm.com/developerworks/linux/library/l-pymeta/index.html">Metaclass programming in Python</a> - a series of articles explaining metaclasses.</li>
<li><a class="reference external" href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">What is a metaclass in Python?</a> - a great StackOverflow discussion.</li>
<li><a class="reference external" href="http://www.python.org/download/releases/2.2.3/descrintro">Unifying types and classes in Python 2.2</a> - a very informative article by Guido von Rossum that touches on metaclasses as well.</li>
<li><a class="reference external" href="http://stackoverflow.com/questions/4859129/python-and-python-c-api-new-versus-init">A StackOverflow discussion</a> on the differences between <tt class="docutils literal">__new__</tt> and <tt class="docutils literal">__init__</tt>.</li>
<li>Another StackOverflow discussion about the <a class="reference external" href="http://stackoverflow.com/questions/392160/what-are-your-concrete-use-cases-for-metaclasses-in-python">concrete uses of metaclasses</a>.</li>
</ul>
<img class="align-center" src="../../../images/hline.jpg" style="width: 320px; height: 5px;" />
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Moreover, I'm only touching upon <em>new-style</em> classes (i.e. those deriving from <tt class="docutils literal">object</tt>). I hope that all new code you write and the vast majority of code you see these days uses new-style classes. With old-style classes, some of the specifics of metaclasses presented here are a bit different, though in general the same principles apply.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The word-play here is unintended. In &quot;first-class objects&quot; the word <em>class</em> has the same meaning as &quot;rank&quot; or &quot;caliber&quot;, to imply that these objects aren't worse than other objects in the language.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>You may notice a duplicity here - <tt class="docutils literal">type</tt> is both a class and a built-in used for creating new classes and checking the types of objects. This isn't different from other built-ins in Python. For example, <tt class="docutils literal">dict</tt> is both the class of dictionaries (<tt class="docutils literal"><span class="pre">{}.__class__</span></tt> is <tt class="docutils literal">&lt;type 'dict'&gt;</tt>) and a constructor of dictionaries. In fact, this is true for user-defined classes as well, since the name of the class also serves as a constructor for new objects. So you can think of <tt class="docutils literal">type</tt> as just another built-in class in Python.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>You can look up the exact rules in the <a class="reference external" href="http://docs.python.org/reference/datamodel.html">data model reference</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Again, a reminder that I describe Python 2 in this article. In Python 3 the syntax of defining metaclasses has been changed, and made a bit more intuitive.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Explaining the exact differences between <tt class="docutils literal">__new__</tt> and <tt class="docutils literal">__init__</tt> will take an article of its own and I won't cover it beyond the simple examples here. You may want to google this topic for better understanding.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>For a good discussion of this, see <a class="reference external" href="http://stackoverflow.com/questions/6966772/using-the-call-method-of-a-metaclass-instead-of-new/6966942#6966942">this StackOverflow question</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>Since Python's metaclass lookup rules dictate that if a class itself has no metaclass, its base classes are looked at to find metaclasses.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td>And, more importantly, aggregates several lexers in each module.</td></tr>
</tbody>
</table>
</div>

    
            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:04:11 GMT -->
</html>