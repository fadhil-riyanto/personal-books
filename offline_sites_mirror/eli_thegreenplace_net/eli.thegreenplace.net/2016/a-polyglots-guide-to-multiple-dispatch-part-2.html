<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-2 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:01:33 GMT -->
<head>
    <title>A polyglot's guide to multiple dispatch - part 2 - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../theme/css/style.css" type="text/css"/>

        <link href="../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../index.html" class="navbar-brand">
                <img src="../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="a-polyglots-guide-to-multiple-dispatch-part-2/index.html"
                       rel="bookmark"
                       title="Permalink to A polyglot's guide to multiple dispatch - part 2">
                        A polyglot's guide to multiple dispatch - part 2
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> April 21, 2016 at 05:07</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../tag/python.html">Python</a>
        ,
    <a href="../tag/multiple-dispatch.html">Multiple dispatch</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This is part 2 in the <a class="reference external" href="../tag/multiple-dispatch.html">series of articles</a> on multiple dispatch.
<a class="reference external" href="a-polyglots-guide-to-multiple-dispatch.html">Part 1</a>
introduced the problem and discussed the issues surrounding it, along with a
couple of possible solutions in C++. In this part, I'm going to talk about
implementing multiple dispatch in a completely different language - Python.</p>
<div class="section" id="a-brief-re-statement-of-the-problem">
<h2>A brief re-statement of the problem</h2>
<p>It's very important to read part 1 in the series before reading this one, but
for the sake of completeness here's a (very) brief re-statement of the
programming problem we're trying to solve:</p>
<p>We have different &quot;shape&quot; types - rectangles, ellipses, triangles and so on.
We'd like to compute intersections between these shapes, but the algorithm may
be completely different based on the two shapes being intersected. The problem
is how to structure the code for maximal flexibility, correctness and
maintainability.</p>
</div>
<div class="section" id="brute-force-solution-in-python">
<h2>Brute force solution in Python</h2>
<p>Part 1 showed a &quot;brute force&quot; approach in C++ that uses a nested chain of
<tt class="docutils literal"><span class="pre">if-else</span></tt> conditions. It's instructional to start by presenting the same with
Python <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a> so we have a useful baseline to compare subsequent solutions to.
Here is a basic Shape hierarchy:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>

<span class="k">class</span> <span class="nc">Rectangle</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Ellipse</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Triangle</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
<p>And this is the <tt class="docutils literal">intersect</tt> function:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">Ellipse</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Ellipse [names s1=</span><span class="si">%s</span><span class="s1">, s2=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Rectangle [names s1=</span><span class="si">%s</span><span class="s1">, s2=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Generic shape intersection.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shape x Shape [names s1=</span><span class="si">%s</span><span class="s1">, s2=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</pre></div>
<p>Though it requires somewhat less code than in C++, this approach is equivalent
to the brute-force checking using <tt class="docutils literal">dynamic_cast</tt> we've seen in part 1, and it
suffers from the same problems:</p>
<ol class="arabic simple">
<li>Large amount of code that grows square with the number of types.</li>
<li>Brittleness due to subtle ordering of checks for an inheritance hierarchy.</li>
</ol>
<p>The brute-force solution appears odious to C++ programmers. In Python, it's even
more so. Python programmers are not constrained by static typing - they have
a fully dynamic duck-typed language at their disposal - <tt class="docutils literal">isinstance</tt> is
usually a code smell, and Python's reflection and meta-programming capabilities
are far greater than what C++'s templates allow, so there must be a better way.</p>
</div>
<div class="section" id="improving-brute-force-by-dispatching-on-types">
<h2>Improving brute-force by dispatching on types</h2>
<p>In Python it's very easy to create maps (<tt class="docutils literal">dict</tt>s, to be precise) with almost
anything as a key. <a class="reference external" href="../2012/03/30/python-objects-types-classes-and-instances-a-glossary.html">Even types are first-class objects</a>.
Let's replace the <tt class="docutils literal"><span class="pre">if-else</span></tt> chain by a map lookup:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">intersect_rectangle_ellipse</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Ellipse [names r=</span><span class="si">%s</span><span class="s1">, e=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">intersect_rectangle_rectangle</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Rectangle [names r1=</span><span class="si">%s</span><span class="s1">, r2=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">r2</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">intersect_generic</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shape x Shape [names s1=</span><span class="si">%s</span><span class="s1">, s2=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<span class="n">_dispatch_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Ellipse</span><span class="p">):</span> <span class="n">intersect_rectangle_ellipse</span><span class="p">,</span>
    <span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">):</span> <span class="n">intersect_rectangle_rectangle</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">_dispatch_map</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">s2</span><span class="p">)),</span> <span class="n">intersect_generic</span><span class="p">)</span>
    <span class="n">handler</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
</pre></div>
<p>This is much better! Now, whenever we have a new combination of shapes with
a custom intersection handler, we just add the new function, add a line to
<tt class="docutils literal">_dispatch_map</tt> and we're done. Note that we do introduce a subtle
issue here: base-class defaults won't work now, because the dispatch has to be
by the exact type name. In other words, if we have a <tt class="docutils literal">Square</tt> inheriting from
a <tt class="docutils literal">Rectangle</tt>, we may want to reuse <tt class="docutils literal">intersect_rectangle_rectangle</tt> for
interesecting two squares, but right now we'll fall into the generic <tt class="docutils literal">Shape</tt>
handler. I'll examine this problem and possible solutions in more detail later
on.</p>
</div>
<div class="section" id="decorators-and-callable-wrapper-objects-ftw">
<h2>Decorators and callable wrapper objects FTW</h2>
<p>The type mapping code in the last section isn't bad, but we can do better in
Python. Indeed, Guido posted <a class="reference external" href="https://www.artima.com/weblogs/viewpost.jsp?thread=101605">a nice article</a> on this topic a
long while ago. The main insight is to use decorators in combination with
callable objects that wrap the handler functions to make client code look like
this:</p>
<div class="highlight"><pre><span></span><span class="nd">@multimethod</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Ellipse</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Ellipse [names r=</span><span class="si">%s</span><span class="s1">, e=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<span class="nd">@multimethod</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Rectangle [names r1=</span><span class="si">%s</span><span class="s1">, r2=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">r2</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<span class="nd">@multimethod</span><span class="p">(</span><span class="n">Shape</span><span class="p">,</span> <span class="n">Shape</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shape x Shape [names s1=</span><span class="si">%s</span><span class="s1">, s2=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</pre></div>
<p>The magic that makes this tick is:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_MultiMethod</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Maps a tuple of types to function to call for these types.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="vm">__class__</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span><span class="p">[</span><span class="n">types</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;no match </span><span class="si">%s</span><span class="s1"> for types </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">register_function_for_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">types</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;duplicate registration&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span><span class="p">[</span><span class="n">types</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span>


<span class="c1"># Maps function.__name__ -&gt; _MultiMethod object.</span>
<span class="n">_multi_registry</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">multimethod</span><span class="p">(</span><span class="o">*</span><span class="n">types</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">_multi_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="n">_multi_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_MultiMethod</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">mm</span><span class="o">.</span><span class="n">register_function_for_types</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mm</span>
    <span class="k">return</span> <span class="n">register</span>
</pre></div>
<p>There are two levels of map dispatching here. <tt class="docutils literal">_multi_registry</tt> is a map from
functions we consider &quot;multi methods&quot; to a wrapper object of type
<tt class="docutils literal">_MultiMethod</tt>. The intersection algorithm is one example of a multi method,
there may be others (maybe <tt class="docutils literal">collide</tt> or some such). Each instance of
<tt class="docutils literal">_MultiMethod</tt> holds its own mapping akin to <tt class="docutils literal">_dispatch_map</tt> from the
previous section, mapping types of arguments to the actual function. Finally,
the <tt class="docutils literal">multimethod</tt> decorator completes the picture for a very nice solution
overall <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>. Except that it has some issues.</p>
</div>
<div class="section" id="handling-symmetry">
<h2>Handling symmetry</h2>
<p>I presented these issues in part 1, and they bite us again here. First,
symmetry: the way <tt class="docutils literal">&#64;multimethod</tt> is currently defined, we specify the exact
order of the types dispatched upon. In the sample above, we defined:</p>
<div class="highlight"><pre><span></span><span class="nd">@multimethod</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Ellipse</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Ellipse [names r=</span><span class="si">%s</span><span class="s1">, e=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</pre></div>
<p>However, if a call to <tt class="docutils literal">intersect</tt> is made where the first argument is an
<tt class="docutils literal">Ellipse</tt> and the second argument a <tt class="docutils literal">Rectangle</tt>, we're most likely
interested in dispatching to the same function. It won't work the way the code
is currently structured, but it's fairly easy to fix.</p>
<p>Most obviously, we can have something like:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">symmetric_intersection_rectangle_ellipse</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Ellipse [names r=</span><span class="si">%s</span><span class="s1">, e=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<span class="nd">@multimethod</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Ellipse</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="n">symmetric_intersection_rectangle_ellipse</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

<span class="nd">@multimethod</span><span class="p">(</span><span class="n">Ellipse</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">symmetric_intersection_rectangle_ellipse</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
<p>This is similar to the C++ approach in part 1. However, let's try something more
advanced if we <em>always</em> want symmetry for these dispatches. We can easily sort
the types in Python, thus providing symmetry automatically. Here's the new
<tt class="docutils literal">_MultiMethod.register_function_for_types</tt> <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">register_function_for_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="c1"># Sort the tuple of types before setting it in the dispatch map.</span>
    <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">id</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">types</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;duplicate registration&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span><span class="p">[</span><span class="n">types</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span>
</pre></div>
<p>The difference is that now the tuple of types is sorted by type id, which is
guaranteed to be unique and orderable.</p>
<p>The lookup in <tt class="docutils literal">_MultiMethod.__call__</tt> also has to sort the types, but there's
an additional subtlety. If we reorder the arguments, we have to find
a way to route them to the handler function in the right order. In our
<tt class="docutils literal">intersect</tt> example, the handler function takes the rectangle first, then the
ellipse. So if we dispatch <tt class="docutils literal">intersect(e, r)</tt> to the same handler, the order of
arguments has to be reversed:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Find the right function to call based on a sorted tuple of types. We</span>
    <span class="c1"># have to sort the call arguments themselves together with the types,</span>
    <span class="c1"># so that the handler function can get them in the order it expects.</span>
    <span class="n">args_with_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="vm">__class__</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)),</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">id</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ty</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">ty</span> <span class="ow">in</span> <span class="n">args_with_types</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">args_with_types</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span><span class="p">[</span><span class="n">types</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;no match </span><span class="si">%s</span><span class="s1"> for types </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="p">))</span>
</pre></div>
<p>Now using the single multi-method definition:</p>
<div class="highlight"><pre><span></span><span class="nd">@multimethod</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">,</span> <span class="n">Ellipse</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rectangle x Ellipse [names r=</span><span class="si">%s</span><span class="s1">, e=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</pre></div>
<p>We can run:</p>
<div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">()</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">()</span>

<span class="n">intersect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="n">intersect</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
<p>And get:</p>
<div class="highlight"><pre><span></span>Rectangle x Ellipse [names r=&lt;class &#39;__main__.Rectangle&#39;&gt;, e=&lt;class &#39;__main__.Ellipse&#39;&gt;]
Rectangle x Ellipse [names r=&lt;class &#39;__main__.Rectangle&#39;&gt;, e=&lt;class &#39;__main__.Ellipse&#39;&gt;]
</pre></div>
<p>It works, but there are (at least) two problems:</p>
<ol class="arabic simple">
<li>The runtime cost of the dispatch is now excessive. Every call to
<tt class="docutils literal">intersect</tt> has to sort the types of arguments to determine which handler
to dispatch to. This can be alleviated by some sort of caching, but it won't
be free.</li>
<li>The <tt class="docutils literal">intersect(r, e)</tt> handler always accepts the rectangle first.
This implicitly relies on the relative sorting order between <tt class="docutils literal">Rectangle</tt>
and <tt class="docutils literal">Ellipse</tt>: we assume <tt class="docutils literal">Rectangle</tt> will be sorted lower. This is a
pretty bad assumption to make. To solve this we could use keyword arguments,
for example.</li>
</ol>
<p>Even though these problems have solutions, it should be clear that making
symmetry work &quot;magically&quot; is tricky. Is it worth the trouble? YMMV.</p>
</div>
<div class="section" id="handling-base-class-defaults">
<h2>Handling base-class defaults</h2>
<p>Another interesting issue the Python solution doesn't address yet is base-class
defaults; it suffers from the same problem presented above in the manual
dispatch dict approach. We want to add a <tt class="docutils literal">Square</tt> shape:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
<p>But unless we define a version of <tt class="docutils literal">intersect</tt> for the type tuple <tt class="docutils literal">(Square,
Ellipse)</tt>, when we attempt to intersect squares and ellipses we get:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; e = Ellipse()
&gt;&gt;&gt; sq = Square()
&gt;&gt;&gt; intersect(sq, e)
Traceback (most recent call last):
  File &quot;multi_with_base_class_defaults.py&quot;, line 32, in __call__
    return self.typemap[types](*args)
KeyError: (&lt;class &#39;__main__.Square&#39;&gt;, &lt;class &#39;__main__.Ellipse&#39;&gt;)
</pre></div>
<p>Even though a <tt class="docutils literal">Square</tt> <em>is-a</em> <tt class="docutils literal">Rectangle</tt> and we could reasonably expect
this call to dispatch to a <tt class="docutils literal">(Rectangle, Ellipse)</tt> handler that we <em>did</em>
define.</p>
<p>There are a couple of ways we could go about this. The most obvious is to find
a handler at <em>call-time</em>; that is, when <tt class="docutils literal">intersect</tt> is called and we don't
find a handler for the exact type tuple passed in, we can keep looking -
creating tuples of the types' superclasses, until we find something (eventually
we'd hit a handler for <tt class="docutils literal">(Shape, Shape)</tt>). Note that this is lookup over all
<em>combinations</em> of superclasses for the input types: for each superclass of the
left-hand-side type, we have to check with every superclass of the
right-hand-side type.</p>
<p>This is obviously costly and doing it for each dispatch is unthinkable. So how
about we shift it to <em>registration-time</em>? When a handler is registered, we can
walk over all the combinations of <em>subclasses</em> of the input types, and register
the same handler for those too. The actual dispatch in <tt class="docutils literal">_MultiMethod.__call__</tt>
then remains unchanged. Here's the new registration method <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">register_function_for_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="n">types_with_subclasses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
        <span class="n">types_with_subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ty</span><span class="p">]</span> <span class="o">+</span> <span class="n">all_subclasses</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">type_tuple</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">types_with_subclasses</span><span class="p">):</span>
        <span class="c1"># Here we explicitly support overriding the registration, so that</span>
        <span class="c1"># more specific dispatches can override earlier-defined generic</span>
        <span class="c1"># dispatches.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typemap</span><span class="p">[</span><span class="n">type_tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span>
</pre></div>
<p>It uses this helper function to recursively list all subclasses of a given
class:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of *all* subclasses of cls, recursively.&quot;&quot;&quot;</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">subcls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
        <span class="n">subclasses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">all_subclasses</span><span class="p">(</span><span class="n">subcls</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">subclasses</span>
</pre></div>
<p>This works as expected. The registration of <tt class="docutils literal">intersect</tt> for <tt class="docutils literal">(Rectangle,
Ellipse)</tt> registered the same handler for <tt class="docutils literal">(Square, Ellipse)</tt>, the dispatch
succeeds and we get:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; e = Ellipse()
&gt;&gt;&gt; sq = Square()
&gt;&gt;&gt; intersect(sq, e)
Rectangle x Ellipse [names r=&lt;class &#39;__main__.Square&#39;&gt;, e=&lt;class &#39;__main__.Ellipse&#39;&gt;]
</pre></div>
<p>There are a couple of caveats we have to be aware of with this solution:</p>
<ol class="arabic simple">
<li>When registering handlers, the generic (base) handlers must be registered
before the more concrete (subclass) handlers, because later registrations
override earlier ones. If we register the <tt class="docutils literal">(Shape, Shape)</tt> handler last,
it will override <em>all</em> other handlers because all the shapes are subclasses
of <tt class="docutils literal">Shape</tt>.</li>
<li>The handlers must be registered after the whole type hierarchy has been
declared. Since <tt class="docutils literal">register_function_for_types</tt> walks the tree of subclasses
of any type it sees, it has to know about all subclasses at that point in
the execution. As a concrete example, if we register a handler for
<tt class="docutils literal">(Ellipse, Triangle)</tt> and only later define a new shape <tt class="docutils literal">Circle</tt>
inheriting from <tt class="docutils literal">Ellipse</tt>, a <tt class="docutils literal">(Circle, Triangle)</tt> call will not be
correctly routed to the <tt class="docutils literal">(Ellipse, Triangle)</tt> handler, since <tt class="docutils literal">Circle</tt> was
unkown when the handler was registered.</li>
</ol>
</div>
<div class="section" id="generalized-dispatch">
<h2>Generalized dispatch</h2>
<p>Armed with the magic capabilities of Python, everything seems doable and we feel
our programming powers grow; along with them, so does our appetite. So far we've
looked at dispatching fairly rigidly by the types of the arguments. Can we come
up with something more... general? For example, can we place arbitrary
predicates in our decorator, and have the dispatcher invoke the handler only if
the predicate is true for an argument? We sure can, and there's a Python library
that does these things - <a class="reference external" href="https://pypi.python.org/pypi/PEAK-Rules">PEAK-rules</a>.</p>
<p>I won't spend much time on it, but will just say that it lets us specify
dispatch conditions like:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nd">@when</span><span class="p">(</span><span class="n">pprint</span><span class="p">,</span> <span class="s2">&quot;isinstance(ob,list) and len(ob)&gt;50&quot;</span><span class="p">)</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">pprint_long_list</span><span class="p">(</span><span class="n">ob</span><span class="p">):</span>
<span class="o">...</span>     <span class="o">...</span>
</pre></div>
<p>It then parses the Python code in the condition and uses that to dispatch the
calls when the condition is satisfied <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>. This is just a small example - the
library is very general.</p>
<p>It shouldn't be hard to implement a basic form of this functionality on our
own and you should definitely try as an exercise. I will spend more time on
generalized dispatch in parts 3 and 4 of the series.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This article demonstrates how multiple dispatch can be easily bolted
on top of Python, leveraging the language's dynamism and permissive typing.
Moreover, with the help of decorators, multiple dispatch can be handsomely
integrated into the program's syntax in a very natural way. What's most
appealing is that after being marked as <tt class="docutils literal">&#64;multi</tt>, handlers can be used just
like any other Python function - calling them looks no different, but the
underlying mechanism gets more sophisticated.</p>
<p>However, as we've seen here there are several variations on the multiple
dispatch scheme, and each requires slightly different implementation
considerations. This is why I actually think that given a real-world need to do
multiple dispatch, I'd be more inclined to roll a domain-specific solution
rather than use a library. The basic form of multiple dispatch is just 30 lines
of Python; moreover, this is fairly run-of-the-mill code once you have some
experience with decorators and callable objects. Is using something like
<tt class="docutils literal"><span class="pre">PEAK-rules</span></tt> worth the learning curve? I'm not convinced at all.</p>
<p>In the next part of the series we'll see how multiple dispatch works in
a language that supports it as a built-in feature.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>I'm using Python 3 (more specifically 3.4) for these code samples.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>It's even true <em>multiple</em> dispatch, rather than just double dispatch.
Nothing in this approach limits the number of arguments dispatched upon
to 2.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>The full code sample for multi-dispatch with symmetry is available
<a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/multiple-dispatch/python/multi_with_sorted_types.py">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>The full code sample for multi-dispatch with base-class defaults is
available <a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/multiple-dispatch/python/multi_with_base_class_defaults.py">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>Why does it need to parse Python where a <tt class="docutils literal">lambda</tt> would do? The
documentation of <tt class="docutils literal"><span class="pre">PEAK-rules</span></tt> is somewhat dense, but I believe it tries
to optimize dispatches based on possible sub-expressions, and so on. So
for example, if one handler is registered when <tt class="docutils literal">foo &gt; 20</tt> and another
when <tt class="docutils literal">foo &gt; 40</tt>, then the first handler should fire too whenever the
second one does. The library needs understanding of the code in question
to make that possible. Note that the library is fairly old, predating
Python's <tt class="docutils literal">ast</tt> module, so it does its own source-to-AST parsing of
a subset of Python.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-2 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:01:33 GMT -->
</html>