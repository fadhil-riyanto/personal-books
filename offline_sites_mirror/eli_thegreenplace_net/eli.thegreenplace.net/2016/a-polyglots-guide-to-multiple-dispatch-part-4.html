<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-4 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:01:32 GMT -->
<head>
    <title>A polyglot's guide to multiple dispatch - part 4 - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../theme/css/style.css" type="text/css"/>

        <link href="../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../index.html" class="navbar-brand">
                <img src="../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="a-polyglots-guide-to-multiple-dispatch-part-4/index.html"
                       rel="bookmark"
                       title="Permalink to A polyglot's guide to multiple dispatch - part 4">
                        A polyglot's guide to multiple dispatch - part 4
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> April 28, 2016 at 06:05</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../tag/lisp.html">Lisp</a>
        ,
    <a href="../tag/clojure.html">Clojure</a>
        ,
    <a href="../tag/multiple-dispatch.html">Multiple dispatch</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This is part 4 in the series of articles on multiple dispatch. In
<a class="reference external" href="../tag/multiple-dispatch.html">previous parts</a>
we've seen what multiple dispatch is and how it can be
emulated in C++ and Python. We've also seen a programming language with
first-class support for multiple dispatch - Common Lisp. In this part, I'd like
to discuss another language where multiple dispatch is in the standard toolbox -
Clojure.</p>
<p>Clojure is a relatively new language but it has ancient roots. It was designed
in 2007 by Rich Hickey, and has been rapidly gaining popularity in the last few
years as a modern, concurrent and all-around exciting Lisp running on top of the
JVM. Clojure has a large, friendly and vibrant user community and many talented
developers hacking on it. I certainly harbor the hope that Clojure is what's
going to finally bring Lisp mainstream... but I digress.</p>
<p>This article shows how multiple dispatch is done in Clojure; to prepare the
ground, I'll start with single dispatch.</p>
<div class="section" id="single-class-based-dispatch">
<h2>Single class-based dispatch</h2>
<p>Dispatching based on some property of a value in Clojure is done using the
<tt class="docutils literal">defmulti</tt> / <tt class="docutils literal">defmethod</tt> macro duo. These macros are sort-of, but not
exactly, the equivalents of <tt class="docutils literal">defgeneric</tt> / <tt class="docutils literal">defmethod</tt> in Common Lisp, and
the difference will be apparent very soon.</p>
<p><tt class="docutils literal">defmulti</tt> declares a &quot;multi-method&quot; and sets its dispatch function, which is
an arbitrary Clojure function. At runtime, whenever the multi-method is called,
the dispatch function is first invoked on its arguments, and the value it
returns is used to choose which method to call. A simple example should help
clarify this:</p>
<div class="highlight"><pre><span></span><span class="c1">; Single-dispatch multimethod, dispatching on the class of the argument.</span><span class="w"></span>
<span class="c1">; Here &#39;class&#39; refers to the built-in function clojure.core/class</span><span class="w"></span>
<span class="p">(</span><span class="kd">defmulti </span><span class="nv">describe-thing</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span><span class="w"></span>

<span class="c1">; Define dispatcher methods for built-in Long and String values.</span><span class="w"></span>
<span class="p">(</span><span class="kd">defmethod </span><span class="nv">describe-thing</span><span class="w"> </span><span class="nv">java.lang.Long</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">thing</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;a Long&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="nv">thing</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">describe-thing</span><span class="w"> </span><span class="nv">java.lang.String</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">thing</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;a String&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="nv">thing</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>We define the multi-method <tt class="docutils literal"><span class="pre">describe-thing</span></tt> and then two implementations,
one for the built-in <tt class="docutils literal">Long</tt> type, another for the built-in <tt class="docutils literal">String</tt> type.
Here it is in action:</p>
<div class="highlight"><pre><span></span><span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">describe-thing</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"></span>
<span class="nv">a</span><span class="w"> </span><span class="nv">Long</span><span class="w"> </span><span class="mi">12</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">describe-thing</span><span class="w"> </span><span class="s">&quot;tim&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nv">a</span><span class="w"> </span><span class="nv">String</span><span class="w"> </span><span class="nv">tim</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
</pre></div>
<p>We can also define methods for custom types:</p>
<div class="highlight"><pre><span></span><span class="c1">; Define a custom class and add a dispatcher for it.</span><span class="w"></span>
<span class="p">(</span><span class="kd">defrecord </span><span class="nv">Person</span><span class="w"> </span><span class="p">[</span><span class="nb">name </span><span class="nv">phone</span><span class="p">])</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">describe-thing</span><span class="w"> </span><span class="nv">Person</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">thing</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;a Person with name&quot;</span><span class="w"> </span><span class="p">(</span><span class="ss">:name</span><span class="w"> </span><span class="nv">thing</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>There are several ways to define new types in Clojure. Here I'm using
<tt class="docutils literal">defrecord</tt>, which is somewhat similar to a C++ <tt class="docutils literal">struct</tt> (and a Common Lisp
<tt class="docutils literal">class</tt>). Now the right <tt class="docutils literal"><span class="pre">describe-thing</span></tt> is called when invoked with an
instance of <tt class="docutils literal">Person</tt>:</p>
<div class="highlight"><pre><span></span><span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">describe-thing</span><span class="w"> </span><span class="p">(</span><span class="nf">Person.</span><span class="w"> </span><span class="s">&quot;joe&quot;</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w"></span>
<span class="nv">a</span><span class="w"> </span><span class="nv">Person</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nb">name </span><span class="nv">joe</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="single-value-based-dispatch-and-duck-typing">
<h2>Single value-based dispatch and duck typing</h2>
<p>So far so good. Note, however, that I said the dispatch function can be
<em>arbitrary</em>. Indeed, in the example above we've used <tt class="docutils literal">class</tt> as the dispatch
function, but we could use something else. In fact, we could use any custom
function. As another example, here's dispatch based on a field value:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmulti </span><span class="nv">promotion-due</span><span class="w"> </span><span class="ss">:position</span><span class="p">)</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">promotion-due</span><span class="w"> </span><span class="ss">:engineer</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">emp</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="ss">:lines-of-code</span><span class="w"> </span><span class="nv">emp</span><span class="p">)</span><span class="w"> </span><span class="mi">100000</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">promotion-due</span><span class="w"> </span><span class="ss">:manager</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">emp</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="ss">:num-reports</span><span class="w"> </span><span class="nv">emp</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"></span>

<span class="c1">; Works with records</span><span class="w"></span>
<span class="p">(</span><span class="kd">defrecord </span><span class="nv">Employee</span><span class="w"> </span><span class="p">[</span><span class="nb">name </span><span class="nv">position</span><span class="w"> </span><span class="nv">num-reports</span><span class="w"> </span><span class="nv">lines-of-code</span><span class="p">])</span><span class="w"></span>
</pre></div>
<p>Forgive my rather simplistic exposition of how merit-based promotion in the tech
industry works. Rather, note how cleanly this code avoids a position-based
<tt class="docutils literal">switch</tt> that would be the ordinary solution to this problem, essentially
delegating the <tt class="docutils literal">switch</tt> to Clojure itself. Let's try with a couple different
employees:</p>
<div class="highlight"><pre><span></span><span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">promotion-due</span><span class="w"> </span><span class="p">(</span><span class="nf">Employee.</span><span class="w"> </span><span class="s">&quot;jim&quot;</span><span class="w"> </span><span class="ss">:manager</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="nv">true</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">promotion-due</span><span class="w"> </span><span class="p">(</span><span class="nf">Employee.</span><span class="w"> </span><span class="s">&quot;sue&quot;</span><span class="w"> </span><span class="ss">:engineer</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">98000</span><span class="p">))</span><span class="w"></span>
<span class="nv">false</span><span class="w"></span>
</pre></div>
<p>What's the dispatch function here? It's <tt class="docutils literal">:position</tt>. In Clojure, keywords in
the first position in a form are taken as functions that access the key named
by the keyword from values that support it. It works fine for records. It also
works for maps, though. Can <tt class="docutils literal"><span class="pre">promotion-due</span></tt> work on maps?</p>
<div class="highlight"><pre><span></span><span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def </span><span class="nv">joe</span><span class="w"> </span><span class="p">{</span><span class="ss">:name</span><span class="w"> </span><span class="s">&quot;joe&quot;</span>,<span class="w"> </span><span class="ss">:position</span><span class="w"> </span><span class="ss">:manager</span>,<span class="w"> </span><span class="ss">:num-reports</span><span class="w"> </span><span class="mi">9</span><span class="p">})</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">promotion-due</span><span class="w"> </span><span class="nv">joe</span><span class="p">)</span><span class="w"></span>
<span class="nv">false</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def </span><span class="nv">tim</span><span class="w"> </span><span class="p">{</span><span class="ss">:name</span><span class="w"> </span><span class="s">&quot;tim&quot;</span>,<span class="w"> </span><span class="ss">:position</span><span class="w"> </span><span class="ss">:engineer</span>,<span class="w"> </span><span class="ss">:lines-of-code</span><span class="w"> </span><span class="mi">124000</span><span class="p">})</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">promotion-due</span><span class="w"> </span><span class="nv">tim</span><span class="p">)</span><span class="w"></span>
<span class="nv">true</span><span class="w"></span>
</pre></div>
<p>Wowza! So Clojure multi-methods don't actually care what the class of the value
they dispatch upon is. Indeed, they don't even care whether it's a custom class
at all. As long as the dispatch function can be successfully called on the value
and returns something that can be dispatched upon, multi-methods work. This is
a pretty cool form of duck typing - a programming technique recently popularized
by Python but also available in C++ at compile-time with templates.</p>
<p>In fact, the &quot;Clojure way&quot; of programming is to do as much duck typing as
possible, on <em>built-in types</em>. If entities can be represented as combinations of
vectors and maps, that's great because it means that in addition to custom
functions we write to operate on these &quot;types&quot;, we can also use all the other
functions in our arsenal that work on built-in types. The philosophy, according
to the designers of Clojure is - <em>rather than use many different classes with a
few methods on each, use a small number of data structures with many different
functions that act on them</em> <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>.</p>
<p>In any case, as we've just seen, Clojure's records have some map-like behaviors
that make it easy to intermix methods operating on them with methods operating
on regular maps.</p>
<p>The sample code shown here uses <tt class="docutils literal">:position</tt> as the dispatch function. An
alternative method of achieving the same would be more explicit:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmulti </span><span class="nv">promotion-due</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">emp</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="ss">:position</span><span class="w"> </span><span class="nv">emp</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>The previous form is preferred because it's more concise. However, this variant
is highlighting the possibility of using <em>any</em> custom function as the
dispatcher. For example, it could return a pair of values (position and
department, say) and then we'd write methods to dispatch on both. Try it as an
exercise.</p>
</div>
<div class="section" id="multiple-dispatch">
<h2>Multiple dispatch</h2>
<p>The last paragraph serves as a segue to multiple dispatch. In the general case,
Clojure methods accept multiple arguments (just as regular functions do). All
the arguments are passed into the dispatch function, which can then return a
tuple. Here's our shape intersection example in Clojure <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">deftype </span><span class="nv">Shape</span><span class="w"> </span><span class="p">[])</span><span class="w"></span>
<span class="p">(</span><span class="kd">deftype </span><span class="nv">Rectangle</span><span class="w"> </span><span class="p">[])</span><span class="w"></span>
<span class="p">(</span><span class="kd">deftype </span><span class="nv">Ellipse</span><span class="w"> </span><span class="p">[])</span><span class="w"></span>
<span class="p">(</span><span class="kd">deftype </span><span class="nv">Triangle</span><span class="w"> </span><span class="p">[])</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmulti </span><span class="nv">intersect</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[(</span><span class="nb">class </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">class </span><span class="nv">b</span><span class="p">)]))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">intersect</span><span class="w"> </span><span class="p">[</span><span class="nv">Rectangle</span><span class="w"> </span><span class="nv">Ellipse</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">r</span><span class="w"> </span><span class="nv">e</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">&quot;Rectangle x Ellipse [names r=%s, e=%s]\n&quot;</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="nb">class </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">class </span><span class="nv">e</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">intersect</span><span class="w"> </span><span class="p">[</span><span class="nv">Rectangle</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">r1</span><span class="w"> </span><span class="nv">r2</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">&quot;Rectangle x Rectangle [names r1=%s, r2=%s]\n&quot;</span><span class="w"></span>
<span class="w">                  </span><span class="p">(</span><span class="nb">class </span><span class="nv">r1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">class </span><span class="nv">r2</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">intersect</span><span class="w"> </span><span class="p">[</span><span class="nv">Rectangle</span><span class="w"> </span><span class="nv">Shape</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">r</span><span class="w"> </span><span class="nv">s</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">&quot;Rectangle x Shape [names r=%s, s=%s]\n&quot;</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="nb">class </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">class </span><span class="nv">s</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>The dispatch function here takes both arguments and returns a vector of their
classes. We can then dispatch upon this vector to define methods for
handling different pairs of shapes. Let's try it:</p>
<div class="highlight"><pre><span></span><span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">Rectangle.</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Ellipse.</span><span class="p">))</span><span class="w"></span>
<span class="nv">Rectangle</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">Ellipse</span><span class="w"> </span><span class="p">[</span><span class="nv">names</span><span class="w"> </span><span class="nv">r=class</span><span class="w"> </span><span class="nv">multi.shapes_double_dispatch.Rectangle</span>,<span class="w"> </span><span class="nv">e=class</span><span class="w"> </span><span class="nv">multi.shapes_double_dispatch.Ellipse</span><span class="p">]</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">Rectangle.</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Rectangle.</span><span class="p">))</span><span class="w"></span>
<span class="nv">Rectangle</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">Rectangle</span><span class="w"> </span><span class="p">[</span><span class="nv">names</span><span class="w"> </span><span class="nv">r1=class</span><span class="w"> </span><span class="nv">multi.shapes_double_dispatch.Rectangle</span>,<span class="w"> </span><span class="nv">r2=class</span><span class="w"> </span><span class="nv">multi.shapes_double_dispatch.Rectangle</span><span class="p">]</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">Rectangle.</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Shape.</span><span class="p">))</span><span class="w"></span>
<span class="nv">Rectangle</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">Shape</span><span class="w"> </span><span class="p">[</span><span class="nv">names</span><span class="w"> </span><span class="nv">r=class</span><span class="w"> </span><span class="nv">multi.shapes_double_dispatch.Rectangle</span>,<span class="w"> </span><span class="nv">s=class</span><span class="w"> </span><span class="nv">multi.shapes_double_dispatch.Shape</span><span class="p">]</span><span class="w"></span>
</pre></div>
<p>So far so good. But now let's try to invoke a base-class default. We didn't
define a method to intersect rectangles with triangles, so we'd like the
<tt class="docutils literal">[Rectangle Shape]</tt> variant to be invoked here:</p>
<div class="highlight"><pre><span></span><span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">Rectangle.</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Triangle.</span><span class="p">))</span><span class="w"></span>

<span class="nv">IllegalArgumentException</span><span class="w"> </span><span class="nv">No</span><span class="w"> </span><span class="nv">method</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">multimethod</span><span class="w"> </span><span class="ss">&#39;intersect</span><span class="o">&#39;</span><span class="w"> </span><span class="nb">for </span><span class="nv">dispatch</span><span class="w"> </span><span class="nv">value</span><span class="err">:</span><span class="w"> </span><span class="p">[</span><span class="nv">...</span><span class="p">]</span><span class="w"></span>
</pre></div>
<p>Oops... What did we expect, though? Nothing in our code even tells Clojure that
<tt class="docutils literal">Triangle</tt> and <tt class="docutils literal">Shape</tt> are in any way related! How <em>do</em> we do that?
<tt class="docutils literal">deftype</tt> won't let us specify base classes. To understand how inheritance
hierarchies work in Clojure, we have to take a short detour.</p>
</div>
<div class="section" id="clojure-s-ad-hoc-inheritance-with-derive-and-isa">
<h2>Clojure's ad-hoc inheritance with derive and isa?</h2>
<p>Clojure's approach to inheritance is very unusual. Some call it abstract, and
some call it &quot;ad-hoc&quot;. You'll soon understand why.</p>
<p>Typically, in most languages, inheritance relations are defined between classes
at the point where these classes are defined. In Clojure, the concept of an
inheritance hierarchy is completely detached from any particular class mechanism
- it lives on its own. We define inheritance relationships between abstract
&quot;tags&quot;, which are customarily either (namespace-qualified) symbols or
keywords.</p>
<p>Let's define a simple animal hierarchy to demonstrate <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>:</p>
<div class="highlight"><pre><span></span><span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="ss">::dog</span><span class="w"> </span><span class="ss">::mammal</span><span class="p">)</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="ss">::cat</span><span class="w"> </span><span class="ss">::mammal</span><span class="p">)</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="ss">::husky</span><span class="w"> </span><span class="ss">::dog</span><span class="p">)</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
</pre></div>
<p>Now we can do some queries:</p>
<div class="highlight"><pre><span></span><span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">parents</span><span class="w"> </span><span class="ss">::husky</span><span class="p">)</span><span class="w"></span>
<span class="o">#</span><span class="p">{</span><span class="ss">:multi.core/dog</span><span class="p">}</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">ancestors</span><span class="w"> </span><span class="ss">::husky</span><span class="p">)</span><span class="w"></span>
<span class="o">#</span><span class="p">{</span><span class="ss">:multi.core/mammal</span><span class="w"> </span><span class="ss">:multi.core/dog</span><span class="p">}</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">descendants</span><span class="w"> </span><span class="ss">::mammal</span><span class="p">)</span><span class="w"></span>
<span class="o">#</span><span class="p">{</span><span class="ss">:multi.core/cat</span><span class="w"> </span><span class="ss">:multi.core/husky</span><span class="w"> </span><span class="ss">:multi.core/dog</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>As well as use <tt class="docutils literal">isa?</tt> to answer the customary is-a test of object
relationships:</p>
<div class="highlight"><pre><span></span><span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">isa?</span><span class="w"> </span><span class="ss">::dog</span><span class="w"> </span><span class="ss">::mammal</span><span class="p">)</span><span class="w"></span>
<span class="nv">true</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">isa?</span><span class="w"> </span><span class="ss">::husky</span><span class="w"> </span><span class="ss">::dog</span><span class="p">)</span><span class="w"></span>
<span class="nv">true</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">isa?</span><span class="w"> </span><span class="ss">::husky</span><span class="w"> </span><span class="ss">::cat</span><span class="p">)</span><span class="w"></span>
<span class="nv">false</span><span class="w"></span>
</pre></div>
<p>Another nice feature <tt class="docutils literal">isa?</tt> has is accepting sequences of types and combining
a per-element answer with a kind-of <tt class="docutils literal">every?</tt>:</p>
<div class="highlight"><pre><span></span><span class="c1">; isa? ::husky ::dog AND isa? ::husky ::cat</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">isa?</span><span class="w"> </span><span class="p">[</span><span class="ss">::husky</span><span class="w"> </span><span class="ss">::husky</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="ss">::dog</span><span class="w"> </span><span class="ss">::cat</span><span class="p">])</span><span class="w"></span>
<span class="nv">false</span><span class="w"></span>
<span class="c1">; isa? ::husky ::dog AND isa? ::husky ::mammal</span><span class="w"></span>
<span class="nv">multi.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">isa?</span><span class="w"> </span><span class="p">[</span><span class="ss">::husky</span><span class="w"> </span><span class="ss">::husky</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="ss">::dog</span><span class="w"> </span><span class="ss">::mammal</span><span class="p">])</span><span class="w"></span>
<span class="nv">true</span><span class="w"></span>
</pre></div>
<p>A final piece of the puzzle we need to understand to get back to our shape
intersections is that multi-methods use <tt class="docutils literal">isa?</tt> rather than <tt class="docutils literal">=</tt> to dispatch.
In other words, when the dispatch function is called and returns a result, to
find a method that should be invoked Clojure calls <tt class="docutils literal">(isa? <span class="pre">actual-value</span>
<span class="pre">expected-value)</span></tt> for each method's expected value to find a match. <tt class="docutils literal">(isa? x
y)</tt> always returns true if <tt class="docutils literal">(= x y)</tt>, so exact matches work as expected.</p>
</div>
<div class="section" id="mutliple-dispatch-with-base-class-defaults">
<h2>Mutliple dispatch with base-class defaults</h2>
<p>Now we have all we need to make that intersection between a rectangle and
a triangle dispatch as expected. Just for kicks, in this sample I'll forego
creating new types with <tt class="docutils literal">deftype</tt> and <tt class="docutils literal">defrecord</tt> and will use maps instead:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="ss">::rectangle</span><span class="w"> </span><span class="ss">::shape</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="ss">::ellipse</span><span class="w"> </span><span class="ss">::shape</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="nf">derive</span><span class="w"> </span><span class="ss">::triangle</span><span class="w"> </span><span class="ss">::shape</span><span class="p">)</span><span class="w"></span>

<span class="c1">; Helper constructors to create new &quot;instances&quot; of shapes. In a real program</span><span class="w"></span>
<span class="c1">; they could take parameters that would be assigned to fields.</span><span class="w"></span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">make-shape</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="ss">:kind</span><span class="w"> </span><span class="ss">::shape</span><span class="p">})</span><span class="w"></span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">make-rectangle</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="ss">:kind</span><span class="w"> </span><span class="ss">::rectangle</span><span class="p">})</span><span class="w"></span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">make-ellipse</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="ss">:kind</span><span class="w"> </span><span class="ss">::ellipse</span><span class="p">})</span><span class="w"></span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">make-triangle</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="ss">:kind</span><span class="w"> </span><span class="ss">::triangle</span><span class="p">})</span><span class="w"></span>
</pre></div>
<p>Shapes are represented by maps. A special key named <tt class="docutils literal">:kind</tt> holds the kind of
the shape, which is a symbol participating in an inheritance hierarchy we've
defined. The <tt class="docutils literal">intersect</tt> dispatch is now slightly different, as are the
methods:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmulti </span><span class="nv">intersect</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[(</span><span class="ss">:kind</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">:kind</span><span class="w"> </span><span class="nv">b</span><span class="p">)]))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">intersect</span><span class="w"> </span><span class="p">[</span><span class="ss">::rectangle</span><span class="w"> </span><span class="ss">::ellipse</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">r</span><span class="w"> </span><span class="nv">e</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">&quot;Rectangle x Ellipse&quot;</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">intersect</span><span class="w"> </span><span class="p">[</span><span class="ss">::rectangle</span><span class="w"> </span><span class="ss">::rectangle</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">r1</span><span class="w"> </span><span class="nv">r2</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">&quot;Rectangle x Rectangle&quot;</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">intersect</span><span class="w"> </span><span class="p">[</span><span class="ss">::rectangle</span><span class="w"> </span><span class="ss">::shape</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">r</span><span class="w"> </span><span class="nv">s</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">&quot;Rectangle x Shape&quot;</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Let's try some intersections:</p>
<div class="highlight"><pre><span></span><span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">make-rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">make-ellipse</span><span class="p">))</span><span class="w"></span>
<span class="nv">Rectangle</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">Ellipse</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">make-rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">make-rectangle</span><span class="p">))</span><span class="w"></span>
<span class="nv">Rectangle</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">Rectangle</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">make-rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">make-shape</span><span class="p">))</span><span class="w"></span>
<span class="nv">Rectangle</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">Shape</span><span class="w"></span>
<span class="nv">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">intersect</span><span class="w"> </span><span class="p">(</span><span class="nf">make-rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">make-triangle</span><span class="p">))</span><span class="w"></span>
<span class="nv">Rectangle</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">Shape</span><span class="w"></span>
</pre></div>
<p>Now the last <tt class="docutils literal">intersect</tt> call works as expected - picking up the <tt class="docutils literal">::rectangle
::shape</tt> method variant, since <tt class="docutils literal">::triange</tt> derives from <tt class="docutils literal">::shape</tt>. When
<tt class="docutils literal">intersect</tt> is called on a rectangle and a triangle, the return value of
the dispatch function is <tt class="docutils literal">::rectangle ::triangle</tt>, which passes the <tt class="docutils literal">isa?</tt>
test on <tt class="docutils literal">::rectangle ::shape</tt>.</p>
</div>
<div class="section" id="the-flexibility-of-clojure-s-dispatch-mechanism">
<h2>The flexibility of Clojure's dispatch mechanism</h2>
<p>Clojure's dispatch mechanism is very general, since the dispatch function is
arbitrary. In <a class="reference external" href="a-polyglots-guide-to-multiple-dispatch-part-3.html">part 3</a>
we've seen how multi-methods in CLOS work: they either directly take a class to
dispatch on or have an <tt class="docutils literal">eql</tt> comparison to dispatch by-value. Clojure
generalizes that - the dispatch function can do whatever it wants, as far as
Clojure is concerned - it's completely unconstrained.</p>
<p>With added flexibility come costs, though. First and foremost, this lets us write
obscure code where dispatches are made on runtime-computed values, making the
code harder to reason about. I'd strongly advise against these techniques,
leaving them for the inevitable 1% of the cases. For 99%, simple <tt class="docutils literal">isa</tt>-based
dispatch should be what we're looking for.</p>
<p>The second cost is performance. Since every call to a method has to go through
the dispatch mechanism first, these pathways better be well optimized. Deferring
the decision so far into the run-time makes it more difficult for the compiler
to optimize. The Clojure designers had this concern in mind when they exposed
<em>protocols</em> - a sort-of Java-like virtual dispatch mechanism that is much
faster, but has some limitations compared to general multi-methods <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>.
I'll cover Clojure protocols in a future post.</p>
</div>
<div class="section" id="thoughts-on-the-ad-hoc-inheritance-hierarchy">
<h2>Thoughts on the ad-hoc inheritance hierarchy</h2>
<p>On one hand, Clojure's way of defining inheritance hierarchies is markedly
weird. Why can't we just tag the base classes on type definitions, the way it
works in other languages (even in CLOS)? Why do we have to provide <em>another</em> set
of definitions in parallel with the actual type definitions? Isn't this error
prone and overly verbose?</p>
<p>Well, yes. It's a bit error prone (though I find it hard to imagine it can lead
to deep bugs in the presence of even basic testing). It's also more verbose
than strictly needed - just a list of bases in <tt class="docutils literal">deftype</tt> would be shorter,
keeping related things together.</p>
<p>But thinking about it another way, Clojure's choice actually makes sense. Unlike
other language, Clojure really isn't centered around objects. In fact, objects
and custom types are probably the last tool you should be reaching for, after
all other possibilities were exhausted. As a couple of code samples in this
article show, Clojure much prefers working with simple maps and compositions of
built-in data types, since then the whole capabilities of the Clojure standard
library are applicable to values, so we have to write less code all in all. In
this light, the detached hierarchy-definition tools appear to be a very
reasonable approach. In Clojure you can define new &quot;types&quot; with maps, with
<tt class="docutils literal">deftype</tt>, with <tt class="docutils literal">defrecord</tt> - as well as a couple of other ways I don't
cover here. Why implement the same base-class capabilities for each, when an
orthogonal way of defining inheritance could be created which would then be
applicable to all these approaches?</p>
<p>In summary, though I admit the Clojure way here is unusual, I think that overall
it aligns itself well with the philosophy of the language and guides developers
to think about more Clojure-y solutions to problems rather than reaching for
the tools they're familiar with from traditional OO languages like Java.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>This concludes the article, as well as the &quot;Polyglot's guide to multiple
dispatch&quot; series. It was a fun ride, and I hope it was interesting for readers
to see a powerful programming techique explained and demonstrated in four
different programming languages. At first - when looking at it from the
point-of-view of C++ and Python - multiple dispatch appears to be an advanced
feature of OOP. I think that the Common Lisp and Clojure samples demonstrate
that it goes well beyond that. In fact, multiple dispatch is best categorized as
a generalization of OOP, being more in the domain of <em>generic programming</em>.
Kinda like the <a class="reference external" href="http://www.boost.org/community/generic_programming.html">generic programming of C++</a>, just at runtime
instead of being limited to compile-time constructs and metaprogramming.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>When &quot;plain&quot; maps are used for data structures they should be still
encapsulated behind functions to decouple their implementation from the
interface exposed to clients.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>Note that <tt class="docutils literal">deftype</tt> is used here, instead of <tt class="docutils literal">defrecord</tt>. Choosing
between the two is a matter of style; IMHO when the type has no fields,
a <tt class="docutils literal">deftype</tt> conveys the meaning in a clearer way.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>The Clojure syntax <tt class="docutils literal">::foo</tt> stands for namespace-qualified keyword.
Also, <tt class="docutils literal">derive</tt> and friends (as well as multi-methods) accept an
optional hierarchy map to which to add relationships. By default a global
map is used, and it's good enough for our purposes in this article.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>Another optimization of multi-methods in Clojure is that they're not
implemented in pure Clojure as a set of macros (the way CLOS is done in
Common Lisp). Rather, they dip into the <a class="reference external" href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/MultiFn.java">Java innards</a>
of Clojure's implementation.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-4 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:01:32 GMT -->
</html>