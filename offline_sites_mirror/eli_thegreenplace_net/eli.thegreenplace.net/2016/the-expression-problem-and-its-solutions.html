<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:58:26 GMT -->
<head>
    <title>The Expression Problem and its solutions - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../theme/css/style.css" type="text/css"/>

        <link href="../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../index.html" class="navbar-brand">
                <img src="../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="the-expression-problem-and-its-solutions/index.html"
                       rel="bookmark"
                       title="Permalink to The Expression Problem and its solutions">
                        The Expression Problem and its solutions
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> May 12, 2016 at 05:44</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../tag/c-c.html">C & C++</a>
        ,
    <a href="../tag/clojure.html">Clojure</a>
        ,
    <a href="../tag/multiple-dispatch.html">Multiple dispatch</a>
        ,
    <a href="../tag/haskell.html">Haskell</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>The craft of programming is almost universally concerned with different types of
data and operations/algorithms that act on this data <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>. Therefore, it's
hardly surprising that designing abstractions for data types and operations has
been on the mind of software engineers and programming-language designers
since... forever.</p>
<p>Yet I've only recently encountered a name for a software design problem which I
ran into multiple times in my career. It's a problem so fundamental that I was
quite surprised that I haven't seen it named before. Here is a quick problem
statement.</p>
<p>Imagine that we have a set of data types and a set of operations that act on
these types. Sometimes we need to add more operations and make sure they work
properly on all types; sometimes we need to add more types and make sure all
operations work properly on them. Sometimes, however, we need to add both - and
herein lies the problem. Most of the mainstream programming languages don't
provide good tools to add both new types and new operations to an existing
system without having to change existing code. This is called the &quot;expression
problem&quot;. Studying the problem and its possible solutions gives great insight
into the fundamental differences between object-oriented and functional
programming and well as concepts like interfaces and multiple dispatch.</p>
<div class="section" id="a-motivating-example">
<h2>A motivating example</h2>
<p>As is my wont, my example comes from the world of compilers and interpreters.
To my defense, this is also the example used in some of the seminal historic
sources on the expression problem, as the historical perspective section below
details.</p>
<p>Imagine we're designing a simple expression evaluator. Following the standard
<a class="reference external" href="on-the-composite-and-interpreter-design-patterns.html">interpreter design pattern</a>, we have
a tree structure consisting of expressions, with some operations we can do on
such trees. In C++ we'd have an interface every node in the expression tree
would have to implement:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Expr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ToString</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">Eval</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>This interface shows that we currently have two operations we can do on
expression trees - evaluate them and query for their string representations.
A typical leaf node expression:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Constant</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">Constant</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ToString</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">ss</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ss</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">Eval</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>And a typical composite expression:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryPlus</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">BinaryPlus</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lhs_</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span><span class="w"> </span><span class="n">rhs_</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ToString</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs_</span><span class="p">.</span><span class="n">ToString</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs_</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">Eval</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs_</span><span class="p">.</span><span class="n">Eval</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs_</span><span class="p">.</span><span class="n">Eval</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Until now, it's all fairly basic stuff. How extensible is this design? Let's
see... if we want to add new expression types (&quot;variable reference&quot;, &quot;function
call&quot; etc.), that's pretty easy. We just define additional classes inheriting
from <tt class="docutils literal">Expr</tt> and implement the <tt class="docutils literal">Expr</tt> interface (<tt class="docutils literal">ToString</tt> and <tt class="docutils literal">Eval</tt>).</p>
<p>However, what happens if we want to add new <em>operations</em> that can be applied to
expression trees? Right now we have <tt class="docutils literal">Eval</tt> and <tt class="docutils literal">ToString</tt>, but we may want
additional operations like &quot;type check&quot; or &quot;serialize&quot; or &quot;compile to
machine code&quot; or whatever.</p>
<p>It turns out that adding new operations isn't as easy as adding new types. We'd
have to change the <tt class="docutils literal">Expr</tt> interface, and consequently change every existing
expression type to support the new method(s). If we don't control the original
code or it's hard to change it for other reasons, we're in trouble.</p>
<p>In other words, we'd have to violate the venerable <em>open-closed principle</em>,
one of the <a class="reference external" href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">main principles of object-oriented design</a>, defined
as:</p>
<blockquote>
software entities (classes, modules, functions, etc.) should be open for
extension, but closed for modification</blockquote>
<p>The problem we're hitting here is called the <em>expression problem</em>, and the
example above shows how it applies to object-oriented programming.</p>
<p>Interestingly, the expression problem bites functional programming languages as
well. Let's see how.</p>
</div>
<div class="section" id="the-expression-problem-in-functional-programming">
<h2>The expression problem in functional programming</h2>
<p><strong>Update 2018-02-05:</strong> <a class="reference external" href="../2018/more-thoughts-on-the-expression-problem-in-haskell/index.html">a new post</a>
discusses the problem and its solutions in Haskell in more depth.</p>
<p>Object-oriented approaches tend to collect functionality in objects (types).
Functional languages cut the cake from a different angle, usually preferring
types as thin data containers, collecting most functionality in functions
(operations) that act upon them. Functional languages don't escape the
expression problem - it just manifests there in a different way.</p>
<p>To demonstrate this, let's see how the expression evaluator / stringifier looks
in Haskell. Haskell is a good poster child for functional programming since its
pattern matching on types makes such code especially succinct:</p>
<div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Expressions</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Constant</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Expr</span><span class="w"></span>

<span class="nf">stringify</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">stringify</span><span class="w"> </span><span class="n">lhs</span><span class="w"></span>
<span class="w">                                </span><span class="o">++</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"></span>
<span class="w">                                </span><span class="o">++</span><span class="w"> </span><span class="n">stringify</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>

<span class="nf">evaluate</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="kt">Constant</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="kt">BinaryPlus</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>
</pre></div>
<p>Now let's say we want to add a new operation - type checking. We simply have
to add a new function <tt class="docutils literal">typecheck</tt> and define how it behaves for all known
kinds of expressions. No need to modify existing code.</p>
<p>On the other hand, if we want to add a new type (like &quot;function call&quot;), we get
into trouble. We now have to modify all existing functions to handle this new
type. So we hit exactly the same problem, albeit from a different angle.</p>
</div>
<div class="section" id="the-expression-problem-matrix">
<h2>The expression problem matrix</h2>
<p>A visual representation of the expression problem can be helpful to appreciate
how it applies to OOP and FP in different ways, and how a potential solution
would look.</p>
<p>The following 2-D table (a &quot;matrix&quot;) has types in its rows and operations in its
columns. A matrix cell <tt class="docutils literal">row, col</tt> is checked when the operation <tt class="docutils literal">col</tt> is
implemented for type <tt class="docutils literal">row</tt>:</p>
<img alt="Basic expression problem matrix demonstarting the starting point" class="align-center" src="../images/2016/expr-problem-matrix.png" />
<p>In object-oriented languages, it's easy to add new types but difficult to add
new operations:</p>
<img alt="OOP expression problem matrix" class="align-center" src="../images/2016/expr-problem-oop.png" />
<p>Whereas in functional languages, it's easy to add new operations but difficult
to add new types:</p>
<img alt="FP expression problem matrix" class="align-center" src="../images/2016/expr-problem-fp.png" />
</div>
<div class="section" id="a-historical-perspective">
<h2>A historical perspective</h2>
<p>The expression problem isn't new, and has likely been with us since the early
days; it pops its head as soon as programs reach some not-too-high level of
complexity.</p>
<p>It's fairly certain that the name <em>expression problem</em> comes from <a class="reference external" href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">an email</a> sent
by <a class="reference external" href="https://en.wikipedia.org/wiki/Philip_Wadler">Philip Wadler</a> to a mailing
list deailing with adding generics to Java (this was back in the 1990s).</p>
<p>In that email, Wadler points to the paper <a class="reference external" href="https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/">&quot;Synthesizing Object-Oriented and
Functional Design to Promote Re-Use&quot;</a> by
Krishnamurthi, Felleisen and Friedman as an earlier work describing the problem
and proposed solutions. This is a great paper and I highly recommend reading it.
Krishnamurthi et.al., in their references, point to papers from as early as 1975
describing variations of the problem in Algol.</p>
</div>
<div class="section" id="flipping-the-matrix-with-the-visitor-pattern">
<h2>Flipping the matrix with the visitor pattern</h2>
<p>So far the article has focused on the expression <em>problem</em>, and I hope it's
clear by now. However, the title also has the word <em>solution</em> in it, so let's
turn to that.</p>
<p>It's possible to kinda solve (read on to understand why I say &quot;kinda&quot;) the
expression problem in object-oriented languages; first, we have to look at how
we can flip the problem on its side using the visitor pattern. The visitor
pattern is very common for this kind of problems, and for a good reason. It lets
us reformulate our code in a way that makes it easier to change in some
dimensions (though harder in others).</p>
<p>For the C++ sample shown above, rewriting it using the visitor pattern means
adding a new &quot;visitor&quot; interface:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ExprVisitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">VisitConstant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Constant</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">VisitBinaryPlus</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">BinaryPlus</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>And changing the <tt class="docutils literal">Expr</tt> interface to be:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Expr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">ExprVisitor</span><span class="o">*</span><span class="w"> </span><span class="n">visitor</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Now expression types defer the actual computation to the visitor, as
follows:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Constant</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">Constant</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">ExprVisitor</span><span class="o">*</span><span class="w"> </span><span class="n">visitor</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">visitor</span><span class="o">-&gt;</span><span class="n">VisitConstant</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">GetValue</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// ... similarly, BinaryPlus would have</span>
<span class="c1">//</span>
<span class="c1">//    void Accept(ExprVisitor* visitor) const {</span>
<span class="c1">//      visitor-&gt;VisitBinaryPlus(*this);</span>
<span class="c1">//    }</span>
<span class="c1">//</span>
<span class="c1">// ... etc.</span>
</pre></div>
<p>A sample visitor for evaluation would be <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Evaluator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExprVisitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">GetValueForExpr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">value_map_</span><span class="p">[</span><span class="o">&amp;</span><span class="n">e</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">VisitConstant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Constant</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">value_map_</span><span class="p">[</span><span class="o">&amp;</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">GetValue</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">VisitBinaryPlus</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">BinaryPlus</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bp</span><span class="p">.</span><span class="n">GetLhs</span><span class="p">().</span><span class="n">Accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">bp</span><span class="p">.</span><span class="n">GetRhs</span><span class="p">().</span><span class="n">Accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">value_map_</span><span class="p">[</span><span class="o">&amp;</span><span class="n">bp</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_map_</span><span class="p">[</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bp</span><span class="p">.</span><span class="n">GetLhs</span><span class="p">())]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">value_map_</span><span class="p">[</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bp</span><span class="p">.</span><span class="n">GetRhs</span><span class="p">())];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">value_map_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>It should be obvious that for a given set of data types, adding new visitors is
easy and doesn't require modifying any other code. On the other hand, adding new
types is problematic since it means we have to update the <tt class="docutils literal">ExprVisitor</tt>
interface with a new abstract method, and consequently update all the visitors
to implement it.</p>
<p>So it seems that we've just turned the expression problem on its side: we're
using an OOP language, but now it's hard to add types and easy to add ops, just
like in the functional approach. I find it extremely interesting that we can do
this. In my eyes this highlights the power of different abstractions and
paradigms, and how they enable us to rethink a problem in a completely different
light.</p>
<p>So we haven't solved anything yet; we've just changed the nature of the problem
we're facing. Worry not - this is just a stepping stone to an actual solution.</p>
</div>
<div class="section" id="extending-the-visitor-pattern">
<h2>Extending the visitor pattern</h2>
<p>The following is code excerpts from a C++ solution that follows the extended
visitor pattern proposed by Krishnamurthi et. al. in their paper; I strongly
suggest reading the paper (particularly section 3) if you want to understand
this code on a deep level. A complete code sample in C++ that compiles and runs
is <a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/c++/visitor-extended.cpp">available here</a>.</p>
<p>Adding new visitors (ops) with the visitor pattern is easy. Our challenge is to
add a new <em>type</em> without upheaving too much existing code. Let's see how it's
done.</p>
<p>One small design change that we should make to the original visitor pattern is
use <tt class="docutils literal">virtual</tt> inheritance for <tt class="docutils literal">Evaluator</tt>, for reasons that will soon become
obvious:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Evaluator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExprVisitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// .. the rest is the same</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Now we're going to add a new type - <tt class="docutils literal">FunctionCall</tt>:</p>
<div class="highlight"><pre><span></span><span class="c1">// This is the new (&quot;extended&quot;) expression we&#39;re adding.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FunctionCall</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">FunctionCall</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">argument</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="w"> </span><span class="n">argument_</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">ExprVisitor</span><span class="o">*</span><span class="w"> </span><span class="n">visitor</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ExprVisitorWithFunctionCall</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">ExprVisitorWithFunctionCall</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">visitor</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Fatal: visitor is not ExprVisitorWithFunctionCall</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">VisitFunctionCall</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">argument_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Since we don't want to modify the existing visitors, we create a new one,
extending <tt class="docutils literal">Evaluator</tt> for function calls. But first, we need to extend the
<tt class="docutils literal">ExprVisitor</tt> interface to support the new type:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ExprVisitorWithFunctionCall</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExprVisitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">VisitFunctionCall</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FunctionCall</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fc</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Finally, we write the new evaluator, which extends <tt class="docutils literal">Evaluator</tt> and supports
the new type:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">EvaluatorWithFunctionCall</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExprVisitorWithFunctionCall</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">public</span><span class="w"> </span><span class="n">Evaluator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">VisitFunctionCall</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FunctionCall</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Visiting FunctionCall!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Multiple inheritance, virtual inheritance, dynamic type checking... that's
pretty hard-core C++ we have to use here, but there's no choice. Unfortunately,
multiple inheritance is the only way C++ lets us express the idea that a class
implements some interface while at the same time deriving functionality from
another class. What we want to have here is an evaluator
(<tt class="docutils literal">EvaluatorWithFunctionCall</tt>) that inherits all functionality from
<tt class="docutils literal">Evaluator</tt>, and also implements the <tt class="docutils literal">ExprVisitorWithFunctionCall</tt>
interface. In Java, we could say something like:</p>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">EvaluatorWithFunctionCall</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Evaluator</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ExprVisitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>But in C++ virtual multiple inheritance is the tool we have. The virtual part of
the inheritance is essential here for the compiler to figure out that the
<tt class="docutils literal">ExprVisitor</tt> base underlying both <tt class="docutils literal">Evaluator</tt> and
<tt class="docutils literal">ExprVisitorWithFunctionCall</tt> is the same and should only appear once in
<tt class="docutils literal">EvaluatorWithFunctionCall</tt>. Without virtual, the compiler would complain that
<tt class="docutils literal">EvaluatorWithFunctionCall</tt> doesn't implement the <tt class="docutils literal">ExprVisitor</tt> interface.</p>
<p>This is a solution, alright. We kinda added a new type <tt class="docutils literal">FunctionCall</tt> and can
now visit it without changing existing code (assuming the virtual inheritance
was built into the design from the start to anticipate this approach). Here I
am using this &quot;kinda&quot; word again... it's time to explain why.</p>
<p>This approach has multiple flaws, in my opinion:</p>
<ol class="arabic simple">
<li>Note the <tt class="docutils literal">dynamic_cast</tt> in <tt class="docutils literal"><span class="pre">FunctionCall::Accept</span></tt>. It's fairly ugly that
we're forced to mix in dynamic checks into this code, which should supposedly
rely on static typing and the compiler. But it's just a sign of a larger
problem.</li>
<li>If we have an instance of an <tt class="docutils literal">Evaluator</tt>, it will no longer work on the
whole extended expression tree since it has no understanding of
<tt class="docutils literal">FunctionCall</tt>. It's easy to say that all new evaluators should rather be
<tt class="docutils literal">EvaluatorWithFunctionCall</tt>, but we don't always control this. What about
code that was already written? What about <tt class="docutils literal">Evaluator</tt>s created in
third-party or library code which we have no control of?</li>
<li>The virtual inheritance is not the only provision we have to build into the
design to support this pattern. Some visitors would need to create new,
recursive visitors to process complex expressions. But we can't anticipate
in advance which dynamic type of visitor needs to be created. Therefore,
the visitor interface should also accept a &quot;visitor factory&quot; which extended
visitors will supply. I know this sounds complicated, and I don't want to
spend more time on this here - but the Krishnamurthi paper addresses this
issue extensively in section 3.4</li>
<li>Finally, the solution is unwieldy for realistic applications. Adding one
new type looks manageable; what about adding 15 new types, gradually over
time? Imagine the horrible zoo of <tt class="docutils literal">ExprVisitor</tt> extensions and dynamic
checks this would lead to.</li>
</ol>
<p>Yeah, programming is hard. I could go on and on about the limitations of
classical OOP and how they surface in this example <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>. Instead, I'll just
present how the expression problem can be solved in a language that supports
multiple dispatch and separates the defintion of methods from the bodies of
types they act upon.</p>
</div>
<div class="section" id="solving-the-expression-problem-in-clojure">
<h2>Solving the expression problem in Clojure</h2>
<p>There are a number of ways the expression problem as displayed in this article
can be solved in Clojure using the language's built-in features. Let's start
with the simplest one - multi-methods.</p>
<p>First we'll define the types as records:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Constant</span><span class="w"> </span><span class="p">[</span><span class="nv">value</span><span class="p">])</span><span class="w"></span>
<span class="p">(</span><span class="kd">defrecord </span><span class="nv">BinaryPlus</span><span class="w"> </span><span class="p">[</span><span class="nv">lhs</span><span class="w"> </span><span class="nv">rhs</span><span class="p">])</span><span class="w"></span>
</pre></div>
<p>Then, we'll define <tt class="docutils literal">evaluate</tt> as a multimethod that dispatches upon the type
of its argument, and add method implementations for <tt class="docutils literal">Constant</tt> and
<tt class="docutils literal">BinaryPlus</tt>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmulti </span><span class="nv">evaluate</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">evaluate</span><span class="w"> </span><span class="nv">Constant</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">c</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="ss">:value</span><span class="w"> </span><span class="nv">c</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">evaluate</span><span class="w"> </span><span class="nv">BinaryPlus</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">bp</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="ss">:lhs</span><span class="w"> </span><span class="nv">bp</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="ss">:rhs</span><span class="w"> </span><span class="nv">bp</span><span class="p">))))</span><span class="w"></span>
</pre></div>
<p>Now we can already evaluate expressions:</p>
<div class="highlight"><pre><span></span><span class="nv">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">&#39;expression.multimethod</span><span class="p">)</span><span class="w"></span>
<span class="nv">nil</span><span class="w"></span>
<span class="nv">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;BinaryPlus</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Constant</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Constant</span><span class="w"> </span><span class="mf">2.2</span><span class="p">)))</span><span class="w"></span>
<span class="mf">3.3000000000000003</span><span class="w"></span>
</pre></div>
<p>Adding a new operation is easy. Let's add <tt class="docutils literal">stringify</tt>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmulti </span><span class="nv">stringify</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">stringify</span><span class="w"> </span><span class="nv">Constant</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">c</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:value</span><span class="w"> </span><span class="nv">c</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">stringify</span><span class="w"> </span><span class="nv">BinaryPlus</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">bp</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"> </span><span class="p">[(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="ss">:lhs</span><span class="w"> </span><span class="nv">bp</span><span class="p">))</span><span class="w"></span>
<span class="w">                              </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="ss">:rhs</span><span class="w"> </span><span class="nv">bp</span><span class="p">))]))</span><span class="w"></span>
</pre></div>
<p>Testing it:</p>
<div class="highlight"><pre><span></span><span class="nv">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;BinaryPlus</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Constant</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Constant</span><span class="w"> </span><span class="mf">2.2</span><span class="p">)))</span><span class="w"></span>
<span class="s">&quot;1.1 + 2.2&quot;</span><span class="w"></span>
</pre></div>
<p>How about adding new types? Suppose we want to add <tt class="docutils literal">FunctionCall</tt>. First,
we'll define the new type. For simplicity, the <tt class="docutils literal">func</tt> field of
<tt class="docutils literal">FunctionCall</tt> is just a Clojure function. In real code it could be some sort
of function object in the language we're interpreting:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defrecord </span><span class="nv">FunctionCall</span><span class="w"> </span><span class="p">[</span><span class="nv">func</span><span class="w"> </span><span class="nv">argument</span><span class="p">])</span><span class="w"></span>
</pre></div>
<p>And define how <tt class="docutils literal">evaluate</tt> and <tt class="docutils literal">stringify</tt> work for <tt class="docutils literal">FunctionCall</tt>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmethod </span><span class="nv">evaluate</span><span class="w"> </span><span class="nv">FunctionCall</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">fc</span><span class="p">]</span><span class="w"> </span><span class="p">((</span><span class="ss">:func</span><span class="w"> </span><span class="nv">fc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="ss">:argument</span><span class="w"> </span><span class="nv">fc</span><span class="p">))))</span><span class="w"></span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">stringify</span><span class="w"> </span><span class="nv">FunctionCall</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nv">fc</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">clojure.repl/demunge</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:func</span><span class="w"> </span><span class="nv">fc</span><span class="p">)))</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;(&quot;</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="ss">:argument</span><span class="w"> </span><span class="nv">fc</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;)&quot;</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Let's take it for a spin (the full code <a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/clojure/expression/src/expression/multimethod.clj">is here</a>):</p>
<div class="highlight"><pre><span></span><span class="nv">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def </span><span class="nv">callexpr</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;FunctionCall</span><span class="w"> </span><span class="nv">twice</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;BinaryPlus</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Constant</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w"></span>
<span class="w">                                                         </span><span class="p">(</span><span class="nf">-&gt;Constant</span><span class="w"> </span><span class="mf">2.2</span><span class="p">))))</span><span class="w"></span>
<span class="o">#</span><span class="ss">&#39;user/callexpr</span><span class="w"></span>
<span class="nv">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="nv">callexpr</span><span class="p">)</span><span class="w"></span>
<span class="mf">6.6000000000000005</span><span class="w"></span>
<span class="nv">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="nv">callexpr</span><span class="p">)</span><span class="w"></span>
<span class="s">&quot;expression.multimethod/twice@52e29c38(1.1 + 2.2)&quot;</span><span class="w"></span>
</pre></div>
<p>It should be evident that the expression problem matrix for Clojure is:</p>
<img alt="Expression problem matrix in Clojure" class="align-center" src="../images/2016/expr-problem-clojure.png" />
<p>We can add new ops without touching any existing code. We can also add new types
without touching any existing code. The code we're adding is <em>only</em> the new code
to handle the ops/types in question. The existing ops and types could come from
a third-party library to which we don't have source access. We could still
extend them for our new ops and types, without ever having to touch (or even
see) the original source code <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>.</p>
</div>
<div class="section" id="is-multiple-dispatch-necessary-to-cleanly-solve-the-expression-problem">
<h2>Is multiple dispatch necessary to cleanly solve the expression problem?</h2>
<p>I've written about <a class="reference external" href="a-polyglots-guide-to-multiple-dispatch-part-4.html">multiple dispatch in Clojure</a>
before, and in the previous section we see another example of how to use the
language's <tt class="docutils literal">defmulti</tt>/<tt class="docutils literal">defmethod</tt> constructs. But is it multiple dispatch at
all? No! It's just <em>single</em> dispatch, really. Our ops (<tt class="docutils literal">evaluate</tt> and
<tt class="docutils literal">stringify</tt>) dispatch on a <em>single</em> argument - the expression type) <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>.</p>
<p>If we're not really using multiple dispatch, what <em>is</em> the secret sauce that
lets us solve the expression problem so elegantly in Clojure? The answer is -
open methods. Note a crucial difference between how methods are defined in
C++/Java and in Clojure. In C++/Java, methods have to be part of a class and
defined (or at least declared) in its body. You cannot add a method to a class
without changing the class's source code.</p>
<p>In Clojure, you can. In fact, since data types and multimethods are orthogonal
entities, this is by design. Methods simply live outside types - they are first
class citizens, rather than properties of types. We don't add methods <em>to a
type</em>, we add new methods that <em>act upon the type</em>. This doesn't require
modifying the type's code in any way (or even having access to its code).</p>
<p>Some of the other popular programming languages take a middle way. In languages
like Python, Ruby and JavaScript methods belong to types, but we can dynamically
add, remove and replace methods in a class even after it was created. This
technique is lovingly called <em>monkey patching</em>. While initially enticing, it
can lead to big maintainability headaches in code unless we're very careful.
Therefore, if I had to face the expression problem in Python I'd prefer to roll
out some sort of <a class="reference external" href="a-polyglots-guide-to-multiple-dispatch-part-2.html">multiple dispatch mechanism</a>
for my program rather than rely on monkey patching.</p>
</div>
<div class="section" id="another-clojure-solution-using-protocols">
<h2>Another Clojure solution - using protocols</h2>
<p>Clojure's multimethods are very general and powerful. So general, in fact, that
their performance may not be optimal for the most common case - which is single
dispatch based on the type of the sole method argument; note that this is
exactly the kind of dispatch I'm using in this article. Therefore, starting with
Clojure 1.2, user code gained the ability to define and use <em>protocols</em> - a
language feature that was previously restricted only to built-in types.</p>
<p>Protocols leverage the host platform's (which in Clojure's case is mostly Java)
ability to provide quick virtual dispatch, so using them is a very efficient way
to implement runtime polymorphism. In addition, protocols retain enough of
the flexibility of multimethods to elegantly solve the expression problem.
Curiously, this was on the mind of Clojure's designers right from the start. The
Clojure <a class="reference external" href="http://clojure.org/reference/protocols">documentation page about protocols</a> lists this as one of their
capabilities:</p>
<blockquote>
[...] Avoid the 'expression problem' by allowing independent extension of the
set of types, protocols, and implementations of protocols on types, by
different parties. [...] do so without wrappers/adapters</blockquote>
<p>Clojure protocols are an interesting topic, and while I'd like to spend some
more time on them, this article is becoming too long as it is. So I'll leave
a more thorough treatment for some later time and for now will just show how
protocols can also be used to solve the expression problem we're discussing.</p>
<p>The type definitions remain the same:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Constant</span><span class="w"> </span><span class="p">[</span><span class="nv">value</span><span class="p">])</span><span class="w"></span>
<span class="p">(</span><span class="kd">defrecord </span><span class="nv">BinaryPlus</span><span class="w"> </span><span class="p">[</span><span class="nv">lhs</span><span class="w"> </span><span class="nv">rhs</span><span class="p">])</span><span class="w"></span>
</pre></div>
<p>However, instead of defining a multimethod for each operation, we now define
a <em>protocol</em>. A protocol can be thought of as an interface in a language like
Java, C++ or Go - a type implements an interface when it defines the set of
methods declared by the interface. In this respect, Clojure's protocols are more
like Go's interfaces than Java's, as we don't have to say a-priori which
interfaces a type implements when we define it.</p>
<p>Let's start with the <tt class="docutils literal">Evaluatable</tt> protocol, that consists of a single method
- <tt class="docutils literal">evaluate</tt>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Evaluatable</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]))</span><span class="w"></span>
</pre></div>
<p>Another protocol we'll define is <tt class="docutils literal">Stringable</tt>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Stringable</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]))</span><span class="w"></span>
</pre></div>
<p>Now we can make sure our types implement these protocols:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">extend-type</span><span class="w"> </span><span class="nv">Constant</span><span class="w"></span>
<span class="w">  </span><span class="nv">Evaluatable</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="ss">:value</span><span class="w"> </span><span class="nv">this</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="nv">Stringable</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:value</span><span class="w"> </span><span class="nv">this</span><span class="p">))))</span><span class="w"></span>

<span class="p">(</span><span class="nf">extend-type</span><span class="w"> </span><span class="nv">BinaryPlus</span><span class="w"></span>
<span class="w">  </span><span class="nv">Evaluatable</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="ss">:lhs</span><span class="w"> </span><span class="nv">this</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">evaluate</span><span class="w"> </span><span class="p">(</span><span class="ss">:rhs</span><span class="w"> </span><span class="nv">this</span><span class="p">))))</span><span class="w"></span>
<span class="w">  </span><span class="nv">Stringable</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"> </span><span class="p">[(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="ss">:lhs</span><span class="w"> </span><span class="nv">this</span><span class="p">))</span><span class="w"></span>
<span class="w">                                  </span><span class="p">(</span><span class="nf">stringify</span><span class="w"> </span><span class="p">(</span><span class="ss">:rhs</span><span class="w"> </span><span class="nv">this</span><span class="p">))])))</span><span class="w"></span>
</pre></div>
<p>The <tt class="docutils literal"><span class="pre">extend-type</span></tt> macro is a convenience wrapper around the more general
<tt class="docutils literal">extend</tt> - it lets us implement multiple protocols for a given type.
A sibling macro named <tt class="docutils literal"><span class="pre">extend-protocol</span></tt> lets us implement the same protocol
for multiple types in the same invocation <a class="footnote-reference" href="#footnote-6" id="footnote-reference-6">[6]</a>.</p>
<p>It's fairly obvious that adding new data types is easy - just as we did above,
we simply use <tt class="docutils literal"><span class="pre">extend-type</span></tt> for each new data type to implement our current
protocols. But how do we add a new protocol and make sure all existing data
types implement it? Once again, it's easy because we don't have to modify any
existing code. Here's a new protocol:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Serializable</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nf">serialize</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]))</span><span class="w"></span>
</pre></div>
<p>And this is its implementation for the currently supported data types:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">extend-protocol</span><span class="w"> </span><span class="nv">Serializable</span><span class="w"></span>
<span class="w">  </span><span class="nv">Constant</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nf">serialize</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nf">type</span><span class="w"> </span><span class="nv">this</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">:value</span><span class="w"> </span><span class="nv">this</span><span class="p">)])</span><span class="w"></span>
<span class="w">  </span><span class="nv">BinaryPlus</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nf">serialize</span><span class="w"> </span><span class="p">[</span><span class="nv">this</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nf">type</span><span class="w"> </span><span class="nv">this</span><span class="p">)</span><span class="w"></span>
<span class="w">                       </span><span class="p">(</span><span class="nf">serialize</span><span class="w"> </span><span class="p">(</span><span class="ss">:lhs</span><span class="w"> </span><span class="nv">this</span><span class="p">))</span><span class="w"></span>
<span class="w">                       </span><span class="p">(</span><span class="nf">serialize</span><span class="w"> </span><span class="p">(</span><span class="ss">:rhs</span><span class="w"> </span><span class="nv">this</span><span class="p">))]))</span><span class="w"></span>
</pre></div>
<p>This time, extending a single protocol for multiple data types -
<tt class="docutils literal"><span class="pre">extend-protocol</span></tt> is the more convenient macro to use.</p>
</div>
<div class="section" id="small-interfaces-are-extensibility-friendly">
<h2>Small interfaces are extensibility-friendly</h2>
<p>You may have noted that the protocols (interfaces) defined in the Clojure
solution are very small - consisting of a single method. Since adding methods to
an existing protocol is much more problematic (I'm not aware of a way to do this
in Clojure), keeping protocols small is a good idea. This guideline comes up in
other contexts as well; for example, it's good practice to keep interfaces in Go
very minimal.</p>
<p>In our C++ solution, splitting the <tt class="docutils literal">Expr</tt> interface could also be a good idea,
but it wouldn't help us with the expression problem, since we can't modify which
interfaces a class implements after we've defined it; in Clojure we can.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>&quot;Types of data&quot; and &quot;operations&quot; are two terms that should be fairly
obvious to modern-day programmers. Philip Wadler, in his discussion of
the expression problem (see the &quot;historical perspective&quot; section of the
article) calls them &quot;datatypes&quot; and &quot;functions&quot;. A famous quote from Fred
Brooks's <em>The Mythical Man Month</em> (1975) is &quot;Show me your flowcharts and
conceal your tables, and I shall continue to be mystified. Show me your
tables, and I wont usually need your flowcharts; theyll be obvious.&quot;</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td><p class="first">Note the peculiar way in which data is passed between <tt class="docutils literal">Visit*</tt> methods
in a <tt class="docutils literal">Expr* <span class="pre">-&gt;</span> Value</tt> map kept in the visitor. This is due to our
inability to make <tt class="docutils literal">Visit*</tt> methods return different types in different
visitors. For example, in <tt class="docutils literal">Evaluator</tt> we'd want them to return
<tt class="docutils literal">double</tt>, but in <tt class="docutils literal">Stringifier</tt> they'd probably return
<tt class="docutils literal"><span class="pre">std::string</span></tt>. Unfortunately C++ won't let us easily mix templates and
virtual functions, so we have to resort to either returning <tt class="docutils literal">void*</tt> the
C way or the method I'm using here.</p>
<p class="last">Curiously, in their paper Krishnamurthi et.al. run into the same issue in
the dialect of Java they're using, and propose some language extensions
to solve it. Philip Wadler uses proposed Java generics in <em>his</em> approach.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>I can't resist, so just in brief: IMHO inheritance is only good for a
very narrow spectrum of uses, but languages like C++ hail it as the main
extension mechanism of types. But inheritance is deeply
flawed for many other use cases, such as implementations of
interfaces. Java is a bit better in this regard, but in the end the
primacy of classes and their &quot;closed-ness&quot; make a lot of tasks - like the
expression problem - very difficult to express in a clean way.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>In fact, there are plenty of examples in which the Clojure implementation
and the standard library provide protocols that can be extended by the
user for user-defined types. Extending user-written protocols and
multimethods for built-in types is trivial. As an exercise, add an
<tt class="docutils literal">evaluate</tt> implementation for <tt class="docutils literal">java.lang.Long</tt>, so that built-in
integers could participate in our expression trees without requiring
wrapping in a <tt class="docutils literal">Constant</tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>FWIW, we <em>can</em> formulate a multiple dispatch solution to the expression
problem in Clojure. The key idea is to dispatch on two things: type and
operation. Just for fun, I coded a prototype that does this which you can
see <a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/expression-problem/clojure/expression/src/expression/multidispatch.clj">here</a>.
I think the approach presented in the article - each operation being its
own multimethod - is preferable, though.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-6">[6]</a></td><td>The sharp-eyed reader will notice a cool connection to the expression
problem matrix. <tt class="docutils literal"><span class="pre">extend-type</span></tt> can add a whole new row to the matrix,
while <tt class="docutils literal"><span class="pre">extend-protocol</span></tt> adds a column. <tt class="docutils literal">extend</tt> adds just a single
cell.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 00:58:26 GMT -->
</html>