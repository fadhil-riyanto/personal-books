<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2016/returning-multiple-values-from-functions-in-c/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:59:45 GMT -->
<head>
    <title>Returning multiple values from functions in C++ - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Returning multiple values from functions in C++">
                        Returning multiple values from functions in C++
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> March 04, 2016 at 06:33</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/c-c.html">C & C++</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Since C++ has no built-in syntax for returning multiple values from functions
and methods, programmers have been using a number of techniques to
simulate this when needed, and the number has grown since the introduction of
C++11. In this post I want to provide an overview of some of the options we
have today for returning multiple values from functions, and possible future
directions in the language.</p>
<div class="section" id="introduction-why-multiple-return-values">
<h2>Introduction - why multiple return values?</h2>
<p>Multiple return values from functions are not a new concept in programming -
some old and venerable languages like Common Lisp have had them since the early
1980s.</p>
<p>There are many scenarios where multiple return values are useful:</p>
<p>First and foremost, for functions that naturally have more than one value to
compute. For example, the Common Lisp <tt class="docutils literal">floor</tt> function computes the quotient
<em>and</em> the remainder of its two operands, and returns both. Another example is
<tt class="docutils literal"><span class="pre">std::minmax</span></tt> in C++11, that finds the minimal and the maximal value in a
container simultaneously.</p>
<p>Second, multiple return values are helpful when the data structure the function
operates on contains multiple values per entry. For example, Python 3's
<tt class="docutils literal">dict.items</tt> is an iterator over key / value pairs, and each iteration returns
both, which is frequently useful. Similarly, in C++ the mapping family of
containers provides iterators that hold key / value pairs, and methods like
<tt class="docutils literal"><span class="pre">std::map::find</span></tt> logically return a pair, even though it's encapsulated in an
iterator object. Another related, but slightly different example is Python's
<tt class="docutils literal">enumerate</tt>, which takes any sequence or iterator and returns index / value
pairs - very useful for writing some kinds of <tt class="docutils literal">for</tt> loops.</p>
<p>Third, the multiple return values may signal different &quot;paths&quot; - like error
conditions or &quot;not found&quot; flags, in addition to actual values. In Go, map lookup
returns a value / found pair, where &quot;found&quot; is a boolean flag saying whether the
key was found in the map. In general, in Go it's idiomatic to return a value /
error pair from functions. This method is useful in C++ as well, and I'll cover
an example in the next section.</p>
<p>Multiple return values are so convenient that programmers usually find ways to
simulate them even in languages that don't support them directly. As for new
programming languages, most of them come with this feature natively supported.
Go, Swift, Clojure, Rust and Scala all support multiple return values.</p>
</div>
<div class="section" id="multiple-return-values-in-c-with-output-parameters">
<h2>Multiple return values in C++ with output parameters</h2>
<p>Back to C++, let's start our quest with the oldest and possibly still most
common method - using some of the function's parameters as &quot;out&quot; parameters.
This method is made possible by C++ (based on C before it) making a strict
distinction between parameters passed by value and by reference (or pointer)
into functions. Parameters passed by pointers can be used to &quot;return&quot; values to
the caller.</p>
<p>This technique has old roots in C, where it's used in many places in the
standard library; for example <tt class="docutils literal">fgets</tt> and <tt class="docutils literal">fscanf</tt>. Many POSIX functions
adopt the conventions of returning an integer &quot;error code&quot; (0 for success),
while writing any output they have into an output parameter. Examples abound -
<tt class="docutils literal">gettimeofday</tt>, <tt class="docutils literal">pthread_create</tt>... there are hundreds (or thousands). This
has become such a common convention that some code-bases adopt a special
marker for output parameters, either with a comment or a dummy macro. This is
to distinguish by-pointer input parameters from output parameters in the
function signature, thus signaling to the user which is which:</p>
<div class="highlight"><pre><span></span><span class="cp">#define OUT</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">myfunc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">input1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">input2</span><span class="p">,</span><span class="w"> </span><span class="n">OUT</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>C++ employs this technique in the standard library as well. A good example is
the <tt class="docutils literal"><span class="pre">std::getline</span></tt> function. Here's how we read everything from stdin and
echo every line back with a prefix:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">line</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;echo: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">std::getline</span></tt> writes the line it has read into its second parameter. It
returns the stream (the first parameter), since a C++ stream has interesting
behavior in boolean context. It's <tt class="docutils literal">true</tt> so long as everything is OK, but
flips to <tt class="docutils literal">false</tt> once an error occurs, or an end-of-file condition is reached.
The latter is what the sample above uses to concisely invoke <tt class="docutils literal"><span class="pre">std::getline</span></tt> in
the condition of a <tt class="docutils literal">while</tt> loop.</p>
<p>C++'s introduction of reference types adds a choice over the C approach. Do we
use pointers or references for output parameters? On one hand references result
in simpler syntax (if the line would have to be passed by pointer in the code
above, we'd have to use <tt class="docutils literal">&amp;line</tt> in the call) and also cannot be <tt class="docutils literal">nullptr</tt>,
which is important for output parameters. On the other hand, with references it
is very hard to look at a call and discern which parameters are input and which
are output. Also, the <tt class="docutils literal">nullptr</tt> argument works both ways - occasionally it is
useful to convey to the callee that some output is not needed and a <tt class="docutils literal">nullptr</tt>
in an output parameter is a common way to do this.</p>
<p>As a result, some coding guidelines recommend only using pointers for output
parameters, while using <tt class="docutils literal">const</tt> references for input parameters. But as with
all issues of style, YMMV.</p>
<p>Whichever style you pick, this approach has obvious downsides:</p>
<ul class="simple">
<li>The output values are not uniform - some are returned, some are parameters,
and it's not easy to know which parameters are for output. <tt class="docutils literal"><span class="pre">std::getline</span></tt>
is simple enough, but when your function takes 4 and returns 3 values, things
start getting hairy.</li>
<li>Calls require declarations of output parameters beforehead (such as <tt class="docutils literal">line</tt>
in the example above). This bloats the code.</li>
<li>Worse, the separation of parameter declaration from its assignment within the
function call can result in uninitialized variables in some cases. To analyze
whether <tt class="docutils literal">line</tt> is initialized in the example above, one has to carefully
understand the semantics of <tt class="docutils literal"><span class="pre">std::getline</span></tt>.</li>
</ul>
<p>On the other hand, prior to the introduction of move semantics in C++11,
this style had serious performance advantages over the alternatives, since it
can avoid extra copying. I'll discuss this a bit more later on in the article.</p>
</div>
<div class="section" id="pairs-and-tuples">
<h2>Pairs and tuples</h2>
<p>The <tt class="docutils literal"><span class="pre">std::pair</span></tt> type is a veteran in C++. It's used in a bunch of places in
the standard library to do things like hold keys and values of mappings, or
to hold &quot;status, result&quot; pairs. Here's an example that demonstrates both:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="n">map_int_to_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">try_insert</span><span class="p">(</span><span class="n">map_int_to_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">map_int_to_string</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">});</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;insertion succeeded. &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;insertion failed. &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;key=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; value=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mymap</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">mymap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">try_insert</span><span class="p">(</span><span class="n">mymap</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">try_insert</span><span class="p">(</span><span class="n">mymap</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The <tt class="docutils literal"><span class="pre">std::unordered_map::insert</span></tt> method returns two values: an element
iterator and a boolen flag saying whether the requested pair was inserted or not
(it won't be inserted if the key already exists in the map). What makes the
example really interesting is that there are <em>nested</em> multiple values being
returned here. <tt class="docutils literal">insert</tt> returns a <tt class="docutils literal"><span class="pre">std::pair</span></tt>. But the first element of the
pair, the iterator, is just a thin wrapper over another pair - the key/value
pair - hence the <tt class="docutils literal"><span class="pre">first-&gt;first</span></tt> and <tt class="docutils literal"><span class="pre">first-&gt;second</span></tt> accesses we use when
printing the values out.</p>
<p>Thus we also have an example of a shortcoming of <tt class="docutils literal"><span class="pre">std::pair</span></tt> - the obscureness
of <tt class="docutils literal">first</tt> and <tt class="docutils literal">second</tt>, which requires us to always remember the relative
positions of values within the pairs. <tt class="docutils literal"><span class="pre">p.first-&gt;second</span></tt> gets the job done but
it's not exactly a paragon of readable code.</p>
<p>With C++11, we have an alternative - <tt class="docutils literal"><span class="pre">std::tie</span></tt>:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">try_insert_with_tie</span><span class="p">(</span><span class="n">map_int_to_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">map_int_to_string</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">did_insert</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n">did_insert</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">});</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">did_insert</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;insertion succeeded. &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;insertion failed. &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;key=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; value=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now we can give the pair members readable names. The disadvantage of this
approach is, of course, that we need the separate declarations that take
extra space. Also, while in the original example we could use <tt class="docutils literal">auto</tt> to infer
the type of the pair (useful for really hairy iterators), here we have to
declare them fully.</p>
<p>Pairs work for two return values, but sometimes we need more. C++11's
introduction of variadic templates finally made it possible to add a generic
tuple type into the standard library. A <tt class="docutils literal"><span class="pre">std::tuple</span></tt> is a generalization of
a <tt class="docutils literal"><span class="pre">std::pair</span></tt> for multiple values. Here's an example:</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">create_a_tuple</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;baz&quot;</span><span class="p">),</span><span class="w"> </span><span class="mf">1.2f</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_a_tuple</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the int: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the string: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the float: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The <tt class="docutils literal"><span class="pre">std::get</span></tt> template is used to access tuple members. Again, this is not
the friendliest syntax but we can alleviate it somewhat with <tt class="docutils literal"><span class="pre">std::tie</span></tt>:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_a_tuple</span><span class="p">();</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the int: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the string: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the float: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Another alternative is to use even more template metaprogramming magic to create
a &quot;named&quot; tuple (similar to the Python <tt class="docutils literal">namedtuple</tt> type). <a class="reference external" href="http://stackoverflow.com/questions/13065166">Here's an example</a>. There are no standard solutions
for this, though.</p>
</div>
<div class="section" id="structs">
<h2>Structs</h2>
<p>When faced with sophisticated &quot;named tuple&quot; implementations, old-timers snort
and remind us that in the olden days of C, this problem already had a
perfectly valid solution - a <tt class="docutils literal">struct</tt>. Here's the last example rewritten using
a struct:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">RetVal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inumber</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">fnumber</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">RetVal</span><span class="w"> </span><span class="nf">create_a_struct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;baz&quot;</span><span class="p">),</span><span class="w"> </span><span class="mf">1.2f</span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ... usage</span>

<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">retvaldata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_a_struct</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the int: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">retvaldata</span><span class="p">.</span><span class="n">inumber</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the string: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">retvaldata</span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the float: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">retvaldata</span><span class="p">.</span><span class="n">fnumber</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>When the returned value is created, the syntax is nice an concise. We could
even omit some of the fields if their default values are good enough (or the
<tt class="docutils literal">struct</tt> has  constructors for partial field initialization). Also note how
natural the access to the returned value's fields is: all fields have
descriptive names - this is perfect! C99 went a step further here, allowing
named initialization syntax for struct fields:</p>
<div class="highlight"><pre><span></span><span class="n">RetVal</span><span class="w"> </span><span class="nf">create_a_struct_named</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{.</span><span class="n">inumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;baz&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">.</span><span class="n">fnumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.2f</span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This is very useful for self-documenting code that doesn't force you to go peek
into the <tt class="docutils literal">RetVal</tt> type every time you want to decode a value. Unfortunately,
even if your C++ compiler supports this, it's <em>not standard C++</em>, because C++
did not adopt the feature. Apparently there <a class="reference external" href="http://htmlpreview.github.io/?https://raw.github.com/CTMacUser/multiarray-iso-proposal/master/designation-proposal.html">was an active proposal to add it</a>,
but it wasn't accepted; at least not yet.</p>
<p>The rationale of the C++ committee, AFAIU, is to prefer constructors to
initialize struct fields. Still, since C++ functions don't have a named
parameter (&quot;keyword argument&quot; in Python parlance) syntax, using ctors here
wouldn't be more readable. What it would allow, though, is convenient non-zero
default initialization values.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">RetValInitialized</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foobar&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">fnumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.24f</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">RetValInitialized</span><span class="w"> </span><span class="nf">create_an_initialized_struct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Or even fancier initialization patterns with a constructor:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">RetValWithCtor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">RetValWithCtor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">inumber</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">str</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;x&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">fnumber</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inumber</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">fnumber</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">RetValWithCtor</span><span class="w"> </span><span class="nf">create_a_constructed_struct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This would also be a good place to briefly address the performance issue I
mentioned earlier. In C++11, it's almost certain that structs returned by value
will not actually copied due to the <a class="reference external" href="https://en.wikipedia.org/wiki/Return_value_optimization">return-value optimization mechanism</a>. Neither will the
<tt class="docutils literal"><span class="pre">std::string</span></tt> held by value within the struct be copied. For even more details,
see section 12.8 of the C++11 standard, in the paragraph starting with:</p>
<blockquote>
When certain criteria are met, an implementation is allowed to omit the
copy/move construction of a class object, even if the copy/move constructor
and/or destructor for the object have side effects. In such cases, the
implementation treats the source and target of the omitted copy/move
operation as simply two different ways of referring to the same object, and
the destruction of that object occurs at the later of the times when the two
objects would have been destroyed without the optimization</blockquote>
<p>This mechanism is called <em>copy elision</em> by the standard.</p>
</div>
<div class="section" id="structured-bindings-a-new-hope-for-c-17">
<h2>Structured bindings: a new hope for C++17</h2>
<p>Luckily, the C++ standard committee consists of brilliant folks who have already
recognized that even though C++ has many ways to do multiple return values, none
is really perfect. So there's a new proposal making the rounds now for the C++17
edition of the language, called <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf">Structured bindings</a>.</p>
<p>In brief, the idea is to support a new syntax that will make tying results of
tuple-returning functions easier. Recall from the discussion above that while
tuples have a fairly convenient syntax returning them from functions, the
situation on the receiving side is less than optimal with a choice between
clunky <tt class="docutils literal"><span class="pre">std::get</span></tt> calls or pre-declaration and <tt class="docutils literal"><span class="pre">std::tie</span></tt>.</p>
<p>What the proposal puts forward is the following syntax for receiving the tuple
returned by <tt class="docutils literal">create_a_tuple</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_a_tuple</span><span class="p">();</span><span class="w"></span>
<span class="c1">// Note: proposed C++17 code, doesn&#39;t compile yet</span>
</pre></div>
<p>The types of <tt class="docutils literal">i</tt>, <tt class="docutils literal">s</tt> and <tt class="docutils literal">f</tt> are &quot;auto&quot;-inferred by the compiler from
the return type of <tt class="docutils literal">create_a_tuple</tt>. Moreover, a different enhancement of C++17
is to permit a shorter tuple creation syntax as well, removing the need for
<tt class="docutils literal"><span class="pre">std::make_tuple</span></tt> and making it as concise as struct creation:</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">create_a_tuple</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;baz&quot;</span><span class="p">),</span><span class="w"> </span><span class="mf">1.2f</span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Note: proposed C++17 code, doesn&#39;t compile yet</span>
</pre></div>
<p>The structured bindings proposal is for returned struct values as well, not just
tuples, so we'll be able to do this:</p>
<div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_a_struct</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>I sure hope this proposal will get accepted. It will make simple code pleasant
to write and read, at no cost to the compiler and runtime.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>So many possibilities, what to choose? Personally, since I believe code
readability is more important than making it quick to compose, I like the
explicit approach of wrapping multiple values in structs. When the returned
values logically belong together, this is a great way to collect them in a
natural self-documenting way. So this would be the approach I'd use most often.</p>
<p>That said, sometimes the two values returned really don't belong together in any
logical sense - such as a stream and a string in the <tt class="docutils literal">getline</tt> example.
Littering the source code with one-off <tt class="docutils literal">struct</tt> types named
<tt class="docutils literal">StreamAndResult</tt> or <tt class="docutils literal">OutputAndStatus</tt> is far from ideal, so in these cases
I'd actually consider a <tt class="docutils literal"><span class="pre">std::pair</span></tt> or a <tt class="docutils literal"><span class="pre">std::tuple</span></tt>.</p>
<p>It goes without saying that the proposed structured bindings in C++17 can make
all of this even easier to write, making folks less averse to the current
verboseness of tuples.</p>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2016/returning-multiple-values-from-functions-in-c/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:59:45 GMT -->
</html>