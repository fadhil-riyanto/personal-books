<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-3 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:01:37 GMT -->
<head>
    <title>A polyglot's guide to multiple dispatch - part 3 - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../theme/css/style.css" type="text/css"/>

        <link href="../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../index.html" class="navbar-brand">
                <img src="../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="a-polyglots-guide-to-multiple-dispatch-part-3/index.html"
                       rel="bookmark"
                       title="Permalink to A polyglot's guide to multiple dispatch - part 3">
                        A polyglot's guide to multiple dispatch - part 3
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> April 26, 2016 at 05:36</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../tag/lisp.html">Lisp</a>
        ,
    <a href="../tag/multiple-dispatch.html">Multiple dispatch</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This is part 3 in the <a class="reference external" href="../tag/multiple-dispatch.html">series of articles</a> on multiple dispatch.
<a class="reference external" href="a-polyglots-guide-to-multiple-dispatch.html">Part 1</a>
introduced the problem and discussed the issues surrounding it, along with a
couple of possible solutions in C++. <a class="reference external" href="a-polyglots-guide-to-multiple-dispatch-part-2.html">Part 2</a>
revisited multiple dispatch in Python, implementing a couple of variations. In
this part, I'm going back to the roots of multiple dispatch - Common Lisp - one
of the first mainstream programming languages to introduce <em>multi-methods</em> and
an OOP system based on multiple dispatch at its core.</p>
<p>It's strange to leave the language where multiple dispatch is actually built-in
to the third article in the series; however, as Common Lisp is not exactly the
most widely used language these days, I wanted to start with languages folks
are more familiar with. Besides, my hope is that by now readers of the series
have a much better understanding and appreciation of multiple dispatch, and it
should be interesting to see a very powerful and feature-full version of it
directly supported by a language.</p>
<p>The lessons from Common Lisp weren't lost on some modern language designers, and
you can find variations of its multi-methods in 21st-century languages. In the
next part of the series I'll show how multiple dispatch works in Clojure - a
modern Lisp dialect <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>.</p>
<div class="section" id="a-bit-of-history">
<h2>A bit of history</h2>
<p>Young programmers getting started in the 2010s can be forgiven to think that
object-oriented programming (OOP) the way it's done in C++, Java and Ruby is how
it was always done. But in fact, while C++ appeared in the early 80s and Java in
1995, OOP first appeared in the 1960s in specialized languages like Simula, and
then Smalltalk in 1972. Smalltalk itself was influenced by Lisp in many aspects,
and Lisp hackers didn't wait long to borrow back OOP ideas from Smalltalk; the
first beginnings of OOP libraries in Lisp <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a> started popping up in the mid
70s, years before a PhD student from Denmark started tinkering with bolting
classes on top of C. That was Bjarne Stroustrup, of course, and C++ saw first
light in 1982. Meanwhile, the OOP features in Lisp already started to fragment
into multiple competing approaches (<em>everything</em> in the Lisp world fragments,
it's an unwritten law). It was then (before 1980) when the initial ideas of
what we now know as CLOS - the <em>Common Lisp Object System</em> - started appearing,
with multi-methods, custom method combinations, the meta-object protocol <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>
and so on.</p>
<p>There's a lesson in this long historical preamble. OOP as it manifests itself in
Common Lisp may seem foreign if all you're familiar with is languages like C++
and Java. However, don't let that fool you. OOP is not a single recipe on how to
do things - it's a concept, which was realized in many different ways in the
past, in different languages. In fact, if you spend a bit of time learning it -
you'll quickly realize that CLOS's OOP is a superset of the single-dispatch OOP
in C++ and Java, and is much more powerful and general overall.</p>
</div>
<div class="section" id="common-lisp-and-clos">
<h2>Common Lisp and CLOS</h2>
<p>Common Lisp is the result of a Babelian consolidation of multiple Lisp
implementations that happened in the 1980s, with an ANSI standard that appeared
in the early 1990s. From the start, CLOS (the Common Lisp Object System) was
part of the Common Lisp standard, itself consolidating two earlier attempts at
OOP in Lisp - <em>Flavors</em> and <em>LOOPS</em>.</p>
<p>All in all, CLOS is a very powerful OOP system with many advanced features that
don't exist in today's mainstream languages. It's well worth learning about
- in this humble article I only provide a small taste. I listed some links and
references to materials about CLOS I personally liked at the end of the post.</p>
</div>
<div class="section" id="polymorphic-dispatch-in-clos">
<h2>Polymorphic dispatch in CLOS</h2>
<p>From the very start CLOS's idea of runtime polymorphism was based on multiple,
rather than single dispatch. Let's see why this made sense.</p>
<p>Here's a sample method in C++:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Frobnicate</span><span class="p">(</span><span class="n">Record</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">Spreadsheet</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// &#39;this&#39; points to a Person.</span>
<span class="w">        </span><span class="c1">// &#39;r&#39; points to a Record, &#39;s&#39; to a Spreadsheet.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>And this is how we may call it:</p>
<div class="highlight"><pre><span></span><span class="n">Person</span><span class="w"> </span><span class="n">person</span><span class="p">;</span><span class="w"></span>
<span class="n">Record</span><span class="w"> </span><span class="n">record</span><span class="p">;</span><span class="w"></span>
<span class="n">Spreadsheet</span><span class="w"> </span><span class="n">spreadsheet</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ...</span>
<span class="n">person</span><span class="p">.</span><span class="n">Frobnicate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">record</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spreadsheet</span><span class="p">)</span><span class="w">     </span><span class="c1">// CALL</span>
</pre></div>
<p>The call line marked with <strong>CALL</strong> is the most interesting here. Note how there
are two distinct roles in this call: a special position is reserved to
<tt class="docutils literal">person</tt>, which is the object the method is invoked on. It goes before the
dot. Method arguments go inside the function call syntax. Within the
implementation of <tt class="docutils literal">Frobnicate</tt>, the <tt class="docutils literal">Person</tt> instance is known as <tt class="docutils literal">this</tt>;
the arguments are declared with the usual function parameter bindings. This is
frequently called &quot;message passing&quot; - we're sending a <tt class="docutils literal">Frobnicate</tt> <em>message</em>
to a <tt class="docutils literal">Person</tt> object with <tt class="docutils literal">Record</tt> and <tt class="docutils literal">Spreadsheet</tt> arguments.</p>
<p>In Python this would be very similar, except that the method implementation has
a <tt class="docutils literal">self</tt> parameter as a more explicit reference to the object the method is
invoked on. Thus most of the widespread OOP languages these days have this
special slot for one of the arguments - the object we invoke the method on. Note
that this is distinct syntax from regular function calls.</p>
<p>In Lisp, such an approach goes against the philosophy of the language, where
<em>uniform syntax</em> is paramount. In Lisp, all the main abstraction techniques
have the same syntax, called &quot;a form&quot;:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="nv">bar</span><span class="w"> </span><span class="nv">baz</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>The first position in the form defines the meaning of the
form. It may be a function call, a macro invocation, or a <em>special form</em> (such
as <tt class="docutils literal">if</tt>); whatever it is, the syntax is uniform. This is one of the greatest
strengths of Lisp.</p>
<p>Back to dispatch, though. Since Lisp wants to preserve its uniform invocation
syntax, a special syntax for calling methods on symbols won't do. Therefore,
what CLOS has is:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Person</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">frobnicate</span><span class="w"> </span><span class="p">((</span><span class="nv">p</span><span class="w"> </span><span class="nv">Person</span><span class="p">)</span><span class="w"> </span><span class="nv">record</span><span class="w"> </span><span class="nv">spreadsheet</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~a ~a ~a~&amp;&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">record</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">spreadsheet</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>The syntax is different from what we're used to. The <em>method</em> <tt class="docutils literal">frobnicate</tt> is
defined outside the class <tt class="docutils literal">Person</tt>. However, the special parameter form <tt class="docutils literal">(p
Person)</tt> in the definition of <tt class="docutils literal">frobnicate</tt> makes sure that this method is
only called when the first argument is indeed a <tt class="docutils literal">Person</tt>. If we had another
type with a <tt class="docutils literal">frobnicate</tt> method, we'd define that method as:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Asteroid</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">frobnicate</span><span class="w"> </span><span class="p">((</span><span class="nv">a</span><span class="w"> </span><span class="nv">Asteroid</span><span class="p">)</span><span class="w"> </span><span class="nv">velocity</span><span class="w"> </span><span class="nv">size</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="c1">; do stuff</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Then, at runtime:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">frobnicate</span><span class="w"> </span><span class="nv">a-person</span><span class="w"> </span><span class="nv">his-record</span><span class="w"> </span><span class="nv">big-spreadsheet</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Would be routed to the former method, while:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">frobnicate</span><span class="w"> </span><span class="nv">an-asteroid</span><span class="w"> </span><span class="nv">very-fast</span><span class="w"> </span><span class="nv">pretty-small</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Would be routed to the latter. As you can see, this is your standard
single-dispatch runtime polymoprhism (the dispatch indeed happens <em>at runtime</em> -
Common Lisp is dynamically typed, like Python), but based on a uniform Lisp-y
syntax where the first parameter (the actual class instance) doesn't have a
special position; besides being the first, of course.</p>
<p>It shouldn't be a huge leap of imagination to go from this to multi-methods.
Because, you see, if the class instance has no special syntax dedicated to it,
who says it's special at all. Can't we dispatch upon the <em>second</em> argument
instead? Something like:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">interplex</span><span class="w"> </span><span class="p">(</span><span class="nv">solution</span><span class="w"> </span><span class="p">(</span><span class="nv">p</span><span class="w"> </span><span class="nv">Person</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~a ~a~&amp;&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">solution</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">p</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>Here, the dispatch happens upon the runtime type of the <em>second</em> argument, so
even the position in the call is not special. What <em>is</em> special about <tt class="docutils literal">Person</tt>
as far as these methods are concerned? Well, nothing really.</p>
<p>This is where CLOS turns OOP on its head, at least to some degree. In C++, Java
and kin, methods are properties of classes; each class has its set of methods.
In CLOS, this works differently. Classes and methods are orthogonal. Methods do
not belong to classes (as you may have guessed by now, if only from the fact
that methods are defined <em>outside</em> of classes entirely, rather than being nested
in them). Classes do not belong to methods. Methods are simply functions that
are invoked when one <em>or more</em> of their argument matches some runtime criteria -
most often type.</p>
<p>So what prevents methods to dispatch based on the types of more than one
parameter? Nothing indeed.</p>
</div>
<div class="section" id="clos-and-multi-methods">
<h2>CLOS and multi-methods</h2>
<p>Without further ado, here is a Common Lisp implementation of the shape
intersection problem we've been using throughout the series:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Shape</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Rectangle</span><span class="w"> </span><span class="p">(</span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Ellipse</span><span class="w"> </span><span class="p">(</span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Triangle</span><span class="w"> </span><span class="p">(</span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">())</span><span class="w"></span>

<span class="c1">; Having a defgeneric is not strictly necessary in CLOS. The code would</span><span class="w"></span>
<span class="c1">; work without this definition. However, this is good practice as it gives</span><span class="w"></span>
<span class="c1">; us a natural place to document the generic interface methods are expected</span><span class="w"></span>
<span class="c1">; to implement. It also lets us add a default handler with a meaningful</span><span class="w"></span>
<span class="c1">; error message, if no suitable method was found in some case.</span><span class="w"></span>
<span class="p">(</span><span class="nb">defgeneric</span><span class="w"> </span><span class="nv">intersect</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="ss">:documentation</span><span class="w"> </span><span class="s">&quot;Shape intersection&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="ss">:method</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Cannot interesect these shapes&quot;</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">intersect</span><span class="w"> </span><span class="p">((</span><span class="nv">r</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">e</span><span class="w"> </span><span class="nv">Ellipse</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Rectangle x Ellipse [names r=~a, e=~a]~&amp;&quot;</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">e</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">intersect</span><span class="w"> </span><span class="p">((</span><span class="nv">r1</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">r2</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Rectangle x Rectangle [names r1=~a, r2=~a]~&amp;&quot;</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">r1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">r2</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">intersect</span><span class="w"> </span><span class="p">((</span><span class="nv">r</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">s</span><span class="w"> </span><span class="nv">Shape</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Rectangle x Shape [names r=~a, s=~a]~&amp;&quot;</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">s</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>A few things to note here:</p>
<ul class="simple">
<li>Most importantly: <tt class="docutils literal">intersect</tt> is specialized by the types of both its
parameters, and a different method is invoked based on the actual combination
of runtime types passed in. We'll see this in action soon.</li>
<li>Inheritance is used. <tt class="docutils literal">defclass</tt> lets us list the superclasses of any class
after its name, and here <tt class="docutils literal">Rectangle</tt>, <tt class="docutils literal">Ellipse</tt>, and <tt class="docutils literal">Triangle</tt> are
all set to inherit from <tt class="docutils literal">Shape</tt>.</li>
</ul>
<p>Let's create some objects and do some <tt class="docutils literal">intersect</tt> calls:</p>
<div class="highlight"><pre><span></span><span class="c1">;; Create some objects</span><span class="w"></span>
<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">r1</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;Rectangle</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">r2</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;Rectangle</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">e1</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;Ellipse</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">t1</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;Triangle</span><span class="p">))</span><span class="w"></span>

<span class="c1">;; Do intersects</span><span class="w"></span>
<span class="p">(</span><span class="nv">intersect</span><span class="w"> </span><span class="nv">r1</span><span class="w"> </span><span class="nv">e1</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="nv">intersect</span><span class="w"> </span><span class="nv">r1</span><span class="w"> </span><span class="nv">r2</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="nv">intersect</span><span class="w"> </span><span class="nv">r1</span><span class="w"> </span><span class="nv">t1</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>We get:</p>
<div class="highlight"><pre><span></span>Rectangle x Ellipse [names r=RECTANGLE, e=ELLIPSE]
Rectangle x Rectangle [names r1=RECTANGLE, r2=RECTANGLE]
Rectangle x Shape [names r=RECTANGLE, s=TRIANGLE]
</pre></div>
<p>The dispatch works as expected. Moreover, base-class defaults work out of the
box - we didn't define a method for <tt class="docutils literal">Rectangle x Triangle</tt>, so the method
for <tt class="docutils literal">Rectangle x Shape</tt> was invoked in the last call to <tt class="docutils literal">intersect</tt> <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>.</p>
<p>Multiple dispatch is supported natively in CLOS. Moreover, as the earlier
discussion hopefully highlights, multiple dispatch is not just a variation
bolted onto the system (like our <tt class="docutils literal">&#64;multi</tt> decorators in part 2), but it is
<em>the</em> way polymorphic dispatch works in the language. Single dispatch is just a
special case of multiple dispatch.</p>
</div>
<div class="section" id="clos-methods-are-just-functions">
<h2>CLOS methods are just functions</h2>
<p>As I've mentioned before, CLOS methods are just functions. They are not special
in the same way C++ methods are special (<em>bound</em> to objects). This means we can
use them just as we use any other function.</p>
<p>For example, we can map them onto objects, and it will work as expected:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">mapcar</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nv">intersect</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">r1</span><span class="w"> </span><span class="nv">r2</span><span class="w"> </span><span class="nv">e1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">r2</span><span class="w"> </span><span class="nv">e1</span><span class="w"> </span><span class="nv">t1</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Had <tt class="docutils literal">intersect</tt> been special as it is in C++, it wouldn't be as easy. We'd
need something like <tt class="docutils literal"><span class="pre">std::bind</span></tt> to &quot;bind&quot; it to an object instance first. In
CLOS, we don't care. We can have a higher-order function that takes a function
and applies it to pairs of objects:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">domap</span><span class="w"> </span><span class="p">(</span><span class="nv">func</span><span class="w"> </span><span class="nv">lst1</span><span class="w"> </span><span class="nv">lst2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">mapcar</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">lst1</span><span class="w"> </span><span class="nv">lst2</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>We can now invoke <tt class="docutils literal">domap</tt> with either a &quot;regular&quot; function or a method, using
the same syntax:</p>
<div class="highlight"><pre><span></span><span class="c1">;; invoke cons on pairs of objects</span><span class="w"></span>
<span class="p">(</span><span class="nv">domap</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">r1</span><span class="w"> </span><span class="nv">r2</span><span class="w"> </span><span class="nv">e1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">r2</span><span class="w"> </span><span class="nv">e1</span><span class="w"> </span><span class="nv">t1</span><span class="p">))</span><span class="w"></span>

<span class="c1">;; invoke intersect on pairs of objects</span><span class="w"></span>
<span class="p">(</span><span class="nv">domap</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nv">intersect</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">r1</span><span class="w"> </span><span class="nv">r2</span><span class="w"> </span><span class="nv">e1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">r2</span><span class="w"> </span><span class="nv">e1</span><span class="w"> </span><span class="nv">t1</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>I'm showing this example to stress that CLOS methods are just <em>functions</em>.
Decoupling class declarations from methods that act upon these classes lets us
be much more flexible in the usage of these methods. Since Lisp is all about
uniform syntax and functional programming, the result is an object-oriented
system elegantly blended into the whole.</p>
</div>
<div class="section" id="variations-on-a-theme">
<h2>Variations on a theme</h2>
<p>The sample above demonstrates how CLOS gives us powerful multiple-dispatch
capabilities right out of the box. As it turns out, this is just the tip of the
iceberg, as CLOS supports many more features. I want to give a short taste
of a few here - for more information I recommend doing some reading on CLOS.</p>
<p>Let's start with value-based dispatch. So far we've seen how a method can
speficy which <em>type</em> of argument it specializes on. We can also specialize
methods by the <em>value</em> of an argument. Here's a silly example based on the same
world of shapes:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defgeneric</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">(</span><span class="nv">shape</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="ss">:documentation</span><span class="w"> </span><span class="s">&quot;Scale a shape by a factor&quot;</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">((</span><span class="nv">shape</span><span class="w"> </span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Scale shape by ~a~&amp;&quot;</span><span class="w"> </span><span class="nv">factor</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">((</span><span class="nv">shape</span><span class="w"> </span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">factor</span><span class="w"> </span><span class="p">(</span><span class="nb">eql</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Scale shape by a zero~&amp;&quot;</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Now given some <tt class="docutils literal">s</tt> - an instance of <tt class="docutils literal">Shape</tt>, the call <tt class="docutils literal">(scale s 42)</tt> will
dispatch to the first method, while the call <tt class="docutils literal">(scale s 0)</tt> will dispatch to
the second method. Sure, we could have achieved the same by having an <tt class="docutils literal">if</tt>
condition in the beginning of <tt class="docutils literal">scale</tt>, and sometimes that's what we need. But
<tt class="docutils literal">eql</tt>-based dispatch lets us decouple such code and express our intent more
directly. An ad-hoc <tt class="docutils literal">if</tt>-based solution would bury the special case somewhere
in the method body, while the approach shown above makes it explicit and visible
that a 0 gets special treatment.</p>
<p>CLOS also has the concept of <em>method combinations</em>, which manifects in several
ways. For example, with each method we can have a variation marked with
<tt class="docutils literal">:before</tt> that can serve as a pre-processor:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Shape</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Rectangle</span><span class="w"> </span><span class="p">(</span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Ellipse</span><span class="w"> </span><span class="p">(</span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">Triangle</span><span class="w"> </span><span class="p">(</span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">())</span><span class="w"></span>

<span class="p">(</span><span class="nb">defgeneric</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">(</span><span class="nv">shape</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="ss">:documentation</span><span class="w"> </span><span class="s">&quot;Scale a shape by a factor&quot;</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">((</span><span class="nv">r</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">)</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Scale Rectangle by ~a~&amp;&quot;</span><span class="w"> </span><span class="nv">factor</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">((</span><span class="nv">e</span><span class="w"> </span><span class="nv">Ellipse</span><span class="p">)</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Scale Ellipse by ~a~&amp;&quot;</span><span class="w"> </span><span class="nv">factor</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="ss">:before</span><span class="w"> </span><span class="p">((</span><span class="nv">s</span><span class="w"> </span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;:before preprocessor on ~a scaled by ~a~&amp;&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">type-of</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"> </span><span class="nv">factor</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>Now if we create a couple of shapes and <tt class="docutils literal">scale</tt> them:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;Rectangle</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;Ellipse</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nv">scale</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="nv">scale</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>We get:</p>
<div class="highlight"><pre><span></span>:before preprocessor on RECTANGLE scaled by 20
Scale Rectangle by 20
:before preprocessor on ELLIPSE scaled by 30
Scale Ellipse by 30
</pre></div>
<p>The dispatches of <tt class="docutils literal">scale</tt> happened as we expect by now; additionally, the
<tt class="docutils literal">scale</tt> method marked with <tt class="docutils literal">:before</tt> was invoked in both cases before the
actual method.</p>
<p>CLOS has <tt class="docutils literal">:before</tt>, <tt class="docutils literal">:after</tt> and <tt class="docutils literal">:around</tt> markings; moreover, we can
specify an arbitrary number of preprocessors, postprocessors or
&quot;around&quot;-processors and even control their exact invocation order if we're so
inclined. There's a huge amount of flexibility here.</p>
<p>But there's more. As we've seen so far, the most specific dispatch method is
used it it exists; if it doesn't, the base class's dispatch is tried, and so on.
This plays well with our intuition from other OOP languages. But in CLOS, there
are powerful ways to customize this flow. What really happens when a method is
called is that a list of functions to call is built, including all the
<tt class="docutils literal">:before</tt> (and others) methods, as well as the actual <em>primary</em> methods <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>,
from most to least specific. We can actually control how these invocations
happen.</p>
<p>Here's an example:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defgeneric</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">(</span><span class="nv">shape</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="ss">:documentation</span><span class="w"> </span><span class="s">&quot;Scale a shape by a factor&quot;</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">((</span><span class="nv">s</span><span class="w"> </span><span class="nv">Shape</span><span class="p">)</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Scale Shape by ~a~&amp;&quot;</span><span class="w"> </span><span class="nv">factor</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="p">((</span><span class="nv">r</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">)</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Scale Rectangle by ~a~&amp;&quot;</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">call-next-method</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;Rectangle</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nv">scale</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Now <tt class="docutils literal">(scale r 20)</tt> prints:</p>
<div class="highlight"><pre><span></span>Scale Rectangle by 20
Scale Shape by 20
</pre></div>
<p>This is not unlike <tt class="docutils literal">super</tt> calls in Python, or base-class method calls in C++.
But in CLOS, the very nature of how multiple viable methods are combined can
be customized.</p>
<p>The default combination of primary methods is, as we've seen above, the familiar
approach of OOP languages with inheritance support: dispatch to the most
specific method and if it doesn't exist try to dispatch with the base class, and
so on. <em>Method combinations</em> is a CLOS concept that lets us do it differently.
There are a number of standard method combinations supported by CLOS, and custom
ones can be defined with <tt class="docutils literal"><span class="pre">define-method-combination</span></tt>. Let's see a standard
one for an example.</p>
<p>We'll start with a simple demonstration of the regular dispatch again:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defgeneric</span><span class="w"> </span><span class="nv">getstuff</span><span class="w"> </span><span class="p">(</span><span class="nv">shape</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">getstuff</span><span class="w"> </span><span class="p">((</span><span class="nv">s</span><span class="w"> </span><span class="nv">Shape</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">shape</span><span class="w"> </span><span class="nv">stuff</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">getstuff</span><span class="w"> </span><span class="p">((</span><span class="nv">r</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">rectangle</span><span class="w"> </span><span class="nv">stuff</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>If we call <tt class="docutils literal">(getstuff <span class="pre">(make-instance</span> 'Rectangle))</tt> we get <tt class="docutils literal">(rectangle
stuff)</tt>. If we call <tt class="docutils literal">(getstuff <span class="pre">(make-instance</span> 'Shape))</tt> we get <tt class="docutils literal">(shape
stuff)</tt>; so far so good. But now, let's use the <tt class="docutils literal">list</tt> method combination
instead:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defgeneric</span><span class="w"> </span><span class="nv">getstuff</span><span class="w"> </span><span class="p">(</span><span class="nv">shape</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="ss">:method-combination</span><span class="w"> </span><span class="nb">list</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">getstuff</span><span class="w"> </span><span class="nb">list</span><span class="w"> </span><span class="p">((</span><span class="nv">s</span><span class="w"> </span><span class="nv">Shape</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">shape</span><span class="w"> </span><span class="nv">stuff</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">getstuff</span><span class="w"> </span><span class="nb">list</span><span class="w"> </span><span class="p">((</span><span class="nv">r</span><span class="w"> </span><span class="nv">Rectangle</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">rectangle</span><span class="w"> </span><span class="nv">stuff</span><span class="p">))</span><span class="w"></span>
</pre></div>
<p>What this means is that when <tt class="docutils literal">getstuff</tt> is invoked and CLOS finds all the
viable methods, instead of calling the most specific one (and letting it call
the others with <tt class="docutils literal"><span class="pre">call-next-method</span></tt> if it desires), it calls <em>all</em> of them,
combining their results with the <tt class="docutils literal">list</tt> function.</p>
<p>Now, calling <tt class="docutils literal">(getstuff <span class="pre">(make-instance</span> 'Rectangle))</tt> produces the list
<tt class="docutils literal">((rectangle stuff) (shape stuff))</tt>. Bizarre? Maybe. Useful? <em>Maybe</em>.</p>
<p>If you're now thinking &quot;this is crazy, those Lisp people have completely jumped
the shark&quot;, I can't say I entirely disagree. If you're thinking &quot;wow, this is
immensely cool&quot; I can't say I disagree either :-) These features are
as <em>power</em> as you can get - all implemented as a library - as a set of macros
and functions in standard Common Lisp. This is the power of Lisp, friends, and
herein lies its beauty... and its biggest pitfall.</p>
<p>IMHO these features are too advanced to be useful in 99% of the cases. It's
way too easy to produce write-only code with them. Besides, even though Lisp is
a multi-paradigm language and can do OOP when OOP is due, it's not idiomatic
to write OOP code in Lisp since the other paradigms it provides are often better
suited for the task. For the few applications where OOP really shines, the
capabilities are there - but even then, I'd stick to the basics - at least
in realistic multi-person code bases, leaving the power-sauce to pet projects
and exploratory blog posts.</p>
<p>This is a good place for a quote from Paul Graham's &quot;On Lisp&quot;:</p>
<blockquote>
With the addition of CLOS, Common Lisp has become the most powerful
object-oriented language in widespread use. Ironically, it is also the
language in which object-oriented programming is least necessary.</blockquote>
</div>
<div class="section" id="clos-yay-or-nay">
<h2>CLOS - yay or nay?</h2>
<p>Let's not forget the goal of this series - explore multiple dispatch and its use
and implementation in different languages. In this aspect, Common Lisp and CLOS
truly shine, I think. Leaving all the crazy features aside, the basic form of
OOP in CLOS relies on multiple dispatch at its very core, and lets us write
object-oriented code while still remaining fairly Lisp-y.</p>
<p>It's not impossible to reproduce CLOS-like features in languages like Python,
but it takes effort. Moreover, Python and other non-Lisp languages miss the
biggest trait that makes CLOS possible - uniform syntax.</p>
<p>As for the power-features of CLOS, while I think they provide a sobering
perspective to judge the OOP capabilities of C++, Java and Python by, I
personally would be wary about using them. The Lisp ideal is <em>growing your
language</em> towards the problem you're solving; in other words, construct an
embedded DSL on top of Lisp for solving the problem. CLOS is just another
example of that, where extremely powerful - to the point of obscurity - features
let us really custom-tailor the language to a specific problem when necessary.</p>
</div>
<div class="section" id="looking-forward">
<h2>Looking forward</h2>
<p>Common Lisp is an interesting and, in many ways, inspiring language. However,
I'll admit it's not very popular or well known nowadays, and it doesn't feel
right ending the series with a language &quot;from the past&quot;. Therefore, the upcoming
part 4 in the series will focus on Clojure - a modern dialect of Lisp that's
become fairly popular in the last few years.</p>
</div>
<div class="section" id="links">
<h2>Links</h2>
<p>There are plenty of resources to learn about CLOS. Some I found most useful are:</p>
<ul class="simple">
<li>Richard Gabriel's <a class="reference external" href="http://www.dreamsongs.com/Files/ECOOP.pdf">overview of CLOS</a>.
He was instrumental in the definition of CLOS in the 1980s - highly
recommended.</li>
<li>The excellent and freely available <em>Practical Common Lisp</em> book has a couple
of nice chapters on CLOS, starting with <a class="reference external" href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">Object Reorientation: Generic
Functions</a>.</li>
<li>Paul Graham's <a class="reference external" href="http://www.paulgraham.com/onlisp.html">On Lisp</a> is another
classic Common Lisp book that's freely available online. It has an interesting
chapter about CLOS.</li>
<li>Finally, Norvig's PAIP has a chapter about CLOS - I find it very well written
(like the rest of this extraordinary book).</li>
</ul>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Julia and Perl 6 are some of the other modern languages that support
multiple dispatch natively.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>This is the place to mention that the name &quot;Lisp&quot; as I use it applies to
a big family of programming languages. There were multiple
implementations of Lisp almost from the very start, and later on the
rifts only deepened with Scheme and Common Lisp. These days we also have
Racket, Clojure and others, which add their own idiosyncracies but remain
&quot;a Lisp&quot; at their core.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>The meta-object protocol (MOP) is a fascinating subject I won't say more
about in this article. I'll just mention that it's the idea wherein
classes themselves are instances of other classes - <em>metaclasses</em>. If
this reminds you of Python, that's because Python took these ideas from
Smalltalk, just as CLOS did.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>What about symmetry? CLOS doesn't support symmetric dispatch - the order
of methods matters. As we've seen in part 2, implementing symmetry
generically is not trivial and not without certain runtime costs.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>&quot;Primary&quot; methods in CLOS are methods defined with <tt class="docutils literal">defmethod</tt> without
special tags like <tt class="docutils literal">:before</tt>, <tt class="docutils literal">:after</tt> or <tt class="docutils literal">:around</tt>. In other words,
this is what we just call &quot;methods&quot; in other languages. CLOS has the
concept of &quot;primary&quot; to distinguish them from specially tagged methods.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-3 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 17 Feb 2025 01:01:37 GMT -->
</html>