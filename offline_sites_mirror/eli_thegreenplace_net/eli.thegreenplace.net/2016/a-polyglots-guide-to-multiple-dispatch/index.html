<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:59:38 GMT -->
<head>
    <title>A polyglot's guide to multiple dispatch - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to A polyglot's guide to multiple dispatch">
                        A polyglot's guide to multiple dispatch
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> April 19, 2016 at 05:02</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/c-c.html">C & C++</a>
        ,
    <a href="../../tag/multiple-dispatch.html">Multiple dispatch</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This is the first article in a series dedicated to <em>multiple dispatch</em> - an
advanced abstraction technique available to programmers out-of-the-box in some
languages, and implementable in others. This first post in the series presents
the technique and explains the problem it intends to solve. It uses C++ as the
presentation language because C++ does not support multiple dispatch directly,
but can be used to implement it in various ways. Showing how multiple dispatch
is implemented in a language that doesn't support it natively is important, in
my opinion, as it lets us understand the issue on a deeper level.</p>
<p>Follow-up articles will keep focusing on multiple dispatch using other
programming languages : Part 2 will show how to implement multiple dispatch in
Python; Part 3 will use Common Lisp, where multiple dispatch comes built-in as
part of a large and powerful object-oriented system called CLOS; Part 4 will use
Clojure, a more modern attempt at a Lisp, where multiple dispatch is also
built-in, but works somewhat differently.</p>
<div class="section" id="polymorphism-single-dispatch-multiple-dispatch">
<h2>Polymorphism, single dispatch, multiple dispatch</h2>
<p>There are many <a class="reference external" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">kinds of polymorphism</a> in
programming. The kind we're talking about here is <em>runtime subtype-based</em>
polymorphism, where behavior is chosen dynamically based on the runtime types
of objects. More specifically, multiple dispatch is all about the runtime types
of <em>more than one object</em>.</p>
<p>The best way to understand multiple dispatch is to first think about single
dispatch. Single dispatch is what we usually refer to as &quot;runtime polymorphism&quot;
in languages like C++ and Java <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>. We have an object on which we call a
method, and the actual method being called at runtime depends on the <em>runtime</em>
type of the object. In C++ this is done with virtual functions:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ComputeArea</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ComputeArea</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle: width times height</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Ellipse</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ComputeArea</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Ellipse: width times height times pi/4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pr</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Rectangle</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pe</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Ellipse</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">ComputeArea</span><span class="p">();</span><span class="w">    </span><span class="c1">// invokes Rectangle::ComputeArea</span>
<span class="w">  </span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">ComputeArea</span><span class="p">();</span><span class="w">    </span><span class="c1">// invokes Ellipse::ComputeArea</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Even though both <tt class="docutils literal">pr</tt> and <tt class="docutils literal">pe</tt> are pointers to a <tt class="docutils literal">Shape</tt> as far as the C++
compiler is concerned, the two calls to <tt class="docutils literal">ComputeArea</tt> get dispatched to
different methods at runtime due to C++'s implementation of runtime polymorphism
via virtual functions.</p>
<p>Now, spend a few seconds thinking about the question: &quot;What is the dispatch done
<em>upon</em> in the code sample above?&quot;</p>
<p>It's fairly obvious that the entity we dispatch upon is a pointer to <tt class="docutils literal">Shape</tt>.
We have <tt class="docutils literal">pr</tt> and we call a method on it. The C++ compiler emits code for this
call such that at runtime the right function is invoked. The decision which
function to invoke is based upon examining a single object - what <tt class="docutils literal">pr</tt> points
to. Hence <em>single dispatch</em>.</p>
<p>A natural extension of this idea is <em>multiple dispatch</em>, wherein the decision
which function to call is based on the runtime types of <em>multiple</em> objects. Why
is this useful? It's not a tool programmers reach for very often, but when it
<em>is</em> appropriate, alternatives tend to be cumbersome and repetitive. A telling
sign that multiple dispatch may be in order is when you have some operation that
involves more than one class and there is no single obvious class where this
operation belongs. Think of simulating a sound when a drumstick hits a drum.
There are many kinds of drumsticks, and many kinds of drums; their combinations
produce different sounds. Say we want to write a function (or family of
functions) that determines which sound is produced. Should this function be
a method of the <tt class="docutils literal">Drum</tt> class or the <tt class="docutils literal">DrumStick</tt> class? Forcing this decision
is one of the follies of classical OOP, and multiple dispatch helps us solve it
naturally without adding a kludge into our design.</p>
<p>A simpler and more canonical example is computing intersections of shapes -
maybe for computer graphics, or for simulation, or other use cases. A generic
shape intersection computation can be complex to implement, but in many specific
cases it's easy. For example, computing intersections of rectangles with
rectangles is trivial; same for circles and ellipses; rectangles with triangles
may be a tiny bit harder, but still much simpler than artibrary polygons, and so
on <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>.</p>
<p>How do we write code to handle all these cases? All in all, we just need an
<tt class="docutils literal">intersect</tt> function that takes two shapes and computes an intersection. This
function may have a whole bunch of special cases inside for different
combinations of shapes it knows how to do easily, before it resorts to some
heavy-handed generic polygon intersection approach. Such code, however, would be
gross to develop and maintain. Wouldn't it be nice if we could have:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// implement intersection of rectangle with ellipse</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// implement intersection of rectangle with another rectangle</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// implement interesction of two generic shapes</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And then the call <tt class="docutils literal">Intersect(some_shape, other_shape)</tt> would just magically
dispatch to the right function? This capability is what's most often referred to
by <em>multiple dispatch</em> in programming language parlance <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>.</p>
</div>
<div class="section" id="a-failed-attempt-in-c">
<h2>A failed attempt in C++</h2>
<p>You may be tempted to come up with the following &quot;trivial&quot; solution in C++:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">name</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Ellipse</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Triangle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="c1">// Overloaded Intersect methods.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle x Ellipse [names r=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, e=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle x Rectangle [names r1=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, r2=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Fallback to shapes</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Shape x Shape [names s1=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, s2=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now in <tt class="docutils literal">main</tt>:</p>
<div class="highlight"><pre><span></span><span class="n">Rectangle</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">;</span><span class="w"></span>
<span class="n">Ellipse</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="n">Triangle</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Static type dispatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">Intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="n">Intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r2</span><span class="p">);</span><span class="w"></span>
<span class="n">Intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>We'll see:</p>
<div class="highlight"><pre><span></span>Static type dispatch
Rectangle x Ellipse [names r=9Rectangle, e=7Ellipse]
Rectangle x Rectangle [names r1=9Rectangle, r2=9Rectangle]
Shape x Shape [names s1=9Rectangle, s2=8Triangle]
</pre></div>
<p>Note how the intersections get dispatched to specialized functions when these
exist and to a generic catch-all <tt class="docutils literal">Shape x Shape</tt> handler when there is no
specialized function.</p>
<p>So that's it, multiple dispatch works out of the box? Not so fast... What we see
here is just C++ function overloading in action. The compiler knows the static,
compile-time types of the pointers passed to the <tt class="docutils literal">Intersect</tt> calls, so it
just emits the right call. Function overloading is great and useful, but this is
not the general problem we're trying to solve. In a realistic code-base, you
won't be passing pointers to concrete subclasses of <tt class="docutils literal">Shape</tt> around. You are
almost certainly going to be dealing with pointers to the <tt class="docutils literal">Shape</tt> base class.
Let's try to see how the code in the previous sample works with dynamic types:</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pr1</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Rectangle</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pr2</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Rectangle</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pe</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Ellipse</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Triangle</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dynamic type dispatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">Intersect</span><span class="p">(</span><span class="n">pr1</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">pe</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="n">Intersect</span><span class="p">(</span><span class="n">pr1</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">pr2</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="n">Intersect</span><span class="p">(</span><span class="n">pr1</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">pt</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
</pre></div>
<p>Prints:</p>
<div class="highlight"><pre><span></span>Dynamic type dispatch
Shape x Shape [names s1=9Rectangle, s2=7Ellipse]
Shape x Shape [names s1=9Rectangle, s2=9Rectangle]
Shape x Shape [names s1=9Rectangle, s2=8Triangle]
</pre></div>
<p>Yeah... that's not good. All calls were dispatched to the generic <tt class="docutils literal">Shape x
Shape</tt> handler, even though the runtime types of the objects are different (see
the names gathered from  <tt class="docutils literal">typeid</tt>). This is hardly surprising, because when
the compiler sees <tt class="docutils literal"><span class="pre">Intersect(pr1.get(),</span> <span class="pre">pr2.get())</span></tt>, the static types for the
two arguments are <tt class="docutils literal">Shape*</tt> and <tt class="docutils literal">Shape*</tt>. You could be forgiven for thinking
that the compiler may invoke virtual dispatch here, but virtual dispatch in C++
doesn't work this way. It only works when <em>a virtual method is called on a
pointer to a base object</em>, which is not what's happening here.</p>
</div>
<div class="section" id="multiple-dispatch-in-c-with-the-visitor-pattern">
<h2>Multiple dispatch in C++ with the visitor pattern</h2>
<p>I'll admit I'm calling this approach &quot;the visitor pattern&quot; only because this
is how it's called <a class="reference external" href="https://en.wikipedia.org/wiki/Double_dispatch#Double_dispatch_in_C">elsewhere</a> and
because I don't have a better name for it. In fact, it's probably closer to an
&quot;inverted&quot; visitor pattern, and in general the pattern name may obscure the code
more than help. So forget about the name, and just study the code.</p>
<p>The last paragraph of the previous section ended with an important observation:
virtual dispatch in C++ kicks in <em>only</em> when a virtual method is called on a
pointer to a base object. Let's leverage this idea to simulate double dispatch
on our hierarchy of shapes. The plan is to arrange <tt class="docutils literal">Intersect</tt> to hop through
virtual dispatches on both its arguments to get to the right method for their
runtime types.</p>
<p>We'll start by defining <tt class="docutils literal">Shape</tt> like this:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">name</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Dispatcher that should be called by clients to intersect different shapes.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Specific interesection methods implemented by subclasses. If subclass A</span>
<span class="w">  </span><span class="c1">// has a special way to intersect with subclass B, it should implement</span>
<span class="w">  </span><span class="c1">// InteresectWith(const B*).</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>The <tt class="docutils literal">Intersect</tt> method is what the users of the code will invoke. To be able
to make use of virtual dispatches, we are forced to turn a two-argument call
<tt class="docutils literal">Intersect(A*, B*)</tt> to a method call <tt class="docutils literal"><span class="pre">A-&gt;Intersect(B)</span></tt>. The
<tt class="docutils literal">IntersectWith</tt> methods are concrete implementations of intersections the code
will dispatch to and should be implemented by subclasses on a case-per-case
basis.</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle x Shape [names this=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, s=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle x Rectangle [names this=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, r=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Ellipse</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Ellipse x Rectangle [names this=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, r=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pr1</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Rectangle</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pr2</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Rectangle</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pe</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Ellipse</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dynamic type dispatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">pr1</span><span class="o">-&gt;</span><span class="n">Intersect</span><span class="p">(</span><span class="n">pe</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="n">pr1</span><span class="o">-&gt;</span><span class="n">Intersect</span><span class="p">(</span><span class="n">pr2</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
</pre></div>
<p>Will now print:</p>
<div class="highlight"><pre><span></span>Dynamic type dispatch
Ellipse x Rectangle [names this=7Ellipse, r=9Rectangle]
Rectangle x Rectangle [names this=9Rectangle, r=9Rectangle]
</pre></div>
<p>Success! Even though we're dealing solely in pointers to <tt class="docutils literal">Shape</tt>, the right
intersections are computed. Why does this work?</p>
<p>As I've mentioned before, the key here is use C++'s virtual function dispatch
capability, twice. Let's trace through one execution to see what's going on.
We have:</p>
<div class="highlight"><pre><span></span><span class="n">pr1</span><span class="o">-&gt;</span><span class="n">Intersect</span><span class="p">(</span><span class="n">pe</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">pr1</tt> is a pointer to <tt class="docutils literal">Shape</tt>, and <tt class="docutils literal">Intersect</tt> is a virtual method.
Therefore, the runtime type's <tt class="docutils literal">Intersect</tt> is called here, which is
<tt class="docutils literal"><span class="pre">Rectangle::Intersect</span></tt>. The argument passed into the method is another pointer
to <tt class="docutils literal">Shape</tt> which at runtime points to an <tt class="docutils literal">Ellipse</tt> (<tt class="docutils literal">pe</tt>).
<tt class="docutils literal"><span class="pre">Rectangle::Intersect</span></tt> calls <tt class="docutils literal"><span class="pre">s-&gt;IntersectWith(this)</span></tt>. The compiler sees
that <tt class="docutils literal">s</tt> is a <tt class="docutils literal">Shape*</tt>, and <tt class="docutils literal">IntersectWith</tt> is a virtual method, so this
is <em>another</em> virtual dispatch. What gets called is <tt class="docutils literal"><span class="pre">Ellipse::IntersectWith</span></tt>.
But which overload of this method is called?</p>
<p>This is an extremely crucial point in the explanation, so please focus :-) Here
is <tt class="docutils literal"><span class="pre">Rectangle::Intersect</span></tt> again:</p>
<div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">s-&gt;IntersectWith</span></tt> is called with <tt class="docutils literal">this</tt>, which the compiler knows is a
pointer to <tt class="docutils literal">Rectangle</tt>, <em>statically</em>. If you wondered why I define
<tt class="docutils literal">Intersect</tt> in each subclass rather than doing it once in <tt class="docutils literal">Shape</tt>, even
though its code is exactly the same for each subclass, this is the reason. Had I
defined it in <tt class="docutils literal">Shape</tt>, the compiler would think the type of <tt class="docutils literal">this</tt> is
<tt class="docutils literal">Shape*</tt> and would always dispatch to the <tt class="docutils literal">IntersectWith(const Shape*)</tt>
overload. Defining this method in each subclass helps the compiler leverage
overloading to call the right method.</p>
<p>What happens eventually is that the call <tt class="docutils literal"><span class="pre">pr1-&gt;Intersect(pe.get())</span></tt> gets
routed to <tt class="docutils literal"><span class="pre">Ellipse::IntersectWith(const</span> Rectangle*)</tt>, thanks to two virtual
dispatches and one use of method overloading. The end result is double dispatch!
<a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a></p>
<p>But wait a second, how did we end up with <tt class="docutils literal"><span class="pre">Ellipse::IntersectWith(Rectangle)</span></tt>?
Shouldn't <tt class="docutils literal"><span class="pre">pr1-&gt;Intersect(pe.get())</span></tt> go to
<tt class="docutils literal"><span class="pre">Rectangle::IntersectWith(Ellipse)</span></tt> instead? Well, yes and no. Yes because
this is what you'd expect from how the call is syntactically structured. No
because you almost certainly want double dispatches to be symmetric. I'll
discuss this and other related issues in the next section.</p>
</div>
<div class="section" id="symmetry-and-base-class-defaults">
<h2>Symmetry and base-class defaults</h2>
<p>When we come up with ways to do multiple dispatch, whether in C++ or in other
languages, there are two aspects of the solution we should always keep in mind:</p>
<ol class="arabic simple">
<li>Does it permit symmetry? In other words, does the order of objects dispatched
upon matters? And if it doesn't, how much extra code is needed to express
this fact.</li>
<li>Does base-class default dispatch work as expected? Suppose we create a new
subclass of <tt class="docutils literal">Rectangle</tt>, called <tt class="docutils literal">Square</tt> and we don't explicitly create
an <tt class="docutils literal">IntersectWith</tt> method for <tt class="docutils literal">Square</tt> and <tt class="docutils literal">Ellipse</tt>. Will the right
thing happen and the intersection between a <tt class="docutils literal">Rectangle</tt> and <tt class="docutils literal">Ellipse</tt> be
invoked when we ask for <tt class="docutils literal">Square x Ellipse</tt>? This is the right thing because
this is what we've come to expect from class hierarchies in object-oriented
languages.</li>
</ol>
<p>In the visitor-based solution presented above, both aspects will work, though
symmetry needs a bit of extra code. The full code sample is <a class="reference external" href="https://github.com/eliben/code-for-blog/blob/main/2016/multiple-dispatch/c++/visitor_full.h">available here</a>
(and the accompanying <tt class="docutils literal">.cpp</tt> file). It's conceptually similar to the code
shown above, but with a bit more details. In particular, it implements symmetry
between rectangle and ellipse intersections as follows:</p>
<div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="c1">// All intersections between rectangles and ellipses dispatch here.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">SymmetricIntersectRectangleEllipse</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;IntersectRectangleEllipse [names r=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, e=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">::</span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">SymmetricIntersectRectangleEllipse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">::</span><span class="n">IntersectWith</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">SymmetricIntersectRectangleEllipse</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This ensures that both <tt class="docutils literal"><span class="pre">rectangle-&gt;Intersect(ellipse)</span></tt> and
<tt class="docutils literal"><span class="pre">ellipse-&gt;Intersect(rectangle)</span></tt> end up in the same function. As far as I know
there's not way to do this automatically in the visitor approach, so a bit of
extra coding is due when symmetry between subclasses is desired.</p>
<p>Note also that this method doesn't <em>force</em> symmetry either. If some form of
dispatch is order-dependent, it's easy to express.</p>
</div>
<div class="section" id="the-problem-with-the-visitor-based-approach">
<h2>The problem with the visitor-based approach</h2>
<p>Although the visitor-based approach works, enables fairly clean client code
and is efficient (constant time - two virtual calls), there's a glaring issue
with it that's apparent with the most cursory look at the code: it's very
intrusive, and hence hard to maintain.</p>
<p>Imagine we want to add a new kind of shape - a <tt class="docutils literal">HyperFrob</tt>. Suppose also that
there's an efficient algorithm for intersecting a <tt class="docutils literal">HyperFrob</tt> with an
<tt class="docutils literal">Ellipse</tt>. Ideally, we'd only have to write code for the new functionality:</p>
<ol class="arabic simple">
<li>Define the new <tt class="docutils literal">HyperFrob</tt> class deriving from <tt class="docutils literal">Shape</tt>.</li>
<li>Implement the generic <tt class="docutils literal">HyperFrob x Shape</tt> intersection algorithm.</li>
<li>Implement the specific <tt class="docutils literal">HyperFrom x Ellipse</tt> algorithm.</li>
</ol>
<p>But in reality, we're forced to modify the definition of the base class
<tt class="docutils literal">Shape</tt> to add an overload of <tt class="docutils literal">IntersectWith</tt> for <tt class="docutils literal">HyperFrob</tt>. Moreover,
if we want intersections between <tt class="docutils literal">HyperFrob</tt> and <tt class="docutils literal">Ellipse</tt> to be symmetric
(which we almost certainly do), we'll have to modify <tt class="docutils literal">Ellipse</tt> as well to add
the same overload.</p>
<p>If we don't control the <tt class="docutils literal">Shape</tt> base class at all, we're in real trouble.
This is an instance of the <a class="reference external" href="https://en.wikipedia.org/wiki/Expression_problem">expression problem</a>. I'll have more to say
about the expression problem in a future post, but for now the Wikipedia link
will have to do. It's not an easy problem to solve in C++, and the approaches to
implement multiple dispatch should be judged by how flexible they are in this
respect, along with the other considerations.</p>
</div>
<div class="section" id="multiple-dispatch-in-c-by-brute-force">
<h2>Multiple-dispatch in C++ by brute-force</h2>
<p>The visitor-based approach is kind-of clever, leveraging single virtual dispatch
multiple times to simulate multiple dispatch. But if we go back to first
principles for a moment, it becomes clear that there's a much more obvious
solution to the problem - brute-force <tt class="docutils literal"><span class="pre">if-else</span></tt> checks. I mentioned this
possibility early in the article and called it &quot;gross to develop and maintain&quot;,
but it makes sense to at least get a feel for how it would look:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">name</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Ellipse</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Triangle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle x Rectangle [names r1=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, r2=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle x Ellipse [names r1=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, e2=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Rectangle x Shape [names r1=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, s2=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Ellipse x Ellipse [names e1=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, e2=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Handle other Ellipse x ... dispatches.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Handle Triangle s1</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>One thing is immediately noticeable: the intrusiveness issue of the
visitor-based approach is completely solved. Obliterated! <tt class="docutils literal">Intersect</tt> is now
a stand-alone function that encapsulates the dispatch. If we add new kinds of
shape, we only have to change <tt class="docutils literal">Intersect</tt>, nothing else. Perfect... or is it?</p>
<p>The other immediately noticeable fact about this code is: holy cow, how long
it is. I'm only showing a small snippet here, but the number of these <tt class="docutils literal">if</tt>
clauses grows as square of the number of subclasses. Imagine how this could
look for 20 kinds of shapes. Moreover, <tt class="docutils literal">Intersect</tt> is just one algorithm. We
may have other &quot;multi methods&quot; - this travesty would have to be repeated for
each algorithm.</p>
<p>Another, less obvious problem is that the code is somewhat brittle. Given a
non-trivial inheritance hierarchy, we have to be very careful about the order
of the <tt class="docutils literal">if</tt> clauses, lest a parent class &quot;shadows&quot; all its subclasses by
coming before them in the chain.</p>
<p>It's no wonder that one would be very reluctant to write all this code. In fact,
smart folks came up with all kinds of ways to automate such <tt class="docutils literal">if</tt> chains. If
you're thinking - &quot;hey I could just store pairs of <tt class="docutils literal">typeid</tt>s in a map and
dispatch upon that&quot; - congrats, you're in the right direction.</p>
<p>One of the most notable experts to tackle the beast is Andrei Alexandrescu, who
dedicated chapter 11 of &quot;Modern C++ Design&quot; to this problem, implementing all
kinds of automated solutions based on heavy template metaprogramming. It's a
fairly impressive piece of work, presenting multiple approaches with different
tradeoffs in terms of performance and intrusiveness. If you Google for <tt class="docutils literal">Loki</tt>
(his C++ template library) and look into the <tt class="docutils literal">MultiMethods.h</tt> header
you'll see it in all its glory - complete with type lists, traits, policies, and
template templates. This is C++, and these are the abstractions the
language provides for meta-programming - so take it or leave it :-) If you are
seriously considering using multiple dispatch in your C++ code, Loki is well
worth a look.</p>
</div>
<div class="section" id="an-attempt-for-standardization">
<h2>An attempt for standardization</h2>
<p>By far the most interesting attempt to solve this problem came from Bjarne
Stroustrup himself, who co-authored a paper with two of his students named &quot;Open
Multi-Methods for C++&quot; <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>. In this paper, the authors thoroughly review the
problem and propose a C++ language extension that will implement it efficiently
in the compiler.</p>
<p>The main idea is to let function arguments be potentially <tt class="docutils literal">virtual</tt>, meaning
that they perform dynamic dispatch and not just static overloading. So we could
implement our intersection problem as follows:</p>
<div class="highlight"><pre><span></span><span class="c1">// This is not real C++: the syntax is based on the paper</span>
<span class="c1">// &quot;Open Multi-Methods for C++&quot; and was only implemented experimentally.</span>

<span class="c1">// Generic Shape x Shape intersection.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Interesection for Rectangle x Ellipse.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Intersect</span><span class="p">(</span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rectangle</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Ellipse</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Note how similar this is to the failed attempt to leverage overloading for
multiple dispatch in the beginning of this article. All we add is the
<tt class="docutils literal">virtual</tt> keyword for arguments, and the dispatch turns from static to
dynamic.</p>
<p>Unfortunately, the proposal never made it into the standard (it was proposed
as document number N2216).</p>
</div>
<div class="section" id="conclusions-and-next-steps">
<h2>Conclusions and next steps</h2>
<p>This part in the series presented the multiple dispatch problem and demonstrated
possible solutions in C++. Each solution has its advantages and issues, and
choosing one depends on the exact needs of your project. C++ presents unique
challenges in designing such high-level abstractions, because it's comparatively
rigid and statically typed. Abstractions in C++ also tend to strive to
being as cheap as possible in terms of runtime performance and memory
consumption, which adds another dimension of complexity to the problem.</p>
<p>In the following parts of the series we'll examine how the same problem is
solved in other, more dynamic and structurally flexible programming languages.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>As opposed to &quot;compile-time&quot; polymorphism which in C++ is done with
overloaded functions and templates.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>More examples: You may have multiple event types handled by multiple
handlers - mixing and matching them boils down to the same problem. Or in
game code, you may have collision detection between different kinds of
objects; or completely different battle scenarios depending on two kinds
of units - knight vs. mage, mage vs. mage, knight vs. elf, or whatever.
These examples sound like toys, but this is because realistic examples
are often much more boring and more difficult to explain. Battles between
mages and knights is more reasonable to discuss in an introductory
article than different kinds of mathematical transforms applied to
different kinds of nodes in a dataflow graph.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>To be more precise, this is a special case - <em>double dispatch</em>, where
dispatch is done on two objects. I will mostly focus on double dispatch
in this series, even though some of the languages and techniques
presented support an arbitrary number of objects. In my experience, in
99% of the cases where multiple dispatch is useful, two objects are
sufficient.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>I'll lament again that the &quot;visitor&quot; pattern is not a great name to
apply here. An alternative way to talk about this approach is &quot;partial
application&quot;. With double dispatch, we route the call through two virtual
method calls. The first of these can be seen to create a partially
applied method that knows the dynamic type of one of its arguments, and
what remains is to grab the other. This idea also extends naturally to
multiple dispatch with more than 2 objects. As an exercise, try to figure
out how to do triple dispatch using this technique.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>The paper is available from Stroustrup's home page.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:59:38 GMT -->
</html>