<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2017/clojure-the-perfect-language-to-expand-your-brain/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:58 GMT -->
<head>
    <title>Clojure - the perfect language to expand your brain? - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Clojure - the perfect language to expand your brain?">
                        Clojure - the perfect language to expand your brain?
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> August 04, 2017 at 05:25</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/clojure.html">Clojure</a>
        ,
    <a href="../../tag/lisp.html">Lisp</a>
        ,
    <a href="../../tag/programming.html">Programming</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>I sometimes get asked for recommendations of what programming language to &quot;learn
next&quot;. It's great that folks appreciate the fact that being exposed to several
sufficiently different programming languages is an important step on the path
to programming enlightenment. But it's also true that, given limited free time,
the choice of which languages to learn is important. As the famous quote by
<a class="reference external" href="https://en.wikiquote.org/wiki/Alan_Perlis">Alan Perlis</a> says:</p>
<blockquote>
A language that doesn't affect the way you think about programming, is not
worth knowing.</blockquote>
<p>In this post I want to explain why I think Clojure is a <em>terrific</em> language for
this task. Whatever your background, it's <a class="reference external" href="http://www.paulgraham.com/icad.html">almost guaranteed</a> to affect the way you think about
programming. It's a fairly new language (from 2007) that did a good job of
collecting insights and paradigms from many existing languages and organizing
them into a coherent whole. It's chock-full of great ideas. In
other words, the <em>perfect language to expand your brain</em>.</p>
<img alt="Brain with Clojure inside" class="align-center" src="../../images/2017/brainclojure.png" />
<div class="section" id="it-s-a-lisp">
<h2>It's a Lisp!</h2>
<p>First and foremost, Clojure belongs to the Lisp family of languages, like Common
Lisp, Scheme and Racket. Lisp is one of the oldest and still most important
families of programming languages to be familiar with. Being a Lisp in this case
means several things:</p>
<ul class="simple">
<li>Clojure is a dynamic language. No matter where you stand on the static vs.
dynamic typing debate, knowing languages in both camps is important. Clojure
has a kind of optional typing, but in essence it's dynamic.</li>
<li>It promotes combinations of built-in data structures (lists, maps, vectors)
over objects and has very good reasons for doing so.</li>
<li>It promotes programming with higher-order functions. Some built-in features
like <a class="reference external" href="../reducers-transducers-and-coreasync-in-clojure/index.html">reducers and transducers</a>
rely heavily on composing higher order functions for transforming other
functions.</li>
<li>It has uniform syntax with full Lisp-style macro support! This capability
has proved to be very elusive for non-Lisp languages, and seeing some <em>real</em>
macros in action is enlightening. Clojure has a whole Go-like CSP equivalent
implemented using macros in <tt class="docutils literal">core.async</tt>.</li>
<li>It encourages REPL-based development, where functionality is built and testsed
gradually from the bottom up in an interactive terminal.</li>
</ul>
<p>Importantly, Clojure is a very <em>modern</em> Lisp, with tons of libraries for tasks
common in our day and age. It also builds upon important recent research in data
structures, such as efficient persistent vectors, that only appeared in the
1990s or later. I've been dabbling with various Lisps for almost 15 years, and
Clojure is the first Lisp I'd consider using in production.</p>
<p>I want the stress the importance of full Lisp-style macros once again. Lisp's
(and Clojure's) uniform syntax and macros force us to think about the
<a class="reference external" href="https://en.wikipedia.org/wiki/Meta-circular_evaluator">Meta-circular abstraction</a> - there's just no way
around it! We have to think of our code as data, and this has profound
implications. Back in 2005, when I was still a programming neophyte, I faced a
performance challenge for a data-decoding program I was hacking on in Perl.
Having learned some Lisp, I had the insight of <a class="reference external" href="../../2005/09/04/cool-hack-creating-custom-subroutines-on-the-fly-in-perl.html">generating and evaluating new
Perl code on the fly</a>,
which turned out to be key to the success of that program. I'm confident I could
not have come up with that solution back then without being aware of the &quot;Lisp
way&quot;.</p>
</div>
<div class="section" id="pragmatism-and-hard-won-experience">
<h2>Pragmatism and hard-won experience</h2>
<p>The designers of Clojure are extremely pragmatic, building upon decades of
industry experience. I strongly recommend watching some <a class="reference external" href="https://www.youtube.com/user/ClojureTV">YouTube videos of talks</a> by leading Clojure developers. In
particular, watch a few of the more popular talks by Rich Hickey - Clojure's
original designer. The Alan Perlis quote mentioned above may be his most
popular, but there's another I find at least as insightful:</p>
<blockquote>
Simplicity does not precede complexity, but follows it.</blockquote>
<p>There's a certain quality in programmers I believe we can all recognize. It can
only come from <em>real</em>, hard-won experience of building systems for many years
and pondering about how to build such systems more effectively next time. Rich
Hickey certainly belongs to this quality category - his talks are very
insightful, and this philosophy reigns in the design and implementation of
Clojure, as well as its (friendly and vibrant) community.</p>
</div>
<div class="section" id="sequences-and-laziness-for-powerful-in-language-data-processing">
<h2>Sequences and laziness for powerful in-language data processing</h2>
<p>Applications that process and extract useful bits of information from large
datasets all look alike in many programming languages, at least to some extent.
What we <em>really</em> want in many cases is SQL-like primitives built into our
languages, but this is often challenging (.NET's LINQ is one example of a
successful approach).</p>
<p>Clojure combines pervasive sequence protocols with persistent data structures
and laziness to make this kind of task natural, using only built-in tools.
Here's a realistic example of a function taken from the <a class="reference external" href="https://pragprog.com/book/vmclojeco/clojure-applied">Clojure Applied</a> book:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">revenue-by-department</span><span class="w"> </span><span class="p">[</span><span class="nv">carts</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">filter </span><span class="ss">:settled?</span><span class="w"> </span><span class="nv">carts</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="nb">mapcat </span><span class="ss">:line-items</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="nb">map </span><span class="nv">line-summary</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="ss">:dept</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="nf">reduce-kv</span><span class="w"> </span><span class="nv">dept-total</span><span class="p">)))</span><span class="w"></span>
</pre></div>
<p>All the functions used here are built-ins, including the <tt class="docutils literal"><span class="pre">-&gt;&gt;</span></tt> macro. This
code reads like SQL and it's efficient too. In fact, it can be made somewhat
more efficient and even seamlessly parallelized using <a class="reference external" href="../reducers-transducers-and-coreasync-in-clojure/index.html">Reducers and Transducers</a>.</p>
<p>The <a class="reference external" href="https://clojure.org/guides/spec">clojure.spec</a> library provides a degree
of type-safety for nested data structures. If you've ever written comments like
&quot;this maps strings to lists, where each list element is a map of ...&quot;,
<tt class="docutils literal">clojure.spec</tt> makes it more formal and verifiable. This is very useful when
working with data, and is another example of where Clojure's pragmatism shines;
the language is dynamic in its core, but when you need static checking - it's
there, optionally (<tt class="docutils literal">core.typed</tt> is another option for a more statically typed
flavor).</p>
</div>
<div class="section" id="the-right-approach-to-object-orientation">
<h2>The right approach to object-orientation</h2>
<p>Historically, Lisp programmers weren't the biggest proponents of OOP. This
doesn't mean that OOP has absolutely no value in Lisp-y languages, however.
Common Lisp has had CLOS for decades, and Clojure also comes with an array of
OO-like features.</p>
<p>That said, Clojure's flavor of OOP is particularly powerful and tends to
discourage bad practices. Clojure uses &quot;protocols&quot;, which are a kind of
interfaces, and encourages thinking in terms of protocols rather than in terms
of classes with inheritance hierarchies, sort of like Go. Add to that an ability
to do true <a class="reference external" href="../../2016/a-polyglots-guide-to-multiple-dispatch-part-4/index.html">multiple dispatch</a>
and you have a powerful modeling tool at your fingertips.</p>
</div>
<div class="section" id="built-in-support-for-concurrency-and-parallelism">
<h2>Built-in support for concurrency and parallelism</h2>
<p>It wouldn't be a real language of the 2000s without powerful support for
concurrency and parallelism right at the core. Clojure supports this in many
ways, which are interleaved.</p>
<p>First, it's a functional language with persistent data structures. Persistent
data structures are effectively immutable, which makes them very attractive in a
multi-threaded context. Clojure has a great implementation of persistent data
structures even for things like vectors (which are quite challenging to
implement in an efficient manner). This is a bigger deal than may originally
appear. Pure functions are often great in theory but fail in practice due to too
much copying of non-trivial data structures; Clojure's elegant usage of
persistent data structures solves this problem, making pure functions efficient
and thus much more applicable to a wide array of problems.</p>
<p>Second, Clojure doesn't lock itself in the closet of purism and does support
lower-level primitives for concurrency and mutation, where needed. Atoms are
built-in mutable state units with atomic updates. <a class="reference external" href="https://clojure.org/reference/refs">Refs and transactions</a> go further, implementing STM.</p>
<p>Third, Clojure comes with a bunch of concurrency tools built in. Promises,
futures and threads leverage the underlying JVM's threading utilities.</p>
<p>Finally, Clojure has a pretty good implementation of Go's CSP in the
<tt class="docutils literal">core.async</tt> module. It provides two useful things:</p>
<ol class="arabic simple">
<li>Channels and Go <tt class="docutils literal">select</tt>-like functionality (<tt class="docutils literal">alts!!</tt>) which makes it
easy to work with safe concurrent queues and &quot;share data by communicating&quot;.</li>
<li>go-blocks with non-blocking primitives that <a class="reference external" href="../clojure-concurrency-and-blocking-with-coreasync/index.html">make it possible</a>
to write cooperative &quot;green threads&quot; with ease.</li>
</ol>
</div>
<div class="section" id="conclusion-try-it">
<h2>Conclusion - try it</h2>
<p>Finally, it's important to mention that Clojure is far from being an academic
exercise. It's used in production by several companies, and has strong roots in
the massive Java ecosystem. Clojure's interoperability with Java is seamless -
Java code can be called from Clojure with no special provisions, and all core
Clojure entities are Java objects deep under the hood.</p>
<p>On the client side, Clojurescript has been gaining traction recently as another
language-compiled-to-JS option. It brings the elegance of Clojure to client-side
programming, among with some unique features like <tt class="docutils literal">core.async</tt> for
callback-free concurrency.</p>
<p>This doesn't mean that you should only consider Clojure as a fit for your next
project. On the contrary, I recommend learning if even if there's little chance
of using it in production any time soon. In fact, this was exactly my situation,
Clojure is a great language to expand your programming horizons; who knows,
maybe in the future you'll find it useful for some real work. If you do, great!
If you don't, learning it will positively affect how you use other programming
languages.</p>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2017/clojure-the-perfect-language-to-expand-your-brain/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:58 GMT -->
</html>