<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2017/right-and-left-folds-primitive-recursion-patterns-in-python-and-haskell/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:56 GMT -->
<head>
    <title>Right and left folds, primitive recursion patterns in Python and Haskell - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Right and left folds, primitive recursion patterns in Python and Haskell">
                        Right and left folds, primitive recursion patterns in Python and Haskell
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> August 16, 2017 at 05:48</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/python.html">Python</a>
        ,
    <a href="../../tag/haskell.html">Haskell</a>
        ,
    <a href="../../tag/programming.html">Programming</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>A &quot;fold&quot; is a fundamental primitive in defining operations on data structures;
it's particularly important in functional languages where recursion is the
default tool to express repetition. In this article I'll present how left and
right folds work and how they map to some fundamental recursive patterns.</p>
<p>The article starts with Python, which should be (or at least look) familiar to
most programmers. It then switches to Haskell for a discussion of more advanced
topics like the connection between folding and laziness, as well as monoids.</p>
<div class="section" id="extracting-a-fundamental-recursive-pattern">
<h2>Extracting a fundamental recursive pattern</h2>
<p>Let's begin by defining a couple of straightforward functions in a recursive
manner, in Python. First, computing the product of all the numbers in a given
list:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">product</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
<p>Needless to say, we wouldn't really write this function recursively in Python;
but <em>if we were</em>, this is probably how we'd write it.</p>
<p>Now another, slightly different, function. How do we double (multiply by 2)
every element in a list, recursively?</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">double</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
<p>Again, ignoring the fact that Python has much better ways to do this (list
comprehensions, for example), this is a straightforward recursive pattern that
experienced programmers can produce in their sleep.</p>
<p>In fact, there's a lot in common between these two implementation. Let's try to
find the commonalities.</p>
<img alt="Recursion pattern in the product function" class="align-center" src="../../images/2017/productrecursionpattern.png" />
<p>As this diagram shows, the functions <tt class="docutils literal">product</tt> and <tt class="docutils literal">double</tt> are really only
different in three places:</p>
<ol class="arabic simple">
<li>The <span class="purplecolor">initial value</span> produced when the input sequence is empty.</li>
<li>The <span class="orangecolor">mapping</span> applied to every sequence value processed.</li>
<li>The <span class="redcolor">combination</span> of the mapped sequence value with the rest of the
sequence.</li>
</ol>
<p>For <tt class="docutils literal">product</tt>:</p>
<ol class="arabic simple">
<li>The <span class="purplecolor">initial value</span> is 1.</li>
<li>The <span class="orangecolor">mapping</span> is identity (each sequence element just keeps its
value, without change).</li>
<li>The <span class="redcolor">combination</span> is the multiplication operator.</li>
</ol>
<p>Can you figure out the same classification for <tt class="docutils literal">double</tt>? Take a few moments to
try for yourself. Here it is:</p>
<ol class="arabic simple">
<li>The <span class="purplecolor">initial value</span> is the empty list <tt class="docutils literal">[]</tt>.</li>
<li>The <span class="orangecolor">mapping</span> takes a value, multiplies it by 2 and puts it into
a list. We could express this in Python as <tt class="docutils literal">lambda x: [x * 2]</tt>.</li>
<li>The <span class="redcolor">combination</span> is the list concatenation operator <tt class="docutils literal">+</tt>.</li>
</ol>
<p>With the diagram above and these examples, it's straightforward to write a
generalized &quot;recursive transform&quot; function that can be used to implement both
<tt class="docutils literal">product</tt> and <tt class="docutils literal">double</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">combination</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">init</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">combination</span><span class="p">(</span><span class="n">mapping</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                           <span class="n">transform</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">combination</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
</pre></div>
<p>The <tt class="docutils literal">transform</tt> function is parameterized with <tt class="docutils literal">init</tt> - the initial value,
<tt class="docutils literal">mapping</tt>- a mapping function applied to every sequence value, and
<tt class="docutils literal">combination</tt> - the combination of the mapped sequence value with the rest of
the sequence. With these given, it implements the actual recursive traversal of
the list.</p>
<p>Here's how we'd write <tt class="docutils literal">product</tt> in terms of <tt class="docutils literal">transform</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">product_with_transform</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>And <tt class="docutils literal">double</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">double_with_transform</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">transform</span><span class="p">([],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="foldr-fold-right">
<h2>foldr - fold right</h2>
<p>Generalizations like <tt class="docutils literal">transform</tt> make functional programming fun and powerful,
since they let us express complex ideas with the help of relatively few building
blocks. Let's take this idea further, by generalizing <tt class="docutils literal">transform</tt> even more.
The main insight guiding us is that the mapping and the combination don't even
have to be separate functions. A single function can play both roles.</p>
<p>In the definition of <tt class="docutils literal">transform</tt>, <tt class="docutils literal">combination</tt> is applied to:</p>
<ol class="arabic simple">
<li>The result of calling <tt class="docutils literal">mapping</tt> on the current sequence value.</li>
<li>The recursive application of the transformation to the rest of the sequence.</li>
</ol>
<p>We can encapsulate both in a function we call the &quot;reduction function&quot;. This
reduction function takes two arguments: the current sequence value (item), and
the result of applying the full transfromation to the rest of the sequence. The
driving transformation that uses this reduction function is called &quot;a right
fold&quot; (or <tt class="docutils literal">foldr</tt>):</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foldr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">init</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">foldr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
</pre></div>
<p>We'll get to why this is called &quot;fold&quot; shortly; first, let's convince ourselves
it really works. Here's <tt class="docutils literal">product</tt> implemented using <tt class="docutils literal">foldr</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">product_with_foldr</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">foldr</span><span class="p">(</span><span class="k">lambda</span> <span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">:</span> <span class="n">seqval</span> <span class="o">*</span> <span class="n">acc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>The key here is the <tt class="docutils literal">func</tt> argument. In the case of <tt class="docutils literal">product</tt>, it &quot;reduces&quot;
the current sequence value with the &quot;accumulator&quot; (the result of the overall
transformation invoked on the <em>rest</em> of the sequence) by multiplying them
together. The overall result is a product of all the elements in the list.</p>
<p>Let's trace the calls to see the recursion pattern. I'll be using the tracing
technique <a class="reference external" href="../../2012/08/22/easy-tracing-of-nested-function-calls-in-python.html">described in this post</a>.
For this purpose I hoisted the reducing function into a standalone function
called <tt class="docutils literal">product_reducer</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">product_reducer</span><span class="p">(</span><span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">seqval</span> <span class="o">*</span> <span class="n">acc</span>

<span class="k">def</span> <span class="nf">product_with_foldr</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">foldr</span><span class="p">(</span><span class="n">product_reducer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>The full code for this experiment is <a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2017/folds">available here</a>. Here's the
tracing of invoking <tt class="docutils literal"><span class="pre">product_with_foldr([2,</span> 4, 6, 8])</tt>:</p>
<div class="highlight"><pre><span></span>product_with_foldr([2, 4, 6, 8])
  foldr(&lt;function product_reducer at 0x7f3415145ae8&gt;, 1, [2, 4, 6, 8])
    foldr(&lt;function product_reducer at 0x7f3415145ae8&gt;, 1, [4, 6, 8])
      foldr(&lt;function product_reducer at 0x7f3415145ae8&gt;, 1, [6, 8])
        foldr(&lt;function product_reducer at 0x7f3415145ae8&gt;, 1, [8])
          foldr(&lt;function product_reducer at 0x7f3415145ae8&gt;, 1, [])
          --&gt; 1
          product_reducer(8, 1)
          --&gt; 8
        --&gt; 8
        product_reducer(6, 8)
        --&gt; 48
      --&gt; 48
      product_reducer(4, 48)
      --&gt; 192
    --&gt; 192
    product_reducer(2, 192)
    --&gt; 384
  --&gt; 384
</pre></div>
<p>The recursion first builds a full stack of calls for every element in the
sequence, until the base case (empty list) is reached. Then the calls to
<tt class="docutils literal">product_reducer</tt> start executing. The first reduces 8 (the last element in
the list) with 1 (the result of the base case). The second reduces this result
with 6 (the second-to-last element in the list), and so on until we reach the
final result.</p>
<p>Since <tt class="docutils literal">foldr</tt> is just a generic traversal pattern, we can say that the <em>real
work</em> here happens in the reducers. If we build a tree of invocations of
<tt class="docutils literal">product_reducer</tt>, we get:</p>
<img alt="foldr mul tree" class="align-center" src="../../images/2017/foldrmul.png" />
<p>And this is why it's called the <em>right</em> fold. It takes the rightmost element and
combines it with <tt class="docutils literal">init</tt>. Then it takes the result and combines it with the
second rightmost element, and so on until the first element is reached.</p>
</div>
<div class="section" id="more-general-operations-with-foldr">
<h2>More general operations with foldr</h2>
<p>We've seen how <tt class="docutils literal">foldr</tt> can implement all kinds of functions on lists by
encapsulating a fundamental recursive pattern. Let's see a couple more examples.
The function <tt class="docutils literal">double</tt> shown above is just a special case of the functional
<tt class="docutils literal">map</tt> primitive:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">mapf</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mapf</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="nb">map</span><span class="p">(</span><span class="n">mapf</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
<p>Instead of applying a hardcoded &quot;multiply by 2&quot; function to each element in the
sequence, <tt class="docutils literal">map</tt> applies a user-provided unary function. Here's <tt class="docutils literal">map</tt>
implemented in terms of <tt class="docutils literal">foldr</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">map_with_foldr</span><span class="p">(</span><span class="n">mapf</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">foldr</span><span class="p">(</span><span class="k">lambda</span> <span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">:</span> <span class="p">[</span><span class="n">mapf</span><span class="p">(</span><span class="n">seqval</span><span class="p">)]</span> <span class="o">+</span> <span class="n">acc</span><span class="p">,</span> <span class="p">[],</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>Another functional primitive that we can implement with <tt class="docutils literal">foldr</tt> is <tt class="docutils literal">filter</tt>.
This one is just a bit trickier because we sometimes want to &quot;skip&quot; a value
based on what the filtering predicate returns:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">maybeitem</span> <span class="o">=</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">maybeitem</span> <span class="o">+</span> <span class="nb">filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
<p>Feel free to try to rewrite it with <tt class="docutils literal">foldr</tt> as an exercise before looking at
the code below. We just follow the same pattern:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">filter_with_foldr</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">reducer</span><span class="p">(</span><span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">seqval</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">seqval</span><span class="p">]</span> <span class="o">+</span> <span class="n">acc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">acc</span>
    <span class="k">return</span> <span class="n">foldr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="p">[],</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>We can also represent less &quot;linear&quot; operations with <tt class="docutils literal">foldr</tt>. For example,
here's a function to reverse a sequence:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reverse_with_foldr</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">foldr</span><span class="p">(</span><span class="k">lambda</span> <span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">:</span> <span class="n">acc</span> <span class="o">+</span> <span class="p">[</span><span class="n">seqval</span><span class="p">],</span> <span class="p">[],</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>Note how similar it is to <tt class="docutils literal">map_with_foldr</tt>; only the order of concatenation is
flipped.</p>
</div>
<div class="section" id="left-associative-operations-and-foldl">
<h2>Left-associative operations and foldl</h2>
<p>Let's probe at some of the apparent limitations of <tt class="docutils literal">foldr</tt>. We've seen how it
can be used to easily compute the product of numbers in a sequence. What about a
ratio? For the list <tt class="docutils literal">[3, 2, 2]</tt> the ratio is &quot;3 divided by 2, divided by 2&quot;,
or 0.75 <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>.</p>
<p>If we take <tt class="docutils literal">product_with_foldr</tt> from above and replace <tt class="docutils literal">*</tt> by <tt class="docutils literal">/</tt>, we get:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; foldr(lambda seqval, acc: seqval / acc, 1, [3, 2, 2])
3.0
</pre></div>
<p>What gives? The problem here is the associativity of the operator <tt class="docutils literal">/</tt>. Take
another look at the call tree diagram shown above. It's obvious this diagram
represents a right-associative evaluation. In other words, what our attempt at a
ratio did is compute <tt class="docutils literal">3 / (2 / 2)</tt>, which is indeed 3.0; instead, what we'd
like is <tt class="docutils literal">(3 / 2) / 2</tt>. But <tt class="docutils literal">foldr</tt> is fundamentally folding the expression
<em>from the right</em>. This works well for associative operations like <tt class="docutils literal">+</tt> or <tt class="docutils literal">*</tt>
(operations that don't care about the order in which they are applied to a
sequence), and also for right-associative operations like exponentiation, but it
doesn't work that well for left-associative operations like <tt class="docutils literal">/</tt> or <tt class="docutils literal">-</tt>.</p>
<p>This is where the <em>left</em> fold comes in. It does precisely what you'd expect -
folds a sequence from the left, rather than from the right. I'm going to leave
the division operation for later <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a> and use another example of a
left-associative operation: converting a sequence of digits into a number. For
example <tt class="docutils literal">[2, 3]</tt> represents 23, <tt class="docutils literal">[3, 4, 5, 6]</tt> represents 3456, etc. (a
related problem which is more common in introductory programming is converting a
string that contains a number into an integer).</p>
<p>The basic reducing operation we'll use here is: <tt class="docutils literal">acc * 10 + sequence value</tt>.
To get 3456 from <tt class="docutils literal">[3, 4, 5, 6]</tt> we'll compute:</p>
<div class="highlight"><pre><span></span>(((((3 * 10) + 4) * 10) + 5) * 10) + 6
</pre></div>
<p>Note how this operation is left-associative. Reorganizing the parens to a
rightmost-first evaluation would give us a completely different result.</p>
<p>Without further ado, here's the left fold:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foldl</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">init</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">foldl</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
<p>Note that the order of calls between the recursive call to itself and the call
to <tt class="docutils literal">func</tt> is reversed vs. <tt class="docutils literal">foldr</tt>. This is also why it's customary to put
<tt class="docutils literal">acc</tt> first and <tt class="docutils literal">seqval</tt> second in the reducing functions passed to
<tt class="docutils literal">foldl</tt>.</p>
<p>If we perform multiplication with <tt class="docutils literal">foldl</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">product_with_foldl</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">foldl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">acc</span><span class="p">,</span> <span class="n">seqval</span><span class="p">:</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">seqval</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
<p>We'll get this trace:</p>
<div class="highlight"><pre><span></span>product_with_foldl([2, 4, 6, 8])
  foldl(&lt;function product_reducer at 0x7f2924cbdc80&gt;, 1, [2, 4, 6, 8])
    product_reducer(1, 2)
    --&gt; 2
    foldl(&lt;function product_reducer at 0x7f2924cbdc80&gt;, 2, [4, 6, 8])
      product_reducer(2, 4)
      --&gt; 8
      foldl(&lt;function product_reducer at 0x7f2924cbdc80&gt;, 8, [6, 8])
        product_reducer(8, 6)
        --&gt; 48
        foldl(&lt;function product_reducer at 0x7f2924cbdc80&gt;, 48, [8])
          product_reducer(48, 8)
          --&gt; 384
          foldl(&lt;function product_reducer at 0x7f2924cbdc80&gt;, 384, [])
          --&gt; 384
        --&gt; 384
      --&gt; 384
    --&gt; 384
  --&gt; 384
</pre></div>
<p>Contrary to the right fold, the reduction function here is called immediately
for each recursive step, rather than waiting for the recursion to reach the end
of the sequence first. Let's draw the call graph to make the
folding-from-the-left obvious:</p>
<img alt="foldl mul tree" class="align-center" src="../../images/2017/foldlmul.png" />
<p>Now, to implement the digits-to-a-number function task described earlier, we'll
write:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">digits2num_with_foldl</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">foldl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">acc</span><span class="p">,</span> <span class="n">seqval</span><span class="p">:</span> <span class="n">acc</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">seqval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="stepping-it-up-a-notch-function-composition-with-foldr">
<h2>Stepping it up a notch - function composition with foldr</h2>
<p>Since we're looking at functional programming primitives, it's only natural to
consider how to put higher order functions to more use in combination with
folds. Let's see how to express function composition; the input is a sequence of
unary functions: <tt class="docutils literal">[f, g, h]</tt> and the output is a single function that
implements <tt class="docutils literal"><span class="pre">f(g(h(...)))</span></tt>. Note this operation is right-associative, so it's a
natural candidate for <tt class="docutils literal">foldr</tt>:</p>
<div class="highlight"><pre><span></span><span class="n">identity</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">fcompose_with_foldr</span><span class="p">(</span><span class="n">fseq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">foldr</span><span class="p">(</span><span class="k">lambda</span> <span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">seqval</span><span class="p">(</span><span class="n">acc</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">identity</span><span class="p">,</span> <span class="n">fseq</span><span class="p">)</span>
</pre></div>
<p>In this case <tt class="docutils literal">seqval</tt> and <tt class="docutils literal">acc</tt> are both functions. Each step in the fold
consumes a new function from the sequence and composes it on top of the
accumulator (which is the function composed so far). The initial value for this
fold has to be the identity for the composition operation, which just happens to
be the identity function.</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; f = fcompose_with_foldr([lambda x: x+1, lambda x: x*7, lambda x: -x])
&gt;&gt;&gt; f(8)
-55
</pre></div>
<p>Let's take this trick one step farther. Recall how I said <tt class="docutils literal">foldr</tt> is limited
to right-associative operations? Well, I lied a little. While it's true that the
fundamental recursive pattern expressed by <tt class="docutils literal">foldr</tt> is right-associative, we
can use the function composition trick to evaluate some operation on a sequence
in a left-associative way. Here's the digits-to-a-number function with
<tt class="docutils literal">foldr</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">digits2num_with_foldr</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="n">composed</span> <span class="o">=</span> <span class="n">foldr</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">acc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">seqval</span><span class="p">),</span>
                <span class="n">identity</span><span class="p">,</span>
                <span class="n">seq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">composed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
<p>To understand what's going on, manually trace the invocation of this
function on some simple sequence like <tt class="docutils literal">[1, 2, 3]</tt>. The key to this approach
is to recall that <tt class="docutils literal">foldr</tt> gets to the end of the list before it actually
starts applying the function it folds. The following is a careful trace of what
happens, with the folded function replaced by <tt class="docutils literal">g</tt> for clarify.</p>
<div class="highlight"><pre><span></span>digits2num_with_foldl([1, 2, 3])
-&gt; foldr(g, identity, [1, 2, 3])
-&gt; g(1, foldr(g, identity, [2, 3]))
-&gt; g(1, g(2, foldr(g, identity, [3])))
-&gt; g(1, g(2, g(3, foldr(g, identity, []))))
-&gt; g(1, g(2, g(3, identity)))
-&gt; g(1, g(2, lambda n: identity(n * 10 + 3)))
</pre></div>
<p>Now things become a bit trickier to track because of the different anonymous
functions and their bound variables. It helps to give these function names.</p>
<div class="highlight"><pre><span></span>&lt;f1 = lambda n: identity(n * 10 + 3)&gt;
-&gt; g(1, g(2, f1))
-&gt; g(1, lambda n: f1(n * 10 + 2))
&lt;f2 = lambda n: f1(n * 10 + 2)&gt;
-&gt; g(1, f2)
-&gt; lambda n: f2(n * 10 + 1)
</pre></div>
<p>Finally, we invoke this returned function on 0:</p>
<div class="highlight"><pre><span></span>f2(0 * 10 + 1)
-&gt; f1(1 * 10 + 2)
-&gt; identity(12 * 10 + 3)
-&gt; 123
</pre></div>
<p>In other words, the actual computation passed to that final <tt class="docutils literal">identity</tt> is:</p>
<div class="highlight"><pre><span></span>((1 * 10) + 2) * 10 + 3
</pre></div>
<p>Which is the left-associative application of the folded function.</p>
</div>
<div class="section" id="expressing-foldl-with-foldr">
<h2>Expressing foldl with foldr</h2>
<p>After the last example, it's not very surprising that we can take this approach
to its logical conclusion and express the general <tt class="docutils literal">foldl</tt> by using <tt class="docutils literal">foldr</tt>.
It's just a generalization of <tt class="docutils literal">digits2num_with_foldr</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foldl_with_foldr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="n">composed</span> <span class="o">=</span> <span class="n">foldr</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">seqval</span><span class="p">,</span> <span class="n">acc</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">acc</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">seqval</span><span class="p">)),</span>
                <span class="n">identity</span><span class="p">,</span>
                <span class="n">seq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">composed</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
</pre></div>
<p>In fact, the pattern expressed by <tt class="docutils literal">foldr</tt> is very close to what is called
<em>primitive recursion</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Î-recursive_function">by Stephen Kleene</a> in his 1952 book
<em>Introduction to Metamathematics</em>. In other words, <tt class="docutils literal">foldr</tt> can be used to
express a wide range of recursive patterns. I won't get into the theory here,
but Graham Hutton's article <em>A tutorial on the universality and expressiveness
of fold</em> is a good read.</p>
</div>
<div class="section" id="foldr-and-foldl-in-haskell">
<h2>foldr and foldl in Haskell</h2>
<p>Now I'll switch gears a bit and talk about Haskell. Writing transformations with
folds is not really Pythonic, but it's very much the default Haskell style. In
Haskell recursion is <em>the way</em> to iterate.</p>
<p>Haskell is a lazily evaluated language, which makes the discussion of folds a
bit more interesting. While this behavior isn't hard to emulate in Python, the
Haskell code dealing with folds on lazy sequences is pleasantly concise and
clear.</p>
<p>Let's starts by implementing <tt class="docutils literal">product</tt> and <tt class="docutils literal">double</tt> - the functions this
article started with. Here's the function computing a product of a sequence of
numbers:</p>
<div class="highlight"><pre><span></span><span class="nf">myproduct</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">myproduct</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">myproduct</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
<p>And a sample invocation:</p>
<div class="highlight"><pre><span></span>*Main&gt; myproduct [2,4,6,8]
384
</pre></div>
<p>The function doubling every element in a sequence:</p>
<div class="highlight"><pre><span></span><span class="nf">mydouble</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">mydouble</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">mydouble</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
<p>Sample invocation:</p>
<div class="highlight"><pre><span></span>*Main&gt; mydouble [2,4,6,8]
[4,8,12,16]
</pre></div>
<p>IMHO, the Haskell variants of these functions make it very obvious that a
right-fold recursive pattern is in play. The pattern matching idiom of
<tt class="docutils literal">(x:xs)</tt> on sequences splits the &quot;head&quot; from the &quot;tail&quot; of the sequence, and
the combining function is applied between the head and the result of the
transformation on the tail. Here's <tt class="docutils literal">foldr</tt> in Haskell, with a type declaration
that should help clarify what goes where:</p>
<div class="highlight"><pre><span></span><span class="nf">myfoldr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">myfoldr</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="nf">myfoldr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">myfoldr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>If you're not familiar with Haskell this code may look foreign, but it's really
a one-to-one mapping of the Python code for <tt class="docutils literal">foldr</tt>, using some Haskell idioms
like pattern matching.</p>
<p>These are the product and doubling functions implemented with <tt class="docutils literal">myfoldr</tt>,
using currying to avoid specifying the last parameter:</p>
<div class="highlight"><pre><span></span><span class="nf">myproductWithFoldr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myfoldr</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="nf">mydoubleWithFoldr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myfoldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
<p>Haskell also has a built-in <tt class="docutils literal">foldl</tt> which performs the left fold. Here's how
we could write our own:</p>
<div class="highlight"><pre><span></span><span class="nf">myfoldl</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">myfoldl</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="nf">myfoldl</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myfoldl</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
<p>And this is how we'd write the left-associative function to convert a sequence
of digits into a number using this left fold:</p>
<div class="highlight"><pre><span></span><span class="nf">digitsToNumWithFoldl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myfoldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="folds-laziness-and-infinite-lists">
<h2>Folds, laziness and infinite lists</h2>
<p>Haskell evaluates all expressions <em>lazily</em> by default, which can be either a
blessing or a curse for folds, depending on what we need to do exactly. Let's
start by looking at the cool applications of laziness with <tt class="docutils literal">foldr</tt>.</p>
<p>Given infinite lists (yes, Haskell easily supports infinite lists because of
laziness), it's fairly easy to run short-circuiting algorithms on them with
<tt class="docutils literal">foldr</tt>. By short-circuiting I mean an algorithm that terminates the recursion
at some point throughout the list, based on a condition.</p>
<p>As a silly but educational example, consider doubling every element in a
sequence but only until a 5 is encountered, at which point we stop:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="w"></span>
</pre></div>
<p>Now let's try the same on an infinite list:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="w"></span>
</pre></div>
<p>It terminates and returns the right answer! Even though our earlier stack trace
of folding makes it appear like we iterate all the way to the end of the input
list, this is not the case for our folding function. Since the folding function
doesn't use <tt class="docutils literal">acc</tt> when <tt class="docutils literal">x == 5</tt>, Haskell won't evaluate the recursive fold
further <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>.</p>
<p>The same trick will <em>not</em> work with <tt class="docutils literal">foldl</tt>, since <tt class="docutils literal">foldl</tt> is not lazy in
its second argument. Because of this, Haskell programmers are usually pointed to
<tt class="docutils literal">foldl'</tt>, the <em>eager</em> version of <tt class="docutils literal">foldl</tt>, as the better option. <tt class="docutils literal">foldl'</tt>
evaluates its arguments eagerly, meaning that:</p>
<ol class="arabic simple">
<li>It won't support infinite sequences (but neither does <tt class="docutils literal">foldl</tt>!)</li>
<li>It's significantly more efficient than <tt class="docutils literal">foldl</tt> because it can be easily
turned into a loop (note that the recursion in <tt class="docutils literal">foldl</tt> is a tail call, and
the eager <tt class="docutils literal">foldl'</tt> doesn't have to build a thunk of increasing size due to
laziness in the first argument).</li>
</ol>
<p>There is also an eager version of the right fold - <tt class="docutils literal">foldr'</tt>, which can be more
efficient than <tt class="docutils literal">foldr</tt> in some cases; it's not in <tt class="docutils literal">Prelude</tt> but can be
imported from <tt class="docutils literal">Data.Foldable</tt> <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>.</p>
</div>
<div class="section" id="folding-vs-reducing">
<h2>Folding vs. reducing</h2>
<p>Our earlier discussion of folds may have reminded you of the <tt class="docutils literal">reduce</tt> built-in
function, which seems to be doing something similar. In fact, Python's
<tt class="docutils literal">reduce</tt> implements the left fold where the first element in the sequence is
used as the zero value. One nice property of <tt class="docutils literal">reduce</tt> is that it doesn't
require an explicit zero value (though it does support it via an optional
parameter - this can be useful when the sequence is empty, for example).</p>
<p>Haskell has its own variations of folds that implement <tt class="docutils literal">reduce</tt> - they have
the digit 1 as suffix: <tt class="docutils literal">foldl1</tt> is the more direct equivalent of Python's
<tt class="docutils literal">reduce</tt> - it doesn't need an initializer and folds the sequence from the
left. <tt class="docutils literal">foldr1</tt> is similar, but folds from the right. Both have eager variants:
<tt class="docutils literal">foldl1'</tt> and <tt class="docutils literal">foldr1'</tt>.</p>
<p>I promised to revisit calculating the ratio of a sequence; here's a way, in
Haskell:</p>
<div class="highlight"><pre><span></span><span class="nf">myratioWithFoldl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl1</span><span class="w"> </span><span class="p">(</span><span class="o">/</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>The problem with using a regular <tt class="docutils literal">foldl</tt> is that there's no natural identity
value to use on the leftmost side of a ratio (on the rightmost side 1 works, but
the associativity is wrong). This is not an issue for <tt class="docutils literal">foldl1</tt>, which starts
the recursion with the first item in the sequence, rather than an explicit
initial value.</p>
<div class="highlight"><pre><span></span>*Main&gt; myratioWithFoldl [3,2,2]
0.75
</pre></div>
<p>Note that <tt class="docutils literal">foldl1</tt> will throw an exception if the given sequence is empty,
since it needs at least one item in there.</p>
</div>
<div class="section" id="folding-arbitrary-data-structures">
<h2>Folding arbitrary data structures</h2>
<p>The built-in folds in Haskell are defined on lists. However, lists are not the
only data structure we should be able to fold. Why can't we fold maps (say,
summing up all the keys), or even custom data structures? What is the minimum
amount of abstraction we can extract to enable folding?</p>
<p>Let's start by defining a simple binary tree data structure:</p>
<div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Leaf</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span><span class="w"></span>

<span class="c1">-- A sample tree with a few nodes</span><span class="w"></span>
<span class="nf">t1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">(</span><span class="kt">Leaf</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Leaf</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="kt">Leaf</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Suppose we want to fold the tree with <tt class="docutils literal">(+)</tt>, summing up all the values
contained within it. How do we go about it? <tt class="docutils literal">foldr</tt> or <tt class="docutils literal">foldl</tt> won't cut it
here - they expect <tt class="docutils literal">[a]</tt>, not <tt class="docutils literal">Tree a</tt>. We could try to write our own foldr:</p>
<div class="highlight"><pre><span></span><span class="nf">foldTree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">foldTree</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="nf">foldTree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">(</span><span class="kt">Leaf</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">??</span><span class="w"></span>
<span class="nf">foldTree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">??</span><span class="w"></span>
</pre></div>
<p>There's a problem, however. Since we want to support an arbitrary folding
result, we're not quite sure what to substitute for the <tt class="docutils literal"><span class="pre">??</span></tt>s in the code
above. In <tt class="docutils literal">foldr</tt>, the folding function takes the accumulator and the next
value in the sequence, but for trees it's not so simple. We may encounter a
single leaf, and we may encounter several values to summarize; for the latter
we have to invoke <tt class="docutils literal">f</tt> on <tt class="docutils literal">x</tt> as well as on the result of folding <tt class="docutils literal">left</tt>
and <tt class="docutils literal">right</tt>. So it's not clear what the type of <tt class="docutils literal">f</tt> should be - <tt class="docutils literal">(b <span class="pre">-&gt;</span> a <span class="pre">-&gt;</span>
a)</tt> doesn't appear to work <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>.</p>
<p>A useful Haskell abstraction that can help us solve this problem is <tt class="docutils literal">Monoid</tt>.
A monoid is any data type that has an identity element (called <tt class="docutils literal">mempty</tt>) and
an associative binary operation called <tt class="docutils literal">mappend</tt>. Monoids are, therefore,
amenable to &quot;summarization&quot;.</p>
<div class="highlight"><pre><span></span><span class="nf">foldTree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monoid</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">foldTree</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mempty</span><span class="w"></span>
<span class="nf">foldTree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Leaf</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">foldTree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">foldTree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">foldTree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>We no longer need to pass in an explicit zero element: since <tt class="docutils literal">a</tt> is a
<tt class="docutils literal">Monoid</tt>, we have its <tt class="docutils literal">mempty</tt>. Also, we can now apply a single <tt class="docutils literal">(b <span class="pre">-&gt;</span> a)</tt>
function onto every element in the tree, and combine the results together into a
summary using <tt class="docutils literal">a</tt>'s <tt class="docutils literal">mappend</tt> (<tt class="docutils literal">&lt;&gt;</tt> is the infix synonym of <tt class="docutils literal">mappend</tt>).</p>
<p>The challenge of using <tt class="docutils literal">foldTree</tt> is that we now actually need to use a unary
function that returns a <tt class="docutils literal">Monoid</tt>. Luckily, Haskell has some useful built-in
monoids. For example, <tt class="docutils literal">Data.Monoid.Sum</tt> wraps numbers into monoids under
addition. We can find the sum of all elements in our tree <tt class="docutils literal">t1</tt> using
<tt class="docutils literal">foldTree</tt> and <tt class="docutils literal">Sum</tt>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">foldrTree</span><span class="w"> </span><span class="kt">Sum</span><span class="w"> </span><span class="n">t1</span><span class="w"></span>
<span class="kt">Sum</span><span class="w"> </span><span class="p">{</span><span class="n">getSum</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">47</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Similarly, <tt class="docutils literal">Data.Monoid.Product</tt> wraps numbers into monoids under
multiplication:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">foldrTree</span><span class="w"> </span><span class="kt">Product</span><span class="w"> </span><span class="n">t1</span><span class="w"></span>
<span class="kt">Product</span><span class="w"> </span><span class="p">{</span><span class="n">getProduct</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">33600</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Haskell provides a built-in typeclass named <tt class="docutils literal">Data.Foldable</tt> that only requires
us to implement a similar mapping function, and then takes care of defining many
folding methods. Here's the instance for our tree:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Foldable</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">foldMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mempty</span><span class="w"></span>
<span class="w">  </span><span class="n">foldMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Leaf</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="n">foldMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">foldMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
</pre></div>
<p>And we'll automatically have <tt class="docutils literal">foldr</tt>, <tt class="docutils literal">foldl</tt> and other folding methods
available on <tt class="docutils literal">Tree</tt> objects:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Foldable</span><span class="o">.</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">t1</span><span class="w"></span>
<span class="mi">47</span><span class="w"></span>
</pre></div>
<p>Note that we can pass a regular binary <tt class="docutils literal">(+)</tt> here; <tt class="docutils literal">Data.Foldable</tt> employs
a bit of magic to turn this into a properly monadic operation. We get many more
useful methods on trees just from implementing <tt class="docutils literal">foldMap</tt>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Foldable</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="n">t1</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Foldable</span><span class="o">.</span><span class="n">elem</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="n">t1</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
</pre></div>
<p>It's possible that for some special data structure these methods can be
implemented more efficiently than by inference from <tt class="docutils literal">foldMap</tt>, but nothing is
stopping us from redefining specific methods in our <tt class="docutils literal">Foldable</tt> instance. It's
pretty cool, however, to see just how much functionality can be derived from
having a single mapping method (and the <tt class="docutils literal">Monoid</tt> guarantees) defined. See the
documentation of <tt class="docutils literal">Data.Foldable</tt> for more details.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Note that I'm using Python 3 for all the code in this article; hence,
<a class="reference external" href="https://www.python.org/dev/peps/pep-0238/">Python 3's division semantics</a>
apply.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>Division has a problem with not having a natural &quot;zero&quot; element;
therefore, it's more suitable for <tt class="docutils literal">foldl1</tt> and <tt class="docutils literal">reduce</tt>, which are
described later on.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>I'm prefixing most functions here with <tt class="docutils literal">my</tt> since they have Haskell
standard library builtin equivalents; while it's possible to avoid the
name clashes with some <tt class="docutils literal">import</tt> tricks, custom names are the
least-effort approach, also for copy-pasting these code snippets into a
REPL.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>I realize this is a very rudimentary explanation of Haskell laziness, but
going deeper is really out of scope of this article. There are plenty of
resources online to read about lazy vs. eager evaluation, if you're
interested.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>We could try to apply <tt class="docutils literal">f</tt> between the leaf value and <tt class="docutils literal">z</tt>, but it's
not clear in what order this should be done (what if <tt class="docutils literal">f</tt> is sensitive
to order?). Similarly for a <tt class="docutils literal">Node</tt>, since there are no guarantees on
the associativity of <tt class="docutils literal">f</tt>, it's hard to predict what is the right way
of applying it multiple times.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2017/right-and-left-folds-primitive-recursion-patterns-in-python-and-haskell/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:58:56 GMT -->
</html>