<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2020/embedding-in-go-part-3-interfaces-in-structs/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:55:04 GMT -->
<head>
    <title>Embedding in Go: Part 3 - interfaces in structs - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Embedding in Go: Part 3 - interfaces in structs">
                        Embedding in Go: Part 3 - interfaces in structs
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> August 19, 2020 at 19:54</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/go.html">Go</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This post is part 3 in a series describing the kinds of embedding Go supports:</p>
<ol class="arabic simple">
<li>Structs in structs (<a class="reference external" href="../embedding-in-go-part-1-structs-in-structs/index.html">part 1</a>)</li>
<li>Interfaces in interfaces (<a class="reference external" href="../embedding-in-go-part-2-interfaces-in-interfaces/index.html">part 2</a>)</li>
<li>Interfaces in structs (this part)</li>
</ol>
<div class="section" id="embedding-interfaces-in-structs">
<h2>Embedding interfaces in structs</h2>
<p>At first sight, this is the most confusing embedding supported in Go. It's not
immediately clear what embedding an interface in a struct means. In this post
we'll work through this technique slowly and present several real-world
examples. At the end, you'll see that the underlying mechanics are pretty simple
and the technique is useful in various scenarios.</p>
<p>Let's start with a simple synthetic example:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Fooer</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Foo</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Container</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Fooer</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">Fooer</tt> is an interface and <tt class="docutils literal">Container</tt> embeds it. Recall from <a class="reference external" href="../embedding-in-go-part-1-structs-in-structs/index.html">part 1</a>
that an embedding in a struct <em>promotes</em> the embedded struct's methods to the
embedding struct. It works similarly for embedded interfaces; we can visualize
it as if <tt class="docutils literal">Container</tt> had a forwarding method like this:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cont</span><span class="w"> </span><span class="nx">Container</span><span class="p">)</span><span class="w"> </span><span class="nx">Foo</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">cont</span><span class="p">.</span><span class="nx">Fooer</span><span class="p">.</span><span class="nx">Foo</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>But what does <tt class="docutils literal">cont.Fooer</tt> refer to? Well, it's just any object that
implements the <tt class="docutils literal">Fooer</tt> interface. Where does this object come from? It is
assigned to the <tt class="docutils literal">Fooer</tt> field of <tt class="docutils literal">Container</tt> when the container is
initialized, or later. Here's an example:</p>
<div class="highlight"><pre><span></span><span class="c1">// sink takes a value implementing the Fooer interface.</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="nx">sink</span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="nx">Fooer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;sink:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">Foo</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// TheRealFoo is a type that implements the Fooer interface.</span><span class="w"></span>
<span class="kd">type</span><span class="w"> </span><span class="nx">TheRealFoo</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">trf</span><span class="w"> </span><span class="nx">TheRealFoo</span><span class="p">)</span><span class="w"> </span><span class="nx">Foo</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;TheRealFoo Foo&quot;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now we can do:</p>
<div class="highlight"><pre><span></span><span class="nx">co</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Container</span><span class="p">{</span><span class="nx">Fooer</span><span class="p">:</span><span class="w"> </span><span class="nx">TheRealFoo</span><span class="p">{}}</span><span class="w"></span>
<span class="nx">sink</span><span class="p">(</span><span class="nx">co</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>This will print <tt class="docutils literal">sink: TheRealFoo Foo</tt>.</p>
<p>What's going on? Notice how the <tt class="docutils literal">Container</tt> is initialized; the embedded
<tt class="docutils literal">Fooer</tt> field gets assigned a value of type <tt class="docutils literal">TheRealFoo</tt>. We can only assign
values that implement the <tt class="docutils literal">Fooer</tt> interface to this field - any other value
will be rejected by the compiler. Since the <tt class="docutils literal">Fooer</tt> interface is embedded in
<tt class="docutils literal">Container</tt>, its methods are promoted to be <tt class="docutils literal">Container</tt>'s methods, which
makes <tt class="docutils literal">Container</tt> implement the <tt class="docutils literal">Fooer</tt> interface as well! This is why we
can pass a <tt class="docutils literal">Container</tt> to <tt class="docutils literal">sink</tt> at all; without the embedding, <tt class="docutils literal">sink(co)</tt>
would not compile because <tt class="docutils literal">co</tt> wouldn't implement <tt class="docutils literal">Fooer</tt>.</p>
<p>You may wonder what happens if the embedded <tt class="docutils literal">Fooer</tt> field of <tt class="docutils literal">Container</tt> is
not initialized; this is a great question! What happens is pretty much what
you'd expect - the field retains its default value, which in the case of an
interface is <tt class="docutils literal">nil</tt>. So this code:</p>
<div class="highlight"><pre><span></span><span class="nx">co</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Container</span><span class="p">{}</span><span class="w"></span>
<span class="nx">sink</span><span class="p">(</span><span class="nx">co</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Would result in a <tt class="docutils literal">runtime error: invalid memory address or nil pointer
dereference</tt>.</p>
<p>This pretty much covers <em>how</em> embedding interfaces in structs works. What
remains is the even more important question of - why would we need this? The
following examples will present several use cases from the standard library,
but I want to begin with one coming from elsewhere and demonstrating what is -
in my opinion - the most important use of this technique in client code.</p>
</div>
<div class="section" id="example-interface-wrapper">
<h2>Example: interface wrapper</h2>
<p>This example is courtesy of GitHub user <a class="reference external" href="https://github.com/valyala">valyala</a>,
taken from <a class="reference external" href="https://github.com/golang/go/issues/22013#issuecomment-331886875">this comment</a>.</p>
<p>Suppose we want to have a socket connection with some additional functionality,
like counting the total number of bytes read from it. We can define the following
struct:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">StatsConn</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="w"></span>

<span class="w">  </span><span class="nx">BytesRead</span><span class="w"> </span><span class="kt">uint64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">StatsConn</tt> now implements the <tt class="docutils literal">net.Conn</tt> interface and can be used anywhere
a <tt class="docutils literal">net.Conn</tt> is expected. When a <tt class="docutils literal">StatsConn</tt> is initialized with a proper
value implementing <tt class="docutils literal">net.Conn</tt> for the embedded field, it &quot;inherits&quot; all the
methods of that value; the key insight is, though, that we can intercept any
method we wish, leaving all the others intact. For our purpose in this example,
we'd like to intercept the <tt class="docutils literal">Read</tt> method and record the number of bytes
read:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">sc</span><span class="w"> </span><span class="o">*</span><span class="nx">StatsConn</span><span class="p">)</span><span class="w"> </span><span class="nx">Read</span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sc</span><span class="p">.</span><span class="nx">Conn</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">sc</span><span class="p">.</span><span class="nx">BytesRead</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>To users of <tt class="docutils literal">StatsConn</tt>, this change is transparent; we can still call
<tt class="docutils literal">Read</tt> on it and it will do what we expect (due to delegating to
<tt class="docutils literal">sc.Conn.Read</tt>), but it will also do additional bookkeeping.</p>
<p>As shown in the previous section, it's critical to initialize a <tt class="docutils literal">StatsConn</tt>
properly; for example:</p>
<div class="highlight"><pre><span></span><span class="nx">conn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">u</span><span class="p">.</span><span class="nx">Host</span><span class="o">+</span><span class="s">&quot;:80&quot;</span><span class="p">)</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nx">sconn</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">StatsConn</span><span class="p">{</span><span class="nx">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>Here <tt class="docutils literal">net.Dial</tt> returns a value that implements <tt class="docutils literal">net.Conn</tt>, so we can use
that to initialize the embedded field of <tt class="docutils literal">StatsConn</tt>.</p>
<p>We can now pass our <tt class="docutils literal">sconn</tt> to any function that expects a <tt class="docutils literal">net.Conn</tt>
argument, e.g:</p>
<div class="highlight"><pre><span></span><span class="nx">resp</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">sconn</span><span class="p">)</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And later we can access its <tt class="docutils literal">BytesRead</tt> field to get the total.</p>
<p>This is an example of <em>wrapping</em> an interface. We created a new type that
implements an existing interface, but reused an embedded value to implement most
of the functionality. We could implement this without embedding by having an
explicit <tt class="docutils literal">conn</tt> field like this:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">StatsConn</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">conn</span><span class="w"> </span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="w"></span>

<span class="w">  </span><span class="nx">BytesRead</span><span class="w"> </span><span class="kt">uint64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And then writing forwarding methods for each method in the <tt class="docutils literal">net.Conn</tt>
interface, e.g.:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">sc</span><span class="w"> </span><span class="o">*</span><span class="nx">StatsConn</span><span class="p">)</span><span class="w"> </span><span class="nx">Close</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">sc</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>However, the <tt class="docutils literal">net.Conn</tt> interface has 8 methods. Writing forwarding methods
for all of them is tedious and unnecessary. Embedding the
interface gives us all these forwarding methods for free, and we can override
just the ones we need.</p>
</div>
<div class="section" id="example-sort-reverse">
<h2>Example: sort.Reverse</h2>
<p>A classical example of embedding an interface in a struct in the Go standard
library is <tt class="docutils literal">sort.Reverse</tt>. The usage of this function is often confounding
to Go newbies, because it's not at all clear how it's supposed to work.</p>
<p>Let's start with a simpler example of sorting in Go, by sorting an integer slice.</p>
<div class="highlight"><pre><span></span><span class="nx">lst</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"></span>
<span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntSlice</span><span class="p">(</span><span class="nx">lst</span><span class="p">))</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">lst</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>This prints <tt class="docutils literal">[1 2 3 4 5 8 9]</tt>. How does it work? The <tt class="docutils literal">sort.Sort</tt> function
takes an argument implementing the <tt class="docutils literal">sort.Interface</tt> interface, which is
defined as:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Interface</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Len is the number of elements in the collection.</span><span class="w"></span>
<span class="w">    </span><span class="nx">Len</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Less reports whether the element with</span><span class="w"></span>
<span class="w">    </span><span class="c1">// index i should sort before the element with index j.</span><span class="w"></span>
<span class="w">    </span><span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Swap swaps the elements with indexes i and j.</span><span class="w"></span>
<span class="w">    </span><span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>If we have a type we'd like to sort with <tt class="docutils literal">sort.Sort</tt>, we'll have to implement
this interface; for simple types like an <tt class="docutils literal">int</tt> slice, the standard library
provides convenience types like <tt class="docutils literal">sort.IntSlice</tt> that take our value and
implement the <tt class="docutils literal">sort.Interface</tt> methods on it. So far so good.</p>
<p>So how does <tt class="docutils literal">sort.Reverse</tt> work? By cleverly employing an interface embedded
in a struct. The <tt class="docutils literal">sort</tt> package has this (unexported) type to help with the
task:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">reverse</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">sort</span><span class="p">.</span><span class="nx">Interface</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">reverse</span><span class="p">)</span><span class="w"> </span><span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">Interface</span><span class="p">.</span><span class="nx">Less</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>By this point it should be clear what this does; <tt class="docutils literal">reverse</tt> implements
<tt class="docutils literal">sort.Interface</tt> by means of embedding it (as long as it's initialized with a
value implementing the interface), and it intercepts a single method from that
interface - <tt class="docutils literal">Less</tt>. It then delegates it to the <tt class="docutils literal">Less</tt> of the embedded
value, but inverts the order of arguments. This <tt class="docutils literal">Less</tt> actually compares
element in reverse, which will make the sort work in reverse.</p>
<p>To complete the solution, the <tt class="docutils literal">sort.Reverse</tt> function is simply:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">data</span><span class="w"> </span><span class="nx">sort</span><span class="p">.</span><span class="nx">Interface</span><span class="p">)</span><span class="w"> </span><span class="nx">sort</span><span class="p">.</span><span class="nx">Interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">reverse</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And now we can do:</p>
<div class="highlight"><pre><span></span><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntSlice</span><span class="p">(</span><span class="nx">lst</span><span class="p">)))</span><span class="w"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">lst</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Which prints <tt class="docutils literal">[9 8 5 4 3 2 1]</tt>. The key point to understand here is that
calling <tt class="docutils literal">sort.Reverse</tt> itself does not sort or reverse anything. It can be
seen as a higher order function: it produces a value that wraps the interface
given to it and adjusts its functionality. The call to <tt class="docutils literal">sort.Sort</tt> is where
the sorting happens.</p>
</div>
<div class="section" id="example-context-withvalue">
<h2>Example: context.WithValue</h2>
<p>The <tt class="docutils literal">context</tt> package has a function called <tt class="docutils literal">WithValue</tt>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">WithValue</span><span class="p">(</span><span class="nx">parent</span><span class="w"> </span><span class="nx">Context</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="nx">Context</span><span class="w"></span>
</pre></div>
<p>It &quot;returns a copy of <tt class="docutils literal">parent</tt> in which the value associated with <tt class="docutils literal">key</tt> is
<tt class="docutils literal">val</tt>.&quot; Let's see how it works under the hood.</p>
<p>Ignoring error checking, <tt class="docutils literal">WithValue</tt> basically boils down to:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">WithValue</span><span class="p">(</span><span class="nx">parent</span><span class="w"> </span><span class="nx">Context</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="nx">Context</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">val</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Where <tt class="docutils literal">valueCtx</tt> is:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">valueCtx</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Context</span><span class="w"></span>
<span class="w">  </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Here it is - a struct embedding an interface again. <tt class="docutils literal">valueCtx</tt> now implements
the <tt class="docutils literal">Context</tt> interface and is free to intercept any of <tt class="docutils literal">Context</tt>'s 4
methods. It intercepts <tt class="docutils literal">Value</tt>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span><span class="w"> </span><span class="nx">Value</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nx">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And leaves the rest of the methods untouched.</p>
</div>
<div class="section" id="example-degrading-capability-with-a-more-restricted-interface">
<h2>Example: degrading capability with a more restricted interface</h2>
<p>This technique is quite advanced, but it's used in many places throughout the
standard library. That said, I don't expect it is commonly needed in client code
so if you're a Go newbie and you don't get it on the first read, don't worry too
much. Get back to it after you gain some more Go experience.</p>
<p>Let's start by talking about the <tt class="docutils literal">io.ReaderFrom</tt> interface:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">ReaderFrom</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">ReadFrom</span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">Reader</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="kt">int64</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This interface is implemented by types that can meaningfully read data from an
<tt class="docutils literal">io.Reader</tt>. For example, the <tt class="docutils literal">os.File</tt> type implements this interface and
reads the data from the reader into the open file it (<tt class="docutils literal">os.File</tt>) represents.
Let's see how it does it:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="o">*</span><span class="nx">File</span><span class="p">)</span><span class="w"> </span><span class="nx">ReadFrom</span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="kt">int64</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">checkValid</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">handled</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">readFrom</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">handled</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">genericReadFrom</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">wrapErr</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It first attempts to read from <tt class="docutils literal">r</tt> using the <tt class="docutils literal">readFrom</tt> method, which is OS
specific. On Linux, for example, it uses the <a class="reference external" href="https://man7.org/linux/man-pages/man2/copy_file_range.2.html">copy_file_range</a> syscall for
very fast copying between two files, directly in the kernel.</p>
<p><tt class="docutils literal">readFrom</tt> returns a boolean saying whether it succeeded (<tt class="docutils literal">handled</tt>). If not,
<tt class="docutils literal">ReadFrom</tt> attempts to do a &quot;generic&quot; operation using <tt class="docutils literal">genericReadFrom</tt>,
which is implemented as:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">genericReadFrom</span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="o">*</span><span class="nx">File</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int64</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">onlyWriter</span><span class="p">{</span><span class="nx">f</span><span class="p">},</span><span class="w"> </span><span class="nx">r</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>It uses <tt class="docutils literal">io.Copy</tt> to copy from <tt class="docutils literal">r</tt> to <tt class="docutils literal">f</tt>, so far so good. But what is
this <tt class="docutils literal">onlyWriter</tt> wrapper?</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">onlyWriter</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Interesting. So this is our - familiar by now - trick of an interface embedded
in a struct. But if we search around in the file we won't find any methods
defined on <tt class="docutils literal">onlyWriter</tt>, so it doesn't intercept anything. Why is it needed
then?</p>
<p>To understand why, we should look at what <tt class="docutils literal">io.Copy</tt> does. Its code is long
so I won't reproduce it fully here; but the key part to notice is that if
its destination implements <tt class="docutils literal">io.ReaderFrom</tt>, it will invoke <tt class="docutils literal">ReadFrom</tt>. But
this brings us back in a circle, since we ended up in <tt class="docutils literal">io.Copy</tt> when
<tt class="docutils literal">File.ReadFrom</tt> was called. This causes an infinite recursion!</p>
<p>Now it starts to become clear why <tt class="docutils literal">onlyWriter</tt> is needed. By wrapping <tt class="docutils literal">f</tt>
in the call to <tt class="docutils literal">io.Copy</tt>, what <tt class="docutils literal">io.Copy</tt> gets is not a type that implements
<tt class="docutils literal">io.ReaderFrom</tt>, but only a type that implements <tt class="docutils literal">io.Writer</tt>. It will then
call the <tt class="docutils literal">Write</tt> method of our <tt class="docutils literal">File</tt> and avoid the infinite recursion trap
of <tt class="docutils literal">ReadFrom</tt>.</p>
<p>As I've mentioned earlier, this technique is on the advanced side. I felt it's
important to highlight because it represents a markedly different use of the
&quot;embed interface in struct&quot; tool, and it's pervasively used throughout the
standard library.</p>
<p>The usage in <tt class="docutils literal">File</tt> is a good one because it gives <tt class="docutils literal">onlyWriter</tt> an
explicitly named type, which helps understand what it does. Some code in the
standard library eschews this self-documenting pattern and uses an anonymous
struct. For example, in the <tt class="docutils literal">tar</tt> package it's done with:</p>
<div class="highlight"><pre><span></span><span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="kd">struct</span><span class="p">{</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="w"> </span><span class="p">}{</span><span class="nx">sw</span><span class="p">},</span><span class="w"> </span><span class="nx">r</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2020/embedding-in-go-part-3-interfaces-in-structs/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:55:04 GMT -->
</html>