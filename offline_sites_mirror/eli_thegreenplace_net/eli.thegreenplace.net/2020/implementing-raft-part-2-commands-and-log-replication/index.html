<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2020/implementing-raft-part-2-commands-and-log-replication/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:46:13 GMT -->
<head>
    <title>Implementing Raft: Part 2 - Commands and Log Replication - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Implementing Raft: Part 2 - Commands and Log Replication">
                        Implementing Raft: Part 2 - Commands and Log Replication
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> February 29, 2020 at 06:33</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/concurrency.html">Concurrency</a>
        ,
    <a href="../../tag/go.html">Go</a>
        ,
    <a href="../../tag/network-programming.html">Network Programming</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This is Part 2 in a series of posts describing the Raft distributed consensus
algorithm and its complete implementation in Go. Here is a list of posts in the
series:</p>
<ul class="simple">
<li><a class="reference external" href="../implementing-raft-part-0-introduction/index.html">Part 0: Introduction</a></li>
<li><a class="reference external" href="../implementing-raft-part-1-elections/index.html">Part 1: Elections</a></li>
<li>Part 2: Commands and log replication (this post)</li>
<li><a class="reference external" href="../implementing-raft-part-3-persistence-and-optimizations/index.html">Part 3: Persistence and optimizations</a></li>
<li><a class="reference external" href="../../2024/implementing-raft-part-4-keyvalue-database/index.html">Part 4: Key/Value database</a></li>
<li><a class="reference external" href="../../2024/implementing-raft-part-5-exactly-once-delivery/index.html">Part 5: Exactly-once delivery</a></li>
</ul>
<p>In this part, we'll greatly enhance the Raft implementation to actually handle
commands submitted by clients and replicate them across the Raft cluster. The
code structure remains the same as in <a class="reference external" href="../implementing-raft-part-1-elections/index.html">Part 1</a>.
There are a couple of new structs and functions and some changes to existing
code - I'll present and explain all of these shortly.</p>
<p>All the code in this part is located in <a class="reference external" href="https://github.com/eliben/raft/tree/main/part2">this directory</a>.</p>
<div class="section" id="client-interaction">
<h2>Client interaction</h2>
<p>We already had a brief discussion of client interaction in <a class="reference external" href="../implementing-raft-part-0-introduction/index.html">Part 0</a>;
I strongly encourage you to go back and re-read that section. Here we're not
going to focus on <em>how</em> a client finds the leader; rather, we'll talk about what
happens <em>when</em> it finds one.</p>
<p>Some terminology first; as discussed earlier, clients use Raft to replicate a
sequence of <em>commands</em>, which can be seen as inputs to a generic state machine.
As far as our Raft implementation is concerned, these commands are completely
arbitrary and we represent them with Go's <tt class="docutils literal">any</tt> type.
A command goes through the following process in its
Raft consensus journey:</p>
<ol class="arabic simple">
<li>First, a command is <em>submitted</em> to the leader by a client. In a cluster of
Raft peers, a command is typically submitted only to a single peer.</li>
<li>The leader <em>replicates</em> the command to its followers.</li>
<li>Finally, once the leader is satisfied that the command is sufficiently
replicated (that is, a majority of cluster peers acknowledge they have the
command in their logs <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>), the command is <em>committed</em> and all clients are
notified of a new commit.</li>
</ol>
<p>Note the asymmetry between submitting and committing a command - this is
important to keep in mind when examining the implementation decisions we're
going to be discussing soon. A command is submitted to a single Raft peer, but
multiple peers (specifically, all connected/live peers) commit it after some
time and notify their clients.</p>
<p>Recall this diagram from Part 0:</p>
<img alt="Raft consensus module and log connected to state machine" class="align-center" src="../../images/2020/raft-consensus-module-log.png" />
<p>The state machine represents an arbitrary service using Raft for replication;
for example, this could be a key-value database. <em>Committed</em> commands change
the state of the service (e.g. add a key/value pair to the database).</p>
<p>When we're talking of a <em>client</em> in the context of a Raft <tt class="docutils literal">ConsensusModule</tt>,
we usually mean this service, because this is where the commits are reported
to. In other words, the black arrow from Consensus Module to the service state
machine is that notification.</p>
<p>There's another notion of client, which is the client of the service (e.g.
a user of the key-value database). The service's interaction with its clients
is its own business; in this post we focus just on Raft's interaction with the
service.</p>
</div>
<div class="section" id="implementation-commit-channel">
<h2>Implementation: commit channel</h2>
<p>In our implementation, when a <tt class="docutils literal">ConsensusModule</tt> is created it takes in a
<em>commit channel</em> - a channel which it uses to send committed commands
to the caller: <tt class="docutils literal">commitChan chan&lt;- CommitEntry</tt>.</p>
<p><tt class="docutils literal">CommitEntry</tt> is defined as follows:</p>
<div class="highlight"><pre><span></span><span class="c1">// CommitEntry is the data reported by Raft to the commit channel. Each commit</span><span class="w"></span>
<span class="c1">// entry notifies the client that consensus was reached on a command and it can</span><span class="w"></span>
<span class="c1">// be applied to the client&#39;s state machine.</span><span class="w"></span>
<span class="kd">type</span><span class="w"> </span><span class="nx">CommitEntry</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Command is the client command being committed.</span><span class="w"></span>
<span class="w">  </span><span class="nx">Command</span><span class="w"> </span><span class="kt">any</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Index is the log index at which the client command is committed.</span><span class="w"></span>
<span class="w">  </span><span class="nx">Index</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Term is the Raft term at which the client command is committed.</span><span class="w"></span>
<span class="w">  </span><span class="nx">Term</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Using a channel for this is a design choice, but it's not the only way to solve
it. We could use a callback instead; when creating a <tt class="docutils literal">ConsensusModule</tt> the
caller would register a callback function that we'd invoke whenever we have a
command to commit.</p>
<p>We'll see the code that sends entries on the channel shortly; first, we have
to discuss how Raft servers replicate commands and decide that commands are
committed.</p>
</div>
<div class="section" id="raft-log">
<h2>Raft log</h2>
<p>The Raft log has been mentioned a number of times in this series already, but we
haven't yet said much about it. The log is simply the linear sequence of
commands that should be applied to the state machine; the log should be
sufficient to &quot;replay&quot; the state machine from some starting state, if needed.
During normal operation, the logs of all Raft peers are identical; when the
leader gets a new command, it places it in its own log and then replicates it to
followers. Followers place the command in their logs and acknowledge it to the
leader, which keeps count of the latest log index that was safely replicated
to a majority of servers in the cluster.</p>
<p>The Raft paper has several diagrams of logs that look somewhat like this:</p>
<img alt="Raft log with terms and indexes" class="align-center" src="../../images/2020/logdiagram.png" />
<p>Each box is a log entry; a number in the top part of the box is the term in
which it was added to the log (these are the terms from <a class="reference external" href="../implementing-raft-part-0-introduction/index.html">Part 1</a>).
The bottom part is the key-value command that this log contains. Each log entry
has a linear index <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>. The colors of the boxes are another representation of
terms.</p>
<p>If this log is applied to an empty key-value store, the end result will have
the values <tt class="docutils literal">x = 4, y = 7</tt>.</p>
<p>In our implementation, log entries are represented by:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">LogEntry</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">Command</span><span class="w"> </span><span class="kt">any</span><span class="w"></span>
<span class="w">  </span><span class="nx">Term</span><span class="w">    </span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And each <tt class="docutils literal">ConsensusModule</tt>'s log is then simply <tt class="docutils literal">log []LogEntry</tt>. The
clients typically don't care about terms; terms are critical to the
correctness of Raft, however, so they're important to keep in mind when
reading the code.</p>
</div>
<div class="section" id="submitting-new-commands">
<h2>Submitting new commands</h2>
<p>Let's start with the new <tt class="docutils literal">Submit</tt> method, which lets clients submit new
commands:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cm</span><span class="w"> </span><span class="o">*</span><span class="nx">ConsensusModule</span><span class="p">)</span><span class="w"> </span><span class="nx">Submit</span><span class="p">(</span><span class="nx">command</span><span class="w"> </span><span class="kt">any</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;Submit received by %v: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span><span class="w"> </span><span class="nx">command</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">Leader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">,</span><span class="w"> </span><span class="nx">LogEntry</span><span class="p">{</span><span class="nx">Command</span><span class="p">:</span><span class="w"> </span><span class="nx">command</span><span class="p">,</span><span class="w"> </span><span class="nx">Term</span><span class="p">:</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;... log=%v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Very straightforward; if this CM is a leader, the new command is appended to the
log and <tt class="docutils literal">true</tt> is returned. Otherwise, it's ignored and <tt class="docutils literal">false</tt> is returned.</p>
<p><strong>Q:</strong> Is a <tt class="docutils literal">true</tt> value returned from <tt class="docutils literal">Submit</tt> sufficient indication
for the client that it has submitted a command to the leader?</p>
<p><strong>A:</strong> Unfortunately not. In rare cases, a leader may become partitioned from
the other Raft servers, who will go on to elect a new leader after a while.
Clients may still be contacting the old leader, however. A client should wait
for some reasonable time for the command it submitted to appear on the commit
channel; if it doesn't, it means that it contacted the wrong leader and it
should retry with a different leader.</p>
</div>
<div class="section" id="replicating-log-entries">
<h2>Replicating log entries</h2>
<p>We've just seen that a new command submitted to the leader is appended at the
end of the log. How does this new command get to followers? The steps followed
by leaders are precisely described in the Raft paper, Figure 2 in the &quot;Rules for
Servers&quot; section. Our implementation does this in <tt class="docutils literal">leaderSendHeartbeats</tt>;
this is the new method <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cm</span><span class="w"> </span><span class="o">*</span><span class="nx">ConsensusModule</span><span class="p">)</span><span class="w"> </span><span class="nx">leaderSendHeartbeats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="nx">savedCurrentTerm</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">peerId</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">peerIds</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">peerId</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="nx">ni</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peerId</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="nx">prevLogIndex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ni</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="nx">prevLogTerm</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="nx">prevLogIndex</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">prevLogTerm</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="nx">prevLogIndex</span><span class="p">].</span><span class="nx">Term</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="nx">entries</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="nx">ni</span><span class="p">:]</span><span class="w"></span>

<span class="w">      </span><span class="nx">args</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">AppendEntriesArgs</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">Term</span><span class="p">:</span><span class="w">         </span><span class="nx">savedCurrentTerm</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">LeaderId</span><span class="p">:</span><span class="w">     </span><span class="nx">cm</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">PrevLogIndex</span><span class="p">:</span><span class="w"> </span><span class="nx">prevLogIndex</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">PrevLogTerm</span><span class="p">:</span><span class="w">  </span><span class="nx">prevLogTerm</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">Entries</span><span class="p">:</span><span class="w">      </span><span class="nx">entries</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">LeaderCommit</span><span class="p">:</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;sending AppendEntries to %v: ni=%d, args=%+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">peerId</span><span class="p">,</span><span class="w"> </span><span class="nx">ni</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">reply</span><span class="w"> </span><span class="nx">AppendEntriesReply</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">Call</span><span class="p">(</span><span class="nx">peerId</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ConsensusModule.AppendEntries&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">reply</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">savedCurrentTerm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;term out of date in heartbeat reply&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="nx">cm</span><span class="p">.</span><span class="nx">becomeFollower</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">Leader</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">savedCurrentTerm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nx">cm</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peerId</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">ni</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="nx">cm</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">[</span><span class="nx">peerId</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peerId</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;AppendEntries reply from %d success: nextIndex := %v, matchIndex := %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">peerId</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="nx">savedCommitIndex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Term</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nx">matchCount</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">peerId</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">peerIds</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">[</span><span class="nx">peerId</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nx">matchCount</span><span class="o">++</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">matchCount</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">peerIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">i</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">savedCommitIndex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;leader sets commitIndex := %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="nx">cm</span><span class="p">.</span><span class="nx">newCommitReadyChan</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kd">struct</span><span class="p">{}{}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nx">cm</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peerId</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">ni</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;AppendEntries reply from %d !success: nextIndex := %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">peerId</span><span class="p">,</span><span class="w"> </span><span class="nx">ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}(</span><span class="nx">peerId</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This is certainly more complicated than what we did in Part 1, but it really
just follows Figure 2 in the paper. A few notes on this code:</p>
<ul class="simple">
<li>The fields of an AE RPC are fully populated now: see Figure 2 in the paper
for their meaning.</li>
<li>AE responses have a <tt class="docutils literal">success</tt> field that tell the leader
whether the follower saw a match for <tt class="docutils literal">prevLogIndex</tt> and <tt class="docutils literal">prevLogTerm</tt>.
Based on this field, the leader updates <tt class="docutils literal">nextIndex</tt> for this follower.</li>
<li><tt class="docutils literal">commitIndex</tt> is updated based on the count of followers that replicated
a certain log index. If an index is replicated by a majority, <tt class="docutils literal">commitIndex</tt>
advances to it.</li>
</ul>
<p>This part of the code is particularly important in relation to our earlier
discussion of client interaction:</p>
<div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">savedCommitIndex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;leader sets commitIndex := %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">newCommitReadyChan</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kd">struct</span><span class="p">{}{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><tt class="docutils literal">newCommitReadyChan</tt> is a channel used internally by the CM to signal that new
entries are ready to be sent on the commit channel to the client. It's acted
upon by this method which is run in a goroutine on CM start-up:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cm</span><span class="w"> </span><span class="o">*</span><span class="nx">ConsensusModule</span><span class="p">)</span><span class="w"> </span><span class="nx">commitChanSender</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">newCommitReadyChan</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Find which entries we have to apply.</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">savedTerm</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"></span>
<span class="w">    </span><span class="nx">savedLastApplied</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">lastApplied</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">entries</span><span class="w"> </span><span class="p">[]</span><span class="nx">LogEntry</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">lastApplied</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">entries</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="nx">cm</span><span class="p">.</span><span class="nx">lastApplied</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">lastApplied</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;commitChanSender entries=%v, savedLastApplied=%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">entries</span><span class="p">,</span><span class="w"> </span><span class="nx">savedLastApplied</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">entry</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">entries</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitChan</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">CommitEntry</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">Command</span><span class="p">:</span><span class="w"> </span><span class="nx">entry</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">Index</span><span class="p">:</span><span class="w">   </span><span class="nx">savedLastApplied</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">Term</span><span class="p">:</span><span class="w">    </span><span class="nx">savedTerm</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;commitChanSender done&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This method updates the <tt class="docutils literal">lastApplied</tt> state variable to know which entries
were already sent to the client, and sends only new ones.</p>
</div>
<div class="section" id="updating-logs-in-followers">
<h2>Updating logs in followers</h2>
<p>We've seen what the leader does with new log entries. Now it's time to examine
the code of followers; specifically, the <tt class="docutils literal">AppendEntries</tt> RPC. In the following
code sample, lines that are new compared to Part 1 are highlighted:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cm</span><span class="w"> </span><span class="o">*</span><span class="nx">ConsensusModule</span><span class="p">)</span><span class="w"> </span><span class="nx">AppendEntries</span><span class="p">(</span><span class="nx">args</span><span class="w"> </span><span class="nx">AppendEntriesArgs</span><span class="p">,</span><span class="w"> </span><span class="nx">reply</span><span class="w"> </span><span class="o">*</span><span class="nx">AppendEntriesReply</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">Dead</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;AppendEntries: %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;... term out of date in AppendEntries&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">becomeFollower</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">Follower</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">becomeFollower</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">electionResetEvent</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span><span class="w"></span>

<span class="hll"><span class="w">    </span><span class="c1">// Does our log contain an entry at PrevLogIndex whose term matches</span><span class="w"></span>
</span><span class="hll"><span class="w">    </span><span class="c1">// PrevLogTerm? Note that in the extreme case of PrevLogIndex=-1 this is</span><span class="w"></span>
</span><span class="hll"><span class="w">    </span><span class="c1">// vacuously true.</span><span class="w"></span>
</span><span class="hll"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogTerm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span><span class="p">].</span><span class="nx">Term</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
</span><span class="hll">
</span><span class="hll"><span class="w">      </span><span class="c1">// Find an insertion point - where there&#39;s a term mismatch between</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="c1">// the existing log starting at PrevLogIndex+1 and the new entries sent</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="c1">// in the RPC.</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="nx">logInsertIndex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="nx">newEntriesIndex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</span><span class="hll">
</span><span class="hll"><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">logInsertIndex</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">newEntriesIndex</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class="hll"><span class="w">          </span><span class="k">break</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="nx">logInsertIndex</span><span class="p">].</span><span class="nx">Term</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="nx">newEntriesIndex</span><span class="p">].</span><span class="nx">Term</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class="hll"><span class="w">          </span><span class="k">break</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">logInsertIndex</span><span class="o">++</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">newEntriesIndex</span><span class="o">++</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="p">}</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="c1">// At the end of this loop:</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="c1">// - logInsertIndex points at the end of the log, or an index where the</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="c1">//   term mismatches with an entry from the leader</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="c1">// - newEntriesIndex points at the end of Entries, or an index where the</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="c1">//   term mismatches with the corresponding log entry</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="nx">newEntriesIndex</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;... inserting entries %v from index %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="nx">newEntriesIndex</span><span class="p">:],</span><span class="w"> </span><span class="nx">logInsertIndex</span><span class="p">)</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[:</span><span class="nx">logInsertIndex</span><span class="p">],</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="nx">newEntriesIndex</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;... log is now: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="p">}</span><span class="w"></span>
</span><span class="hll">
</span><span class="hll"><span class="w">      </span><span class="c1">// Set commit index.</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">LeaderCommit</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">intMin</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">LeaderCommit</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;... setting commitIndex=%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">commitIndex</span><span class="p">)</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">newCommitReadyChan</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kd">struct</span><span class="p">{}{}</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="p">}</span><span class="w"></span>
</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;AppendEntries reply: %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">reply</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This code follows the algorithm in Figure 2 of the paper (<em>Received
implementation</em> section of AppendEntries) closely, and it's well commented.</p>
<p>Note the send on <tt class="docutils literal">ch.newCommitReadyChan</tt> when the code notices that the
leader's <tt class="docutils literal">LeaderCommit</tt> is larger than its own <tt class="docutils literal">cm.commitIndex</tt>; this is
when a follower learns that the leader considers additional entries to be
committed.</p>
<p>When a leader sends new log entries with AE, the following happens:</p>
<ul class="simple">
<li>A follower appends the new entries to its log and replies <tt class="docutils literal">success=true</tt>
to the leader.</li>
<li>As a result, the leader updates its <tt class="docutils literal">matchIndex</tt> for this follower. When
enough followers have their <tt class="docutils literal">matchIndex</tt> at the next index, the leader
updates <tt class="docutils literal">commitIndex</tt> and sends it to all followers in the next AE (in the
<tt class="docutils literal">leaderCommit</tt> field).</li>
<li>When followers receive a new <tt class="docutils literal">leaderCommit</tt> that's beyond what they've seen
before, they know that new log entries are committed and they can send them
to their clients on the commit channel.</li>
</ul>
<p><strong>Q:</strong> How many RPC round-trips does it take to commit a new command?</p>
<p><strong>A:</strong> Two. First round for the leader to send the next log entries to followers
and for the followers to acknowledge them. When the leader processes a reply
to an AE, it may update its commit index based on the response. The second round
will send an updated commit index to followers, who will then mark these entries
as committed and will send them on the commit channel. As an exercise, go back
to the code snippets above and find the pieces of code that implement these
steps.</p>
</div>
<div class="section" id="election-safety">
<h2>Election safety</h2>
<p>So far we've looked at the new code added to support log replication. However,
logs also have an effect on Raft elections. The Raft paper describes this in
section 5.4.1 - <em>Election restriction</em>. Raft uses the election process to
prevent a candidate from winning an election unless its log is at least as
up-to-date as a majority of peers in the cluster <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>.</p>
<p>For this reason, RVs contain the <tt class="docutils literal">lastLogIndex</tt> and <tt class="docutils literal">lastLogTerm</tt> fields.
When a candidate sends out an RV, it populates these with information about
its last log entry. Followers compare these fields to their own and decide
whether the candidate is sufficiently up-to-date to be elected.</p>
<p>Here's the new <tt class="docutils literal">startElection</tt> with added lines highlighted:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cm</span><span class="w"> </span><span class="o">*</span><span class="nx">ConsensusModule</span><span class="p">)</span><span class="w"> </span><span class="nx">startElection</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Candidate</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="nx">savedCurrentTerm</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">electionResetEvent</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">votedFor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">id</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;becomes Candidate (currentTerm=%d); log=%v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">savedCurrentTerm</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="nx">votesReceived</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Send RequestVote RPCs to all other servers concurrently.</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">peerId</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">peerIds</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">peerId</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="hll"><span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="nx">savedLastLogIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">savedLastLogTerm</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">lastLogIndexAndTerm</span><span class="p">()</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
</span><span class="hll">
</span><span class="hll"><span class="w">      </span><span class="nx">args</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">RequestVoteArgs</span><span class="p">{</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">Term</span><span class="p">:</span><span class="w">         </span><span class="nx">savedCurrentTerm</span><span class="p">,</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">CandidateId</span><span class="p">:</span><span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">LastLogIndex</span><span class="p">:</span><span class="w"> </span><span class="nx">savedLastLogIndex</span><span class="p">,</span><span class="w"></span>
</span><span class="hll"><span class="w">        </span><span class="nx">LastLogTerm</span><span class="p">:</span><span class="w">  </span><span class="nx">savedLastLogTerm</span><span class="p">,</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="p">}</span><span class="w"></span>
</span><span class="hll">
</span><span class="hll"><span class="w">      </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;sending RequestVote to %d: %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">peerId</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">)</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">reply</span><span class="w"> </span><span class="nx">RequestVoteReply</span><span class="w"></span>
</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">Call</span><span class="p">(</span><span class="nx">peerId</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ConsensusModule.RequestVote&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">reply</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;received RequestVoteReply %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reply</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">Candidate</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;while waiting for reply, state = %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">savedCurrentTerm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;term out of date in RequestVoteReply&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="nx">cm</span><span class="p">.</span><span class="nx">becomeFollower</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">savedCurrentTerm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nx">votesReceived</span><span class="o">++</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">votesReceived</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">peerIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="c1">// Won the election!</span><span class="w"></span>
<span class="w">              </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;wins election with %d votes&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">votes</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="nx">cm</span><span class="p">.</span><span class="nx">startLeader</span><span class="p">()</span><span class="w"></span>
<span class="w">              </span><span class="k">return</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}(</span><span class="nx">peerId</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Run another election timer, in case this election is not successful.</span><span class="w"></span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">runElectionTimer</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And <tt class="docutils literal">lastLogIndexAndTerm</tt> is a new helper method:</p>
<div class="highlight"><pre><span></span><span class="c1">// lastLogIndexAndTerm returns the last log index and the last log entry&#39;s term</span><span class="w"></span>
<span class="c1">// (or -1 if there&#39;s no log) for this server.</span><span class="w"></span>
<span class="c1">// Expects cm.mu to be locked.</span><span class="w"></span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cm</span><span class="w"> </span><span class="o">*</span><span class="nx">ConsensusModule</span><span class="p">)</span><span class="w"> </span><span class="nx">lastLogIndexAndTerm</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">lastIndex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">lastIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="nx">lastIndex</span><span class="p">].</span><span class="nx">Term</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>A reminder that our implementation has 0-based indexing as opposed to the Raft
paper's 1-based indexing. Therefore -1 often serves as a sentinel value.</p>
<p>Here's an updated RV handler that implements the election safety check, with the
new code highlighted:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cm</span><span class="w"> </span><span class="o">*</span><span class="nx">ConsensusModule</span><span class="p">)</span><span class="w"> </span><span class="nx">RequestVote</span><span class="p">(</span><span class="nx">args</span><span class="w"> </span><span class="nx">RequestVoteArgs</span><span class="p">,</span><span class="w"> </span><span class="nx">reply</span><span class="w"> </span><span class="o">*</span><span class="nx">RequestVoteReply</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">Dead</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="hll"><span class="w">  </span><span class="nx">lastLogIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">lastLogTerm</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">lastLogIndexAndTerm</span><span class="p">()</span><span class="w"></span>
</span><span class="hll"><span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;RequestVote: %+v [currentTerm=%d, votedFor=%d, log index/term=(%d, %d)]&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">votedFor</span><span class="p">,</span><span class="w"> </span><span class="nx">lastLogIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">lastLogTerm</span><span class="p">)</span><span class="w"></span>
</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;... term out of date in RequestVote&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">becomeFollower</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="hll"><span class="w">    </span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">votedFor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">votedFor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">CandidateId</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
</span><span class="hll"><span class="w">    </span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">lastLogTerm</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
</span><span class="hll"><span class="w">      </span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">lastLogTerm</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">LastLogIndex</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">lastLogIndex</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class="w">    </span><span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">votedFor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">args</span><span class="p">.</span><span class="nx">CandidateId</span><span class="w"></span>
<span class="w">    </span><span class="nx">cm</span><span class="p">.</span><span class="nx">electionResetEvent</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cm</span><span class="p">.</span><span class="nx">currentTerm</span><span class="w"></span>
<span class="w">  </span><span class="nx">cm</span><span class="p">.</span><span class="nx">dlog</span><span class="p">(</span><span class="s">&quot;... RequestVote reply: %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reply</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="revisiting-the-runaway-server-scenario">
<h2>Revisiting the &quot;runaway server&quot; scenario</h2>
<p>In <a class="reference external" href="../implementing-raft-part-1-elections/index.html">Part 1</a>,
we've discussed a scenario where server B in a 3-server cluster gets
disconnected for a few seconds, which causes it to become a candidate and re-run
a new round of elections every 150-300 ms. When it reconnects to the cluster,
its term is much higher than the peers that remained in the cluster without
being aware of new elections.</p>
<p>Now it's a good time to revisit this scenario, and consider what happens if the
connected peers replicated some log entries during this time.</p>
<p>Even though B's return to the cluster will trigger a re-election (the leader
will still see a higher term than its own in an AE reply and revert to
follower), B won't be able to win the election because its log is going to be
less complete than the logs of A and C. This is due to the election
safety checks presented in the previous section. Either A or C will win the
re-election, and so the disruption to the cluster will be relatively minimal.</p>
<p>If you are still concerned about this unnecessary disruption (why run
re-election at all?), Ongaro's dissertation discusses this precise problem in a
section titled &quot;Preventing disruptions when a server rejoins a cluster&quot;. The
common solution to this problem is a &quot;pre-vote&quot; step, where a server performs
some checks before becoming a candidate.</p>
<p>Since this is an optimization for an uncommon case, I will not spend more time
on this topic. Feel free to check out the dissertation - it's linked from the
<a class="reference external" href="https://raft.github.io/">Raft website</a>.</p>
</div>
<div class="section" id="some-q-a">
<h2>Some Q&amp;A</h2>
<p>We'll finish this part with some common questions that may arise while studying
and implementing Raft. If you have additional questions, feel free to send me
an email - I'll collect the most common ones and will update these posts.</p>
<p><strong>Q:</strong> Why is <tt class="docutils literal">commitIndex</tt> separate from <tt class="docutils literal">lastApplied</tt>? Can't we just
record how much <tt class="docutils literal">commitIndex</tt> has advanced as a result of an RPC (or RPC
response) and send only these commands to clients?</p>
<p><strong>A:</strong> The two are separate to decouple quick operations (RPC handling) from
potentially slow operations (sending commands to clients). Consider what happens
when a follower gets an AE and learns that the leader's <tt class="docutils literal">commitIndex</tt> is
larger than its own. At this point it can send a number of log commands to the
commit channel. But sending values on a channel (or invoking a callback) can
be a potentially blocking operation, whereas we want to reply to the RPC as
soon as possible. <tt class="docutils literal">lastApplied</tt> helps us decouple these. The RPC only updates
<tt class="docutils literal">commitIndex</tt>, and the <tt class="docutils literal">commitChanSender</tt> goroutine runs in the background
to observe these changes and send new committed commands to the client at its
leisure.</p>
<p>You may wonder if the same applies to the <tt class="docutils literal">newCommitReadyChan</tt> channel, and
that's a good observation. This channel is buffered, however, and since we
control both sides we can set a small buffer that will guarantee no blocking
with high probability. Still, in corner cases very slow clients can delay RPCs
because the Raft code cannot be expected to maintain an infinite buffer. This
is not necessarily a bad thing, as it creates a natural backpressure mechanism.</p>
<p><strong>Q:</strong> Do we need both <tt class="docutils literal">nextIndex</tt> and <tt class="docutils literal">matchIndex</tt> per peer in the leader?</p>
<p><strong>A:</strong> The algorithm would still work with only <tt class="docutils literal">matchIndex</tt>, but it would be
very inefficient in some cases. Consider a leadership change; the new leader
can't assume anything about the up-to-dateness of its peers and initializes
<tt class="docutils literal">matchIndex</tt> to -1. So it will attempt to send the whole log to each follower.
But it's very likely that followers (at least most of them) have almost all the
same log entries; <tt class="docutils literal">nextIndex</tt> helps the leader probe the followers carefully
starting from <em>the end of the log</em>, and not replicate huge logs unnecessarily.</p>
</div>
<div class="section" id="what-s-next">
<h2>What's next</h2>
<p>Once again, I will strongly encourage you to play with
<a class="reference external" href="https://github.com/eliben/raft/tree/main/part2">the code</a> - run some
of the tests and observe the logs.</p>
<p>At this point we have a mostly working Raft implementation, except that we don't
handle <em>persistence</em> at all. This means that our implementation is vulnerable to
crash faults, wherein a server crashes and restarts.</p>
<p>The Raft algorithm has provision for this, and this is what Part 3 will cover.
Adding persistence will enable us to craft more insidious tests that include
servers crashing at the worst time possible.</p>
<p>In addition, Part 3 will discuss some optimizations to the implementation
presented here. Most importantly, leaders should send AEs more promptly when
they have new information for followers; right now they only send AEs every
50 ms. This will also be fixed.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>For example, in a cluster of size 5, the leader will expect
acknowledgments from 2 followers. This makes the total 3 (the 2
followers plus the leader itself), which is a valid majority.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>This is the place to note that, while in the Raft paper log indices are
1-based, in our implementation they are 0-based since this feels much
more natural. These indices have no real effect on the client/user of
a Raft <tt class="docutils literal">ConsensusModule</tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>Calling this method <tt class="docutils literal">leaderSendHeartbeats</tt> is a bit of a misnomer at
this point, because it no longer just sends heartbeats. However, since
in this part it still sends AEs only every 50 ms, I'll keep this name.
We'll fix it in part 3.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>This is a very simplistic explanation, and the truth is more involved.
The reasoning of correctness here is quite complicated, and I recommend
reading the paper for more details. If you're a stickler for formalism,
Ongaro's dissertation has a <a class="reference external" href="https://github.com/ongardie/raft.tla">TLA+ spec of Raft</a> to prove the correctness of
these invariants.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2020/implementing-raft-part-2-commands-and-log-replication/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:46:13 GMT -->
</html>