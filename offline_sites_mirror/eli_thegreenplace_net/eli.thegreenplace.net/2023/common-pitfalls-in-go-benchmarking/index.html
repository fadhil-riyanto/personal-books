<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2023/common-pitfalls-in-go-benchmarking/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:55:44 GMT -->
<head>
    <title>Common pitfalls in Go benchmarking - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Common pitfalls in Go benchmarking">
                        Common pitfalls in Go benchmarking
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> July 24, 2023 at 16:43</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/go.html">Go</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Go programmers have the good fortune of excellent testing and benchmarking
tooling built into the standard library - in the <tt class="docutils literal">testing</tt> package. However,
<em>benchmarking is hard</em>. This isn't Go specific; it's just one of those things
experienced developers learn over time.</p>
<p>This post lists some common benchmarking pitfalls Go programmers run into. It
assumes basic familiarity with writing Go benchmarks; consult the <a class="reference external" href="https://pkg.go.dev/testing">testing
package documentation</a> if needed. While these
pitfalls are presented in Go, they exist in any programming language or
environment, so the lessons learned here are widely applicable.</p>
<div class="section" id="benchmarking-the-wrong-thing">
<h2>Benchmarking the wrong thing</h2>
<p>Let's say we want to benchmark the new sorting functionality available in the
<tt class="docutils literal">slices</tt> package starting with Go 1.21 <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>. Consider the following
benchmark:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">100</span><span class="nx">_000</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkSortIntsWrong</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">ints</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">makeRandomInts</span><span class="p">(</span><span class="nx">N</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">slices</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">ints</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">makeRandomInts</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">ints</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">ints</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">ints</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Why is this benchmark wrong? Because it's not really testing what you think it's
testing. <tt class="docutils literal">slices.Sort</tt> sorts a slice <em>in-place</em>. After the first iteration,
the <tt class="docutils literal">ints</tt> slice is already sorted, so all subsequent iterations &quot;sort&quot;
a sorted slice. This is not what we want to measure <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>. The
right measurement would create a new random slice for each iteration:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkSortInts</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">b</span><span class="p">.</span><span class="nx">StopTimer</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">ints</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">makeRandomInts</span><span class="p">(</span><span class="nx">N</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">b</span><span class="p">.</span><span class="nx">StartTimer</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">slices</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">ints</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>On my machine, the second benchmark is almost 100x slower; this makes sense,
because it actually sorts something on each iteration.</p>
</div>
<div class="section" id="forgetting-to-reset-the-timer">
<h2>Forgetting to reset the timer</h2>
<p>Note how the benchmarks mentioned above are careful to reset or stop/start
the benchmarking timer around certain operations. This is on purpose, because
the benchmark scaffold measures the run-time of the entire <tt class="docutils literal">Benchmark*</tt>
function, executing it many times and dividing the total execution time by
<tt class="docutils literal">b.N</tt> (much more details on this process later in the post).</p>
<p>Try it! Remove the <tt class="docutils literal">b.StopTimer()</tt> and <tt class="docutils literal">b.StartTimer()</tt> calls from the
benchmarking loop in <tt class="docutils literal">BenchmarkSortInts</tt> and compare the results - you'll
notice the benchmark now reports noticeably slower per-op execution time
because creating the slices of random integers also happens <tt class="docutils literal">b.N</tt> times.</p>
<p>This can throw results off significantly in some cases. Even if we use the
same technique to benchmark two approaches, the errors don't necessarily cancel
out. Due to <a class="reference external" href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl's law</a> we
can easily report the wrong speed-up when not isolating the computation we
care about.</p>
</div>
<div class="section" id="fooled-by-the-compiler">
<h2>Fooled by the compiler</h2>
<p>The trickiest benchmarking pitfall is dealing with compiler optimizations
thwarting our results. The Go compiler doesn't give <tt class="docutils literal">Benchmark*</tt> functions
any preferential treatment and will try to optimize them and their contents
just as it would any other Go code <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>. This produces wrong results and it's
not even easy to know they are wrong! Consider this benchmark:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">isCond</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">b</span><span class="o">%</span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">b</span><span class="o">%</span><span class="mi">7</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">b</span><span class="o">%</span><span class="mi">17</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">b</span><span class="o">%</span><span class="mi">31</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkIsCondWrong</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">isCond</span><span class="p">(</span><span class="mi">201</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>We're trying to benchmark the <tt class="docutils literal">isCond</tt> function, but the compiler is
fooling us (at least in recent Go versions):</p>
<div class="highlight"><pre><span></span>BenchmarkIsCondWrong-8        1000000000     0.2401 ns/op
</pre></div>
<p>Sub-nanosecond operation times are always a bit suspect, although not entirely
out of the question given the simplicity of the <tt class="docutils literal">isCond</tt> function. There are
two serious errors here, however:</p>
<ol class="arabic simple">
<li>We use a constant input to <tt class="docutils literal">isCond</tt>; since <tt class="docutils literal">isCond</tt> is a simple function
that is likely to be inlined into the benchmark function, the compiler can
theoretically constant-propagate its input through its contents and replace
the code with the compile-time computed answer.</li>
<li>Even if we used a non-constant for the input, the result of <tt class="docutils literal">isCond</tt> is
unused, so the compiler may optimize it away.</li>
</ol>
<p>And in fact, in this example the contents of the benchmark loop are optimized
away entirely; looking at the disassembly, we see this:</p>
<div class="highlight"><pre><span></span>    JMP     BenchmarkIsCondWrong_pc7
BenchmarkIsCondWrong_pc4:
    INCQ    CX
BenchmarkIsCondWrong_pc7:
    CMPQ    416(AX), CX
    JGT     BenchmarkIsCondWrong_pc4
    RET
</pre></div>
<p><tt class="docutils literal">CX</tt> holds <tt class="docutils literal">i</tt>, and <tt class="docutils literal">416(AX)</tt> accesses <tt class="docutils literal">b.N</tt>. This is just an empty
loop! Now the 0.24 nanoseconds per iteration make sense <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a>.</p>
<p>Here's an even more confounding manifestation of the same problem:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">countCond</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">isCond</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">result</span><span class="o">++</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkCountWrong</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">inp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">getInputContents</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">countCond</span><span class="p">(</span><span class="nx">inp</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">getInputContents</span><span class="p">()</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">400000</span><span class="w"></span>
<span class="w">  </span><span class="nx">buf</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">byte</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">buf</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Now there are certainly no constant propagation issues, and the result of
<tt class="docutils literal">isCond</tt> is clearly used inside <tt class="docutils literal">countCond</tt>. But we've committed the same
error! While the result of <tt class="docutils literal">isCond</tt> is used, the result of <tt class="docutils literal">countCond</tt> is
not, and therefore the compiler will do something like:</p>
<ul class="simple">
<li>Inline <tt class="docutils literal">isCond</tt> into <tt class="docutils literal">countCond</tt></li>
<li>Inline <tt class="docutils literal">countCond</tt> into the benchmark function</li>
<li>Realize that the loop body in <tt class="docutils literal">coundCond</tt> isn't producing side effects or
any result used outside it</li>
<li>Hollow out the loop body in <tt class="docutils literal">countCond</tt>, leaving only an empty loop</li>
</ul>
<p>This process results in confusing benchmark results because the loop
remains in place, and thus if we grow the input, the benchmarked execution
time will grow accordingly! One of the oldest tricks in the benchmarking book is
to change the input size and observe how the run-time is affected; if it's not
moving, something is wrong. If it's growing roughly in line with the asymptotic
complexity of the code under test, it's at least passing a simple smoke test.
But in this case the heuristic fails due to the specific optimizations
performed.</p>
<div class="section" id="keeping-compiler-optimizations-in-benchmarks-under-control">
<h3>Keeping compiler optimizations in benchmarks under control</h3>
<p>There are two main techniques in Go to thwart compiler optimizations where we
don't want them.</p>
<p>The first is using the <a class="reference external" href="https://pkg.go.dev/runtime#KeepAlive">runtime.KeepAlive</a>
function. Originally introduced for fine-grained control of finalizers, it's
also useful as a very-low-overhead way to tell the compiler &quot;I really need this
value, even if you can prove I do not&quot;. Here's how we can fix our <tt class="docutils literal">countCond</tt>
benchmark with its help:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkCountKeepAlive</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">inp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">getInputContents</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">countCond</span><span class="p">(</span><span class="nx">inp</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">runtime</span><span class="p">.</span><span class="nx">KeepAlive</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Running the benchmark makes it clear that there's more work going into each
iteration now:</p>
<div class="highlight"><pre><span></span>BenchmarkCountWrong-8                 12481       95911 ns/op
BenchmarkCountKeepAlive-8              4143      285527 ns/op
</pre></div>
<p>Another way is without needing a special function, but is slightly more
dangerous; we can use a global exported value to collect the result:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">Sink</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkCountSink</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">inp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">getInputContents</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="nx">b</span><span class="p">.</span><span class="nx">ResetTimer</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">Sink</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">countCond</span><span class="p">(</span><span class="nx">inp</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Even though our benchmark doesn't use <tt class="docutils literal">Sink</tt>, it's very difficult for the
compiler to eliminate because it's a package-level exported value that can be
used pretty much anywhere in the program. I did say it's slightly more
dangerous, though, because theoretically the compiler <em>could</em> prove it's
redundant using more sophisticated cross-package analysis.</p>
<p>Which brings us the to ultimate point: when in doubt, always double check the
assembly generated for the benchmark function, and ensure that the compiler
wasn't too clever.</p>
</div>
<div class="section" id="ongoing-work-in-the-go-standard-library">
<h3>Ongoing work in the Go standard library</h3>
<p>Addressing the issue of compiler optimizations in benchmarks is something the Go
team is interested in. There are currently two active proposals in discussion:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/golang/go/issues/61179">Issue 61179</a>: adding a
low-overhead &quot;keep this value&quot; function in the <tt class="docutils literal">testing</tt> package; this would
be similar to <tt class="docutils literal">runtime.KeepAlive</tt>, but more targeted at benchmarks with
a better name and clearer guarantees.</li>
<li>A more ambitious proposal in <a class="reference external" href="https://github.com/golang/go/issues/61515">issue 61515</a> discusses changing the main
benchmarking API of the <tt class="docutils literal">testing</tt> package to facilitate safer benchmarking.</li>
</ul>
</div>
</div>
<div class="section" id="misusing-b-n">
<h2>Misusing <tt class="docutils literal">b.N</tt></h2>
<p>There are at least two common ways to misuse the benchmark repetition indicator
<tt class="docutils literal">b.N</tt>. Here's the first, completely forgetting the loop:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;crypto/rand&quot;</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;testing&quot;</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkRandPrimeWrongNoLoop</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">rand</span><span class="p">.</span><span class="nx">Prime</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>From proper measurements, the <tt class="docutils literal">crypto/rand.Prime</tt> invocation with length 200
should take around 1 ms on my machine, but this benchmark reports impossibly
low times - fractions of a nanosecond.</p>
<p>The second is trickier:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkRandPrimeWrongUseI</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">rand</span><span class="p">.</span><span class="nx">Prime</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note how it's using <tt class="docutils literal">i</tt> in each iteration (and thus indirectly <tt class="docutils literal">b.N</tt>). On my
machine, this benchmark <strong>doesn't terminate</strong>; what gives?</p>
<p>To understand what's going on here, we should first discuss how benchmarking in
Go works in a bit more detail. The benchmarking harness invokes our benchmark
functions several times. How many? This can be
determined by flags like <tt class="docutils literal"><span class="pre">-benchtime</span></tt>, but the default is for one second.
How does the harness know how many repetitions to pass to our benchmark function
in order to get 1s of execution time? By trying it with low repetitions first,
measuring how long it takes, and then running with increasingly high repetitions
until the intended duration is reached <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>.</p>
<p>There are some nuances to the process: e.g. the number of repetitions doesn't
grow too fast between attempts (at most 100x, as of Go 1.21), and it is capped
at 1 billion. The key point is that it uses the execution time from the
previous attempt to determine how many repetitions to run next.</p>
<p>With these insights in mind, let's examine the two misuses shown above.</p>
<ol class="arabic simple">
<li>Forgetting to loop until <tt class="docutils literal">b.N</tt>. Each benchmark invocation only performs the
tested operations once. No matter how many times the benchmark harness
repeats the benchmark with increasing <tt class="docutils literal">b.N</tt>, the function takes a
millisecond to run! Therefore, eventually the benchmark harness hits its
<tt class="docutils literal">N</tt> limit of a billion invocations, and divides the execution time (1 ms)
by this <tt class="docutils literal">N</tt> to get a nonsensical result.</li>
<li>Using the value of <tt class="docutils literal">b.N</tt> for something other than &quot;how many times to
repeat the benchmark&quot;. <tt class="docutils literal">rand.Prime</tt> is very fast when its input length
is small, but gets pretty slow for large inputs. The harness starts by
running the function once to get its bearings, and then 100 times. For size
100 the run-time of <tt class="docutils literal">rand.Prime</tt> is moderate, so the next time the harness
can increase <tt class="docutils literal">b.N</tt> by another factor of 100. But for higher inputs,
<tt class="docutils literal">rand.Prime</tt> also takes much longer. We end up with a quadratic run-time
explosion! Our benchmark function isn't literally hanging - it <em>will</em> finish
eventually, but it may take long minutes or hours.</li>
</ol>
<p>It's worth mentioning that the proposal in <a class="reference external" href="https://github.com/golang/go/issues/61515">issue 61515</a> would address this problem as
well, by exposing a benchmarking API that would be much harder to misuse in this
way. Another proposal that may affect this is <a class="reference external" href="https://github.com/golang/go/issues/61405">add range over int</a>, which will permit us to write
<tt class="docutils literal">for range b.N</tt> to iterate exactly <tt class="docutils literal">b.N</tt> times, without an explicit
iteration variable.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td><p class="first">For background on this work and why the new generic sorting functions
are faster, see <a class="reference external" href="../../2022/faster-sorting-with-go-generics/index.html">this post</a>.</p>
<p class="last">If you're reading this before Go 1.21's final release (in Aug 2023),
you can download the
<a class="reference external" href="https://go.dev/blog/go1.21rc">release candidate</a> or use
<a class="reference external" href="https://pkg.go.dev/golang.org/dl/gotip">gotip</a>.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>To be clear, it's also important to know how well sorting algorithms
perform on sorted or almost-sorted inputs, but here we're talking about
the more general case.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>While it's possible to think of ways to treat <tt class="docutils literal">Benchmark*</tt> specially,
it's pretty hard to do it correctly because we very much <em>want</em> the
compiler to optimize the functions we're benchmarking. After all, we
want to know what their real run-time is. Drawing the line
between &quot;optimize here&quot; and &quot;don't touch there&quot; is tricky!</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>The Go compiler doesn't currently optimize loops entirely away, unless
it can prove they terminate.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>This also has the side effect of providing whatever <em>warming</em> the
benchmark needs w.r.t. caches (CPU caches, paged memory, file system
caches, DNS caches, etc).</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2023/common-pitfalls-in-go-benchmarking/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:55:44 GMT -->
</html>