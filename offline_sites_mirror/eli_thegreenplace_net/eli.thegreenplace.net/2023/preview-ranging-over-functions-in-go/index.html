<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">

<!-- Mirrored from eli.thegreenplace.net/2023/preview-ranging-over-functions-in-go/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:46:39 GMT -->
<head>
    <title>Preview: ranging over functions in Go - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../index.html" class="navbar-brand">
                <img src="../../images/logosmall.png" width="32" height="32"/>
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../pages/about.html">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../pages/projects.html">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Projects</span>
                    </a>
                </li>
                <li>
                    <a href="../../archives/all.html">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="index.html"
                       rel="bookmark"
                       title="Permalink to Preview: ranging over functions in Go">
                        Preview: ranging over functions in Go
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> July 21, 2023 at 14:30</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../tag/go.html">Go</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>A major Go language change proposal was published earlier this week:
<a class="reference external" href="https://github.com/golang/go/issues/61405">add range over int, range over func</a>,
and there's a good chance this change will make it into a future Go release. In
this post I will discuss the motivation for this proposal, how it's going to
work, and provide some examples of how Go code using it would look.</p>
<p><strong>Update 2024.11.02:</strong> this feature has shipped in Go 1.23;
a new version of this post is <a class="reference external" href="../../2024/ranging-over-functions-in-go-123/index.html">available here</a>.</p>
<div class="section" id="background-for-range-statements-today">
<h2>Background - <tt class="docutils literal"><span class="pre">for-range</span></tt> statements today</h2>
<p>All Go programmers know and love the venerable <tt class="docutils literal">for ... := range</tt> loop;
whether it's ranging over elements of a slice, runes of a string, or key/value
pairs of a map - it's a versatile tool, and few programs do without it.</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">elem</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">mySlice</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// use index i or element elem somehow</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>However, so far <tt class="docutils literal"><span class="pre">for-range</span></tt> statements have been limited to a relatively
small number of Go constructs: arrays, slices, strings, maps and channels.</p>
</div>
<div class="section" id="trying-the-proposal-today">
<h2>Trying the proposal today</h2>
<p>You can play with the proposed changes today, and try all the examples in this
post by building Go with the patches implementing the proposal. Using the
<tt class="docutils literal">gotip</tt> tool, this is much easier than it sounds.</p>
<p>First of all, install <tt class="docutils literal">gotip</tt>:</p>
<div class="highlight"><pre><span></span>$ go install golang.org/dl/gotip@latest
</pre></div>
<p>Now, ask <tt class="docutils literal">gotip</tt> to download and build Go at a special CL number (this is the
<a class="reference external" href="https://go-review.googlesource.com/c/go/+/510541">CL stack implementing the proposal</a>):</p>
<div class="highlight"><pre><span></span>$ gotip download 510541
</pre></div>
<p>Once this step is done (it can take a minute or two), you're ready to run the
examples; just use <tt class="docutils literal">gotip</tt> instead of <tt class="docutils literal">go</tt>; as in, <tt class="docutils literal">gotip run</tt>, <tt class="docutils literal">gotip
build</tt> and so on.</p>
<p>All the examples shown in this post <a class="reference external" href="https://github.com/eliben/code-for-blog/tree/main/2023/for-range-proposal">are available on GitHub</a>.</p>
</div>
<div class="section" id="ranging-over-int">
<h2>Ranging over <tt class="docutils literal">int</tt></h2>
<p>The first addition made in <a class="reference external" href="https://github.com/golang/go/issues/61405">the proposal</a> is <tt class="docutils literal">range</tt> over
integers. Here's a basic example of how it's going to look:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This code is exactly equivalent to:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And will do the same thing: print out the numbers 0,1,2,3,4 - each on a separate
line. Obviously, the ranged integer does not have to be a constant and
assigning the range to a per-iteration value is optional:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// do something</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Will <em>do something</em> exactly <tt class="docutils literal">n</tt> times. There's really all there is to it!
This is just a clean shortcut for a very common loop (<tt class="docutils literal">i := 0; i &lt; n; i++</tt>).
In the proposal, Russ mentioned that approximately half of the 3-clause <tt class="docutils literal">for</tt>
loops he observed in the wild can be converted to this &quot;range over int&quot; form.
This includes Go benchmarks, where the main loop can be converted to:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// run the benchmarked code</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Ranging over integers is simple and clear, so I won't spend more time on it.
Let's move on to the more interesting part of the proposal - ranging over
functions.</p>
</div>
<div class="section" id="range-over-functions-motivation">
<h2>Range over functions - motivation</h2>
<p>Since Go's addition of generics <a class="reference external" href="https://go.dev/blog/go1.18">in version 1.18</a>,
people started writing generic <em>containers</em> or Abstract Data Structures;
generics make it possible for programmers to decouple the data structure from
the types it stores in an efficient and convenient way (compared to the older
way of using empty interfaces).</p>
<p>However, one nagging issue for custom containers remained: how do you iterate
over their elements? While Go supports iteration over built-in containers like
slices and maps very naturally with a <tt class="docutils literal"><span class="pre">for-range</span></tt> loop, this utility was
not available for custom containers, so programmers had to come up with ad-hoc
iteration methods... until now.</p>
<p>For a concrete motivating example, let's assume that Lisp programmers were right
all along and <a class="reference external" href="https://en.wikipedia.org/wiki/Association_list">association lists</a> are the best data structure
(TM). Using generics, we can implement a simple assoc list in Go, built
on top of a slice <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="w"> </span><span class="kt">comparable</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">lst</span><span class="w"> </span><span class="p">[]</span><span class="nx">pair</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">type</span><span class="w"> </span><span class="nx">pair</span><span class="p">[</span><span class="nx">K</span><span class="w"> </span><span class="kt">comparable</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">key</span><span class="w">   </span><span class="nx">K</span><span class="w"></span>
<span class="w">  </span><span class="nx">value</span><span class="w"> </span><span class="nx">V</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">al</span><span class="w"> </span><span class="o">*</span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">])</span><span class="w"> </span><span class="nx">Add</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="p">,</span><span class="w"> </span><span class="nx">pair</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">]{</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>I'll leave the &quot;lookup&quot; method as an exercise for motivated readers. We can
create an association list and populate it:</p>
<div class="highlight"><pre><span></span><span class="nx">al</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">AssocList</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">]{}</span><span class="w"></span>
<span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ten&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;twenty&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;five&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>With this data structure in hand, an obvious question arises - how do I iterate
over all its elements? We could cheat and <tt class="docutils literal">range</tt> over the underlying slice,
but this exposes an implementation detail -- what if we want to re-implement
assoc lists without slices later?</p>
<p>We're left with devising a custom iteration API; something like a <tt class="docutils literal">Next()</tt>
method. This is what Go programmers have been doing so far, and you can find
many examples of custom iteration APIs across the standard library and
elsewhere. As you would expect, many different approaches emerged.
With the new proposal, we can finally settle over a single, idiomatic approach.</p>
<p>I'm going to show how we use the proposal to write an iterator for
<tt class="docutils literal">AssocList</tt>; the next section will discuss the mechanics of how it works.
We start by adding a method to <tt class="docutils literal">AssocList</tt> with a special signature; it can
also be a free-standing function, but for a container like <tt class="docutils literal">AssocList</tt>, a
method is natural:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">al</span><span class="w"> </span><span class="o">*</span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">])</span><span class="w"> </span><span class="nx">All</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Then use it as follows:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">AssocList</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">]{}</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ten&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;twenty&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">al</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;five&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">All</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;key=%v, value=%v\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Prints:</span><span class="w"></span>
<span class="c1">//</span><span class="w"></span>
<span class="c1">// key=10, value=ten</span><span class="w"></span>
<span class="c1">// key=20, value=twenty</span><span class="w"></span>
<span class="c1">// key=5, value=five</span><span class="w"></span>
</pre></div>
<p>Magic! We just iterate over our container with a standard <tt class="docutils literal"><span class="pre">for-range</span></tt> loop;
how does it work?</p>
</div>
<div class="section" id="range-over-functions-the-mechanics">
<h2>Range over functions - the mechanics</h2>
<p>To be eligible for <tt class="docutils literal"><span class="pre">for-range</span></tt> iteration, a function is required to have a
special signature of the form:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span><span class="w"> </span><span class="nx">T2</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
</pre></div>
<p>This says: it's a function that takes another function (by convention called
<tt class="docutils literal">yield</tt>, but it could be named anything) and returns a <tt class="docutils literal">bool</tt>. The parameter
function can either have 0, 1 or 2 parameters of arbitrary types and must
return <tt class="docutils literal">bool</tt>.</p>
<p>The number of <tt class="docutils literal">yield</tt>'s parameters is directly mapped to the left-hand side
of the <tt class="docutils literal"><span class="pre">for-range</span></tt> loop w.r.t maximal number of returned values, e.g. <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<div class="highlight"><pre><span></span>for x, y := range ...   // two parameters
for x := range ...      // one parameter
for range ...           // no parameters
</pre></div>
<p>With the proposal, the <tt class="docutils literal"><span class="pre">for-range</span></tt> loop over functions will be automatically
transformed by the compiler. Quoting from the proposal:</p>
<blockquote>
If <tt class="docutils literal">f</tt> is a function type of the form <tt class="docutils literal">func(yield func(T1, T2)bool) bool</tt>,
then <tt class="docutils literal">for x, y := range f { ... }</tt> is similar to <tt class="docutils literal">f(func(x T1, y T2) bool {
... })</tt>, where the loop body has been moved into the function literal, which
is passed to <tt class="docutils literal">f</tt> as <tt class="docutils literal">yield</tt>.</blockquote>
<p>Let’s unpack this, using our <tt class="docutils literal">AssocList</tt> iterator as an example.
<tt class="docutils literal">AssocList.All</tt> is of the right form; here's the transformation:</p>
<img alt="transformation of for-range code" class="align-center" src="../../images/2023/for-range-code-transform.png" />
<p>I've added a return value to the transformed code because the <tt class="docutils literal">yield</tt> function
has to return <tt class="docutils literal">true</tt> if it wants iteration to continue. If <tt class="docutils literal">yield</tt> wants
iteration to stop after the current call, it should return <tt class="docutils literal">false</tt>. The
proposal says:</p>
<blockquote>
The boolean result from <tt class="docutils literal">yield</tt> indicates to <tt class="docutils literal">f</tt> whether to keep iterating.</blockquote>
<p>Now looking into the definition of <tt class="docutils literal">AssocList.All</tt>, it's clear how the
iteration works. The loop in this method iterates over the items in the data
structure, passing each into the supplied <tt class="docutils literal">yield</tt> function, which the compiler
substitutes for the body of the original <tt class="docutils literal">range</tt> loop invoking <tt class="docutils literal">All</tt>.</p>
<p>This is the simplest example, because it doesn't change the control flow in any
way. In more complex cases the compiler applies more sophisticated
transformations; for example, a <tt class="docutils literal">break</tt> in the <tt class="docutils literal"><span class="pre">for-range</span></tt> loop body is
transformed into a <tt class="docutils literal">return false</tt> from the <tt class="docutils literal">yield</tt> function, directing
iteration to stop. A <tt class="docutils literal">continue</tt> is transformed into a <tt class="docutils literal">return true</tt>; more
work is needed for <tt class="docutils literal">goto</tt> statements, early returns, panics, <tt class="docutils literal">defer</tt>s and
so on. For the gory details, take a look at the <a class="reference external" href="https://go-review.googlesource.com/c/go/+/510541/7/src/cmd/compile/internal/rangefunc/rewrite.go">file comment from the CL
implementing the proposal</a>.</p>
<p>One detail I left out is the <tt class="docutils literal">bool</tt> return value from the function type passed
to <tt class="docutils literal"><span class="pre">for-range</span></tt>; I'll cover this later in the post.</p>
</div>
<div class="section" id="stopping-iteration-early">
<h2>Stopping iteration early</h2>
<p>We've touched upon this only glancingly so far, but early stops are an essential
feature of the range over functions proposal. Recall our <tt class="docutils literal">AssocList.All</tt>
method:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">al</span><span class="w"> </span><span class="o">*</span><span class="nx">AssocList</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">])</span><span class="w"> </span><span class="nx">All</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">lst</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Checking for a false return from <tt class="docutils literal">yield</tt> and using that to return early is
important, because this is the invoking <tt class="docutils literal"><span class="pre">for-range</span></tt> loop telling us to
stop. Consider this loop:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">al</span><span class="p">.</span><span class="nx">All</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fi&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;found bad value, aborting!&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;key=%v, value=%v\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>As mentioned earlier, the <tt class="docutils literal">break</tt> is transformed into <tt class="docutils literal">return false</tt> when
the body of this loop is passed into <tt class="docutils literal">AssocList.All</tt> as <tt class="docutils literal">yield</tt>. Once we've
encountered a &quot;bad value&quot;, we don't want to continue iterating, and therefore
the iterator function has to exit early, too.</p>
<p>This is very important because iteration may be costly, have side effects (it
could be reading I/O devices, for example), or because the iterator isn't even
finite.</p>
</div>
<div class="section" id="iterating-over-all-fibonacci-numbers">
<h2>Iterating over &quot;all&quot; Fibonacci numbers</h2>
<p>As an example of an infinite iterator, let's write one for Fibonacci numbers:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">genFib</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This function has a similar signature to <tt class="docutils literal">AssocList.All</tt>, except that it
only takes a single parameter. This means the associated <tt class="docutils literal"><span class="pre">for-range</span></tt> loop
will yield at most a single value. Here's how we can use it:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">genFib</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This will print Fibonacci numbers until (and including) the first one over 1000.
Clearly, there is no &quot;end&quot; to such an iterator; there are infinitely many
Fibonacci numbers. In fact, the <tt class="docutils literal">for</tt> loop in <tt class="docutils literal">genFib</tt> doesn't even have
an end condition; it only exits when <tt class="docutils literal">yield</tt> returns false. This happens
when the <tt class="docutils literal">break</tt> statement from the <tt class="docutils literal">if p &gt; 1000</tt> condition is triggered.</p>
</div>
<div class="section" id="composing-iterators">
<h2>Composing iterators</h2>
<p>So far the iterator examples have all been <em>linear</em>: the iterator had a single
loop that yields all the values one by one. Some iteration patterns are not
linear, however; for example, consider iterating over a binary tree:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">Tree</span><span class="p">[</span><span class="nx">E</span><span class="w"> </span><span class="kt">any</span><span class="p">]</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">val</span><span class="w">         </span><span class="nx">E</span><span class="w"></span>
<span class="w">  </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">E</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">E</span><span class="p">])</span><span class="w"> </span><span class="nx">Inorder</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">Inorder</span><span class="p">(</span><span class="nx">yield</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">yield</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">Inorder</span><span class="p">(</span><span class="nx">yield</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This code follows a familiar recursive pattern; it's fairly obvious that
<tt class="docutils literal">yield</tt> is invoked on the tree elements in-order. However, there's another
important thing to note - how stopping the iteration is handled. By now, we
know that a <tt class="docutils literal">break</tt> in the <tt class="docutils literal"><span class="pre">for-range</span></tt> loop will cause <tt class="docutils literal">yield</tt> to return
<tt class="docutils literal">false</tt>. However, <tt class="docutils literal">Tree.Inorder</tt> isn't just a linear loop that can
<tt class="docutils literal">return</tt> whenever <tt class="docutils literal">yield</tt> returns false; there's potentially a whole stack
of recursive calls to unroll.</p>
<p>Here, we finally see what the <tt class="docutils literal">bool</tt> return value from the iterator function
is for. The iterator function itself returns <tt class="docutils literal">false</tt> whenever its <tt class="docutils literal">yield</tt>
or one of the recursive calls returns <tt class="docutils literal">false</tt>. This makes sure that all
recursive calls return as soon as possible and don't visit additional elements
after an iteration stop was requested (via <tt class="docutils literal">yield</tt> returning <tt class="docutils literal">false</tt>).</p>
<p>Returning a value from the iterator function makes it possible to <em>compose</em>
multiple iterators with proper stopping semantics; while this return value isn't
actually checked by the driving <tt class="docutils literal"><span class="pre">for-range</span></tt>, it's used by the iterator
functions to communicate among themselves. By convention, it should be <tt class="docutils literal">false</tt>
for &quot;stop&quot; and <tt class="docutils literal">true</tt> for &quot;continue&quot;, similarly to the contract of <tt class="docutils literal">yield</tt>.</p>
<p>Here's the in-order tree iterator in action:</p>
<div class="highlight"><pre><span></span><span class="c1">// Create a sample tree:</span><span class="w"></span>
<span class="c1">//</span><span class="w"></span>
<span class="c1">//       10</span><span class="w"></span>
<span class="c1">//      /  \</span><span class="w"></span>
<span class="c1">//     20  40</span><span class="w"></span>
<span class="c1">//    /  \</span><span class="w"></span>
<span class="c1">//   30  39</span><span class="w"></span>
<span class="nx">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="w"></span>
<span class="w">  </span><span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="w"></span>
<span class="w">    </span><span class="mi">20</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="mi">39</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">}},</span><span class="w"></span>
<span class="w">  </span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">tt</span><span class="p">.</span><span class="nx">Inorder</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Prints:</span><span class="w"></span>
<span class="c1">// 30</span><span class="w"></span>
<span class="c1">// 20</span><span class="w"></span>
<span class="c1">// 39</span><span class="w"></span>
<span class="c1">// 10</span><span class="w"></span>
<span class="c1">// 40</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="additional-iteration-examples">
<h2>Additional iteration examples</h2>
<p><a class="reference external" href="https://pkg.go.dev/bufio#Scanner">bufio.Scanner</a> is a useful type for
iterating over lines in text; it can also be used to work with other separators,
but let's just talk about newline-separated lines for simplicity.</p>
<p>The canonical way of iterating over all lines in the input is:</p>
<div class="highlight"><pre><span></span><span class="nx">scanner</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Text</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;reading standard input:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This is a great example of an ad-hoc iteration method the designers of Go came
up with, before the language had real iterator support. There's nothing wrong
with this approach - it's clear and it works well. However, without a standard
for iteration, multiple approaches emerge and one always has to consult the
documentation for the right way to do this.</p>
<p>With the range over functions proposal, we can write an iterator that
works in a <tt class="docutils literal"><span class="pre">for-range</span></tt> loop. I'll wrap <tt class="docutils literal">Scanner</tt> to demonstrate this without
modifying the standard library:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">myScanner</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Scanner</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="nx">newScanner</span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">myScanner</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">myScanner</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">s</span><span class="p">:</span><span class="w"> </span><span class="nx">s</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ms</span><span class="w"> </span><span class="o">*</span><span class="nx">myScanner</span><span class="p">)</span><span class="w"> </span><span class="nx">All</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">ms</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">yield</span><span class="p">(</span><span class="nx">ms</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">Text</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ms</span><span class="w"> </span><span class="o">*</span><span class="nx">myScanner</span><span class="p">)</span><span class="w"> </span><span class="nx">Err</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">ms</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">Err</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>And we can use it as follows:</p>
<div class="highlight"><pre><span></span><span class="nx">scanner</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">newScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nx">line</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">All</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;got line:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">line</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">scanner</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;reading stdin: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>One could envision an <tt class="docutils literal">All</tt> method being added to the actual <tt class="docutils literal">Scanner</tt>
type if the proposal is accepted.</p>
<p>Another example that I like was mentioned by Russ in the proposal discussion.
It uses a closure to create a specialized iterator from a slice:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">Backward</span><span class="p">[</span><span class="nx">E</span><span class="w"> </span><span class="kt">any</span><span class="p">](</span><span class="nx">x</span><span class="w"> </span><span class="p">[]</span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">yield</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">yield</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">i</span><span class="o">--</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Usage:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">Backward</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Prints:</span><span class="w"></span>
<span class="c1">// 22</span><span class="w"></span>
<span class="c1">// 11</span><span class="w"></span>
<span class="c1">// 8</span><span class="w"></span>
<span class="c1">// 7</span><span class="w"></span>
<span class="c1">// 6</span><span class="w"></span>
<span class="c1">// 5</span><span class="w"></span>
</pre></div>
<p>I think it's a neat demonstration of the power of <a class="reference external" href="../higher-order-functions-in-go/index.html">higher-order functions in Go</a>. An
iterator is already a higher order function (it's a function type that takes
another as a parameter), and <tt class="docutils literal">Backward</tt> is another level up - it takes
a slice parameter and builds a closure, returning an iterator tailored for
this slice.</p>
</div>
<div class="section" id="final-words-push-vs-pull-iterators">
<h2>Final words - push vs. pull iterators</h2>
<p>I'm pretty excited about this proposal - it improves the ergonomics of Go
programming with only minimal added complexity <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>. If anything remains
unclear, feel free to send me an email - I can add more examples.</p>
<p>Finally, if you read the proposal and other documents related to it, you'll
quickly run into &quot;push&quot; vs. &quot;pull&quot; iterators; what do these terms mean?</p>
<p>Simply put, &quot;push&quot; iterators push their values into a function given to them;
the iterators in this proposal and the examples in this post are therefore
all push iterators - they take a <tt class="docutils literal">yield</tt> function and generate values by
invoking it; <tt class="docutils literal">yield</tt>'s return value is then used to determine whether the
iterator should continue generating values, or else stop.</p>
<p>&quot;Pull&quot; iterators look somewhat differently; a pull iterator is a function
you can invoke multiple times and its signature is something like:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">cont</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>Where <tt class="docutils literal">value</tt> is the generated value and <tt class="docutils literal">cont</tt> says if the iterator is
ready to produce more values, or else is done.</p>
<p>The control flow around push vs. pull iterators is very different. Push
iterators &quot;drive&quot; the iteration process, feeding values into a function until
they're done or explicitly asked to stop. Pull iterators, on the other hand,
are driven from elsewhere and have to retain state between calls. Both kinds of
iterators are useful for different patterns; the proposal discussed here only
deals with push iterators, but the Go team is also looking at various ways to
add support for pull iterators. See <a class="reference external" href="https://research.swtch.com/coro">Russ's coroutine post</a> for one possible approach.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>As an exercise, if you want to feel like a real Lisp hacker, feel free
to implement it using a proper linked list.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>Note that I'm saying <em>maximal</em> number of returned values. Even if our
<tt class="docutils literal">yield</tt> takes two values, we can still iterate with <tt class="docutils literal">for x := range</tt>
and only the <em>first</em> value fed to <tt class="docutils literal">yield</tt> will be assigned to <tt class="docutils literal">x</tt>.
This is just like iterating over regular maps, where the
<tt class="docutils literal">for k, v := range</tt> form obtains both keys and values, but the
<tt class="docutils literal">for k := range</tt> form is valid as well - for iterating just over keys.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>At least user-observable complexity. The implementation of the proposal
is rather involved in order to handle all forms of control flow properly.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2025 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.2.4.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../theme/js/bootstrap.min.js"></script>

<!--
  Using goatcounter to count visitors. The count.js script is vendored in.
-->
<script data-goatcounter="https://stats.thegreenplace.net/count"
        async src="../../theme/js/count.js"></script>
</body>

<!-- Mirrored from eli.thegreenplace.net/2023/preview-ranging-over-functions-in-go/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 16 Feb 2025 23:46:39 GMT -->
</html>